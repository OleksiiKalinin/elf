exports.id = 442;
exports.ids = [442];
exports.modules = {

/***/ 2125:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
var __webpack_unused_export__;


__webpack_unused_export__ = ({
  value: true
});
__webpack_unused_export__ = ({
  enumerable: true,
  get: function () {
    return _BottomTabBar.default;
  }
});
__webpack_unused_export__ = ({
  enumerable: true,
  get: function () {
    return _BottomTabBarHeightCallbackContext.default;
  }
});
__webpack_unused_export__ = ({
  enumerable: true,
  get: function () {
    return _BottomTabBarHeightContext.default;
  }
});
__webpack_unused_export__ = ({
  enumerable: true,
  get: function () {
    return _BottomTabView.default;
  }
});
Object.defineProperty(exports, "vw", ({
  enumerable: true,
  get: function () {
    return _createBottomTabNavigator.default;
  }
}));
__webpack_unused_export__ = ({
  enumerable: true,
  get: function () {
    return _useBottomTabBarHeight.default;
  }
});
var _createBottomTabNavigator = _interopRequireDefault(__webpack_require__(8001));
var _BottomTabBar = _interopRequireDefault(__webpack_require__(48681));
var _BottomTabView = _interopRequireDefault(__webpack_require__(54954));
var _BottomTabBarHeightCallbackContext = _interopRequireDefault(__webpack_require__(20507));
var _BottomTabBarHeightContext = _interopRequireDefault(__webpack_require__(87988));
var _useBottomTabBarHeight = _interopRequireDefault(__webpack_require__(93160));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 8001:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _native = __webpack_require__(33779);
var React = _interopRequireWildcard(__webpack_require__(16689));
var _warnOnce = _interopRequireDefault(__webpack_require__(12003));
var _BottomTabView = _interopRequireDefault(__webpack_require__(54954));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }
function BottomTabNavigator(_ref) {
  let {
    id,
    initialRouteName,
    backBehavior,
    children,
    screenListeners,
    screenOptions,
    sceneContainerStyle,
    ...restWithDeprecated
  } = _ref;
  const {
    // @ts-expect-error: lazy is deprecated
    lazy,
    // @ts-expect-error: tabBarOptions is deprecated
    tabBarOptions,
    ...rest
  } = restWithDeprecated;
  let defaultScreenOptions = {};
  if (tabBarOptions) {
    Object.assign(defaultScreenOptions, {
      tabBarHideOnKeyboard: tabBarOptions.keyboardHidesTabBar,
      tabBarActiveTintColor: tabBarOptions.activeTintColor,
      tabBarInactiveTintColor: tabBarOptions.inactiveTintColor,
      tabBarActiveBackgroundColor: tabBarOptions.activeBackgroundColor,
      tabBarInactiveBackgroundColor: tabBarOptions.inactiveBackgroundColor,
      tabBarAllowFontScaling: tabBarOptions.allowFontScaling,
      tabBarShowLabel: tabBarOptions.showLabel,
      tabBarLabelStyle: tabBarOptions.labelStyle,
      tabBarIconStyle: tabBarOptions.iconStyle,
      tabBarItemStyle: tabBarOptions.tabStyle,
      tabBarLabelPosition: tabBarOptions.labelPosition ?? (tabBarOptions.adaptive === false ? 'below-icon' : undefined),
      tabBarStyle: [{
        display: tabBarOptions.tabBarVisible ? 'none' : 'flex'
      }, defaultScreenOptions.tabBarStyle]
    });
    Object.keys(defaultScreenOptions).forEach(key => {
      if (defaultScreenOptions[key] === undefined) {
        // eslint-disable-next-line @typescript-eslint/no-dynamic-delete
        delete defaultScreenOptions[key];
      }
    });
    (0, _warnOnce.default)(tabBarOptions, `Bottom Tab Navigator: 'tabBarOptions' is deprecated. Migrate the options to 'screenOptions' instead.\n\nPlace the following in 'screenOptions' in your code to keep current behavior:\n\n${JSON.stringify(defaultScreenOptions, null, 2)}\n\nSee https://reactnavigation.org/docs/bottom-tab-navigator#options for more details.`);
  }
  if (typeof lazy === 'boolean') {
    defaultScreenOptions.lazy = lazy;
    (0, _warnOnce.default)(true, `Bottom Tab Navigator: 'lazy' in props is deprecated. Move it to 'screenOptions' instead.\n\nSee https://reactnavigation.org/docs/bottom-tab-navigator/#lazy for more details.`);
  }
  const {
    state,
    descriptors,
    navigation,
    NavigationContent
  } = (0, _native.useNavigationBuilder)(_native.TabRouter, {
    id,
    initialRouteName,
    backBehavior,
    children,
    screenListeners,
    screenOptions,
    defaultScreenOptions
  });
  return /*#__PURE__*/React.createElement(NavigationContent, null, /*#__PURE__*/React.createElement(_BottomTabView.default, _extends({}, rest, {
    state: state,
    navigation: navigation,
    descriptors: descriptors,
    sceneContainerStyle: sceneContainerStyle
  })));
}
var _default = (0, _native.createNavigatorFactory)(BottomTabNavigator);
exports["default"] = _default;
//# sourceMappingURL=createBottomTabNavigator.js.map

/***/ }),

/***/ 20507:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var React = _interopRequireWildcard(__webpack_require__(16689));
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
var _default = /*#__PURE__*/React.createContext(undefined);
exports["default"] = _default;
//# sourceMappingURL=BottomTabBarHeightCallbackContext.js.map

/***/ }),

/***/ 87988:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var React = _interopRequireWildcard(__webpack_require__(16689));
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
var _default = /*#__PURE__*/React.createContext(undefined);
exports["default"] = _default;
//# sourceMappingURL=BottomTabBarHeightContext.js.map

/***/ }),

/***/ 93160:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = useBottomTabBarHeight;
var React = _interopRequireWildcard(__webpack_require__(16689));
var _BottomTabBarHeightContext = _interopRequireDefault(__webpack_require__(87988));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function useBottomTabBarHeight() {
  const height = React.useContext(_BottomTabBarHeightContext.default);
  if (height === undefined) {
    throw new Error("Couldn't find the bottom tab bar height. Are you inside a screen in Bottom Tab Navigator?");
  }
  return height;
}
//# sourceMappingURL=useBottomTabBarHeight.js.map

/***/ }),

/***/ 95078:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = useIsKeyboardShown;
var React = _interopRequireWildcard(__webpack_require__(16689));
var _reactNative = __webpack_require__(83849);
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function useIsKeyboardShown() {
  const [isKeyboardShown, setIsKeyboardShown] = React.useState(false);
  React.useEffect(() => {
    const handleKeyboardShow = () => setIsKeyboardShown(true);
    const handleKeyboardHide = () => setIsKeyboardShown(false);
    let subscriptions;
    if (_reactNative.Platform.OS === 'ios') {
      subscriptions = [_reactNative.Keyboard.addListener('keyboardWillShow', handleKeyboardShow), _reactNative.Keyboard.addListener('keyboardWillHide', handleKeyboardHide)];
    } else {
      subscriptions = [_reactNative.Keyboard.addListener('keyboardDidShow', handleKeyboardShow), _reactNative.Keyboard.addListener('keyboardDidHide', handleKeyboardHide)];
    }
    return () => {
      subscriptions.forEach(s => s.remove());
    };
  }, []);
  return isKeyboardShown;
}
//# sourceMappingURL=useIsKeyboardShown.js.map

/***/ }),

/***/ 17421:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = Badge;
var _native = __webpack_require__(33779);
var _color = _interopRequireDefault(__webpack_require__(39105));
var React = _interopRequireWildcard(__webpack_require__(16689));
var _reactNative = __webpack_require__(83849);
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }
function Badge(_ref) {
  let {
    children,
    style,
    visible = true,
    size = 18,
    ...rest
  } = _ref;
  const [opacity] = React.useState(() => new _reactNative.Animated.Value(visible ? 1 : 0));
  const [rendered, setRendered] = React.useState(visible);
  const theme = (0, _native.useTheme)();
  React.useEffect(() => {
    if (!rendered) {
      return;
    }
    _reactNative.Animated.timing(opacity, {
      toValue: visible ? 1 : 0,
      duration: 150,
      useNativeDriver: true
    }).start(_ref2 => {
      let {
        finished
      } = _ref2;
      if (finished && !visible) {
        setRendered(false);
      }
    });
    return () => opacity.stopAnimation();
  }, [opacity, rendered, visible]);
  if (!rendered) {
    if (visible) {
      setRendered(true);
    } else {
      return null;
    }
  }

  // @ts-expect-error: backgroundColor definitely exists
  const {
    backgroundColor = theme.colors.notification,
    ...restStyle
  } = _reactNative.StyleSheet.flatten(style) || {};
  const textColor = (0, _color.default)(backgroundColor).isLight() ? 'black' : 'white';
  const borderRadius = size / 2;
  const fontSize = Math.floor(size * 3 / 4);
  return /*#__PURE__*/React.createElement(_reactNative.Animated.Text, _extends({
    numberOfLines: 1,
    style: [{
      transform: [{
        scale: opacity.interpolate({
          inputRange: [0, 1],
          outputRange: [0.5, 1]
        })
      }],
      color: textColor,
      lineHeight: size - 1,
      height: size,
      minWidth: size,
      opacity,
      backgroundColor,
      fontSize,
      borderRadius
    }, styles.container, restStyle]
  }, rest), children);
}
const styles = _reactNative.StyleSheet.create({
  container: {
    alignSelf: 'flex-end',
    textAlign: 'center',
    paddingHorizontal: 4,
    overflow: 'hidden'
  }
});
//# sourceMappingURL=Badge.js.map

/***/ }),

/***/ 48681:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = BottomTabBar;
exports.getTabBarHeight = void 0;
var _elements = __webpack_require__(46651);
var _native = __webpack_require__(33779);
var _react = _interopRequireDefault(__webpack_require__(16689));
var _reactNative = __webpack_require__(83849);
var _reactNativeSafeAreaContext = __webpack_require__(30971);
var _BottomTabBarHeightCallbackContext = _interopRequireDefault(__webpack_require__(20507));
var _useIsKeyboardShown = _interopRequireDefault(__webpack_require__(95078));
var _BottomTabItem = _interopRequireDefault(__webpack_require__(36886));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const DEFAULT_TABBAR_HEIGHT = 49;
const COMPACT_TABBAR_HEIGHT = 32;
const DEFAULT_MAX_TAB_ITEM_WIDTH = 125;
const useNativeDriver = _reactNative.Platform.OS !== 'web';
const shouldUseHorizontalLabels = _ref => {
  let {
    state,
    descriptors,
    layout,
    dimensions
  } = _ref;
  const {
    tabBarLabelPosition
  } = descriptors[state.routes[state.index].key].options;
  if (tabBarLabelPosition) {
    switch (tabBarLabelPosition) {
      case 'beside-icon':
        return true;
      case 'below-icon':
        return false;
    }
  }
  if (layout.width >= 768) {
    // Screen size matches a tablet
    const maxTabWidth = state.routes.reduce((acc, route) => {
      const {
        tabBarItemStyle
      } = descriptors[route.key].options;
      const flattenedStyle = _reactNative.StyleSheet.flatten(tabBarItemStyle);
      if (flattenedStyle) {
        if (typeof flattenedStyle.width === 'number') {
          return acc + flattenedStyle.width;
        } else if (typeof flattenedStyle.maxWidth === 'number') {
          return acc + flattenedStyle.maxWidth;
        }
      }
      return acc + DEFAULT_MAX_TAB_ITEM_WIDTH;
    }, 0);
    return maxTabWidth <= layout.width;
  } else {
    return dimensions.width > dimensions.height;
  }
};
const getPaddingBottom = insets => Math.max(insets.bottom - _reactNative.Platform.select({
  ios: 4,
  default: 0
}), 0);
const getTabBarHeight = _ref2 => {
  var _StyleSheet$flatten;
  let {
    state,
    descriptors,
    dimensions,
    insets,
    style,
    ...rest
  } = _ref2;
  // @ts-ignore
  const customHeight = (_StyleSheet$flatten = _reactNative.StyleSheet.flatten(style)) === null || _StyleSheet$flatten === void 0 ? void 0 : _StyleSheet$flatten.height;
  if (typeof customHeight === 'number') {
    return customHeight;
  }
  const isLandscape = dimensions.width > dimensions.height;
  const horizontalLabels = shouldUseHorizontalLabels({
    state,
    descriptors,
    dimensions,
    ...rest
  });
  const paddingBottom = getPaddingBottom(insets);
  if (_reactNative.Platform.OS === 'ios' && !_reactNative.Platform.isPad && isLandscape && horizontalLabels) {
    return COMPACT_TABBAR_HEIGHT + paddingBottom;
  }
  return DEFAULT_TABBAR_HEIGHT + paddingBottom;
};
exports.getTabBarHeight = getTabBarHeight;
function BottomTabBar(_ref3) {
  let {
    state,
    navigation,
    descriptors,
    insets,
    style
  } = _ref3;
  const {
    colors
  } = (0, _native.useTheme)();
  const buildLink = (0, _native.useLinkBuilder)();
  const focusedRoute = state.routes[state.index];
  const focusedDescriptor = descriptors[focusedRoute.key];
  const focusedOptions = focusedDescriptor.options;
  const {
    tabBarShowLabel,
    tabBarHideOnKeyboard = false,
    tabBarVisibilityAnimationConfig,
    tabBarStyle,
    tabBarBackground,
    tabBarActiveTintColor,
    tabBarInactiveTintColor,
    tabBarActiveBackgroundColor,
    tabBarInactiveBackgroundColor
  } = focusedOptions;
  const dimensions = (0, _reactNativeSafeAreaContext.useSafeAreaFrame)();
  const isKeyboardShown = (0, _useIsKeyboardShown.default)();
  const onHeightChange = _react.default.useContext(_BottomTabBarHeightCallbackContext.default);
  const shouldShowTabBar = !(tabBarHideOnKeyboard && isKeyboardShown);
  const visibilityAnimationConfigRef = _react.default.useRef(tabBarVisibilityAnimationConfig);
  _react.default.useEffect(() => {
    visibilityAnimationConfigRef.current = tabBarVisibilityAnimationConfig;
  });
  const [isTabBarHidden, setIsTabBarHidden] = _react.default.useState(!shouldShowTabBar);
  const [visible] = _react.default.useState(() => new _reactNative.Animated.Value(shouldShowTabBar ? 1 : 0));
  _react.default.useEffect(() => {
    const visibilityAnimationConfig = visibilityAnimationConfigRef.current;
    if (shouldShowTabBar) {
      var _visibilityAnimationC, _visibilityAnimationC2;
      const animation = (visibilityAnimationConfig === null || visibilityAnimationConfig === void 0 ? void 0 : (_visibilityAnimationC = visibilityAnimationConfig.show) === null || _visibilityAnimationC === void 0 ? void 0 : _visibilityAnimationC.animation) === 'spring' ? _reactNative.Animated.spring : _reactNative.Animated.timing;
      animation(visible, {
        toValue: 1,
        useNativeDriver,
        duration: 250,
        ...(visibilityAnimationConfig === null || visibilityAnimationConfig === void 0 ? void 0 : (_visibilityAnimationC2 = visibilityAnimationConfig.show) === null || _visibilityAnimationC2 === void 0 ? void 0 : _visibilityAnimationC2.config)
      }).start(_ref4 => {
        let {
          finished
        } = _ref4;
        if (finished) {
          setIsTabBarHidden(false);
        }
      });
    } else {
      var _visibilityAnimationC3, _visibilityAnimationC4;
      setIsTabBarHidden(true);
      const animation = (visibilityAnimationConfig === null || visibilityAnimationConfig === void 0 ? void 0 : (_visibilityAnimationC3 = visibilityAnimationConfig.hide) === null || _visibilityAnimationC3 === void 0 ? void 0 : _visibilityAnimationC3.animation) === 'spring' ? _reactNative.Animated.spring : _reactNative.Animated.timing;
      animation(visible, {
        toValue: 0,
        useNativeDriver,
        duration: 200,
        ...(visibilityAnimationConfig === null || visibilityAnimationConfig === void 0 ? void 0 : (_visibilityAnimationC4 = visibilityAnimationConfig.hide) === null || _visibilityAnimationC4 === void 0 ? void 0 : _visibilityAnimationC4.config)
      }).start();
    }
    return () => visible.stopAnimation();
  }, [visible, shouldShowTabBar]);
  const [layout, setLayout] = _react.default.useState({
    height: 0,
    width: dimensions.width
  });
  const handleLayout = e => {
    const {
      height,
      width
    } = e.nativeEvent.layout;
    onHeightChange === null || onHeightChange === void 0 ? void 0 : onHeightChange(height);
    setLayout(layout => {
      if (height === layout.height && width === layout.width) {
        return layout;
      } else {
        return {
          height,
          width
        };
      }
    });
  };
  const {
    routes
  } = state;
  const paddingBottom = getPaddingBottom(insets);
  const tabBarHeight = getTabBarHeight({
    state,
    descriptors,
    insets,
    dimensions,
    layout,
    style: [tabBarStyle, style]
  });
  const hasHorizontalLabels = shouldUseHorizontalLabels({
    state,
    descriptors,
    dimensions,
    layout
  });
  const tabBarBackgroundElement = tabBarBackground === null || tabBarBackground === void 0 ? void 0 : tabBarBackground();
  return /*#__PURE__*/_react.default.createElement(_reactNative.Animated.View, {
    style: [styles.tabBar, {
      backgroundColor: tabBarBackgroundElement != null ? 'transparent' : colors.card,
      borderTopColor: colors.border
    }, {
      transform: [{
        translateY: visible.interpolate({
          inputRange: [0, 1],
          outputRange: [layout.height + paddingBottom + _reactNative.StyleSheet.hairlineWidth, 0]
        })
      }],
      // Absolutely position the tab bar so that the content is below it
      // This is needed to avoid gap at bottom when the tab bar is hidden
      position: isTabBarHidden ? 'absolute' : null
    }, {
      height: tabBarHeight,
      paddingBottom,
      paddingHorizontal: Math.max(insets.left, insets.right)
    }, tabBarStyle],
    pointerEvents: isTabBarHidden ? 'none' : 'auto',
    onLayout: handleLayout
  }, /*#__PURE__*/_react.default.createElement(_reactNative.View, {
    pointerEvents: "none",
    style: _reactNative.StyleSheet.absoluteFill
  }, tabBarBackgroundElement), /*#__PURE__*/_react.default.createElement(_reactNative.View, {
    accessibilityRole: "tablist",
    style: styles.content
  }, routes.map((route, index) => {
    const focused = index === state.index;
    const {
      options
    } = descriptors[route.key];
    const onPress = () => {
      const event = navigation.emit({
        type: 'tabPress',
        target: route.key,
        canPreventDefault: true
      });
      if (!focused && !event.defaultPrevented) {
        navigation.dispatch({
          ..._native.CommonActions.navigate({
            name: route.name,
            merge: true
          }),
          target: state.key
        });
      }
    };
    const onLongPress = () => {
      navigation.emit({
        type: 'tabLongPress',
        target: route.key
      });
    };
    const label = options.tabBarLabel !== undefined ? options.tabBarLabel : options.title !== undefined ? options.title : route.name;
    const accessibilityLabel = options.tabBarAccessibilityLabel !== undefined ? options.tabBarAccessibilityLabel : typeof label === 'string' && _reactNative.Platform.OS === 'ios' ? `${label}, tab, ${index + 1} of ${routes.length}` : undefined;
    return /*#__PURE__*/_react.default.createElement(_native.NavigationContext.Provider, {
      key: route.key,
      value: descriptors[route.key].navigation
    }, /*#__PURE__*/_react.default.createElement(_native.NavigationRouteContext.Provider, {
      value: route
    }, /*#__PURE__*/_react.default.createElement(_BottomTabItem.default, {
      route: route,
      descriptor: descriptors[route.key],
      focused: focused,
      horizontal: hasHorizontalLabels,
      onPress: onPress,
      onLongPress: onLongPress,
      accessibilityLabel: accessibilityLabel,
      to: buildLink(route.name, route.params),
      testID: options.tabBarTestID,
      allowFontScaling: options.tabBarAllowFontScaling,
      activeTintColor: tabBarActiveTintColor,
      inactiveTintColor: tabBarInactiveTintColor,
      activeBackgroundColor: tabBarActiveBackgroundColor,
      inactiveBackgroundColor: tabBarInactiveBackgroundColor,
      button: options.tabBarButton,
      icon: options.tabBarIcon ?? (_ref5 => {
        let {
          color,
          size
        } = _ref5;
        return /*#__PURE__*/_react.default.createElement(_elements.MissingIcon, {
          color: color,
          size: size
        });
      }),
      badge: options.tabBarBadge,
      badgeStyle: options.tabBarBadgeStyle,
      label: label,
      showLabel: tabBarShowLabel,
      labelStyle: options.tabBarLabelStyle,
      iconStyle: options.tabBarIconStyle,
      style: options.tabBarItemStyle
    })));
  })));
}
const styles = _reactNative.StyleSheet.create({
  tabBar: {
    left: 0,
    right: 0,
    bottom: 0,
    borderTopWidth: _reactNative.StyleSheet.hairlineWidth,
    elevation: 8
  },
  content: {
    flex: 1,
    flexDirection: 'row'
  }
});
//# sourceMappingURL=BottomTabBar.js.map

/***/ }),

/***/ 36886:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = BottomTabBarItem;
var _native = __webpack_require__(33779);
var _color = _interopRequireDefault(__webpack_require__(39105));
var _react = _interopRequireDefault(__webpack_require__(16689));
var _reactNative = __webpack_require__(83849);
var _TabBarIcon = _interopRequireDefault(__webpack_require__(64154));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }
function BottomTabBarItem(_ref) {
  let {
    focused,
    route,
    descriptor,
    label,
    icon,
    badge,
    badgeStyle,
    to,
    button = _ref2 => {
      let {
        children,
        style,
        onPress,
        to,
        accessibilityRole,
        ...rest
      } = _ref2;
      if (_reactNative.Platform.OS === 'web' && to) {
        // React Native Web doesn't forward `onClick` if we use `TouchableWithoutFeedback`.
        // We need to use `onClick` to be able to prevent default browser handling of links.
        return /*#__PURE__*/_react.default.createElement(_native.Link, _extends({}, rest, {
          to: to,
          style: [styles.button, style],
          onPress: e => {
            if (!(e.metaKey || e.altKey || e.ctrlKey || e.shiftKey) && (
            // ignore clicks with modifier keys
            e.button == null || e.button === 0) // ignore everything but left clicks
            ) {
              e.preventDefault();
              onPress === null || onPress === void 0 ? void 0 : onPress(e);
            }
          }
        }), children);
      } else {
        return /*#__PURE__*/_react.default.createElement(_reactNative.Pressable, _extends({}, rest, {
          accessibilityRole: accessibilityRole,
          onPress: onPress,
          style: style
        }), children);
      }
    },
    accessibilityLabel,
    testID,
    onPress,
    onLongPress,
    horizontal,
    activeTintColor: customActiveTintColor,
    inactiveTintColor: customInactiveTintColor,
    activeBackgroundColor = 'transparent',
    inactiveBackgroundColor = 'transparent',
    showLabel = true,
    allowFontScaling,
    labelStyle,
    iconStyle,
    style
  } = _ref;
  const {
    colors
  } = (0, _native.useTheme)();
  const activeTintColor = customActiveTintColor === undefined ? colors.primary : customActiveTintColor;
  const inactiveTintColor = customInactiveTintColor === undefined ? (0, _color.default)(colors.text).mix((0, _color.default)(colors.card), 0.5).hex() : customInactiveTintColor;
  const renderLabel = _ref3 => {
    let {
      focused
    } = _ref3;
    if (showLabel === false) {
      return null;
    }
    const color = focused ? activeTintColor : inactiveTintColor;
    if (typeof label === 'string') {
      return /*#__PURE__*/_react.default.createElement(_reactNative.Text, {
        numberOfLines: 1,
        style: [styles.label, {
          color
        }, horizontal ? styles.labelBeside : styles.labelBeneath, labelStyle],
        allowFontScaling: allowFontScaling
      }, label);
    }
    const {
      options
    } = descriptor;
    const children = typeof options.tabBarLabel === 'string' ? options.tabBarLabel : options.title !== undefined ? options.title : route.name;
    return label({
      focused,
      color,
      position: horizontal ? 'beside-icon' : 'below-icon',
      children
    });
  };
  const renderIcon = _ref4 => {
    let {
      focused
    } = _ref4;
    if (icon === undefined) {
      return null;
    }
    const activeOpacity = focused ? 1 : 0;
    const inactiveOpacity = focused ? 0 : 1;
    return /*#__PURE__*/_react.default.createElement(_TabBarIcon.default, {
      route: route,
      horizontal: horizontal,
      badge: badge,
      badgeStyle: badgeStyle,
      activeOpacity: activeOpacity,
      inactiveOpacity: inactiveOpacity,
      activeTintColor: activeTintColor,
      inactiveTintColor: inactiveTintColor,
      renderIcon: icon,
      style: iconStyle
    });
  };
  const scene = {
    route,
    focused
  };
  const backgroundColor = focused ? activeBackgroundColor : inactiveBackgroundColor;
  return button({
    to,
    onPress,
    onLongPress,
    testID,
    accessibilityLabel,
    // FIXME: accessibilityRole: 'tab' doesn't seem to work as expected on iOS
    accessibilityRole: _reactNative.Platform.select({
      ios: 'button',
      default: 'tab'
    }),
    accessibilityState: {
      selected: focused
    },
    // @ts-expect-error: keep for compatibility with older React Native versions
    accessibilityStates: focused ? ['selected'] : [],
    style: [styles.tab, {
      backgroundColor
    }, horizontal ? styles.tabLandscape : styles.tabPortrait, style],
    children: /*#__PURE__*/_react.default.createElement(_react.default.Fragment, null, renderIcon(scene), renderLabel(scene))
  });
}
const styles = _reactNative.StyleSheet.create({
  tab: {
    flex: 1,
    alignItems: 'center'
  },
  tabPortrait: {
    justifyContent: 'flex-end',
    flexDirection: 'column'
  },
  tabLandscape: {
    justifyContent: 'center',
    flexDirection: 'row'
  },
  label: {
    textAlign: 'center',
    backgroundColor: 'transparent'
  },
  labelBeneath: {
    fontSize: 10
  },
  labelBeside: {
    fontSize: 13,
    marginLeft: 20,
    marginTop: 3
  },
  button: {
    display: 'flex'
  }
});
//# sourceMappingURL=BottomTabItem.js.map

/***/ }),

/***/ 54954:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = BottomTabView;
var _elements = __webpack_require__(46651);
var React = _interopRequireWildcard(__webpack_require__(16689));
var _reactNative = __webpack_require__(83849);
var _reactNativeSafeAreaContext = __webpack_require__(30971);
var _BottomTabBarHeightCallbackContext = _interopRequireDefault(__webpack_require__(20507));
var _BottomTabBarHeightContext = _interopRequireDefault(__webpack_require__(87988));
var _BottomTabBar = _interopRequireWildcard(__webpack_require__(48681));
var _ScreenFallback = __webpack_require__(16564);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }
function BottomTabView(props) {
  const {
    tabBar = props => /*#__PURE__*/React.createElement(_BottomTabBar.default, props),
    state,
    navigation,
    descriptors,
    safeAreaInsets,
    detachInactiveScreens = _reactNative.Platform.OS === 'web' || _reactNative.Platform.OS === 'android' || _reactNative.Platform.OS === 'ios',
    sceneContainerStyle
  } = props;
  const focusedRouteKey = state.routes[state.index].key;
  const [loaded, setLoaded] = React.useState([focusedRouteKey]);
  if (!loaded.includes(focusedRouteKey)) {
    setLoaded([...loaded, focusedRouteKey]);
  }
  const dimensions = _elements.SafeAreaProviderCompat.initialMetrics.frame;
  const [tabBarHeight, setTabBarHeight] = React.useState(() => (0, _BottomTabBar.getTabBarHeight)({
    state,
    descriptors,
    dimensions,
    layout: {
      width: dimensions.width,
      height: 0
    },
    insets: {
      ..._elements.SafeAreaProviderCompat.initialMetrics.insets,
      ...props.safeAreaInsets
    },
    style: descriptors[state.routes[state.index].key].options.tabBarStyle
  }));
  const renderTabBar = () => {
    return /*#__PURE__*/React.createElement(_reactNativeSafeAreaContext.SafeAreaInsetsContext.Consumer, null, insets => tabBar({
      state: state,
      descriptors: descriptors,
      navigation: navigation,
      insets: {
        top: (safeAreaInsets === null || safeAreaInsets === void 0 ? void 0 : safeAreaInsets.top) ?? (insets === null || insets === void 0 ? void 0 : insets.top) ?? 0,
        right: (safeAreaInsets === null || safeAreaInsets === void 0 ? void 0 : safeAreaInsets.right) ?? (insets === null || insets === void 0 ? void 0 : insets.right) ?? 0,
        bottom: (safeAreaInsets === null || safeAreaInsets === void 0 ? void 0 : safeAreaInsets.bottom) ?? (insets === null || insets === void 0 ? void 0 : insets.bottom) ?? 0,
        left: (safeAreaInsets === null || safeAreaInsets === void 0 ? void 0 : safeAreaInsets.left) ?? (insets === null || insets === void 0 ? void 0 : insets.left) ?? 0
      }
    }));
  };
  const {
    routes
  } = state;
  return /*#__PURE__*/React.createElement(_elements.SafeAreaProviderCompat, null, /*#__PURE__*/React.createElement(_ScreenFallback.MaybeScreenContainer, {
    enabled: detachInactiveScreens,
    hasTwoStates: true,
    style: styles.container
  }, routes.map((route, index) => {
    const descriptor = descriptors[route.key];
    const {
      lazy = true,
      unmountOnBlur
    } = descriptor.options;
    const isFocused = state.index === index;
    if (unmountOnBlur && !isFocused) {
      return null;
    }
    if (lazy && !loaded.includes(route.key) && !isFocused) {
      // Don't render a lazy screen if we've never navigated to it
      return null;
    }
    const {
      freezeOnBlur,
      header = _ref => {
        let {
          layout,
          options
        } = _ref;
        return /*#__PURE__*/React.createElement(_elements.Header, _extends({}, options, {
          layout: layout,
          title: (0, _elements.getHeaderTitle)(options, route.name)
        }));
      },
      headerShown,
      headerStatusBarHeight,
      headerTransparent
    } = descriptor.options;
    return /*#__PURE__*/React.createElement(_ScreenFallback.MaybeScreen, {
      key: route.key,
      style: [_reactNative.StyleSheet.absoluteFill, {
        zIndex: isFocused ? 0 : -1
      }],
      visible: isFocused,
      enabled: detachInactiveScreens,
      freezeOnBlur: freezeOnBlur
    }, /*#__PURE__*/React.createElement(_BottomTabBarHeightContext.default.Provider, {
      value: tabBarHeight
    }, /*#__PURE__*/React.createElement(_elements.Screen, {
      focused: isFocused,
      route: descriptor.route,
      navigation: descriptor.navigation,
      headerShown: headerShown,
      headerStatusBarHeight: headerStatusBarHeight,
      headerTransparent: headerTransparent,
      header: header({
        layout: dimensions,
        route: descriptor.route,
        navigation: descriptor.navigation,
        options: descriptor.options
      }),
      style: sceneContainerStyle
    }, descriptor.render())));
  })), /*#__PURE__*/React.createElement(_BottomTabBarHeightCallbackContext.default.Provider, {
    value: setTabBarHeight
  }, renderTabBar()));
}
const styles = _reactNative.StyleSheet.create({
  container: {
    flex: 1,
    overflow: 'hidden'
  }
});
//# sourceMappingURL=BottomTabView.js.map

/***/ }),

/***/ 16564:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.MaybeScreen = MaybeScreen;
exports.MaybeScreenContainer = void 0;
var _elements = __webpack_require__(46651);
var React = _interopRequireWildcard(__webpack_require__(16689));
var _reactNative = __webpack_require__(83849);
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }
let Screens;
try {
  Screens = __webpack_require__(34206);
} catch (e) {
  // Ignore
}
const MaybeScreenContainer = _ref => {
  var _Screens, _Screens$screensEnabl;
  let {
    enabled,
    ...rest
  } = _ref;
  if ((_Screens = Screens) !== null && _Screens !== void 0 && (_Screens$screensEnabl = _Screens.screensEnabled) !== null && _Screens$screensEnabl !== void 0 && _Screens$screensEnabl.call(_Screens)) {
    return /*#__PURE__*/React.createElement(Screens.ScreenContainer, _extends({
      enabled: enabled
    }, rest));
  }
  return /*#__PURE__*/React.createElement(_reactNative.View, rest);
};
exports.MaybeScreenContainer = MaybeScreenContainer;
function MaybeScreen(_ref2) {
  var _Screens2, _Screens2$screensEnab;
  let {
    visible,
    children,
    ...rest
  } = _ref2;
  if ((_Screens2 = Screens) !== null && _Screens2 !== void 0 && (_Screens2$screensEnab = _Screens2.screensEnabled) !== null && _Screens2$screensEnab !== void 0 && _Screens2$screensEnab.call(_Screens2)) {
    return /*#__PURE__*/React.createElement(Screens.Screen, _extends({
      activityState: visible ? 2 : 0
    }, rest), children);
  }
  return /*#__PURE__*/React.createElement(_elements.ResourceSavingView, _extends({
    visible: visible
  }, rest), children);
}
//# sourceMappingURL=ScreenFallback.js.map

/***/ }),

/***/ 64154:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = TabBarIcon;
var _react = _interopRequireDefault(__webpack_require__(16689));
var _reactNative = __webpack_require__(83849);
var _Badge = _interopRequireDefault(__webpack_require__(17421));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function TabBarIcon(_ref) {
  let {
    route: _,
    horizontal,
    badge,
    badgeStyle,
    activeOpacity,
    inactiveOpacity,
    activeTintColor,
    inactiveTintColor,
    renderIcon,
    style
  } = _ref;
  const size = 25;

  // We render the icon twice at the same position on top of each other:
  // active and inactive one, so we can fade between them.
  return /*#__PURE__*/_react.default.createElement(_reactNative.View, {
    style: [horizontal ? styles.iconHorizontal : styles.iconVertical, style]
  }, /*#__PURE__*/_react.default.createElement(_reactNative.View, {
    style: [styles.icon, {
      opacity: activeOpacity
    }]
  }, renderIcon({
    focused: true,
    size,
    color: activeTintColor
  })), /*#__PURE__*/_react.default.createElement(_reactNative.View, {
    style: [styles.icon, {
      opacity: inactiveOpacity
    }]
  }, renderIcon({
    focused: false,
    size,
    color: inactiveTintColor
  })), /*#__PURE__*/_react.default.createElement(_Badge.default, {
    visible: badge != null,
    style: [styles.badge, horizontal ? styles.badgeHorizontal : styles.badgeVertical, badgeStyle],
    size: size * 3 / 4
  }, badge));
}
const styles = _reactNative.StyleSheet.create({
  icon: {
    // We render the icon twice at the same position on top of each other:
    // active and inactive one, so we can fade between them:
    // Cover the whole iconContainer:
    position: 'absolute',
    alignSelf: 'center',
    alignItems: 'center',
    justifyContent: 'center',
    height: '100%',
    width: '100%',
    // Workaround for react-native >= 0.54 layout bug
    minWidth: 25
  },
  iconVertical: {
    flex: 1
  },
  iconHorizontal: {
    height: '100%',
    marginTop: 3
  },
  badge: {
    position: 'absolute',
    left: 3
  },
  badgeVertical: {
    top: 3
  },
  badgeHorizontal: {
    top: 7
  }
});
//# sourceMappingURL=TabBarIcon.js.map

/***/ }),

/***/ 48219:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _routers = __webpack_require__(55789);
var React = _interopRequireWildcard(__webpack_require__(16689));
var _checkDuplicateRouteNames = _interopRequireDefault(__webpack_require__(7541));
var _checkSerializable = _interopRequireDefault(__webpack_require__(8863));
var _createNavigationContainerRef = __webpack_require__(80742);
var _EnsureSingleNavigator = _interopRequireDefault(__webpack_require__(25192));
var _findFocusedRoute = _interopRequireDefault(__webpack_require__(61392));
var _NavigationBuilderContext = _interopRequireDefault(__webpack_require__(11223));
var _NavigationContainerRefContext = _interopRequireDefault(__webpack_require__(15523));
var _NavigationContext = _interopRequireDefault(__webpack_require__(10871));
var _NavigationRouteContext = _interopRequireDefault(__webpack_require__(44820));
var _NavigationStateContext = _interopRequireDefault(__webpack_require__(21726));
var _UnhandledActionContext = _interopRequireDefault(__webpack_require__(76971));
var _useChildListeners = _interopRequireDefault(__webpack_require__(49275));
var _useEventEmitter = _interopRequireDefault(__webpack_require__(74658));
var _useKeyedChildListeners = _interopRequireDefault(__webpack_require__(93296));
var _useOptionsGetters = _interopRequireDefault(__webpack_require__(72893));
var _useScheduleUpdate = __webpack_require__(18693);
var _useSyncState = _interopRequireDefault(__webpack_require__(73514));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
const serializableWarnings = (/* unused pure expression or super */ null && ([]));
const duplicateNameWarnings = (/* unused pure expression or super */ null && ([]));

/**
 * Remove `key` and `routeNames` from the state objects recursively to get partial state.
 *
 * @param state Initial state object.
 */
const getPartialState = state => {
  if (state === undefined) {
    return;
  }

  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  const {
    key,
    routeNames,
    ...partialState
  } = state;
  return {
    ...partialState,
    stale: true,
    routes: state.routes.map(route => {
      if (route.state === undefined) {
        return route;
      }
      return {
        ...route,
        state: getPartialState(route.state)
      };
    })
  };
};

/**
 * Container component which holds the navigation state.
 * This should be rendered at the root wrapping the whole app.
 *
 * @param props.initialState Initial state object for the navigation tree.
 * @param props.onStateChange Callback which is called with the latest navigation state when it changes.
 * @param props.children Child elements to render the content.
 * @param props.ref Ref object which refers to the navigation object containing helper methods.
 */
const BaseNavigationContainer = /*#__PURE__*/React.forwardRef(function BaseNavigationContainer(_ref, ref) {
  let {
    initialState,
    onStateChange,
    onUnhandledAction,
    independent,
    children
  } = _ref;
  const parent = React.useContext(_NavigationStateContext.default);
  if (!parent.isDefault && !independent) {
    throw new Error("Looks like you have nested a 'NavigationContainer' inside another. Normally you need only one container at the root of the app, so this was probably an error. If this was intentional, pass 'independent={true}' explicitly. Note that this will make the child navigators disconnected from the parent and you won't be able to navigate between them.");
  }
  const [state, getState, setState, scheduleUpdate, flushUpdates] = (0, _useSyncState.default)(() => getPartialState(initialState == null ? undefined : initialState));
  const isFirstMountRef = React.useRef(true);
  const navigatorKeyRef = React.useRef();
  const getKey = React.useCallback(() => navigatorKeyRef.current, []);
  const setKey = React.useCallback(key => {
    navigatorKeyRef.current = key;
  }, []);
  const {
    listeners,
    addListener
  } = (0, _useChildListeners.default)();
  const {
    keyedListeners,
    addKeyedListener
  } = (0, _useKeyedChildListeners.default)();
  const dispatch = React.useCallback(action => {
    if (listeners.focus[0] == null) {
      console.error(_createNavigationContainerRef.NOT_INITIALIZED_ERROR);
    } else {
      listeners.focus[0](navigation => navigation.dispatch(action));
    }
  }, [listeners.focus]);
  const canGoBack = React.useCallback(() => {
    if (listeners.focus[0] == null) {
      return false;
    }
    const {
      result,
      handled
    } = listeners.focus[0](navigation => navigation.canGoBack());
    if (handled) {
      return result;
    } else {
      return false;
    }
  }, [listeners.focus]);
  const resetRoot = React.useCallback(state => {
    var _keyedListeners$getSt, _keyedListeners$getSt2;
    const target = (state === null || state === void 0 ? void 0 : state.key) ?? ((_keyedListeners$getSt = (_keyedListeners$getSt2 = keyedListeners.getState).root) === null || _keyedListeners$getSt === void 0 ? void 0 : _keyedListeners$getSt.call(_keyedListeners$getSt2).key);
    if (target == null) {
      console.error(_createNavigationContainerRef.NOT_INITIALIZED_ERROR);
    } else {
      listeners.focus[0](navigation => navigation.dispatch({
        ..._routers.CommonActions.reset(state),
        target
      }));
    }
  }, [keyedListeners.getState, listeners.focus]);
  const getRootState = React.useCallback(() => {
    var _keyedListeners$getSt3, _keyedListeners$getSt4;
    return (_keyedListeners$getSt3 = (_keyedListeners$getSt4 = keyedListeners.getState).root) === null || _keyedListeners$getSt3 === void 0 ? void 0 : _keyedListeners$getSt3.call(_keyedListeners$getSt4);
  }, [keyedListeners.getState]);
  const getCurrentRoute = React.useCallback(() => {
    const state = getRootState();
    if (state == null) {
      return undefined;
    }
    const route = (0, _findFocusedRoute.default)(state);
    return route;
  }, [getRootState]);
  const emitter = (0, _useEventEmitter.default)();
  const {
    addOptionsGetter,
    getCurrentOptions
  } = (0, _useOptionsGetters.default)({});
  const navigation = React.useMemo(() => ({
    ...Object.keys(_routers.CommonActions).reduce((acc, name) => {
      acc[name] = function () {
        return (
          // @ts-expect-error: this is ok
          dispatch(_routers.CommonActions[name](...arguments))
        );
      };
      return acc;
    }, {}),
    ...emitter.create('root'),
    dispatch,
    resetRoot,
    isFocused: () => true,
    canGoBack,
    getParent: () => undefined,
    getState: () => stateRef.current,
    getRootState,
    getCurrentRoute,
    getCurrentOptions,
    isReady: () => listeners.focus[0] != null
  }), [canGoBack, dispatch, emitter, getCurrentOptions, getCurrentRoute, getRootState, listeners.focus, resetRoot]);
  React.useImperativeHandle(ref, () => navigation, [navigation]);
  const onDispatchAction = React.useCallback((action, noop) => {
    emitter.emit({
      type: '__unsafe_action__',
      data: {
        action,
        noop,
        stack: stackRef.current
      }
    });
  }, [emitter]);
  const lastEmittedOptionsRef = React.useRef();
  const onOptionsChange = React.useCallback(options => {
    if (lastEmittedOptionsRef.current === options) {
      return;
    }
    lastEmittedOptionsRef.current = options;
    emitter.emit({
      type: 'options',
      data: {
        options
      }
    });
  }, [emitter]);
  const stackRef = React.useRef();
  const builderContext = React.useMemo(() => ({
    addListener,
    addKeyedListener,
    onDispatchAction,
    onOptionsChange,
    stackRef
  }), [addListener, addKeyedListener, onDispatchAction, onOptionsChange]);
  const scheduleContext = React.useMemo(() => ({
    scheduleUpdate,
    flushUpdates
  }), [scheduleUpdate, flushUpdates]);
  const isInitialRef = React.useRef(true);
  const getIsInitial = React.useCallback(() => isInitialRef.current, []);
  const context = React.useMemo(() => ({
    state,
    getState,
    setState,
    getKey,
    setKey,
    getIsInitial,
    addOptionsGetter
  }), [state, getState, setState, getKey, setKey, getIsInitial, addOptionsGetter]);
  const onStateChangeRef = React.useRef(onStateChange);
  const stateRef = React.useRef(state);
  React.useEffect(() => {
    isInitialRef.current = false;
    onStateChangeRef.current = onStateChange;
    stateRef.current = state;
  });
  React.useEffect(() => {
    const hydratedState = getRootState();
    if (false) { var _pointer; }
    emitter.emit({
      type: 'state',
      data: {
        state
      }
    });
    if (!isFirstMountRef.current && onStateChangeRef.current) {
      onStateChangeRef.current(hydratedState);
    }
    isFirstMountRef.current = false;
  }, [getRootState, emitter, state]);
  const defaultOnUnhandledAction = React.useCallback(action => {
    if (true) {
      return;
    }
    const payload = action.payload;
    let message = `The action '${action.type}'${payload ? ` with payload ${JSON.stringify(action.payload)}` : ''} was not handled by any navigator.`;
    switch (action.type) {
      case 'NAVIGATE':
      case 'PUSH':
      case 'REPLACE':
      case 'JUMP_TO':
        if (payload !== null && payload !== void 0 && payload.name) {
          message += `\n\nDo you have a screen named '${payload.name}'?\n\nIf you're trying to navigate to a screen in a nested navigator, see https://reactnavigation.org/docs/nesting-navigators#navigating-to-a-screen-in-a-nested-navigator.`;
        } else {
          message += `\n\nYou need to pass the name of the screen to navigate to.\n\nSee https://reactnavigation.org/docs/navigation-actions for usage.`;
        }
        break;
      case 'GO_BACK':
      case 'POP':
      case 'POP_TO_TOP':
        message += `\n\nIs there any screen to go back to?`;
        break;
      case 'OPEN_DRAWER':
      case 'CLOSE_DRAWER':
      case 'TOGGLE_DRAWER':
        message += `\n\nIs your screen inside a Drawer navigator?`;
        break;
    }
    message += `\n\nThis is a development-only warning and won't be shown in production.`;
    console.error(message);
  }, []);
  let element = /*#__PURE__*/React.createElement(_NavigationContainerRefContext.default.Provider, {
    value: navigation
  }, /*#__PURE__*/React.createElement(_useScheduleUpdate.ScheduleUpdateContext.Provider, {
    value: scheduleContext
  }, /*#__PURE__*/React.createElement(_NavigationBuilderContext.default.Provider, {
    value: builderContext
  }, /*#__PURE__*/React.createElement(_NavigationStateContext.default.Provider, {
    value: context
  }, /*#__PURE__*/React.createElement(_UnhandledActionContext.default.Provider, {
    value: onUnhandledAction ?? defaultOnUnhandledAction
  }, /*#__PURE__*/React.createElement(_EnsureSingleNavigator.default, null, children))))));
  if (independent) {
    // We need to clear any existing contexts for nested independent container to work correctly
    element = /*#__PURE__*/React.createElement(_NavigationRouteContext.default.Provider, {
      value: undefined
    }, /*#__PURE__*/React.createElement(_NavigationContext.default.Provider, {
      value: undefined
    }, element));
  }
  return element;
});
var _default = BaseNavigationContainer;
exports["default"] = _default;
//# sourceMappingURL=BaseNavigationContainer.js.map

/***/ }),

/***/ 52210:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var React = _interopRequireWildcard(__webpack_require__(16689));
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
/**
 * Context which holds the values for the current navigation tree.
 * Intended for use in SSR. This is not safe to use on the client.
 */
const CurrentRenderContext = /*#__PURE__*/React.createContext(undefined);
var _default = CurrentRenderContext;
exports["default"] = _default;
//# sourceMappingURL=CurrentRenderContext.js.map

/***/ }),

/***/ 25192:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.SingleNavigatorContext = void 0;
exports["default"] = EnsureSingleNavigator;
var React = _interopRequireWildcard(__webpack_require__(16689));
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
const MULTIPLE_NAVIGATOR_ERROR = `Another navigator is already registered for this container. You likely have multiple navigators under a single "NavigationContainer" or "Screen". Make sure each navigator is under a separate "Screen" container. See https://reactnavigation.org/docs/nesting-navigators for a guide on nesting.`;
const SingleNavigatorContext = /*#__PURE__*/React.createContext(undefined);

/**
 * Component which ensures that there's only one navigator nested under it.
 */
exports.SingleNavigatorContext = SingleNavigatorContext;
function EnsureSingleNavigator(_ref) {
  let {
    children
  } = _ref;
  const navigatorKeyRef = React.useRef();
  const value = React.useMemo(() => ({
    register(key) {
      const currentKey = navigatorKeyRef.current;
      if (currentKey !== undefined && key !== currentKey) {
        throw new Error(MULTIPLE_NAVIGATOR_ERROR);
      }
      navigatorKeyRef.current = key;
    },
    unregister(key) {
      const currentKey = navigatorKeyRef.current;
      if (key !== currentKey) {
        return;
      }
      navigatorKeyRef.current = undefined;
    }
  }), []);
  return /*#__PURE__*/React.createElement(SingleNavigatorContext.Provider, {
    value: value
  }, children);
}
//# sourceMappingURL=EnsureSingleNavigator.js.map

/***/ }),

/***/ 22408:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = Group;
/**
 * Empty component used for grouping screen configs.
 */
function Group(_) {
  /* istanbul ignore next */
  return null;
}
//# sourceMappingURL=Group.js.map

/***/ }),

/***/ 11223:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var React = _interopRequireWildcard(__webpack_require__(16689));
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
/**
 * Context which holds the required helpers needed to build nested navigators.
 */
const NavigationBuilderContext = /*#__PURE__*/React.createContext({
  onDispatchAction: () => undefined,
  onOptionsChange: () => undefined
});
var _default = NavigationBuilderContext;
exports["default"] = _default;
//# sourceMappingURL=NavigationBuilderContext.js.map

/***/ }),

/***/ 15523:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var React = _interopRequireWildcard(__webpack_require__(16689));
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
/**
 * Context which holds the route prop for a screen.
 */
const NavigationContainerRefContext = /*#__PURE__*/React.createContext(undefined);
var _default = NavigationContainerRefContext;
exports["default"] = _default;
//# sourceMappingURL=NavigationContainerRefContext.js.map

/***/ }),

/***/ 10871:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var React = _interopRequireWildcard(__webpack_require__(16689));
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
/**
 * Context which holds the navigation prop for a screen.
 */
const NavigationContext = /*#__PURE__*/React.createContext(undefined);
var _default = NavigationContext;
exports["default"] = _default;
//# sourceMappingURL=NavigationContext.js.map

/***/ }),

/***/ 77709:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var React = _interopRequireWildcard(__webpack_require__(16689));
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
/**
 * Context which holds the navigation helpers of the parent navigator.
 * Navigators should use this context in their view component.
 */
const NavigationHelpersContext = /*#__PURE__*/React.createContext(undefined);
var _default = NavigationHelpersContext;
exports["default"] = _default;
//# sourceMappingURL=NavigationHelpersContext.js.map

/***/ }),

/***/ 44820:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var React = _interopRequireWildcard(__webpack_require__(16689));
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
/**
 * Context which holds the route prop for a screen.
 */
const NavigationRouteContext = /*#__PURE__*/React.createContext(undefined);
var _default = NavigationRouteContext;
exports["default"] = _default;
//# sourceMappingURL=NavigationRouteContext.js.map

/***/ }),

/***/ 21726:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var React = _interopRequireWildcard(__webpack_require__(16689));
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
const MISSING_CONTEXT_ERROR = "Couldn't find a navigation context. Have you wrapped your app with 'NavigationContainer'? See https://reactnavigation.org/docs/getting-started for setup instructions.";
var _default = /*#__PURE__*/React.createContext({
  isDefault: true,
  get getKey() {
    throw new Error(MISSING_CONTEXT_ERROR);
  },
  get setKey() {
    throw new Error(MISSING_CONTEXT_ERROR);
  },
  get getState() {
    throw new Error(MISSING_CONTEXT_ERROR);
  },
  get setState() {
    throw new Error(MISSING_CONTEXT_ERROR);
  },
  get getIsInitial() {
    throw new Error(MISSING_CONTEXT_ERROR);
  }
});
exports["default"] = _default;
//# sourceMappingURL=NavigationStateContext.js.map

/***/ }),

/***/ 16530:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var React = _interopRequireWildcard(__webpack_require__(16689));
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
const PreventRemoveContext = /*#__PURE__*/React.createContext(undefined);
var _default = PreventRemoveContext;
exports["default"] = _default;
//# sourceMappingURL=PreventRemoveContext.js.map

/***/ }),

/***/ 83829:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = PreventRemoveProvider;
var _nonSecure = __webpack_require__(77869);
var React = _interopRequireWildcard(__webpack_require__(16689));
var _useLatestCallback = _interopRequireDefault(__webpack_require__(13438));
var _NavigationHelpersContext = _interopRequireDefault(__webpack_require__(77709));
var _NavigationRouteContext = _interopRequireDefault(__webpack_require__(44820));
var _PreventRemoveContext = _interopRequireDefault(__webpack_require__(16530));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
/**
 * Util function to transform map of prevented routes to a simpler object.
 */
const transformPreventedRoutes = preventedRoutesMap => {
  const preventedRoutesToTransform = [...preventedRoutesMap.values()];
  const preventedRoutes = preventedRoutesToTransform.reduce((acc, _ref) => {
    var _acc$routeKey;
    let {
      routeKey,
      preventRemove
    } = _ref;
    acc[routeKey] = {
      preventRemove: ((_acc$routeKey = acc[routeKey]) === null || _acc$routeKey === void 0 ? void 0 : _acc$routeKey.preventRemove) || preventRemove
    };
    return acc;
  }, {});
  return preventedRoutes;
};

/**
 * Component used for managing which routes have to be prevented from removal in native-stack.
 */
function PreventRemoveProvider(_ref2) {
  let {
    children
  } = _ref2;
  const [parentId] = React.useState(() => (0, _nonSecure.nanoid)());
  const [preventedRoutesMap, setPreventedRoutesMap] = React.useState(new Map());
  const navigation = React.useContext(_NavigationHelpersContext.default);
  const route = React.useContext(_NavigationRouteContext.default);
  const preventRemoveContextValue = React.useContext(_PreventRemoveContext.default);
  // take `setPreventRemove` from parent context - if exist it means we're in a nested context
  const setParentPrevented = preventRemoveContextValue === null || preventRemoveContextValue === void 0 ? void 0 : preventRemoveContextValue.setPreventRemove;
  const setPreventRemove = (0, _useLatestCallback.default)((id, routeKey, preventRemove) => {
    if (preventRemove && (navigation == null || navigation !== null && navigation !== void 0 && navigation.getState().routes.every(route => route.key !== routeKey))) {
      throw new Error(`Couldn't find a route with the key ${routeKey}. Is your component inside NavigationContent?`);
    }
    setPreventedRoutesMap(prevPrevented => {
      var _prevPrevented$get, _prevPrevented$get2;
      // values haven't changed - do nothing
      if (routeKey === ((_prevPrevented$get = prevPrevented.get(id)) === null || _prevPrevented$get === void 0 ? void 0 : _prevPrevented$get.routeKey) && preventRemove === ((_prevPrevented$get2 = prevPrevented.get(id)) === null || _prevPrevented$get2 === void 0 ? void 0 : _prevPrevented$get2.preventRemove)) {
        return prevPrevented;
      }
      const nextPrevented = new Map(prevPrevented);
      if (preventRemove) {
        nextPrevented.set(id, {
          routeKey,
          preventRemove
        });
      } else {
        nextPrevented.delete(id);
      }
      return nextPrevented;
    });
  });
  const isPrevented = [...preventedRoutesMap.values()].some(_ref3 => {
    let {
      preventRemove
    } = _ref3;
    return preventRemove;
  });
  React.useEffect(() => {
    if ((route === null || route === void 0 ? void 0 : route.key) !== undefined && setParentPrevented !== undefined) {
      // when route is defined (and setParentPrevented) it means we're in a nested stack
      // route.key then will be the route key of parent
      setParentPrevented(parentId, route.key, isPrevented);
      return () => {
        setParentPrevented(parentId, route.key, false);
      };
    }
    return;
  }, [parentId, isPrevented, route === null || route === void 0 ? void 0 : route.key, setParentPrevented]);
  const value = React.useMemo(() => ({
    setPreventRemove,
    preventedRoutes: transformPreventedRoutes(preventedRoutesMap)
  }), [setPreventRemove, preventedRoutesMap]);
  return /*#__PURE__*/React.createElement(_PreventRemoveContext.default.Provider, {
    value: value
  }, children);
}
//# sourceMappingURL=PreventRemoveProvider.js.map

/***/ }),

/***/ 3776:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = SceneView;
var React = _interopRequireWildcard(__webpack_require__(16689));
var _EnsureSingleNavigator = _interopRequireDefault(__webpack_require__(25192));
var _NavigationStateContext = _interopRequireDefault(__webpack_require__(21726));
var _StaticContainer = _interopRequireDefault(__webpack_require__(24344));
var _useOptionsGetters = _interopRequireDefault(__webpack_require__(72893));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
/**
 * Component which takes care of rendering the screen for a route.
 * It provides all required contexts and applies optimizations when applicable.
 */
function SceneView(_ref) {
  let {
    screen,
    route,
    navigation,
    routeState,
    getState,
    setState,
    options,
    clearOptions
  } = _ref;
  const navigatorKeyRef = React.useRef();
  const getKey = React.useCallback(() => navigatorKeyRef.current, []);
  const {
    addOptionsGetter
  } = (0, _useOptionsGetters.default)({
    key: route.key,
    options,
    navigation
  });
  const setKey = React.useCallback(key => {
    navigatorKeyRef.current = key;
  }, []);
  const getCurrentState = React.useCallback(() => {
    const state = getState();
    const currentRoute = state.routes.find(r => r.key === route.key);
    return currentRoute ? currentRoute.state : undefined;
  }, [getState, route.key]);
  const setCurrentState = React.useCallback(child => {
    const state = getState();
    setState({
      ...state,
      routes: state.routes.map(r => r.key === route.key ? {
        ...r,
        state: child
      } : r)
    });
  }, [getState, route.key, setState]);
  const isInitialRef = React.useRef(true);
  React.useEffect(() => {
    isInitialRef.current = false;
  });

  // Clear options set by this screen when it is unmounted
  React.useEffect(() => {
    return clearOptions;
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);
  const getIsInitial = React.useCallback(() => isInitialRef.current, []);
  const context = React.useMemo(() => ({
    state: routeState,
    getState: getCurrentState,
    setState: setCurrentState,
    getKey,
    setKey,
    getIsInitial,
    addOptionsGetter
  }), [routeState, getCurrentState, setCurrentState, getKey, setKey, getIsInitial, addOptionsGetter]);
  const ScreenComponent = screen.getComponent ? screen.getComponent() : screen.component;
  return /*#__PURE__*/React.createElement(_NavigationStateContext.default.Provider, {
    value: context
  }, /*#__PURE__*/React.createElement(_EnsureSingleNavigator.default, null, /*#__PURE__*/React.createElement(_StaticContainer.default, {
    name: screen.name,
    render: ScreenComponent || screen.children,
    navigation: navigation,
    route: route
  }, ScreenComponent !== undefined ? /*#__PURE__*/React.createElement(ScreenComponent, {
    navigation: navigation,
    route: route
  }) : screen.children !== undefined ? screen.children({
    navigation,
    route
  }) : null)));
}
//# sourceMappingURL=SceneView.js.map

/***/ }),

/***/ 68894:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = Screen;
/**
 * Empty component used for specifying route configuration.
 */
function Screen(_) {
  /* istanbul ignore next */
  return null;
}
//# sourceMappingURL=Screen.js.map

/***/ }),

/***/ 24344:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var React = _interopRequireWildcard(__webpack_require__(16689));
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
/**
 * Component which prevents updates for children if no props changed
 */
function StaticContainer(props) {
  return props.children;
}
var _default = /*#__PURE__*/React.memo(StaticContainer, (prevProps, nextProps) => {
  const prevPropKeys = Object.keys(prevProps);
  const nextPropKeys = Object.keys(nextProps);
  if (prevPropKeys.length !== nextPropKeys.length) {
    return false;
  }
  for (const key of prevPropKeys) {
    if (key === 'children') {
      continue;
    }
    if (prevProps[key] !== nextProps[key]) {
      return false;
    }
  }
  return true;
});
exports["default"] = _default;
//# sourceMappingURL=StaticContainer.js.map

/***/ }),

/***/ 76971:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var React = _interopRequireWildcard(__webpack_require__(16689));
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
const UnhandledActionContext = /*#__PURE__*/React.createContext(undefined);
var _default = UnhandledActionContext;
exports["default"] = _default;
//# sourceMappingURL=UnhandledActionContext.js.map

/***/ }),

/***/ 7541:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = checkDuplicateRouteNames;
function checkDuplicateRouteNames(state) {
  const duplicates = [];
  const getRouteNames = (location, state) => {
    state.routes.forEach(route => {
      var _route$state, _route$state$routeNam;
      const currentLocation = location ? `${location} > ${route.name}` : route.name;
      (_route$state = route.state) === null || _route$state === void 0 ? void 0 : (_route$state$routeNam = _route$state.routeNames) === null || _route$state$routeNam === void 0 ? void 0 : _route$state$routeNam.forEach(routeName => {
        if (routeName === route.name) {
          duplicates.push([currentLocation, `${currentLocation} > ${route.name}`]);
        }
      });
      if (route.state) {
        getRouteNames(currentLocation, route.state);
      }
    });
  };
  getRouteNames('', state);
  return duplicates;
}
//# sourceMappingURL=checkDuplicateRouteNames.js.map

/***/ }),

/***/ 8863:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = checkSerializable;
const checkSerializableWithoutCircularReference = (o, seen, location) => {
  if (o === undefined || o === null || typeof o === 'boolean' || typeof o === 'number' || typeof o === 'string') {
    return {
      serializable: true
    };
  }
  if (Object.prototype.toString.call(o) !== '[object Object]' && !Array.isArray(o)) {
    return {
      serializable: false,
      location,
      reason: typeof o === 'function' ? 'Function' : String(o)
    };
  }
  if (seen.has(o)) {
    return {
      serializable: false,
      reason: 'Circular reference',
      location
    };
  }
  seen.add(o);
  if (Array.isArray(o)) {
    for (let i = 0; i < o.length; i++) {
      const childResult = checkSerializableWithoutCircularReference(o[i], new Set(seen), [...location, i]);
      if (!childResult.serializable) {
        return childResult;
      }
    }
  } else {
    for (const key in o) {
      const childResult = checkSerializableWithoutCircularReference(o[key], new Set(seen), [...location, key]);
      if (!childResult.serializable) {
        return childResult;
      }
    }
  }
  return {
    serializable: true
  };
};
function checkSerializable(o) {
  return checkSerializableWithoutCircularReference(o, new Set(), []);
}
//# sourceMappingURL=checkSerializable.js.map

/***/ }),

/***/ 80742:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.NOT_INITIALIZED_ERROR = void 0;
exports["default"] = createNavigationContainerRef;
var _routers = __webpack_require__(55789);
const NOT_INITIALIZED_ERROR = "The 'navigation' object hasn't been initialized yet. This might happen if you don't have a navigator mounted, or if the navigator hasn't finished mounting. See https://reactnavigation.org/docs/navigating-without-navigation-prop#handling-initialization for more details.";
exports.NOT_INITIALIZED_ERROR = NOT_INITIALIZED_ERROR;
function createNavigationContainerRef() {
  const methods = [...Object.keys(_routers.CommonActions), 'addListener', 'removeListener', 'resetRoot', 'dispatch', 'isFocused', 'canGoBack', 'getRootState', 'getState', 'getParent', 'getCurrentRoute', 'getCurrentOptions'];
  const listeners = {};
  const removeListener = (event, callback) => {
    if (listeners[event]) {
      listeners[event] = listeners[event].filter(cb => cb !== callback);
    }
  };
  let current = null;
  const ref = {
    get current() {
      return current;
    },
    set current(value) {
      current = value;
      if (value != null) {
        Object.entries(listeners).forEach(_ref => {
          let [event, callbacks] = _ref;
          callbacks.forEach(callback => {
            value.addListener(event, callback);
          });
        });
      }
    },
    isReady: () => {
      if (current == null) {
        return false;
      }
      return current.isReady();
    },
    ...methods.reduce((acc, name) => {
      acc[name] = function () {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        if (current == null) {
          switch (name) {
            case 'addListener':
              {
                const [event, callback] = args;
                listeners[event] = listeners[event] || [];
                listeners[event].push(callback);
                return () => removeListener(event, callback);
              }
            case 'removeListener':
              {
                const [event, callback] = args;
                removeListener(event, callback);
                break;
              }
            default:
              console.error(NOT_INITIALIZED_ERROR);
          }
        } else {
          // @ts-expect-error: this is ok
          return current[name](...args);
        }
      };
      return acc;
    }, {})
  };
  return ref;
}
//# sourceMappingURL=createNavigationContainerRef.js.map

/***/ }),

/***/ 94757:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = createNavigatorFactory;
var _Group = _interopRequireDefault(__webpack_require__(22408));
var _Screen = _interopRequireDefault(__webpack_require__(68894));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
/**
 * Higher order component to create a `Navigator` and `Screen` pair.
 * Custom navigators should wrap the navigator component in `createNavigator` before exporting.
 *
 * @param Navigator The navigtor component to wrap.
 * @returns Factory method to create a `Navigator` and `Screen` pair.
 */
function createNavigatorFactory(Navigator) {
  return function () {
    if (arguments[0] !== undefined) {
      throw new Error("Creating a navigator doesn't take an argument. Maybe you are trying to use React Navigation 4 API? See https://reactnavigation.org/docs/hello-react-navigation for the latest API and guides.");
    }
    return {
      Navigator,
      Group: _Group.default,
      Screen: _Screen.default
    };
  };
}
//# sourceMappingURL=createNavigatorFactory.js.map

/***/ }),

/***/ 61392:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = findFocusedRoute;
function findFocusedRoute(state) {
  var _current2, _current3;
  let current = state;
  while (((_current = current) === null || _current === void 0 ? void 0 : _current.routes[current.index ?? 0].state) != null) {
    var _current;
    current = current.routes[current.index ?? 0].state;
  }
  const route = (_current2 = current) === null || _current2 === void 0 ? void 0 : _current2.routes[((_current3 = current) === null || _current3 === void 0 ? void 0 : _current3.index) ?? 0];
  return route;
}
//# sourceMappingURL=findFocusedRoute.js.map

/***/ }),

/***/ 74139:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = fromEntries;
// Object.fromEntries is not available in older iOS versions
function fromEntries(entries) {
  return entries.reduce((acc, _ref) => {
    let [k, v] = _ref;
    if (acc.hasOwnProperty(k)) {
      throw new Error(`A value for key '${k}' already exists in the object.`);
    }
    acc[k] = v;
    return acc;
  }, {});
}
//# sourceMappingURL=fromEntries.js.map

/***/ }),

/***/ 67486:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = getActionFromState;
function getActionFromState(state, options) {
  var _normalizedConfig$scr;
  // Create a normalized configs object which will be easier to use
  const normalizedConfig = options ? createNormalizedConfigItem(options) : {};
  const routes = state.index != null ? state.routes.slice(0, state.index + 1) : state.routes;
  if (routes.length === 0) {
    return undefined;
  }
  if (!(routes.length === 1 && routes[0].key === undefined || routes.length === 2 && routes[0].key === undefined && routes[0].name === (normalizedConfig === null || normalizedConfig === void 0 ? void 0 : normalizedConfig.initialRouteName) && routes[1].key === undefined)) {
    return {
      type: 'RESET',
      payload: state
    };
  }
  const route = state.routes[state.index ?? state.routes.length - 1];
  let current = route === null || route === void 0 ? void 0 : route.state;
  let config = normalizedConfig === null || normalizedConfig === void 0 ? void 0 : (_normalizedConfig$scr = normalizedConfig.screens) === null || _normalizedConfig$scr === void 0 ? void 0 : _normalizedConfig$scr[route === null || route === void 0 ? void 0 : route.name];
  let params = {
    ...route.params
  };
  let payload = route ? {
    name: route.name,
    path: route.path,
    params
  } : undefined;
  while (current) {
    var _config, _config2, _config2$screens;
    if (current.routes.length === 0) {
      return undefined;
    }
    const routes = current.index != null ? current.routes.slice(0, current.index + 1) : current.routes;
    const route = routes[routes.length - 1];

    // Explicitly set to override existing value when merging params
    Object.assign(params, {
      initial: undefined,
      screen: undefined,
      params: undefined,
      state: undefined
    });
    if (routes.length === 1 && routes[0].key === undefined) {
      params.initial = true;
      params.screen = route.name;
    } else if (routes.length === 2 && routes[0].key === undefined && routes[0].name === ((_config = config) === null || _config === void 0 ? void 0 : _config.initialRouteName) && routes[1].key === undefined) {
      params.initial = false;
      params.screen = route.name;
    } else {
      params.state = current;
      break;
    }
    if (route.state) {
      params.params = {
        ...route.params
      };
      params = params.params;
    } else {
      params.path = route.path;
      params.params = route.params;
    }
    current = route.state;
    config = (_config2 = config) === null || _config2 === void 0 ? void 0 : (_config2$screens = _config2.screens) === null || _config2$screens === void 0 ? void 0 : _config2$screens[route.name];
  }
  if (!payload) {
    return;
  }

  // Try to construct payload for a `NAVIGATE` action from the state
  // This lets us preserve the navigation state and not lose it
  return {
    type: 'NAVIGATE',
    payload
  };
}
const createNormalizedConfigItem = config => typeof config === 'object' && config != null ? {
  initialRouteName: config.initialRouteName,
  screens: config.screens != null ? createNormalizedConfigs(config.screens) : undefined
} : {};
const createNormalizedConfigs = options => Object.entries(options).reduce((acc, _ref) => {
  let [k, v] = _ref;
  acc[k] = createNormalizedConfigItem(v);
  return acc;
}, {});
//# sourceMappingURL=getActionFromState.js.map

/***/ }),

/***/ 56270:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = getFocusedRouteNameFromRoute;
var _useRouteCache = __webpack_require__(37763);
function getFocusedRouteNameFromRoute(route) {
  // @ts-expect-error: this isn't in type definitions coz we want this private
  const state = route[_useRouteCache.CHILD_STATE] ?? route.state;
  const params = route.params;
  const routeName = state ?
  // Get the currently active route name in the nested navigator
  state.routes[
  // If we have a partial state without index, for tab/drawer, first screen will be focused one, and last for stack
  // The type property will only exist for rehydrated state and not for state from deep link
  state.index ?? (typeof state.type === 'string' && state.type !== 'stack' ? 0 : state.routes.length - 1)].name :
  // If state doesn't exist, we need to default to `screen` param if available
  typeof (params === null || params === void 0 ? void 0 : params.screen) === 'string' ? params.screen : undefined;
  return routeName;
}
//# sourceMappingURL=getFocusedRouteNameFromRoute.js.map

/***/ }),

/***/ 88225:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = getPathFromState;
var queryString = _interopRequireWildcard(__webpack_require__(79103));
var _fromEntries = _interopRequireDefault(__webpack_require__(74139));
var _validatePathConfig = _interopRequireDefault(__webpack_require__(97579));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
const getActiveRoute = state => {
  const route = typeof state.index === 'number' ? state.routes[state.index] : state.routes[state.routes.length - 1];
  if (route.state) {
    return getActiveRoute(route.state);
  }
  return route;
};

/**
 * Utility to serialize a navigation state object to a path string.
 *
 * @example
 * ```js
 * getPathFromState(
 *   {
 *     routes: [
 *       {
 *         name: 'Chat',
 *         params: { author: 'Jane', id: 42 },
 *       },
 *     ],
 *   },
 *   {
 *     screens: {
 *       Chat: {
 *         path: 'chat/:author/:id',
 *         stringify: { author: author => author.toLowerCase() }
 *       }
 *     }
 *   }
 * )
 * ```
 *
 * @param state Navigation state to serialize.
 * @param options Extra options to fine-tune how to serialize the path.
 * @returns Path representing the state, e.g. /foo/bar?count=42.
 */
function getPathFromState(state, options) {
  if (state == null) {
    throw Error("Got 'undefined' for the navigation state. You must pass a valid state object.");
  }
  if (options) {
    (0, _validatePathConfig.default)(options);
  }

  // Create a normalized configs object which will be easier to use
  const configs = options !== null && options !== void 0 && options.screens ? createNormalizedConfigs(options === null || options === void 0 ? void 0 : options.screens) : {};
  let path = '/';
  let current = state;
  const allParams = {};
  while (current) {
    let index = typeof current.index === 'number' ? current.index : 0;
    let route = current.routes[index];
    let pattern;
    let focusedParams;
    let focusedRoute = getActiveRoute(state);
    let currentOptions = configs;

    // Keep all the route names that appeared during going deeper in config in case the pattern is resolved to undefined
    let nestedRouteNames = [];
    let hasNext = true;
    while (route.name in currentOptions && hasNext) {
      pattern = currentOptions[route.name].pattern;
      nestedRouteNames.push(route.name);
      if (route.params) {
        var _currentOptions$route;
        const stringify = (_currentOptions$route = currentOptions[route.name]) === null || _currentOptions$route === void 0 ? void 0 : _currentOptions$route.stringify;
        const currentParams = (0, _fromEntries.default)(Object.entries(route.params).map(_ref => {
          let [key, value] = _ref;
          return [key, stringify !== null && stringify !== void 0 && stringify[key] ? stringify[key](value) : String(value)];
        }));
        if (pattern) {
          Object.assign(allParams, currentParams);
        }
        if (focusedRoute === route) {
          var _pattern;
          // If this is the focused route, keep the params for later use
          // We save it here since it's been stringified already
          focusedParams = {
            ...currentParams
          };
          (_pattern = pattern) === null || _pattern === void 0 ? void 0 : _pattern.split('/').filter(p => p.startsWith(':'))
          // eslint-disable-next-line no-loop-func
          .forEach(p => {
            const name = getParamName(p);

            // Remove the params present in the pattern since we'll only use the rest for query string
            if (focusedParams) {
              // eslint-disable-next-line @typescript-eslint/no-dynamic-delete
              delete focusedParams[name];
            }
          });
        }
      }

      // If there is no `screens` property or no nested state, we return pattern
      if (!currentOptions[route.name].screens || route.state === undefined) {
        hasNext = false;
      } else {
        index = typeof route.state.index === 'number' ? route.state.index : route.state.routes.length - 1;
        const nextRoute = route.state.routes[index];
        const nestedConfig = currentOptions[route.name].screens;

        // if there is config for next route name, we go deeper
        if (nestedConfig && nextRoute.name in nestedConfig) {
          route = nextRoute;
          currentOptions = nestedConfig;
        } else {
          // If not, there is no sense in going deeper in config
          hasNext = false;
        }
      }
    }
    if (pattern === undefined) {
      pattern = nestedRouteNames.join('/');
    }
    if (currentOptions[route.name] !== undefined) {
      path += pattern.split('/').map(p => {
        const name = getParamName(p);

        // We don't know what to show for wildcard patterns
        // Showing the route name seems ok, though whatever we show here will be incorrect
        // Since the page doesn't actually exist
        if (p === '*') {
          return route.name;
        }

        // If the path has a pattern for a param, put the param in the path
        if (p.startsWith(':')) {
          const value = allParams[name];
          if (value === undefined && p.endsWith('?')) {
            // Optional params without value assigned in route.params should be ignored
            return '';
          }
          return encodeURIComponent(value);
        }
        return encodeURIComponent(p);
      }).join('/');
    } else {
      path += encodeURIComponent(route.name);
    }
    if (!focusedParams) {
      focusedParams = focusedRoute.params;
    }
    if (route.state) {
      path += '/';
    } else if (focusedParams) {
      for (let param in focusedParams) {
        if (focusedParams[param] === 'undefined') {
          // eslint-disable-next-line @typescript-eslint/no-dynamic-delete
          delete focusedParams[param];
        }
      }
      const query = queryString.stringify(focusedParams, {
        sort: false
      });
      if (query) {
        path += `?${query}`;
      }
    }
    current = route.state;
  }

  // Remove multiple as well as trailing slashes
  path = path.replace(/\/+/g, '/');
  path = path.length > 1 ? path.replace(/\/$/, '') : path;
  return path;
}
const getParamName = pattern => pattern.replace(/^:/, '').replace(/\?$/, '');
const joinPaths = function () {
  for (var _len = arguments.length, paths = new Array(_len), _key = 0; _key < _len; _key++) {
    paths[_key] = arguments[_key];
  }
  return [].concat(...paths.map(p => p.split('/'))).filter(Boolean).join('/');
};
const createConfigItem = (config, parentPattern) => {
  var _pattern2;
  if (typeof config === 'string') {
    // If a string is specified as the value of the key(e.g. Foo: '/path'), use it as the pattern
    const pattern = parentPattern ? joinPaths(parentPattern, config) : config;
    return {
      pattern
    };
  }

  // If an object is specified as the value (e.g. Foo: { ... }),
  // It can have `path` property and `screens` prop which has nested configs
  let pattern;
  if (config.exact && config.path === undefined) {
    throw new Error("A 'path' needs to be specified when specifying 'exact: true'. If you don't want this screen in the URL, specify it as empty string, e.g. `path: ''`.");
  }
  pattern = config.exact !== true ? joinPaths(parentPattern || '', config.path || '') : config.path || '';
  const screens = config.screens ? createNormalizedConfigs(config.screens, pattern) : undefined;
  return {
    // Normalize pattern to remove any leading, trailing slashes, duplicate slashes etc.
    pattern: (_pattern2 = pattern) === null || _pattern2 === void 0 ? void 0 : _pattern2.split('/').filter(Boolean).join('/'),
    stringify: config.stringify,
    screens
  };
};
const createNormalizedConfigs = (options, pattern) => (0, _fromEntries.default)(Object.entries(options).map(_ref2 => {
  let [name, c] = _ref2;
  const result = createConfigItem(c, pattern);
  return [name, result];
}));
//# sourceMappingURL=getPathFromState.js.map

/***/ }),

/***/ 96336:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = getStateFromPath;
var _escapeStringRegexp = _interopRequireDefault(__webpack_require__(49295));
var queryString = _interopRequireWildcard(__webpack_require__(79103));
var _findFocusedRoute = _interopRequireDefault(__webpack_require__(61392));
var _validatePathConfig = _interopRequireDefault(__webpack_require__(97579));
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
/**
 * Utility to parse a path string to initial state object accepted by the container.
 * This is useful for deep linking when we need to handle the incoming URL.
 *
 * @example
 * ```js
 * getStateFromPath(
 *   '/chat/jane/42',
 *   {
 *     screens: {
 *       Chat: {
 *         path: 'chat/:author/:id',
 *         parse: { id: Number }
 *       }
 *     }
 *   }
 * )
 * ```
 * @param path Path string to parse and convert, e.g. /foo/bar?count=42.
 * @param options Extra options to fine-tune how to parse the path.
 */
function getStateFromPath(path, options) {
  if (options) {
    (0, _validatePathConfig.default)(options);
  }
  let initialRoutes = [];
  if (options !== null && options !== void 0 && options.initialRouteName) {
    initialRoutes.push({
      initialRouteName: options.initialRouteName,
      parentScreens: []
    });
  }
  const screens = options === null || options === void 0 ? void 0 : options.screens;
  let remaining = path.replace(/\/+/g, '/') // Replace multiple slash (//) with single ones
  .replace(/^\//, '') // Remove extra leading slash
  .replace(/\?.*$/, ''); // Remove query params which we will handle later

  // Make sure there is a trailing slash
  remaining = remaining.endsWith('/') ? remaining : `${remaining}/`;
  if (screens === undefined) {
    // When no config is specified, use the path segments as route names
    const routes = remaining.split('/').filter(Boolean).map(segment => {
      const name = decodeURIComponent(segment);
      return {
        name
      };
    });
    if (routes.length) {
      return createNestedStateObject(path, routes, initialRoutes);
    }
    return undefined;
  }

  // Create a normalized configs array which will be easier to use
  const configs = [].concat(...Object.keys(screens).map(key => createNormalizedConfigs(key, screens, [], initialRoutes, []))).sort((a, b) => {
    // Sort config so that:
    // - the most exhaustive ones are always at the beginning
    // - patterns with wildcard are always at the end

    // If 2 patterns are same, move the one with less route names up
    // This is an error state, so it's only useful for consistent error messages
    if (a.pattern === b.pattern) {
      return b.routeNames.join('>').localeCompare(a.routeNames.join('>'));
    }

    // If one of the patterns starts with the other, it's more exhaustive
    // So move it up
    if (a.pattern.startsWith(b.pattern)) {
      return -1;
    }
    if (b.pattern.startsWith(a.pattern)) {
      return 1;
    }
    const aParts = a.pattern.split('/');
    const bParts = b.pattern.split('/');
    for (let i = 0; i < Math.max(aParts.length, bParts.length); i++) {
      // if b is longer, b get higher priority
      if (aParts[i] == null) {
        return 1;
      }
      // if a is longer, a get higher priority
      if (bParts[i] == null) {
        return -1;
      }
      const aWildCard = aParts[i] === '*' || aParts[i].startsWith(':');
      const bWildCard = bParts[i] === '*' || bParts[i].startsWith(':');
      // if both are wildcard we compare next component
      if (aWildCard && bWildCard) {
        continue;
      }
      // if only a is wild card, b get higher priority
      if (aWildCard) {
        return 1;
      }
      // if only b is wild card, a get higher priority
      if (bWildCard) {
        return -1;
      }
    }
    return bParts.length - aParts.length;
  });

  // Check for duplicate patterns in the config
  configs.reduce((acc, config) => {
    if (acc[config.pattern]) {
      const a = acc[config.pattern].routeNames;
      const b = config.routeNames;

      // It's not a problem if the path string omitted from a inner most screen
      // For example, it's ok if a path resolves to `A > B > C` or `A > B`
      const intersects = a.length > b.length ? b.every((it, i) => a[i] === it) : a.every((it, i) => b[i] === it);
      if (!intersects) {
        throw new Error(`Found conflicting screens with the same pattern. The pattern '${config.pattern}' resolves to both '${a.join(' > ')}' and '${b.join(' > ')}'. Patterns must be unique and cannot resolve to more than one screen.`);
      }
    }
    return Object.assign(acc, {
      [config.pattern]: config
    });
  }, {});
  if (remaining === '/') {
    // We need to add special handling of empty path so navigation to empty path also works
    // When handling empty path, we should only look at the root level config
    const match = configs.find(config => config.path === '' && config.routeNames.every(
    // Make sure that none of the parent configs have a non-empty path defined
    name => {
      var _configs$find;
      return !((_configs$find = configs.find(c => c.screen === name)) !== null && _configs$find !== void 0 && _configs$find.path);
    }));
    if (match) {
      return createNestedStateObject(path, match.routeNames.map(name => ({
        name
      })), initialRoutes, configs);
    }
    return undefined;
  }
  let result;
  let current;

  // We match the whole path against the regex instead of segments
  // This makes sure matches such as wildcard will catch any unmatched routes, even if nested
  const {
    routes,
    remainingPath
  } = matchAgainstConfigs(remaining, configs.map(c => ({
    ...c,
    // Add `$` to the regex to make sure it matches till end of the path and not just beginning
    regex: c.regex ? new RegExp(c.regex.source + '$') : undefined
  })));
  if (routes !== undefined) {
    // This will always be empty if full path matched
    current = createNestedStateObject(path, routes, initialRoutes, configs);
    remaining = remainingPath;
    result = current;
  }
  if (current == null || result == null) {
    return undefined;
  }
  return result;
}
const joinPaths = function () {
  for (var _len = arguments.length, paths = new Array(_len), _key = 0; _key < _len; _key++) {
    paths[_key] = arguments[_key];
  }
  return [].concat(...paths.map(p => p.split('/'))).filter(Boolean).join('/');
};
const matchAgainstConfigs = (remaining, configs) => {
  let routes;
  let remainingPath = remaining;

  // Go through all configs, and see if the next path segment matches our regex
  for (const config of configs) {
    if (!config.regex) {
      continue;
    }
    const match = remainingPath.match(config.regex);

    // If our regex matches, we need to extract params from the path
    if (match) {
      var _config$pattern;
      const matchedParams = (_config$pattern = config.pattern) === null || _config$pattern === void 0 ? void 0 : _config$pattern.split('/').filter(p => p.startsWith(':')).reduce((acc, p, i) => Object.assign(acc, {
        // The param segments appear every second item starting from 2 in the regex match result
        [p]: match[(i + 1) * 2].replace(/\//, '')
      }), {});
      routes = config.routeNames.map(name => {
        var _config$path;
        const config = configs.find(c => c.screen === name);
        const params = config === null || config === void 0 ? void 0 : (_config$path = config.path) === null || _config$path === void 0 ? void 0 : _config$path.split('/').filter(p => p.startsWith(':')).reduce((acc, p) => {
          const value = matchedParams[p];
          if (value) {
            var _config$parse;
            const key = p.replace(/^:/, '').replace(/\?$/, '');
            acc[key] = (_config$parse = config.parse) !== null && _config$parse !== void 0 && _config$parse[key] ? config.parse[key](value) : value;
          }
          return acc;
        }, {});
        if (params && Object.keys(params).length) {
          return {
            name,
            params
          };
        }
        return {
          name
        };
      });
      remainingPath = remainingPath.replace(match[1], '');
      break;
    }
  }
  return {
    routes,
    remainingPath
  };
};
const createNormalizedConfigs = function (screen, routeConfig) {
  let routeNames = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
  let initials = arguments.length > 3 ? arguments[3] : undefined;
  let parentScreens = arguments.length > 4 ? arguments[4] : undefined;
  let parentPattern = arguments.length > 5 ? arguments[5] : undefined;
  const configs = [];
  routeNames.push(screen);
  parentScreens.push(screen);

  // @ts-expect-error: we can't strongly typecheck this for now
  const config = routeConfig[screen];
  if (typeof config === 'string') {
    // If a string is specified as the value of the key(e.g. Foo: '/path'), use it as the pattern
    const pattern = parentPattern ? joinPaths(parentPattern, config) : config;
    configs.push(createConfigItem(screen, routeNames, pattern, config));
  } else if (typeof config === 'object') {
    let pattern;

    // if an object is specified as the value (e.g. Foo: { ... }),
    // it can have `path` property and
    // it could have `screens` prop which has nested configs
    if (typeof config.path === 'string') {
      if (config.exact && config.path === undefined) {
        throw new Error("A 'path' needs to be specified when specifying 'exact: true'. If you don't want this screen in the URL, specify it as empty string, e.g. `path: ''`.");
      }
      pattern = config.exact !== true ? joinPaths(parentPattern || '', config.path || '') : config.path || '';
      configs.push(createConfigItem(screen, routeNames, pattern, config.path, config.parse));
    }
    if (config.screens) {
      // property `initialRouteName` without `screens` has no purpose
      if (config.initialRouteName) {
        initials.push({
          initialRouteName: config.initialRouteName,
          parentScreens
        });
      }
      Object.keys(config.screens).forEach(nestedConfig => {
        const result = createNormalizedConfigs(nestedConfig, config.screens, routeNames, initials, [...parentScreens], pattern ?? parentPattern);
        configs.push(...result);
      });
    }
  }
  routeNames.pop();
  return configs;
};
const createConfigItem = (screen, routeNames, pattern, path, parse) => {
  // Normalize pattern to remove any leading, trailing slashes, duplicate slashes etc.
  pattern = pattern.split('/').filter(Boolean).join('/');
  const regex = pattern ? new RegExp(`^(${pattern.split('/').map(it => {
    if (it.startsWith(':')) {
      return `(([^/]+\\/)${it.endsWith('?') ? '?' : ''})`;
    }
    return `${it === '*' ? '.*' : (0, _escapeStringRegexp.default)(it)}\\/`;
  }).join('')})`) : undefined;
  return {
    screen,
    regex,
    pattern,
    path,
    // The routeNames array is mutated, so copy it to keep the current state
    routeNames: [...routeNames],
    parse
  };
};
const findParseConfigForRoute = (routeName, flatConfig) => {
  for (const config of flatConfig) {
    if (routeName === config.routeNames[config.routeNames.length - 1]) {
      return config.parse;
    }
  }
  return undefined;
};

// Try to find an initial route connected with the one passed
const findInitialRoute = (routeName, parentScreens, initialRoutes) => {
  for (const config of initialRoutes) {
    if (parentScreens.length === config.parentScreens.length) {
      let sameParents = true;
      for (let i = 0; i < parentScreens.length; i++) {
        if (parentScreens[i].localeCompare(config.parentScreens[i]) !== 0) {
          sameParents = false;
          break;
        }
      }
      if (sameParents) {
        return routeName !== config.initialRouteName ? config.initialRouteName : undefined;
      }
    }
  }
  return undefined;
};

// returns state object with values depending on whether
// it is the end of state and if there is initialRoute for this level
const createStateObject = (initialRoute, route, isEmpty) => {
  if (isEmpty) {
    if (initialRoute) {
      return {
        index: 1,
        routes: [{
          name: initialRoute
        }, route]
      };
    } else {
      return {
        routes: [route]
      };
    }
  } else {
    if (initialRoute) {
      return {
        index: 1,
        routes: [{
          name: initialRoute
        }, {
          ...route,
          state: {
            routes: []
          }
        }]
      };
    } else {
      return {
        routes: [{
          ...route,
          state: {
            routes: []
          }
        }]
      };
    }
  }
};
const createNestedStateObject = (path, routes, initialRoutes, flatConfig) => {
  let state;
  let route = routes.shift();
  const parentScreens = [];
  let initialRoute = findInitialRoute(route.name, parentScreens, initialRoutes);
  parentScreens.push(route.name);
  state = createStateObject(initialRoute, route, routes.length === 0);
  if (routes.length > 0) {
    let nestedState = state;
    while (route = routes.shift()) {
      initialRoute = findInitialRoute(route.name, parentScreens, initialRoutes);
      const nestedStateIndex = nestedState.index || nestedState.routes.length - 1;
      nestedState.routes[nestedStateIndex].state = createStateObject(initialRoute, route, routes.length === 0);
      if (routes.length > 0) {
        nestedState = nestedState.routes[nestedStateIndex].state;
      }
      parentScreens.push(route.name);
    }
  }
  route = (0, _findFocusedRoute.default)(state);
  route.path = path;
  const params = parseQueryParams(path, flatConfig ? findParseConfigForRoute(route.name, flatConfig) : undefined);
  if (params) {
    route.params = {
      ...route.params,
      ...params
    };
  }
  return state;
};
const parseQueryParams = (path, parseConfig) => {
  const query = path.split('?')[1];
  const params = queryString.parse(query);
  if (parseConfig) {
    Object.keys(params).forEach(name => {
      if (Object.hasOwnProperty.call(parseConfig, name) && typeof params[name] === 'string') {
        params[name] = parseConfig[name](params[name]);
      }
    });
  }
  return Object.keys(params).length ? params : undefined;
};
//# sourceMappingURL=getStateFromPath.js.map

/***/ }),

/***/ 93169:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
var _exportNames = {
  BaseNavigationContainer: true,
  createNavigationContainerRef: true,
  createNavigatorFactory: true,
  CurrentRenderContext: true,
  findFocusedRoute: true,
  getActionFromState: true,
  getFocusedRouteNameFromRoute: true,
  getPathFromState: true,
  getStateFromPath: true,
  NavigationContainerRefContext: true,
  NavigationContext: true,
  NavigationHelpersContext: true,
  NavigationRouteContext: true,
  PreventRemoveContext: true,
  PreventRemoveProvider: true,
  useFocusEffect: true,
  useIsFocused: true,
  useNavigation: true,
  useNavigationBuilder: true,
  useNavigationContainerRef: true,
  useNavigationState: true,
  UNSTABLE_usePreventRemove: true,
  usePreventRemoveContext: true,
  useRoute: true,
  validatePathConfig: true
};
Object.defineProperty(exports, "BaseNavigationContainer", ({
  enumerable: true,
  get: function () {
    return _BaseNavigationContainer.default;
  }
}));
Object.defineProperty(exports, "CurrentRenderContext", ({
  enumerable: true,
  get: function () {
    return _CurrentRenderContext.default;
  }
}));
Object.defineProperty(exports, "NavigationContainerRefContext", ({
  enumerable: true,
  get: function () {
    return _NavigationContainerRefContext.default;
  }
}));
Object.defineProperty(exports, "NavigationContext", ({
  enumerable: true,
  get: function () {
    return _NavigationContext.default;
  }
}));
Object.defineProperty(exports, "NavigationHelpersContext", ({
  enumerable: true,
  get: function () {
    return _NavigationHelpersContext.default;
  }
}));
Object.defineProperty(exports, "NavigationRouteContext", ({
  enumerable: true,
  get: function () {
    return _NavigationRouteContext.default;
  }
}));
Object.defineProperty(exports, "PreventRemoveContext", ({
  enumerable: true,
  get: function () {
    return _PreventRemoveContext.default;
  }
}));
Object.defineProperty(exports, "PreventRemoveProvider", ({
  enumerable: true,
  get: function () {
    return _PreventRemoveProvider.default;
  }
}));
Object.defineProperty(exports, "UNSTABLE_usePreventRemove", ({
  enumerable: true,
  get: function () {
    return _usePreventRemove.default;
  }
}));
Object.defineProperty(exports, "createNavigationContainerRef", ({
  enumerable: true,
  get: function () {
    return _createNavigationContainerRef.default;
  }
}));
Object.defineProperty(exports, "createNavigatorFactory", ({
  enumerable: true,
  get: function () {
    return _createNavigatorFactory.default;
  }
}));
Object.defineProperty(exports, "findFocusedRoute", ({
  enumerable: true,
  get: function () {
    return _findFocusedRoute.default;
  }
}));
Object.defineProperty(exports, "getActionFromState", ({
  enumerable: true,
  get: function () {
    return _getActionFromState.default;
  }
}));
Object.defineProperty(exports, "getFocusedRouteNameFromRoute", ({
  enumerable: true,
  get: function () {
    return _getFocusedRouteNameFromRoute.default;
  }
}));
Object.defineProperty(exports, "getPathFromState", ({
  enumerable: true,
  get: function () {
    return _getPathFromState.default;
  }
}));
Object.defineProperty(exports, "getStateFromPath", ({
  enumerable: true,
  get: function () {
    return _getStateFromPath.default;
  }
}));
Object.defineProperty(exports, "useFocusEffect", ({
  enumerable: true,
  get: function () {
    return _useFocusEffect.default;
  }
}));
Object.defineProperty(exports, "useIsFocused", ({
  enumerable: true,
  get: function () {
    return _useIsFocused.default;
  }
}));
Object.defineProperty(exports, "useNavigation", ({
  enumerable: true,
  get: function () {
    return _useNavigation.default;
  }
}));
Object.defineProperty(exports, "useNavigationBuilder", ({
  enumerable: true,
  get: function () {
    return _useNavigationBuilder.default;
  }
}));
Object.defineProperty(exports, "useNavigationContainerRef", ({
  enumerable: true,
  get: function () {
    return _useNavigationContainerRef.default;
  }
}));
Object.defineProperty(exports, "useNavigationState", ({
  enumerable: true,
  get: function () {
    return _useNavigationState.default;
  }
}));
Object.defineProperty(exports, "usePreventRemoveContext", ({
  enumerable: true,
  get: function () {
    return _usePreventRemoveContext.default;
  }
}));
Object.defineProperty(exports, "useRoute", ({
  enumerable: true,
  get: function () {
    return _useRoute.default;
  }
}));
Object.defineProperty(exports, "validatePathConfig", ({
  enumerable: true,
  get: function () {
    return _validatePathConfig.default;
  }
}));
var _BaseNavigationContainer = _interopRequireDefault(__webpack_require__(48219));
var _createNavigationContainerRef = _interopRequireDefault(__webpack_require__(80742));
var _createNavigatorFactory = _interopRequireDefault(__webpack_require__(94757));
var _CurrentRenderContext = _interopRequireDefault(__webpack_require__(52210));
var _findFocusedRoute = _interopRequireDefault(__webpack_require__(61392));
var _getActionFromState = _interopRequireDefault(__webpack_require__(67486));
var _getFocusedRouteNameFromRoute = _interopRequireDefault(__webpack_require__(56270));
var _getPathFromState = _interopRequireDefault(__webpack_require__(88225));
var _getStateFromPath = _interopRequireDefault(__webpack_require__(96336));
var _NavigationContainerRefContext = _interopRequireDefault(__webpack_require__(15523));
var _NavigationContext = _interopRequireDefault(__webpack_require__(10871));
var _NavigationHelpersContext = _interopRequireDefault(__webpack_require__(77709));
var _NavigationRouteContext = _interopRequireDefault(__webpack_require__(44820));
var _PreventRemoveContext = _interopRequireDefault(__webpack_require__(16530));
var _PreventRemoveProvider = _interopRequireDefault(__webpack_require__(83829));
var _types = __webpack_require__(21768);
Object.keys(_types).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _types[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _types[key];
    }
  });
});
var _useFocusEffect = _interopRequireDefault(__webpack_require__(30230));
var _useIsFocused = _interopRequireDefault(__webpack_require__(90017));
var _useNavigation = _interopRequireDefault(__webpack_require__(92381));
var _useNavigationBuilder = _interopRequireDefault(__webpack_require__(36631));
var _useNavigationContainerRef = _interopRequireDefault(__webpack_require__(67675));
var _useNavigationState = _interopRequireDefault(__webpack_require__(85197));
var _usePreventRemove = _interopRequireDefault(__webpack_require__(11984));
var _usePreventRemoveContext = _interopRequireDefault(__webpack_require__(53538));
var _useRoute = _interopRequireDefault(__webpack_require__(40685));
var _validatePathConfig = _interopRequireDefault(__webpack_require__(97579));
var _routers = __webpack_require__(55789);
Object.keys(_routers).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _routers[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _routers[key];
    }
  });
});
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 16842:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = isArrayEqual;
/**
 * Compare two arrays with primitive values as the content.
 * We need to make sure that both values and order match.
 */
function isArrayEqual(a, b) {
  if (a === b) {
    return true;
  }
  if (a.length !== b.length) {
    return false;
  }
  return a.every((it, index) => it === b[index]);
}
//# sourceMappingURL=isArrayEqual.js.map

/***/ }),

/***/ 80219:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = isRecordEqual;
/**
 * Compare two records with primitive values as the content.
 */
function isRecordEqual(a, b) {
  if (a === b) {
    return true;
  }
  const aKeys = Object.keys(a);
  const bKeys = Object.keys(b);
  if (aKeys.length !== bKeys.length) {
    return false;
  }
  return aKeys.every(key => a[key] === b[key]);
}
//# sourceMappingURL=isRecordEqual.js.map

/***/ }),

/***/ 21768:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.PrivateValueStore = void 0;
class PrivateValueStore {}
exports.PrivateValueStore = PrivateValueStore;
//# sourceMappingURL=types.js.map

/***/ }),

/***/ 49275:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = useChildListeners;
var React = _interopRequireWildcard(__webpack_require__(16689));
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
/**
 * Hook which lets child navigators add action listeners.
 */
function useChildListeners() {
  const {
    current: listeners
  } = React.useRef({
    action: [],
    focus: []
  });
  const addListener = React.useCallback((type, listener) => {
    listeners[type].push(listener);
    let removed = false;
    return () => {
      const index = listeners[type].indexOf(listener);
      if (!removed && index > -1) {
        removed = true;
        listeners[type].splice(index, 1);
      }
    };
  }, [listeners]);
  return {
    listeners,
    addListener
  };
}
//# sourceMappingURL=useChildListeners.js.map

/***/ }),

/***/ 71368:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = useComponent;
var React = _interopRequireWildcard(__webpack_require__(16689));
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
const NavigationContent = _ref => {
  let {
    render,
    children
  } = _ref;
  return render(children);
};
function useComponent(render) {
  const renderRef = React.useRef(render);

  // Normally refs shouldn't be mutated in render
  // But we return a component which will be rendered
  // So it's just for immediate consumption
  renderRef.current = render;
  React.useEffect(() => {
    renderRef.current = null;
  });
  return React.useRef(_ref2 => {
    let {
      children
    } = _ref2;
    const render = renderRef.current;
    if (render === null) {
      throw new Error('The returned component must be rendered in the same render phase as the hook.');
    }
    return /*#__PURE__*/React.createElement(NavigationContent, {
      render: render
    }, children);
  }).current;
}
//# sourceMappingURL=useComponent.js.map

/***/ }),

/***/ 22303:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = useCurrentRender;
var React = _interopRequireWildcard(__webpack_require__(16689));
var _CurrentRenderContext = _interopRequireDefault(__webpack_require__(52210));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
/**
 * Write the current options, so that server renderer can get current values
 * Mutating values like this is not safe in async mode, but it doesn't apply to SSR
 */
function useCurrentRender(_ref) {
  let {
    state,
    navigation,
    descriptors
  } = _ref;
  const current = React.useContext(_CurrentRenderContext.default);
  if (current && navigation.isFocused()) {
    current.options = descriptors[state.routes[state.index].key].options;
  }
}
//# sourceMappingURL=useCurrentRender.js.map

/***/ }),

/***/ 40225:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = useDescriptors;
var React = _interopRequireWildcard(__webpack_require__(16689));
var _NavigationBuilderContext = _interopRequireDefault(__webpack_require__(11223));
var _NavigationContext = _interopRequireDefault(__webpack_require__(10871));
var _NavigationRouteContext = _interopRequireDefault(__webpack_require__(44820));
var _SceneView = _interopRequireDefault(__webpack_require__(3776));
var _useNavigationCache = _interopRequireDefault(__webpack_require__(97255));
var _useRouteCache = _interopRequireDefault(__webpack_require__(37763));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
/**
 * Hook to create descriptor objects for the child routes.
 *
 * A descriptor object provides 3 things:
 * - Helper method to render a screen
 * - Options specified by the screen for the navigator
 * - Navigation object intended for the route
 */
function useDescriptors(_ref) {
  let {
    state,
    screens,
    navigation,
    screenOptions,
    defaultScreenOptions,
    onAction,
    getState,
    setState,
    addListener,
    addKeyedListener,
    onRouteFocus,
    router,
    emitter
  } = _ref;
  const [options, setOptions] = React.useState({});
  const {
    onDispatchAction,
    onOptionsChange,
    stackRef
  } = React.useContext(_NavigationBuilderContext.default);
  const context = React.useMemo(() => ({
    navigation,
    onAction,
    addListener,
    addKeyedListener,
    onRouteFocus,
    onDispatchAction,
    onOptionsChange,
    stackRef
  }), [navigation, onAction, addListener, addKeyedListener, onRouteFocus, onDispatchAction, onOptionsChange, stackRef]);
  const navigations = (0, _useNavigationCache.default)({
    state,
    getState,
    navigation,
    setOptions,
    router,
    emitter
  });
  const routes = (0, _useRouteCache.default)(state.routes);
  return routes.reduce((acc, route, i) => {
    const config = screens[route.name];
    const screen = config.props;
    const navigation = navigations[route.key];
    const optionsList = [
    // The default `screenOptions` passed to the navigator
    screenOptions,
    // The `screenOptions` props passed to `Group` elements
    ...(config.options ? config.options.filter(Boolean) : []),
    // The `options` prop passed to `Screen` elements,
    screen.options,
    // The options set via `navigation.setOptions`
    options[route.key]];
    const customOptions = optionsList.reduce((acc, curr) => Object.assign(acc,
    // @ts-expect-error: we check for function but TS still complains
    typeof curr !== 'function' ? curr : curr({
      route,
      navigation
    })), {});
    const mergedOptions = {
      ...(typeof defaultScreenOptions === 'function' ?
      // @ts-expect-error: ts gives incorrect error here
      defaultScreenOptions({
        route,
        navigation,
        options: customOptions
      }) : defaultScreenOptions),
      ...customOptions
    };
    const clearOptions = () => setOptions(o => {
      if (route.key in o) {
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        const {
          [route.key]: _,
          ...rest
        } = o;
        return rest;
      }
      return o;
    });
    acc[route.key] = {
      route,
      // @ts-expect-error: it's missing action helpers, fix later
      navigation,
      render() {
        return /*#__PURE__*/React.createElement(_NavigationBuilderContext.default.Provider, {
          key: route.key,
          value: context
        }, /*#__PURE__*/React.createElement(_NavigationContext.default.Provider, {
          value: navigation
        }, /*#__PURE__*/React.createElement(_NavigationRouteContext.default.Provider, {
          value: route
        }, /*#__PURE__*/React.createElement(_SceneView.default, {
          navigation: navigation,
          route: route,
          screen: screen,
          routeState: state.routes[i].state,
          getState: getState,
          setState: setState,
          options: mergedOptions,
          clearOptions: clearOptions
        }))));
      },
      options: mergedOptions
    };
    return acc;
  }, {});
}
//# sourceMappingURL=useDescriptors.js.map

/***/ }),

/***/ 74658:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = useEventEmitter;
var React = _interopRequireWildcard(__webpack_require__(16689));
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
/**
 * Hook to manage the event system used by the navigator to notify screens of various events.
 */
function useEventEmitter(listen) {
  const listenRef = React.useRef(listen);
  React.useEffect(() => {
    listenRef.current = listen;
  });
  const listeners = React.useRef(Object.create(null));
  const create = React.useCallback(target => {
    const removeListener = (type, callback) => {
      const callbacks = listeners.current[type] ? listeners.current[type][target] : undefined;
      if (!callbacks) {
        return;
      }
      const index = callbacks.indexOf(callback);
      if (index > -1) {
        callbacks.splice(index, 1);
      }
    };
    const addListener = (type, callback) => {
      listeners.current[type] = listeners.current[type] || {};
      listeners.current[type][target] = listeners.current[type][target] || [];
      listeners.current[type][target].push(callback);
      let removed = false;
      return () => {
        // Prevent removing other listeners when unsubscribing same listener multiple times
        if (!removed) {
          removed = true;
          removeListener(type, callback);
        }
      };
    };
    return {
      addListener,
      removeListener
    };
  }, []);
  const emit = React.useCallback(_ref => {
    var _items$target, _listenRef$current;
    let {
      type,
      data,
      target,
      canPreventDefault
    } = _ref;
    const items = listeners.current[type] || {};

    // Copy the current list of callbacks in case they are mutated during execution
    const callbacks = target !== undefined ? (_items$target = items[target]) === null || _items$target === void 0 ? void 0 : _items$target.slice() : [].concat(...Object.keys(items).map(t => items[t])).filter((cb, i, self) => self.lastIndexOf(cb) === i);
    const event = {
      get type() {
        return type;
      }
    };
    if (target !== undefined) {
      Object.defineProperty(event, 'target', {
        enumerable: true,
        get() {
          return target;
        }
      });
    }
    if (data !== undefined) {
      Object.defineProperty(event, 'data', {
        enumerable: true,
        get() {
          return data;
        }
      });
    }
    if (canPreventDefault) {
      let defaultPrevented = false;
      Object.defineProperties(event, {
        defaultPrevented: {
          enumerable: true,
          get() {
            return defaultPrevented;
          }
        },
        preventDefault: {
          enumerable: true,
          value() {
            defaultPrevented = true;
          }
        }
      });
    }
    (_listenRef$current = listenRef.current) === null || _listenRef$current === void 0 ? void 0 : _listenRef$current.call(listenRef, event);
    callbacks === null || callbacks === void 0 ? void 0 : callbacks.forEach(cb => cb(event));
    return event;
  }, []);
  return React.useMemo(() => ({
    create,
    emit
  }), [create, emit]);
}
//# sourceMappingURL=useEventEmitter.js.map

/***/ }),

/***/ 30230:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = useFocusEffect;
var React = _interopRequireWildcard(__webpack_require__(16689));
var _useNavigation = _interopRequireDefault(__webpack_require__(92381));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
/**
 * Hook to run an effect in a focused screen, similar to `React.useEffect`.
 * This can be used to perform side-effects such as fetching data or subscribing to events.
 * The passed callback should be wrapped in `React.useCallback` to avoid running the effect too often.
 *
 * @param callback Memoized callback containing the effect, should optionally return a cleanup function.
 */
function useFocusEffect(effect) {
  const navigation = (0, _useNavigation.default)();
  if (arguments[1] !== undefined) {
    const message = "You passed a second argument to 'useFocusEffect', but it only accepts one argument. " + "If you want to pass a dependency array, you can use 'React.useCallback':\n\n" + 'useFocusEffect(\n' + '  React.useCallback(() => {\n' + '    // Your code here\n' + '  }, [depA, depB])\n' + ');\n\n' + 'See usage guide: https://reactnavigation.org/docs/use-focus-effect';
    console.error(message);
  }
  React.useEffect(() => {
    let isFocused = false;
    let cleanup;
    const callback = () => {
      const destroy = effect();
      if (destroy === undefined || typeof destroy === 'function') {
        return destroy;
      }
      if (false) {}
    };

    // We need to run the effect on intial render/dep changes if the screen is focused
    if (navigation.isFocused()) {
      cleanup = callback();
      isFocused = true;
    }
    const unsubscribeFocus = navigation.addListener('focus', () => {
      // If callback was already called for focus, avoid calling it again
      // The focus event may also fire on intial render, so we guard against runing the effect twice
      if (isFocused) {
        return;
      }
      if (cleanup !== undefined) {
        cleanup();
      }
      cleanup = callback();
      isFocused = true;
    });
    const unsubscribeBlur = navigation.addListener('blur', () => {
      if (cleanup !== undefined) {
        cleanup();
      }
      cleanup = undefined;
      isFocused = false;
    });
    return () => {
      if (cleanup !== undefined) {
        cleanup();
      }
      unsubscribeFocus();
      unsubscribeBlur();
    };
  }, [effect, navigation]);
}
//# sourceMappingURL=useFocusEffect.js.map

/***/ }),

/***/ 42162:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = useFocusEvents;
var React = _interopRequireWildcard(__webpack_require__(16689));
var _NavigationContext = _interopRequireDefault(__webpack_require__(10871));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
/**
 * Hook to take care of emitting `focus` and `blur` events.
 */
function useFocusEvents(_ref) {
  let {
    state,
    emitter
  } = _ref;
  const navigation = React.useContext(_NavigationContext.default);
  const lastFocusedKeyRef = React.useRef();
  const currentFocusedKey = state.routes[state.index].key;

  // When the parent screen changes its focus state, we also need to change child's focus
  // Coz the child screen can't be focused if the parent screen is out of focus
  React.useEffect(() => navigation === null || navigation === void 0 ? void 0 : navigation.addListener('focus', () => {
    lastFocusedKeyRef.current = currentFocusedKey;
    emitter.emit({
      type: 'focus',
      target: currentFocusedKey
    });
  }), [currentFocusedKey, emitter, navigation]);
  React.useEffect(() => navigation === null || navigation === void 0 ? void 0 : navigation.addListener('blur', () => {
    lastFocusedKeyRef.current = undefined;
    emitter.emit({
      type: 'blur',
      target: currentFocusedKey
    });
  }), [currentFocusedKey, emitter, navigation]);
  React.useEffect(() => {
    const lastFocusedKey = lastFocusedKeyRef.current;
    lastFocusedKeyRef.current = currentFocusedKey;

    // We wouldn't have `lastFocusedKey` on initial mount
    // Fire focus event for the current route on mount if there's no parent navigator
    if (lastFocusedKey === undefined && !navigation) {
      emitter.emit({
        type: 'focus',
        target: currentFocusedKey
      });
    }

    // We should only emit events when the focused key changed and navigator is focused
    // When navigator is not focused, screens inside shouldn't receive focused status either
    if (lastFocusedKey === currentFocusedKey || !(navigation ? navigation.isFocused() : true)) {
      return;
    }
    if (lastFocusedKey === undefined) {
      // Only fire events after initial mount
      return;
    }
    emitter.emit({
      type: 'blur',
      target: lastFocusedKey
    });
    emitter.emit({
      type: 'focus',
      target: currentFocusedKey
    });
  }, [currentFocusedKey, emitter, navigation]);
}
//# sourceMappingURL=useFocusEvents.js.map

/***/ }),

/***/ 60616:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = useFocusedListenersChildrenAdapter;
var React = _interopRequireWildcard(__webpack_require__(16689));
var _NavigationBuilderContext = _interopRequireDefault(__webpack_require__(11223));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
/**
 * Hook for passing focus callback to children
 */
function useFocusedListenersChildrenAdapter(_ref) {
  let {
    navigation,
    focusedListeners
  } = _ref;
  const {
    addListener
  } = React.useContext(_NavigationBuilderContext.default);
  const listener = React.useCallback(callback => {
    if (navigation.isFocused()) {
      for (const listener of focusedListeners) {
        const {
          handled,
          result
        } = listener(callback);
        if (handled) {
          return {
            handled,
            result
          };
        }
      }
      return {
        handled: true,
        result: callback(navigation)
      };
    } else {
      return {
        handled: false,
        result: null
      };
    }
  }, [focusedListeners, navigation]);
  React.useEffect(() => addListener === null || addListener === void 0 ? void 0 : addListener('focus', listener), [addListener, listener]);
}
//# sourceMappingURL=useFocusedListenersChildrenAdapter.js.map

/***/ }),

/***/ 90017:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = useIsFocused;
var React = _interopRequireWildcard(__webpack_require__(16689));
var _useNavigation = _interopRequireDefault(__webpack_require__(92381));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
/**
 * Hook to get the current focus state of the screen. Returns a `true` if screen is focused, otherwise `false`.
 * This can be used if a component needs to render something based on the focus state.
 */
function useIsFocused() {
  const navigation = (0, _useNavigation.default)();
  const [isFocused, setIsFocused] = (0, React.useState)(navigation.isFocused);
  const valueToReturn = navigation.isFocused();
  if (isFocused !== valueToReturn) {
    // If the value has changed since the last render, we need to update it.
    // This could happen if we missed an update from the event listeners during re-render.
    // React will process this update immediately, so the old subscription value won't be committed.
    // It is still nice to avoid returning a mismatched value though, so let's override the return value.
    // This is the same logic as in https://github.com/facebook/react/tree/master/packages/use-subscription
    setIsFocused(valueToReturn);
  }
  React.useEffect(() => {
    const unsubscribeFocus = navigation.addListener('focus', () => setIsFocused(true));
    const unsubscribeBlur = navigation.addListener('blur', () => setIsFocused(false));
    return () => {
      unsubscribeFocus();
      unsubscribeBlur();
    };
  }, [navigation]);
  React.useDebugValue(valueToReturn);
  return valueToReturn;
}
//# sourceMappingURL=useIsFocused.js.map

/***/ }),

/***/ 93296:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = useKeyedChildListeners;
var React = _interopRequireWildcard(__webpack_require__(16689));
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
/**
 * Hook which lets child navigators add getters to be called for obtaining rehydrated state.
 */
function useKeyedChildListeners() {
  const {
    current: keyedListeners
  } = React.useRef(Object.assign(Object.create(null), {
    getState: {},
    beforeRemove: {}
  }));
  const addKeyedListener = React.useCallback((type, key, listener) => {
    // @ts-expect-error: according to ref stated above you can use `key` to index type
    keyedListeners[type][key] = listener;
    return () => {
      // @ts-expect-error: according to ref stated above you can use `key` to index type
      keyedListeners[type][key] = undefined;
    };
  }, [keyedListeners]);
  return {
    keyedListeners,
    addKeyedListener
  };
}
//# sourceMappingURL=useKeyedChildListeners.js.map

/***/ }),

/***/ 92381:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = useNavigation;
var React = _interopRequireWildcard(__webpack_require__(16689));
var _NavigationContainerRefContext = _interopRequireDefault(__webpack_require__(15523));
var _NavigationContext = _interopRequireDefault(__webpack_require__(10871));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
/**
 * Hook to access the navigation prop of the parent screen anywhere.
 *
 * @returns Navigation prop of the parent screen.
 */
function useNavigation() {
  const root = React.useContext(_NavigationContainerRefContext.default);
  const navigation = React.useContext(_NavigationContext.default);
  if (navigation === undefined && root === undefined) {
    throw new Error("Couldn't find a navigation object. Is your component inside NavigationContainer?");
  }

  // FIXME: Figure out a better way to do this
  return navigation ?? root;
}
//# sourceMappingURL=useNavigation.js.map

/***/ }),

/***/ 36631:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = useNavigationBuilder;
var _routers = __webpack_require__(55789);
var React = _interopRequireWildcard(__webpack_require__(16689));
var _reactIs = __webpack_require__(1469);
var _Group = _interopRequireDefault(__webpack_require__(22408));
var _isArrayEqual = _interopRequireDefault(__webpack_require__(16842));
var _isRecordEqual = _interopRequireDefault(__webpack_require__(80219));
var _NavigationHelpersContext = _interopRequireDefault(__webpack_require__(77709));
var _NavigationRouteContext = _interopRequireDefault(__webpack_require__(44820));
var _NavigationStateContext = _interopRequireDefault(__webpack_require__(21726));
var _PreventRemoveProvider = _interopRequireDefault(__webpack_require__(83829));
var _Screen = _interopRequireDefault(__webpack_require__(68894));
var _types = __webpack_require__(21768);
var _useChildListeners = _interopRequireDefault(__webpack_require__(49275));
var _useComponent = _interopRequireDefault(__webpack_require__(71368));
var _useCurrentRender = _interopRequireDefault(__webpack_require__(22303));
var _useDescriptors = _interopRequireDefault(__webpack_require__(40225));
var _useEventEmitter = _interopRequireDefault(__webpack_require__(74658));
var _useFocusedListenersChildrenAdapter = _interopRequireDefault(__webpack_require__(60616));
var _useFocusEvents = _interopRequireDefault(__webpack_require__(42162));
var _useKeyedChildListeners = _interopRequireDefault(__webpack_require__(93296));
var _useNavigationHelpers = _interopRequireDefault(__webpack_require__(12543));
var _useOnAction = _interopRequireDefault(__webpack_require__(58627));
var _useOnGetState = _interopRequireDefault(__webpack_require__(60814));
var _useOnRouteFocus = _interopRequireDefault(__webpack_require__(24730));
var _useRegisterNavigator = _interopRequireDefault(__webpack_require__(2438));
var _useScheduleUpdate = _interopRequireDefault(__webpack_require__(18693));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
// This is to make TypeScript compiler happy
// eslint-disable-next-line babel/no-unused-expressions
_types.PrivateValueStore;
const isValidKey = key => key === undefined || typeof key === 'string' && key !== '';

/**
 * Extract route config object from React children elements.
 *
 * @param children React Elements to extract the config from.
 */
const getRouteConfigsFromChildren = (children, groupKey, groupOptions) => {
  const configs = React.Children.toArray(children).reduce((acc, child) => {
    var _child$type, _child$props;
    if ( /*#__PURE__*/React.isValidElement(child)) {
      if (child.type === _Screen.default) {
        // We can only extract the config from `Screen` elements
        // If something else was rendered, it's probably a bug

        if (!isValidKey(child.props.navigationKey)) {
          throw new Error(`Got an invalid 'navigationKey' prop (${JSON.stringify(child.props.navigationKey)}) for the screen '${child.props.name}'. It must be a non-empty string or 'undefined'.`);
        }
        acc.push({
          keys: [groupKey, child.props.navigationKey],
          options: groupOptions,
          props: child.props
        });
        return acc;
      }
      if (child.type === React.Fragment || child.type === _Group.default) {
        if (!isValidKey(child.props.navigationKey)) {
          throw new Error(`Got an invalid 'navigationKey' prop (${JSON.stringify(child.props.navigationKey)}) for the group. It must be a non-empty string or 'undefined'.`);
        }

        // When we encounter a fragment or group, we need to dive into its children to extract the configs
        // This is handy to conditionally define a group of screens
        acc.push(...getRouteConfigsFromChildren(child.props.children, child.props.navigationKey, child.type !== _Group.default ? groupOptions : groupOptions != null ? [...groupOptions, child.props.screenOptions] : [child.props.screenOptions]));
        return acc;
      }
    }
    throw new Error(`A navigator can only contain 'Screen', 'Group' or 'React.Fragment' as its direct children (found ${/*#__PURE__*/React.isValidElement(child) ? `'${typeof child.type === 'string' ? child.type : (_child$type = child.type) === null || _child$type === void 0 ? void 0 : _child$type.name}'${child.props != null && typeof child.props === 'object' && 'name' in child.props && (_child$props = child.props) !== null && _child$props !== void 0 && _child$props.name ? ` for the screen '${child.props.name}'` : ''}` : typeof child === 'object' ? JSON.stringify(child) : `'${String(child)}'`}). To render this component in the navigator, pass it in the 'component' prop to 'Screen'.`);
  }, []);
  if (false) {}
  return configs;
};

/**
 * Hook for building navigators.
 *
 * @param createRouter Factory method which returns router object.
 * @param options Options object containing `children` and additional options for the router.
 * @returns An object containing `state`, `navigation`, `descriptors` objects.
 */
function useNavigationBuilder(createRouter, options) {
  const navigatorKey = (0, _useRegisterNavigator.default)();
  const route = React.useContext(_NavigationRouteContext.default);
  const {
    children,
    screenListeners,
    ...rest
  } = options;
  const {
    current: router
  } = React.useRef(createRouter({
    ...rest,
    ...(route !== null && route !== void 0 && route.params && route.params.state == null && route.params.initial !== false && typeof route.params.screen === 'string' ? {
      initialRouteName: route.params.screen
    } : null)
  }));
  const routeConfigs = getRouteConfigsFromChildren(children);
  const screens = routeConfigs.reduce((acc, config) => {
    if (config.props.name in acc) {
      throw new Error(`A navigator cannot contain multiple 'Screen' components with the same name (found duplicate screen named '${config.props.name}')`);
    }
    acc[config.props.name] = config;
    return acc;
  }, {});
  const routeNames = routeConfigs.map(config => config.props.name);
  const routeKeyList = routeNames.reduce((acc, curr) => {
    acc[curr] = screens[curr].keys.map(key => key ?? '').join(':');
    return acc;
  }, {});
  const routeParamList = routeNames.reduce((acc, curr) => {
    const {
      initialParams
    } = screens[curr].props;
    acc[curr] = initialParams;
    return acc;
  }, {});
  const routeGetIdList = routeNames.reduce((acc, curr) => Object.assign(acc, {
    [curr]: screens[curr].props.getId
  }), {});
  if (!routeNames.length) {
    throw new Error("Couldn't find any screens for the navigator. Have you defined any screens as its children?");
  }
  const isStateValid = React.useCallback(state => state.type === undefined || state.type === router.type, [router.type]);
  const isStateInitialized = React.useCallback(state => state !== undefined && state.stale === false && isStateValid(state), [isStateValid]);
  const {
    state: currentState,
    getState: getCurrentState,
    setState: setCurrentState,
    setKey,
    getKey,
    getIsInitial
  } = React.useContext(_NavigationStateContext.default);
  const stateCleanedUp = React.useRef(false);
  const cleanUpState = React.useCallback(() => {
    setCurrentState(undefined);
    stateCleanedUp.current = true;
  }, [setCurrentState]);
  const setState = React.useCallback(state => {
    if (stateCleanedUp.current) {
      // State might have been already cleaned up due to unmount
      // We do not want to expose API allowing to override this
      // This would lead to old data preservation on main navigator unmount
      return;
    }
    setCurrentState(state);
  }, [setCurrentState]);
  const [initializedState, isFirstStateInitialization] = React.useMemo(() => {
    var _route$params4;
    const initialRouteParamList = routeNames.reduce((acc, curr) => {
      var _route$params, _route$params2, _route$params3;
      const {
        initialParams
      } = screens[curr].props;
      const initialParamsFromParams = (route === null || route === void 0 ? void 0 : (_route$params = route.params) === null || _route$params === void 0 ? void 0 : _route$params.state) == null && (route === null || route === void 0 ? void 0 : (_route$params2 = route.params) === null || _route$params2 === void 0 ? void 0 : _route$params2.initial) !== false && (route === null || route === void 0 ? void 0 : (_route$params3 = route.params) === null || _route$params3 === void 0 ? void 0 : _route$params3.screen) === curr ? route.params.params : undefined;
      acc[curr] = initialParams !== undefined || initialParamsFromParams !== undefined ? {
        ...initialParams,
        ...initialParamsFromParams
      } : undefined;
      return acc;
    }, {});

    // If the current state isn't initialized on first render, we initialize it
    // We also need to re-initialize it if the state passed from parent was changed (maybe due to reset)
    // Otherwise assume that the state was provided as initial state
    // So we need to rehydrate it to make it usable
    if ((currentState === undefined || !isStateValid(currentState)) && (route === null || route === void 0 ? void 0 : (_route$params4 = route.params) === null || _route$params4 === void 0 ? void 0 : _route$params4.state) == null) {
      return [router.getInitialState({
        routeNames,
        routeParamList: initialRouteParamList,
        routeGetIdList
      }), true];
    } else {
      var _route$params5;
      return [router.getRehydratedState((route === null || route === void 0 ? void 0 : (_route$params5 = route.params) === null || _route$params5 === void 0 ? void 0 : _route$params5.state) ?? currentState, {
        routeNames,
        routeParamList: initialRouteParamList,
        routeGetIdList
      }), false];
    }
    // We explicitly don't include routeNames, route.params etc. in the dep list
    // below. We want to avoid forcing a new state to be calculated in those cases
    // Instead, we handle changes to these in the nextState code below. Note
    // that some changes to routeConfigs are explicitly ignored, such as changes
    // to initialParams
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [currentState, router, isStateValid]);
  const previousRouteKeyListRef = React.useRef(routeKeyList);
  React.useEffect(() => {
    previousRouteKeyListRef.current = routeKeyList;
  });
  const previousRouteKeyList = previousRouteKeyListRef.current;
  let state =
  // If the state isn't initialized, or stale, use the state we initialized instead
  // The state won't update until there's a change needed in the state we have initalized locally
  // So it'll be `undefined` or stale until the first navigation event happens
  isStateInitialized(currentState) ? currentState : initializedState;
  let nextState = state;
  if (!(0, _isArrayEqual.default)(state.routeNames, routeNames) || !(0, _isRecordEqual.default)(routeKeyList, previousRouteKeyList)) {
    // When the list of route names change, the router should handle it to remove invalid routes
    nextState = router.getStateForRouteNamesChange(state, {
      routeNames,
      routeParamList,
      routeGetIdList,
      routeKeyChanges: Object.keys(routeKeyList).filter(name => previousRouteKeyList.hasOwnProperty(name) && routeKeyList[name] !== previousRouteKeyList[name])
    });
  }
  const previousNestedParamsRef = React.useRef(route === null || route === void 0 ? void 0 : route.params);
  React.useEffect(() => {
    previousNestedParamsRef.current = route === null || route === void 0 ? void 0 : route.params;
  }, [route === null || route === void 0 ? void 0 : route.params]);
  if (route !== null && route !== void 0 && route.params) {
    const previousParams = previousNestedParamsRef.current;
    let action;
    if (typeof route.params.state === 'object' && route.params.state != null && route.params !== previousParams) {
      // If the route was updated with new state, we should reset to it
      action = _routers.CommonActions.reset(route.params.state);
    } else if (typeof route.params.screen === 'string' && (route.params.initial === false && isFirstStateInitialization || route.params !== previousParams)) {
      // If the route was updated with new screen name and/or params, we should navigate there
      action = _routers.CommonActions.navigate({
        name: route.params.screen,
        params: route.params.params,
        path: route.params.path
      });
    }

    // The update should be limited to current navigator only, so we call the router manually
    const updatedState = action ? router.getStateForAction(nextState, action, {
      routeNames,
      routeParamList,
      routeGetIdList
    }) : null;
    nextState = updatedState !== null ? router.getRehydratedState(updatedState, {
      routeNames,
      routeParamList,
      routeGetIdList
    }) : nextState;
  }
  const shouldUpdate = state !== nextState;
  (0, _useScheduleUpdate.default)(() => {
    if (shouldUpdate) {
      // If the state needs to be updated, we'll schedule an update
      setState(nextState);
    }
  });

  // The up-to-date state will come in next render, but we don't need to wait for it
  // We can't use the outdated state since the screens have changed, which will cause error due to mismatched config
  // So we override the state object we return to use the latest state as soon as possible
  state = nextState;
  React.useEffect(() => {
    setKey(navigatorKey);
    if (!getIsInitial()) {
      // If it's not initial render, we need to update the state
      // This will make sure that our container gets notifier of state changes due to new mounts
      // This is necessary for proper screen tracking, URL updates etc.
      setState(nextState);
    }
    return () => {
      // We need to clean up state for this navigator on unmount
      // We do it in a timeout because we need to detect if another navigator mounted in the meantime
      // For example, if another navigator has started rendering, we should skip cleanup
      // Otherwise, our cleanup step will cleanup state for the other navigator and re-initialize it
      setTimeout(() => {
        if (getCurrentState() !== undefined && getKey() === navigatorKey) {
          cleanUpState();
        }
      }, 0);
    };
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  // We initialize this ref here to avoid a new getState getting initialized
  // whenever initializedState changes. We want getState to have access to the
  // latest initializedState, but don't need it to change when that happens
  const initializedStateRef = React.useRef();
  initializedStateRef.current = initializedState;
  const getState = React.useCallback(() => {
    const currentState = getCurrentState();
    return isStateInitialized(currentState) ? currentState : initializedStateRef.current;
  }, [getCurrentState, isStateInitialized]);
  const emitter = (0, _useEventEmitter.default)(e => {
    let routeNames = [];
    let route;
    if (e.target) {
      var _route;
      route = state.routes.find(route => route.key === e.target);
      if ((_route = route) !== null && _route !== void 0 && _route.name) {
        routeNames.push(route.name);
      }
    } else {
      route = state.routes[state.index];
      routeNames.push(...Object.keys(screens).filter(name => {
        var _route2;
        return ((_route2 = route) === null || _route2 === void 0 ? void 0 : _route2.name) === name;
      }));
    }
    if (route == null) {
      return;
    }
    const navigation = descriptors[route.key].navigation;
    const listeners = [].concat(
    // Get an array of listeners for all screens + common listeners on navigator
    ...[screenListeners, ...routeNames.map(name => {
      const {
        listeners
      } = screens[name].props;
      return listeners;
    })].map(listeners => {
      const map = typeof listeners === 'function' ? listeners({
        route: route,
        navigation
      }) : listeners;
      return map ? Object.keys(map).filter(type => type === e.type).map(type => map === null || map === void 0 ? void 0 : map[type]) : undefined;
    }))
    // We don't want same listener to be called multiple times for same event
    // So we remove any duplicate functions from the array
    .filter((cb, i, self) => cb && self.lastIndexOf(cb) === i);
    listeners.forEach(listener => listener === null || listener === void 0 ? void 0 : listener(e));
  });
  (0, _useFocusEvents.default)({
    state,
    emitter
  });
  React.useEffect(() => {
    emitter.emit({
      type: 'state',
      data: {
        state
      }
    });
  }, [emitter, state]);
  const {
    listeners: childListeners,
    addListener
  } = (0, _useChildListeners.default)();
  const {
    keyedListeners,
    addKeyedListener
  } = (0, _useKeyedChildListeners.default)();
  const onAction = (0, _useOnAction.default)({
    router,
    getState,
    setState,
    key: route === null || route === void 0 ? void 0 : route.key,
    actionListeners: childListeners.action,
    beforeRemoveListeners: keyedListeners.beforeRemove,
    routerConfigOptions: {
      routeNames,
      routeParamList,
      routeGetIdList
    },
    emitter
  });
  const onRouteFocus = (0, _useOnRouteFocus.default)({
    router,
    key: route === null || route === void 0 ? void 0 : route.key,
    getState,
    setState
  });
  const navigation = (0, _useNavigationHelpers.default)({
    id: options.id,
    onAction,
    getState,
    emitter,
    router
  });
  (0, _useFocusedListenersChildrenAdapter.default)({
    navigation,
    focusedListeners: childListeners.focus
  });
  (0, _useOnGetState.default)({
    getState,
    getStateListeners: keyedListeners.getState
  });
  const descriptors = (0, _useDescriptors.default)({
    state,
    screens,
    navigation,
    screenOptions: options.screenOptions,
    defaultScreenOptions: options.defaultScreenOptions,
    onAction,
    getState,
    setState,
    onRouteFocus,
    addListener,
    addKeyedListener,
    router,
    // @ts-expect-error: this should have both core and custom events, but too much work right now
    emitter
  });
  (0, _useCurrentRender.default)({
    state,
    navigation,
    descriptors
  });
  const NavigationContent = (0, _useComponent.default)(children => /*#__PURE__*/React.createElement(_NavigationHelpersContext.default.Provider, {
    value: navigation
  }, /*#__PURE__*/React.createElement(_PreventRemoveProvider.default, null, children)));
  return {
    state,
    navigation,
    descriptors,
    NavigationContent
  };
}
//# sourceMappingURL=useNavigationBuilder.js.map

/***/ }),

/***/ 97255:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = useNavigationCache;
var _routers = __webpack_require__(55789);
var React = _interopRequireWildcard(__webpack_require__(16689));
var _NavigationBuilderContext = _interopRequireDefault(__webpack_require__(11223));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
/**
 * Hook to cache navigation objects for each screen in the navigator.
 * It's important to cache them to make sure navigation objects don't change between renders.
 * This lets us apply optimizations like `React.memo` to minimize re-rendering screens.
 */
function useNavigationCache(_ref) {
  let {
    state,
    getState,
    navigation,
    setOptions,
    router,
    emitter
  } = _ref;
  const {
    stackRef
  } = React.useContext(_NavigationBuilderContext.default);

  // Cache object which holds navigation objects for each screen
  // We use `React.useMemo` instead of `React.useRef` coz we want to invalidate it when deps change
  // In reality, these deps will rarely change, if ever
  const cache = React.useMemo(() => ({
    current: {}
  }),
  // eslint-disable-next-line react-hooks/exhaustive-deps
  [getState, navigation, setOptions, router, emitter]);
  const actions = {
    ...router.actionCreators,
    ..._routers.CommonActions
  };
  cache.current = state.routes.reduce((acc, route) => {
    const previous = cache.current[route.key];
    if (previous) {
      // If a cached navigation object already exists, reuse it
      acc[route.key] = previous;
    } else {
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      const {
        emit,
        ...rest
      } = navigation;
      const dispatch = thunk => {
        const action = typeof thunk === 'function' ? thunk(getState()) : thunk;
        if (action != null) {
          navigation.dispatch({
            source: route.key,
            ...action
          });
        }
      };
      const withStack = callback => {
        let isStackSet = false;
        try {
          if (false) {}
          callback();
        } finally {
          if (isStackSet && stackRef) {
            stackRef.current = undefined;
          }
        }
      };
      const helpers = Object.keys(actions).reduce((acc, name) => {
        acc[name] = function () {
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          return withStack(() =>
          // @ts-expect-error: name is a valid key, but TypeScript is dumb
          dispatch(actions[name](...args)));
        };
        return acc;
      }, {});
      acc[route.key] = {
        ...rest,
        ...helpers,
        // FIXME: too much work to fix the types for now
        ...emitter.create(route.key),
        dispatch: thunk => withStack(() => dispatch(thunk)),
        getParent: id => {
          if (id !== undefined && id === rest.getId()) {
            // If the passed id is the same as the current navigation id,
            // we return the cached navigation object for the relevant route
            return acc[route.key];
          }
          return rest.getParent(id);
        },
        setOptions: options => setOptions(o => ({
          ...o,
          [route.key]: {
            ...o[route.key],
            ...options
          }
        })),
        isFocused: () => {
          const state = getState();
          if (state.routes[state.index].key !== route.key) {
            return false;
          }

          // If the current screen is focused, we also need to check if parent navigator is focused
          // This makes sure that we return the focus state in the whole tree, not just this navigator
          return navigation ? navigation.isFocused() : true;
        }
      };
    }
    return acc;
  }, {});
  return cache.current;
}
//# sourceMappingURL=useNavigationCache.js.map

/***/ }),

/***/ 67675:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = useNavigationContainerRef;
var React = _interopRequireWildcard(__webpack_require__(16689));
var _createNavigationContainerRef = _interopRequireDefault(__webpack_require__(80742));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function useNavigationContainerRef() {
  const navigation = React.useRef(null);
  if (navigation.current == null) {
    navigation.current = (0, _createNavigationContainerRef.default)();
  }
  return navigation.current;
}
//# sourceMappingURL=useNavigationContainerRef.js.map

/***/ }),

/***/ 12543:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = useNavigationHelpers;
var _routers = __webpack_require__(55789);
var React = _interopRequireWildcard(__webpack_require__(16689));
var _NavigationContext = _interopRequireDefault(__webpack_require__(10871));
var _types = __webpack_require__(21768);
var _UnhandledActionContext = _interopRequireDefault(__webpack_require__(76971));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
// This is to make TypeScript compiler happy
// eslint-disable-next-line babel/no-unused-expressions
_types.PrivateValueStore;
/**
 * Navigation object with helper methods to be used by a navigator.
 * This object includes methods for common actions as well as methods the parent screen's navigation object.
 */
function useNavigationHelpers(_ref) {
  let {
    id: navigatorId,
    onAction,
    getState,
    emitter,
    router
  } = _ref;
  const onUnhandledAction = React.useContext(_UnhandledActionContext.default);
  const parentNavigationHelpers = React.useContext(_NavigationContext.default);
  return React.useMemo(() => {
    const dispatch = op => {
      const action = typeof op === 'function' ? op(getState()) : op;
      const handled = onAction(action);
      if (!handled) {
        onUnhandledAction === null || onUnhandledAction === void 0 ? void 0 : onUnhandledAction(action);
      }
    };
    const actions = {
      ...router.actionCreators,
      ..._routers.CommonActions
    };
    const helpers = Object.keys(actions).reduce((acc, name) => {
      // @ts-expect-error: name is a valid key, but TypeScript is dumb
      acc[name] = function () {
        return dispatch(actions[name](...arguments));
      };
      return acc;
    }, {});
    const navigationHelpers = {
      ...parentNavigationHelpers,
      ...helpers,
      dispatch,
      emit: emitter.emit,
      isFocused: parentNavigationHelpers ? parentNavigationHelpers.isFocused : () => true,
      canGoBack: () => {
        const state = getState();
        return router.getStateForAction(state, _routers.CommonActions.goBack(), {
          routeNames: state.routeNames,
          routeParamList: {},
          routeGetIdList: {}
        }) !== null || (parentNavigationHelpers === null || parentNavigationHelpers === void 0 ? void 0 : parentNavigationHelpers.canGoBack()) || false;
      },
      getId: () => navigatorId,
      getParent: id => {
        if (id !== undefined) {
          let current = navigationHelpers;
          while (current && id !== current.getId()) {
            current = current.getParent();
          }
          return current;
        }
        return parentNavigationHelpers;
      },
      getState
    };
    return navigationHelpers;
  }, [navigatorId, emitter.emit, getState, onAction, onUnhandledAction, parentNavigationHelpers, router]);
}
//# sourceMappingURL=useNavigationHelpers.js.map

/***/ }),

/***/ 85197:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = useNavigationState;
var React = _interopRequireWildcard(__webpack_require__(16689));
var _useNavigation = _interopRequireDefault(__webpack_require__(92381));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
/**
 * Hook to get a value from the current navigation state using a selector.
 *
 * @param selector Selector function to get a value from the state.
 */
function useNavigationState(selector) {
  const navigation = (0, _useNavigation.default)();

  // We don't care about the state value, we run the selector again at the end
  // The state is only to make sure that there's a re-render when we have a new value
  const [, setResult] = React.useState(() => selector(navigation.getState()));

  // We store the selector in a ref to avoid re-subscribing listeners every render
  const selectorRef = React.useRef(selector);
  React.useEffect(() => {
    selectorRef.current = selector;
  });
  React.useEffect(() => {
    const unsubscribe = navigation.addListener('state', e => {
      setResult(selectorRef.current(e.data.state));
    });
    return unsubscribe;
  }, [navigation]);
  return selector(navigation.getState());
}
//# sourceMappingURL=useNavigationState.js.map

/***/ }),

/***/ 58627:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = useOnAction;
var React = _interopRequireWildcard(__webpack_require__(16689));
var _NavigationBuilderContext = _interopRequireDefault(__webpack_require__(11223));
var _useOnPreventRemove = _interopRequireWildcard(__webpack_require__(43718));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
/**
 * Hook to handle actions for a navigator, including state updates and bubbling.
 *
 * Bubbling an action is achieved in 2 ways:
 * 1. To bubble action to parent, we expose the action handler in context and then access the parent context
 * 2. To bubble action to child, child adds event listeners subscribing to actions from parent
 *
 * When the action handler handles as action, it returns `true`, otherwise `false`.
 */
function useOnAction(_ref) {
  let {
    router,
    getState,
    setState,
    key,
    actionListeners,
    beforeRemoveListeners,
    routerConfigOptions,
    emitter
  } = _ref;
  const {
    onAction: onActionParent,
    onRouteFocus: onRouteFocusParent,
    addListener: addListenerParent,
    onDispatchAction
  } = React.useContext(_NavigationBuilderContext.default);
  const routerConfigOptionsRef = React.useRef(routerConfigOptions);
  React.useEffect(() => {
    routerConfigOptionsRef.current = routerConfigOptions;
  });
  const onAction = React.useCallback(function (action) {
    let visitedNavigators = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Set();
    const state = getState();

    // Since actions can bubble both up and down, they could come to the same navigator again
    // We keep track of navigators which have already tried to handle the action and return if it's already visited
    if (visitedNavigators.has(state.key)) {
      return false;
    }
    visitedNavigators.add(state.key);
    if (typeof action.target !== 'string' || action.target === state.key) {
      let result = router.getStateForAction(state, action, routerConfigOptionsRef.current);

      // If a target is specified and set to current navigator, the action shouldn't bubble
      // So instead of `null`, we use the state object for such cases to signal that action was handled
      result = result === null && action.target === state.key ? state : result;
      if (result !== null) {
        onDispatchAction(action, state === result);
        if (state !== result) {
          const isPrevented = (0, _useOnPreventRemove.shouldPreventRemove)(emitter, beforeRemoveListeners, state.routes, result.routes, action);
          if (isPrevented) {
            return true;
          }
          setState(result);
        }
        if (onRouteFocusParent !== undefined) {
          // Some actions such as `NAVIGATE` also want to bring the navigated route to focus in the whole tree
          // This means we need to focus all of the parent navigators of this navigator as well
          const shouldFocus = router.shouldActionChangeFocus(action);
          if (shouldFocus && key !== undefined) {
            onRouteFocusParent(key);
          }
        }
        return true;
      }
    }
    if (onActionParent !== undefined) {
      // Bubble action to the parent if the current navigator didn't handle it
      if (onActionParent(action, visitedNavigators)) {
        return true;
      }
    }

    // If the action wasn't handled by current navigator or a parent navigator, let children handle it
    for (let i = actionListeners.length - 1; i >= 0; i--) {
      const listener = actionListeners[i];
      if (listener(action, visitedNavigators)) {
        return true;
      }
    }
    return false;
  }, [actionListeners, beforeRemoveListeners, emitter, getState, key, onActionParent, onDispatchAction, onRouteFocusParent, router, setState]);
  (0, _useOnPreventRemove.default)({
    getState,
    emitter,
    beforeRemoveListeners
  });
  React.useEffect(() => addListenerParent === null || addListenerParent === void 0 ? void 0 : addListenerParent('action', onAction), [addListenerParent, onAction]);
  return onAction;
}
//# sourceMappingURL=useOnAction.js.map

/***/ }),

/***/ 60814:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = useOnGetState;
var React = _interopRequireWildcard(__webpack_require__(16689));
var _isArrayEqual = _interopRequireDefault(__webpack_require__(16842));
var _NavigationBuilderContext = _interopRequireDefault(__webpack_require__(11223));
var _NavigationRouteContext = _interopRequireDefault(__webpack_require__(44820));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function useOnGetState(_ref) {
  let {
    getState,
    getStateListeners
  } = _ref;
  const {
    addKeyedListener
  } = React.useContext(_NavigationBuilderContext.default);
  const route = React.useContext(_NavigationRouteContext.default);
  const key = route ? route.key : 'root';
  const getRehydratedState = React.useCallback(() => {
    const state = getState();

    // Avoid returning new route objects if we don't need to
    const routes = state.routes.map(route => {
      var _getStateListeners$ro;
      const childState = (_getStateListeners$ro = getStateListeners[route.key]) === null || _getStateListeners$ro === void 0 ? void 0 : _getStateListeners$ro.call(getStateListeners);
      if (route.state === childState) {
        return route;
      }
      return {
        ...route,
        state: childState
      };
    });
    if ((0, _isArrayEqual.default)(state.routes, routes)) {
      return state;
    }
    return {
      ...state,
      routes
    };
  }, [getState, getStateListeners]);
  React.useEffect(() => {
    return addKeyedListener === null || addKeyedListener === void 0 ? void 0 : addKeyedListener('getState', key, getRehydratedState);
  }, [addKeyedListener, getRehydratedState, key]);
}
//# sourceMappingURL=useOnGetState.js.map

/***/ }),

/***/ 43718:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = useOnPreventRemove;
exports.shouldPreventRemove = void 0;
var React = _interopRequireWildcard(__webpack_require__(16689));
var _NavigationBuilderContext = _interopRequireDefault(__webpack_require__(11223));
var _NavigationRouteContext = _interopRequireDefault(__webpack_require__(44820));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
const VISITED_ROUTE_KEYS = Symbol('VISITED_ROUTE_KEYS');
const shouldPreventRemove = (emitter, beforeRemoveListeners, currentRoutes, nextRoutes, action) => {
  const nextRouteKeys = nextRoutes.map(route => route.key);

  // Call these in reverse order so last screens handle the event first
  const removedRoutes = currentRoutes.filter(route => !nextRouteKeys.includes(route.key)).reverse();
  const visitedRouteKeys =
  // @ts-expect-error: add this property to mark that we've already emitted this action
  action[VISITED_ROUTE_KEYS] ?? new Set();
  const beforeRemoveAction = {
    ...action,
    [VISITED_ROUTE_KEYS]: visitedRouteKeys
  };
  for (const route of removedRoutes) {
    var _beforeRemoveListener;
    if (visitedRouteKeys.has(route.key)) {
      // Skip if we've already emitted this action for this screen
      continue;
    }

    // First, we need to check if any child screens want to prevent it
    const isPrevented = (_beforeRemoveListener = beforeRemoveListeners[route.key]) === null || _beforeRemoveListener === void 0 ? void 0 : _beforeRemoveListener.call(beforeRemoveListeners, beforeRemoveAction);
    if (isPrevented) {
      return true;
    }
    visitedRouteKeys.add(route.key);
    const event = emitter.emit({
      type: 'beforeRemove',
      target: route.key,
      data: {
        action: beforeRemoveAction
      },
      canPreventDefault: true
    });
    if (event.defaultPrevented) {
      return true;
    }
  }
  return false;
};
exports.shouldPreventRemove = shouldPreventRemove;
function useOnPreventRemove(_ref) {
  let {
    getState,
    emitter,
    beforeRemoveListeners
  } = _ref;
  const {
    addKeyedListener
  } = React.useContext(_NavigationBuilderContext.default);
  const route = React.useContext(_NavigationRouteContext.default);
  const routeKey = route === null || route === void 0 ? void 0 : route.key;
  React.useEffect(() => {
    if (routeKey) {
      return addKeyedListener === null || addKeyedListener === void 0 ? void 0 : addKeyedListener('beforeRemove', routeKey, action => {
        const state = getState();
        return shouldPreventRemove(emitter, beforeRemoveListeners, state.routes, [], action);
      });
    }
  }, [addKeyedListener, beforeRemoveListeners, emitter, getState, routeKey]);
}
//# sourceMappingURL=useOnPreventRemove.js.map

/***/ }),

/***/ 24730:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = useOnRouteFocus;
var React = _interopRequireWildcard(__webpack_require__(16689));
var _NavigationBuilderContext = _interopRequireDefault(__webpack_require__(11223));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
/**
 * Hook to handle focus actions for a route.
 * Focus action needs to be treated specially, coz when a nested route is focused,
 * the parent navigators also needs to be focused.
 */
function useOnRouteFocus(_ref) {
  let {
    router,
    getState,
    key: sourceRouteKey,
    setState
  } = _ref;
  const {
    onRouteFocus: onRouteFocusParent
  } = React.useContext(_NavigationBuilderContext.default);
  return React.useCallback(key => {
    const state = getState();
    const result = router.getStateForRouteFocus(state, key);
    if (result !== state) {
      setState(result);
    }
    if (onRouteFocusParent !== undefined && sourceRouteKey !== undefined) {
      onRouteFocusParent(sourceRouteKey);
    }
  }, [getState, onRouteFocusParent, router, setState, sourceRouteKey]);
}
//# sourceMappingURL=useOnRouteFocus.js.map

/***/ }),

/***/ 72893:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = useOptionsGetters;
var React = _interopRequireWildcard(__webpack_require__(16689));
var _NavigationBuilderContext = _interopRequireDefault(__webpack_require__(11223));
var _NavigationStateContext = _interopRequireDefault(__webpack_require__(21726));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function useOptionsGetters(_ref) {
  let {
    key,
    options,
    navigation
  } = _ref;
  const optionsRef = React.useRef(options);
  const optionsGettersFromChildRef = React.useRef({});
  const {
    onOptionsChange
  } = React.useContext(_NavigationBuilderContext.default);
  const {
    addOptionsGetter: parentAddOptionsGetter
  } = React.useContext(_NavigationStateContext.default);
  const optionsChangeListener = React.useCallback(() => {
    const isFocused = (navigation === null || navigation === void 0 ? void 0 : navigation.isFocused()) ?? true;
    const hasChildren = Object.keys(optionsGettersFromChildRef.current).length;
    if (isFocused && !hasChildren) {
      onOptionsChange(optionsRef.current ?? {});
    }
  }, [navigation, onOptionsChange]);
  React.useEffect(() => {
    optionsRef.current = options;
    optionsChangeListener();
    return navigation === null || navigation === void 0 ? void 0 : navigation.addListener('focus', optionsChangeListener);
  }, [navigation, options, optionsChangeListener]);
  const getOptionsFromListener = React.useCallback(() => {
    for (let key in optionsGettersFromChildRef.current) {
      if (optionsGettersFromChildRef.current.hasOwnProperty(key)) {
        var _optionsGettersFromCh, _optionsGettersFromCh2;
        const result = (_optionsGettersFromCh = (_optionsGettersFromCh2 = optionsGettersFromChildRef.current)[key]) === null || _optionsGettersFromCh === void 0 ? void 0 : _optionsGettersFromCh.call(_optionsGettersFromCh2);

        // null means unfocused route
        if (result !== null) {
          return result;
        }
      }
    }
    return null;
  }, []);
  const getCurrentOptions = React.useCallback(() => {
    const isFocused = (navigation === null || navigation === void 0 ? void 0 : navigation.isFocused()) ?? true;
    if (!isFocused) {
      return null;
    }
    const optionsFromListener = getOptionsFromListener();
    if (optionsFromListener !== null) {
      return optionsFromListener;
    }
    return optionsRef.current;
  }, [navigation, getOptionsFromListener]);
  React.useEffect(() => {
    return parentAddOptionsGetter === null || parentAddOptionsGetter === void 0 ? void 0 : parentAddOptionsGetter(key, getCurrentOptions);
  }, [getCurrentOptions, parentAddOptionsGetter, key]);
  const addOptionsGetter = React.useCallback((key, getter) => {
    optionsGettersFromChildRef.current[key] = getter;
    optionsChangeListener();
    return () => {
      // eslint-disable-next-line @typescript-eslint/no-dynamic-delete
      delete optionsGettersFromChildRef.current[key];
      optionsChangeListener();
    };
  }, [optionsChangeListener]);
  return {
    addOptionsGetter,
    getCurrentOptions
  };
}
//# sourceMappingURL=useOptionsGetters.js.map

/***/ }),

/***/ 11984:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = usePreventRemove;
var _nonSecure = __webpack_require__(77869);
var React = _interopRequireWildcard(__webpack_require__(16689));
var _useLatestCallback = _interopRequireDefault(__webpack_require__(13438));
var _useNavigation = _interopRequireDefault(__webpack_require__(92381));
var _usePreventRemoveContext = _interopRequireDefault(__webpack_require__(53538));
var _useRoute = _interopRequireDefault(__webpack_require__(40685));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
/**
 * Hook to prevent screen from being removed. Can be used to prevent users from leaving the screen.
 *
 * @param preventRemove Boolean indicating whether to prevent screen from being removed.
 * @param callback Function which is executed when screen was prevented from being removed.
 */
function usePreventRemove(preventRemove, callback) {
  const [id] = React.useState(() => (0, _nonSecure.nanoid)());
  const navigation = (0, _useNavigation.default)();
  const {
    key: routeKey
  } = (0, _useRoute.default)();
  const {
    setPreventRemove
  } = (0, _usePreventRemoveContext.default)();
  React.useEffect(() => {
    setPreventRemove(id, routeKey, preventRemove);
    return () => {
      setPreventRemove(id, routeKey, false);
    };
  }, [setPreventRemove, id, routeKey, preventRemove]);
  const beforeRemoveListener = (0, _useLatestCallback.default)(e => {
    if (!preventRemove) {
      return;
    }
    e.preventDefault();
    callback({
      data: e.data
    });
  });
  React.useEffect(() => navigation === null || navigation === void 0 ? void 0 : navigation.addListener('beforeRemove', beforeRemoveListener), [navigation, beforeRemoveListener]);
}
//# sourceMappingURL=usePreventRemove.js.map

/***/ }),

/***/ 53538:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = usePreventRemoveContext;
var React = _interopRequireWildcard(__webpack_require__(16689));
var _PreventRemoveContext = _interopRequireDefault(__webpack_require__(16530));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function usePreventRemoveContext() {
  const value = React.useContext(_PreventRemoveContext.default);
  if (value == null) {
    throw new Error("Couldn't find the prevent remove context. Is your component inside NavigationContent?");
  }
  return value;
}
//# sourceMappingURL=usePreventRemoveContext.js.map

/***/ }),

/***/ 2438:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = useRegisterNavigator;
var _nonSecure = __webpack_require__(77869);
var React = _interopRequireWildcard(__webpack_require__(16689));
var _EnsureSingleNavigator = __webpack_require__(25192);
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
/**
 * Register a navigator in the parent context (either a navigation container or a screen).
 * This is used to prevent multiple navigators under a single container or screen.
 */
function useRegisterNavigator() {
  const [key] = React.useState(() => (0, _nonSecure.nanoid)());
  const container = React.useContext(_EnsureSingleNavigator.SingleNavigatorContext);
  if (container === undefined) {
    throw new Error("Couldn't register the navigator. Have you wrapped your app with 'NavigationContainer'?\n\nThis can also happen if there are multiple copies of '@react-navigation' packages installed.");
  }
  React.useEffect(() => {
    const {
      register,
      unregister
    } = container;
    register(key);
    return () => unregister(key);
  }, [container, key]);
  return key;
}
//# sourceMappingURL=useRegisterNavigator.js.map

/***/ }),

/***/ 40685:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = useRoute;
var React = _interopRequireWildcard(__webpack_require__(16689));
var _NavigationRouteContext = _interopRequireDefault(__webpack_require__(44820));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
/**
 * Hook to access the route prop of the parent screen anywhere.
 *
 * @returns Route prop of the parent screen.
 */
function useRoute() {
  const route = React.useContext(_NavigationRouteContext.default);
  if (route === undefined) {
    throw new Error("Couldn't find a route object. Is your component inside a screen in a navigator?");
  }
  return route;
}
//# sourceMappingURL=useRoute.js.map

/***/ }),

/***/ 37763:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.CHILD_STATE = void 0;
exports["default"] = useRouteCache;
var React = _interopRequireWildcard(__webpack_require__(16689));
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
/**
 * Utilites such as `getFocusedRouteNameFromRoute` need to access state.
 * So we need a way to suppress the warning for those use cases.
 * This is fine since they are internal utilities and this is not public API.
 */
const CHILD_STATE = Symbol('CHILD_STATE');

/**
 * Hook to cache route props for each screen in the navigator.
 * This lets add warnings and modifications to the route object but keep references between renders.
 */
exports.CHILD_STATE = CHILD_STATE;
function useRouteCache(routes) {
  // Cache object which holds route objects for each screen
  const cache = React.useMemo(() => ({
    current: new Map()
  }), []);
  if (true) {
    // We don't want the overhead of creating extra maps every render in prod
    return routes;
  }
  cache.current = routes.reduce((acc, route) => {
    const previous = cache.current.get(route);
    if (previous) {
      // If a cached route object already exists, reuse it
      acc.set(route, previous);
    } else {
      const {
        state,
        ...proxy
      } = route;
      Object.defineProperty(proxy, CHILD_STATE, {
        enumerable: false,
        value: state
      });
      acc.set(route, proxy);
    }
    return acc;
  }, new Map());
  return Array.from(cache.current.values());
}
//# sourceMappingURL=useRouteCache.js.map

/***/ }),

/***/ 18693:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.ScheduleUpdateContext = void 0;
exports["default"] = useScheduleUpdate;
var React = _interopRequireWildcard(__webpack_require__(16689));
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
const MISSING_CONTEXT_ERROR = "Couldn't find a schedule context.";
const ScheduleUpdateContext = /*#__PURE__*/React.createContext({
  scheduleUpdate() {
    throw new Error(MISSING_CONTEXT_ERROR);
  },
  flushUpdates() {
    throw new Error(MISSING_CONTEXT_ERROR);
  }
});

/**
 * When screen config changes, we want to update the navigator in the same update phase.
 * However, navigation state is in the root component and React won't let us update it from a child.
 * This is a workaround for that, the scheduled update is stored in the ref without actually calling setState.
 * It lets all subsequent updates access the latest state so it stays correct.
 * Then we call setState during after the component updates.
 */
exports.ScheduleUpdateContext = ScheduleUpdateContext;
function useScheduleUpdate(callback) {
  const {
    scheduleUpdate,
    flushUpdates
  } = React.useContext(ScheduleUpdateContext);
  scheduleUpdate(callback);
  React.useEffect(flushUpdates);
}
//# sourceMappingURL=useScheduleUpdate.js.map

/***/ }),

/***/ 73514:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = useSyncState;
var React = _interopRequireWildcard(__webpack_require__(16689));
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
const UNINTIALIZED_STATE = {};

/**
 * This is definitely not compatible with concurrent mode, but we don't have a solution for sync state yet.
 */
function useSyncState(initialState) {
  const stateRef = React.useRef(UNINTIALIZED_STATE);
  const isSchedulingRef = React.useRef(false);
  const isMountedRef = React.useRef(true);
  React.useEffect(() => {
    isMountedRef.current = true;
    return () => {
      isMountedRef.current = false;
    };
  }, []);
  if (stateRef.current === UNINTIALIZED_STATE) {
    stateRef.current =
    // @ts-expect-error: initialState is a function, but TypeScript doesn't think so
    typeof initialState === 'function' ? initialState() : initialState;
  }
  const [trackingState, setTrackingState] = React.useState(stateRef.current);
  const getState = React.useCallback(() => stateRef.current, []);
  const setState = React.useCallback(state => {
    if (state === stateRef.current || !isMountedRef.current) {
      return;
    }
    stateRef.current = state;
    if (!isSchedulingRef.current) {
      setTrackingState(state);
    }
  }, []);
  const scheduleUpdate = React.useCallback(callback => {
    isSchedulingRef.current = true;
    try {
      callback();
    } finally {
      isSchedulingRef.current = false;
    }
  }, []);
  const flushUpdates = React.useCallback(() => {
    if (!isMountedRef.current) {
      return;
    }

    // Make sure that the tracking state is up-to-date.
    // We call it unconditionally, but React should skip the update if state is unchanged.
    setTrackingState(stateRef.current);
  }, []);

  // If we're rendering and the tracking state is out of date, update it immediately
  // This will make sure that our updates are applied as early as possible.
  if (trackingState !== stateRef.current) {
    setTrackingState(stateRef.current);
  }
  const state = stateRef.current;
  React.useDebugValue(state);
  return [state, getState, setState, scheduleUpdate, flushUpdates];
}
//# sourceMappingURL=useSyncState.js.map

/***/ }),

/***/ 97579:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = validatePathConfig;
const formatToList = items => items.map(key => `- ${key}`).join('\n');
function validatePathConfig(config) {
  let root = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
  const validKeys = ['initialRouteName', 'screens'];
  if (!root) {
    validKeys.push('path', 'exact', 'stringify', 'parse');
  }
  const invalidKeys = Object.keys(config).filter(key => !validKeys.includes(key));
  if (invalidKeys.length) {
    throw new Error(`Found invalid properties in the configuration:\n${formatToList(invalidKeys)}\n\nDid you forget to specify them under a 'screens' property?\n\nYou can only specify the following properties:\n${formatToList(validKeys)}\n\nSee https://reactnavigation.org/docs/configuring-links for more details on how to specify a linking configuration.`);
  }
  if (config.screens) {
    Object.entries(config.screens).forEach(_ref => {
      let [_, value] = _ref;
      if (typeof value !== 'string') {
        validatePathConfig(value, false);
      }
    });
  }
}
//# sourceMappingURL=validatePathConfig.js.map

/***/ }),

/***/ 73552:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = Background;
var _native = __webpack_require__(33779);
var React = _interopRequireWildcard(__webpack_require__(16689));
var _reactNative = __webpack_require__(83849);
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }
function Background(_ref) {
  let {
    style,
    ...rest
  } = _ref;
  const {
    colors
  } = (0, _native.useTheme)();
  return /*#__PURE__*/React.createElement(_reactNative.View, _extends({}, rest, {
    style: [{
      flex: 1,
      backgroundColor: colors.background
    }, style]
  }));
}
//# sourceMappingURL=Background.js.map

/***/ }),

/***/ 52270:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = Header;
var React = _interopRequireWildcard(__webpack_require__(16689));
var _reactNative = __webpack_require__(83849);
var _reactNativeSafeAreaContext = __webpack_require__(30971);
var _getDefaultHeaderHeight = _interopRequireDefault(__webpack_require__(453));
var _HeaderBackground = _interopRequireDefault(__webpack_require__(71094));
var _HeaderShownContext = _interopRequireDefault(__webpack_require__(73441));
var _HeaderTitle = _interopRequireDefault(__webpack_require__(10516));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
const warnIfHeaderStylesDefined = styles => {
  Object.keys(styles).forEach(styleProp => {
    const value = styles[styleProp];
    if (styleProp === 'position' && value === 'absolute') {
      console.warn("position: 'absolute' is not supported on headerStyle. If you would like to render content under the header, use the 'headerTransparent' option.");
    } else if (value !== undefined) {
      console.warn(`${styleProp} was given a value of ${value}, this has no effect on headerStyle.`);
    }
  });
};
function Header(props) {
  const insets = (0, _reactNativeSafeAreaContext.useSafeAreaInsets)();
  const frame = (0, _reactNativeSafeAreaContext.useSafeAreaFrame)();
  const isParentHeaderShown = React.useContext(_HeaderShownContext.default);
  const {
    layout = frame,
    modal = false,
    title,
    headerTitle: customTitle,
    headerTitleAlign = _reactNative.Platform.select({
      ios: 'center',
      default: 'left'
    }),
    headerLeft,
    headerLeftLabelVisible,
    headerTransparent,
    headerTintColor,
    headerBackground,
    headerRight,
    headerTitleAllowFontScaling: titleAllowFontScaling,
    headerTitleStyle: titleStyle,
    headerLeftContainerStyle: leftContainerStyle,
    headerRightContainerStyle: rightContainerStyle,
    headerTitleContainerStyle: titleContainerStyle,
    headerBackgroundContainerStyle: backgroundContainerStyle,
    headerStyle: customHeaderStyle,
    headerShadowVisible,
    headerPressColor,
    headerPressOpacity,
    headerStatusBarHeight = isParentHeaderShown ? 0 : insets.top
  } = props;
  const defaultHeight = (0, _getDefaultHeaderHeight.default)(layout, modal, headerStatusBarHeight);
  const {
    height = defaultHeight,
    minHeight,
    maxHeight,
    backgroundColor,
    borderBottomColor,
    borderBottomEndRadius,
    borderBottomLeftRadius,
    borderBottomRightRadius,
    borderBottomStartRadius,
    borderBottomWidth,
    borderColor,
    borderEndColor,
    borderEndWidth,
    borderLeftColor,
    borderLeftWidth,
    borderRadius,
    borderRightColor,
    borderRightWidth,
    borderStartColor,
    borderStartWidth,
    borderStyle,
    borderTopColor,
    borderTopEndRadius,
    borderTopLeftRadius,
    borderTopRightRadius,
    borderTopStartRadius,
    borderTopWidth,
    borderWidth,
    // @ts-expect-error: web support for shadow
    boxShadow,
    elevation,
    shadowColor,
    shadowOffset,
    shadowOpacity,
    shadowRadius,
    opacity,
    transform,
    ...unsafeStyles
  } = _reactNative.StyleSheet.flatten(customHeaderStyle || {});
  if (false) {}
  const safeStyles = {
    backgroundColor,
    borderBottomColor,
    borderBottomEndRadius,
    borderBottomLeftRadius,
    borderBottomRightRadius,
    borderBottomStartRadius,
    borderBottomWidth,
    borderColor,
    borderEndColor,
    borderEndWidth,
    borderLeftColor,
    borderLeftWidth,
    borderRadius,
    borderRightColor,
    borderRightWidth,
    borderStartColor,
    borderStartWidth,
    borderStyle,
    borderTopColor,
    borderTopEndRadius,
    borderTopLeftRadius,
    borderTopRightRadius,
    borderTopStartRadius,
    borderTopWidth,
    borderWidth,
    // @ts-expect-error: boxShadow is only for Web
    boxShadow,
    elevation,
    shadowColor,
    shadowOffset,
    shadowOpacity,
    shadowRadius,
    opacity,
    transform
  };

  // Setting a property to undefined triggers default style
  // So we need to filter them out
  // Users can use `null` instead
  for (const styleProp in safeStyles) {
    // @ts-expect-error: typescript wrongly complains that styleProp cannot be used to index safeStyles
    if (safeStyles[styleProp] === undefined) {
      // @ts-expect-error
      // eslint-disable-next-line @typescript-eslint/no-dynamic-delete
      delete safeStyles[styleProp];
    }
  }
  const backgroundStyle = [safeStyles, headerShadowVisible === false && {
    elevation: 0,
    shadowOpacity: 0,
    borderBottomWidth: 0
  }];
  const leftButton = headerLeft ? headerLeft({
    tintColor: headerTintColor,
    pressColor: headerPressColor,
    pressOpacity: headerPressOpacity,
    labelVisible: headerLeftLabelVisible
  }) : null;
  const rightButton = headerRight ? headerRight({
    tintColor: headerTintColor,
    pressColor: headerPressColor,
    pressOpacity: headerPressOpacity
  }) : null;
  const headerTitle = typeof customTitle !== 'function' ? props => /*#__PURE__*/React.createElement(_HeaderTitle.default, props) : customTitle;
  return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(_reactNative.Animated.View, {
    pointerEvents: "box-none",
    style: [_reactNative.StyleSheet.absoluteFill, {
      zIndex: 0
    }, backgroundContainerStyle]
  }, headerBackground ? headerBackground({
    style: backgroundStyle
  }) : headerTransparent ? null : /*#__PURE__*/React.createElement(_HeaderBackground.default, {
    style: backgroundStyle
  })), /*#__PURE__*/React.createElement(_reactNative.Animated.View, {
    pointerEvents: "box-none",
    style: [{
      height,
      minHeight,
      maxHeight,
      opacity,
      transform
    }]
  }, /*#__PURE__*/React.createElement(_reactNative.View, {
    pointerEvents: "none",
    style: {
      height: headerStatusBarHeight
    }
  }), /*#__PURE__*/React.createElement(_reactNative.View, {
    pointerEvents: "box-none",
    style: styles.content
  }, /*#__PURE__*/React.createElement(_reactNative.Animated.View, {
    pointerEvents: "box-none",
    style: [styles.left, headerTitleAlign === 'center' && styles.expand, {
      marginStart: insets.left
    }, leftContainerStyle]
  }, leftButton), /*#__PURE__*/React.createElement(_reactNative.Animated.View, {
    pointerEvents: "box-none",
    style: [styles.title, {
      // Avoid the title from going offscreen or overlapping buttons
      maxWidth: headerTitleAlign === 'center' ? layout.width - ((leftButton ? headerLeftLabelVisible !== false ? 80 : 32 : 16) + Math.max(insets.left, insets.right)) * 2 : layout.width - ((leftButton ? 72 : 16) + (rightButton ? 72 : 16) + insets.left - insets.right)
    }, titleContainerStyle]
  }, headerTitle({
    children: title,
    allowFontScaling: titleAllowFontScaling,
    tintColor: headerTintColor,
    style: titleStyle
  })), /*#__PURE__*/React.createElement(_reactNative.Animated.View, {
    pointerEvents: "box-none",
    style: [styles.right, styles.expand, {
      marginEnd: insets.right
    }, rightContainerStyle]
  }, rightButton))));
}
const styles = _reactNative.StyleSheet.create({
  content: {
    flex: 1,
    flexDirection: 'row',
    alignItems: 'stretch'
  },
  title: {
    marginHorizontal: 16,
    justifyContent: 'center'
  },
  left: {
    justifyContent: 'center',
    alignItems: 'flex-start'
  },
  right: {
    justifyContent: 'center',
    alignItems: 'flex-end'
  },
  expand: {
    flexGrow: 1,
    flexBasis: 0
  }
});
//# sourceMappingURL=Header.js.map

/***/ }),

/***/ 26153:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = HeaderBackButton;
var _native = __webpack_require__(33779);
var React = _interopRequireWildcard(__webpack_require__(16689));
var _reactNative = __webpack_require__(83849);
var _MaskedView = _interopRequireDefault(__webpack_require__(13785));
var _PlatformPressable = _interopRequireDefault(__webpack_require__(91146));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function HeaderBackButton(_ref) {
  let {
    disabled,
    allowFontScaling,
    backImage,
    label,
    labelStyle,
    labelVisible,
    onLabelLayout,
    onPress,
    pressColor,
    pressOpacity,
    screenLayout,
    tintColor: customTintColor,
    titleLayout,
    truncatedLabel = 'Back',
    accessibilityLabel = label && label !== 'Back' ? `${label}, back` : 'Go back',
    testID,
    style
  } = _ref;
  const {
    colors
  } = (0, _native.useTheme)();
  const [initialLabelWidth, setInitialLabelWidth] = React.useState(undefined);
  const tintColor = customTintColor !== undefined ? customTintColor : _reactNative.Platform.select({
    ios: colors.primary,
    default: colors.text
  });
  const handleLabelLayout = e => {
    onLabelLayout === null || onLabelLayout === void 0 ? void 0 : onLabelLayout(e);
    setInitialLabelWidth(e.nativeEvent.layout.x + e.nativeEvent.layout.width);
  };
  const shouldTruncateLabel = () => {
    return !label || initialLabelWidth && titleLayout && screenLayout && (screenLayout.width - titleLayout.width) / 2 < initialLabelWidth + 26;
  };
  const renderBackImage = () => {
    if (backImage) {
      return backImage({
        tintColor
      });
    } else {
      return /*#__PURE__*/React.createElement(_reactNative.Image, {
        style: [styles.icon, Boolean(labelVisible) && styles.iconWithLabel, Boolean(tintColor) && {
          tintColor
        }],
        source: __webpack_require__(32383),
        fadeDuration: 0
      });
    }
  };
  const renderLabel = () => {
    const leftLabelText = shouldTruncateLabel() ? truncatedLabel : label;
    if (!labelVisible || leftLabelText === undefined) {
      return null;
    }
    const labelElement = /*#__PURE__*/React.createElement(_reactNative.View, {
      style: screenLayout ?
      // We make the button extend till the middle of the screen
      // Otherwise it appears to cut off when translating
      [styles.labelWrapper, {
        minWidth: screenLayout.width / 2 - 27
      }] : null
    }, /*#__PURE__*/React.createElement(_reactNative.Animated.Text, {
      accessible: false,
      onLayout:
      // This measurement is used to determine if we should truncate the label when it doesn't fit
      // Only measure it when label is not truncated because we want the measurement of full label
      leftLabelText === label ? handleLabelLayout : undefined,
      style: [styles.label, tintColor ? {
        color: tintColor
      } : null, labelStyle],
      numberOfLines: 1,
      allowFontScaling: !!allowFontScaling
    }, leftLabelText));
    if (backImage || _reactNative.Platform.OS !== 'ios') {
      // When a custom backimage is specified, we can't mask the label
      // Otherwise there might be weird effect due to our mask not being the same as the image
      return labelElement;
    }
    return /*#__PURE__*/React.createElement(_MaskedView.default, {
      maskElement: /*#__PURE__*/React.createElement(_reactNative.View, {
        style: styles.iconMaskContainer
      }, /*#__PURE__*/React.createElement(_reactNative.Image, {
        source: __webpack_require__(15517),
        style: styles.iconMask
      }), /*#__PURE__*/React.createElement(_reactNative.View, {
        style: styles.iconMaskFillerRect
      }))
    }, labelElement);
  };
  const handlePress = () => onPress && requestAnimationFrame(onPress);
  return /*#__PURE__*/React.createElement(_PlatformPressable.default, {
    disabled: disabled,
    accessible: true,
    accessibilityRole: "button",
    accessibilityLabel: accessibilityLabel,
    testID: testID,
    onPress: disabled ? undefined : handlePress,
    pressColor: pressColor,
    pressOpacity: pressOpacity,
    android_ripple: {
      borderless: true
    },
    style: [styles.container, disabled && styles.disabled, style],
    hitSlop: _reactNative.Platform.select({
      ios: undefined,
      default: {
        top: 16,
        right: 16,
        bottom: 16,
        left: 16
      }
    })
  }, /*#__PURE__*/React.createElement(React.Fragment, null, renderBackImage(), renderLabel()));
}
const styles = _reactNative.StyleSheet.create({
  container: {
    alignItems: 'center',
    flexDirection: 'row',
    minWidth: _reactNative.StyleSheet.hairlineWidth,
    // Avoid collapsing when title is long
    ..._reactNative.Platform.select({
      ios: null,
      default: {
        marginVertical: 3,
        marginHorizontal: 11
      }
    })
  },
  disabled: {
    opacity: 0.5
  },
  label: {
    fontSize: 17,
    // Title and back label are a bit different width due to title being bold
    // Adjusting the letterSpacing makes them coincide better
    letterSpacing: 0.35
  },
  labelWrapper: {
    // These styles will make sure that the label doesn't fill the available space
    // Otherwise it messes with the measurement of the label
    flexDirection: 'row',
    alignItems: 'flex-start'
  },
  icon: _reactNative.Platform.select({
    ios: {
      height: 21,
      width: 13,
      marginLeft: 8,
      marginRight: 22,
      marginVertical: 12,
      resizeMode: 'contain',
      transform: [{
        scaleX: _reactNative.I18nManager.getConstants().isRTL ? -1 : 1
      }]
    },
    default: {
      height: 24,
      width: 24,
      margin: 3,
      resizeMode: 'contain',
      transform: [{
        scaleX: _reactNative.I18nManager.getConstants().isRTL ? -1 : 1
      }]
    }
  }),
  iconWithLabel: _reactNative.Platform.OS === 'ios' ? {
    marginRight: 6
  } : {},
  iconMaskContainer: {
    flex: 1,
    flexDirection: 'row',
    justifyContent: 'center'
  },
  iconMaskFillerRect: {
    flex: 1,
    backgroundColor: '#000'
  },
  iconMask: {
    height: 21,
    width: 13,
    marginLeft: -14.5,
    marginVertical: 12,
    alignSelf: 'center',
    resizeMode: 'contain',
    transform: [{
      scaleX: _reactNative.I18nManager.getConstants().isRTL ? -1 : 1
    }]
  }
});
//# sourceMappingURL=HeaderBackButton.js.map

/***/ }),

/***/ 64986:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _getNamedContext = _interopRequireDefault(__webpack_require__(57545));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const HeaderBackContext = (0, _getNamedContext.default)('HeaderBackContext', undefined);
var _default = HeaderBackContext;
exports["default"] = _default;
//# sourceMappingURL=HeaderBackContext.js.map

/***/ }),

/***/ 71094:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = HeaderBackground;
var _native = __webpack_require__(33779);
var React = _interopRequireWildcard(__webpack_require__(16689));
var _reactNative = __webpack_require__(83849);
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }
function HeaderBackground(_ref) {
  let {
    style,
    ...rest
  } = _ref;
  const {
    colors
  } = (0, _native.useTheme)();
  return /*#__PURE__*/React.createElement(_reactNative.Animated.View, _extends({
    style: [styles.container, {
      backgroundColor: colors.card,
      borderBottomColor: colors.border,
      shadowColor: colors.border
    }, style]
  }, rest));
}
const styles = _reactNative.StyleSheet.create({
  container: {
    flex: 1,
    ..._reactNative.Platform.select({
      android: {
        elevation: 4
      },
      ios: {
        shadowOpacity: 0.85,
        shadowRadius: 0,
        shadowOffset: {
          width: 0,
          height: _reactNative.StyleSheet.hairlineWidth
        }
      },
      default: {
        borderBottomWidth: _reactNative.StyleSheet.hairlineWidth
      }
    })
  }
});
//# sourceMappingURL=HeaderBackground.js.map

/***/ }),

/***/ 53005:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _getNamedContext = _interopRequireDefault(__webpack_require__(57545));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const HeaderHeightContext = (0, _getNamedContext.default)('HeaderHeightContext', undefined);
var _default = HeaderHeightContext;
exports["default"] = _default;
//# sourceMappingURL=HeaderHeightContext.js.map

/***/ }),

/***/ 73441:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _getNamedContext = _interopRequireDefault(__webpack_require__(57545));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const HeaderShownContext = (0, _getNamedContext.default)('HeaderShownContext', false);
var _default = HeaderShownContext;
exports["default"] = _default;
//# sourceMappingURL=HeaderShownContext.js.map

/***/ }),

/***/ 10516:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = HeaderTitle;
var _native = __webpack_require__(33779);
var React = _interopRequireWildcard(__webpack_require__(16689));
var _reactNative = __webpack_require__(83849);
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }
function HeaderTitle(_ref) {
  let {
    tintColor,
    style,
    ...rest
  } = _ref;
  const {
    colors
  } = (0, _native.useTheme)();
  return /*#__PURE__*/React.createElement(_reactNative.Animated.Text, _extends({
    accessibilityRole: "header",
    "aria-level": "1",
    numberOfLines: 1
  }, rest, {
    style: [styles.title, {
      color: tintColor === undefined ? colors.text : tintColor
    }, style]
  }));
}
const styles = _reactNative.StyleSheet.create({
  title: _reactNative.Platform.select({
    ios: {
      fontSize: 17,
      fontWeight: '600'
    },
    android: {
      fontSize: 20,
      fontFamily: 'sans-serif-medium',
      fontWeight: 'normal'
    },
    default: {
      fontSize: 18,
      fontWeight: '500'
    }
  })
});
//# sourceMappingURL=HeaderTitle.js.map

/***/ }),

/***/ 453:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = getDefaultHeaderHeight;
var _reactNative = __webpack_require__(83849);
function getDefaultHeaderHeight(layout, modalPresentation, statusBarHeight) {
  let headerHeight;
  const isLandscape = layout.width > layout.height;
  if (_reactNative.Platform.OS === 'ios') {
    if (_reactNative.Platform.isPad || _reactNative.Platform.isTV) {
      if (modalPresentation) {
        headerHeight = 56;
      } else {
        headerHeight = 50;
      }
    } else {
      if (isLandscape) {
        headerHeight = 32;
      } else {
        if (modalPresentation) {
          headerHeight = 56;
        } else {
          headerHeight = 44;
        }
      }
    }
  } else if (_reactNative.Platform.OS === 'android') {
    headerHeight = 56;
  } else {
    headerHeight = 64;
  }
  return headerHeight + statusBarHeight;
}
//# sourceMappingURL=getDefaultHeaderHeight.js.map

/***/ }),

/***/ 79264:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = getHeaderTitle;
function getHeaderTitle(options, fallback) {
  return typeof options.headerTitle === 'string' ? options.headerTitle : options.title !== undefined ? options.title : fallback;
}
//# sourceMappingURL=getHeaderTitle.js.map

/***/ }),

/***/ 71039:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = useHeaderHeight;
var React = _interopRequireWildcard(__webpack_require__(16689));
var _HeaderHeightContext = _interopRequireDefault(__webpack_require__(53005));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function useHeaderHeight() {
  const height = React.useContext(_HeaderHeightContext.default);
  if (height === undefined) {
    throw new Error("Couldn't find the header height. Are you inside a screen in a navigator with a header?");
  }
  return height;
}
//# sourceMappingURL=useHeaderHeight.js.map

/***/ }),

/***/ 13785:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = MaskedView;
/**
 * Use a stub for MaskedView on all Platforms that don't support it.
 */

function MaskedView(_ref) {
  let {
    children
  } = _ref;
  return children;
}
//# sourceMappingURL=MaskedView.js.map

/***/ }),

/***/ 65696:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = MissingIcon;
var React = _interopRequireWildcard(__webpack_require__(16689));
var _reactNative = __webpack_require__(83849);
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function MissingIcon(_ref) {
  let {
    color,
    size,
    style
  } = _ref;
  return /*#__PURE__*/React.createElement(_reactNative.Text, {
    style: [styles.icon, {
      color,
      fontSize: size
    }, style]
  }, "\u23F7");
}
const styles = _reactNative.StyleSheet.create({
  icon: {
    backgroundColor: 'transparent'
  }
});
//# sourceMappingURL=MissingIcon.js.map

/***/ }),

/***/ 91146:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = PlatformPressable;
var _native = __webpack_require__(33779);
var React = _interopRequireWildcard(__webpack_require__(16689));
var _reactNative = __webpack_require__(83849);
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }
const AnimatedPressable = _reactNative.Animated.createAnimatedComponent(_reactNative.Pressable);
const ANDROID_VERSION_LOLLIPOP = 21;
const ANDROID_SUPPORTS_RIPPLE = _reactNative.Platform.OS === 'android' && _reactNative.Platform.Version >= ANDROID_VERSION_LOLLIPOP;

/**
 * PlatformPressable provides an abstraction on top of Pressable to handle platform differences.
 */
function PlatformPressable(_ref) {
  let {
    onPressIn,
    onPressOut,
    android_ripple,
    pressColor,
    pressOpacity = 0.3,
    style,
    ...rest
  } = _ref;
  const {
    dark
  } = (0, _native.useTheme)();
  const [opacity] = React.useState(() => new _reactNative.Animated.Value(1));
  const animateTo = (toValue, duration) => {
    if (ANDROID_SUPPORTS_RIPPLE) {
      return;
    }
    _reactNative.Animated.timing(opacity, {
      toValue,
      duration,
      easing: _reactNative.Easing.inOut(_reactNative.Easing.quad),
      useNativeDriver: true
    }).start();
  };
  const handlePressIn = e => {
    animateTo(pressOpacity, 0);
    onPressIn === null || onPressIn === void 0 ? void 0 : onPressIn(e);
  };
  const handlePressOut = e => {
    animateTo(1, 200);
    onPressOut === null || onPressOut === void 0 ? void 0 : onPressOut(e);
  };
  return /*#__PURE__*/React.createElement(AnimatedPressable, _extends({
    onPressIn: handlePressIn,
    onPressOut: handlePressOut,
    android_ripple: ANDROID_SUPPORTS_RIPPLE ? {
      color: pressColor !== undefined ? pressColor : dark ? 'rgba(255, 255, 255, .32)' : 'rgba(0, 0, 0, .32)',
      ...android_ripple
    } : undefined,
    style: [{
      opacity: !ANDROID_SUPPORTS_RIPPLE ? opacity : 1
    }, style]
  }, rest));
}
//# sourceMappingURL=PlatformPressable.js.map

/***/ }),

/***/ 49199:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = ResourceSavingScene;
var React = _interopRequireWildcard(__webpack_require__(16689));
var _reactNative = __webpack_require__(83849);
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }
const FAR_FAR_AWAY = 30000; // this should be big enough to move the whole view out of its container

function ResourceSavingScene(_ref) {
  let {
    visible,
    children,
    style,
    ...rest
  } = _ref;
  if (_reactNative.Platform.OS === 'web') {
    return /*#__PURE__*/React.createElement(_reactNative.View
    // @ts-expect-error: hidden exists on web, but not in React Native
    , _extends({
      hidden: !visible,
      style: [{
        display: visible ? 'flex' : 'none'
      }, styles.container, style],
      pointerEvents: visible ? 'auto' : 'none'
    }, rest), children);
  }
  return /*#__PURE__*/React.createElement(_reactNative.View, {
    style: [styles.container, style]
    // box-none doesn't seem to work properly on Android
    ,
    pointerEvents: visible ? 'auto' : 'none'
  }, /*#__PURE__*/React.createElement(_reactNative.View, {
    collapsable: false,
    removeClippedSubviews:
    // On iOS & macOS, set removeClippedSubviews to true only when not focused
    // This is an workaround for a bug where the clipped view never re-appears
    _reactNative.Platform.OS === 'ios' || _reactNative.Platform.OS === 'macos' ? !visible : true,
    pointerEvents: visible ? 'auto' : 'none',
    style: visible ? styles.attached : styles.detached
  }, children));
}
const styles = _reactNative.StyleSheet.create({
  container: {
    flex: 1,
    overflow: 'hidden'
  },
  attached: {
    flex: 1
  },
  detached: {
    flex: 1,
    top: FAR_FAR_AWAY
  }
});
//# sourceMappingURL=ResourceSavingView.js.map

/***/ }),

/***/ 92550:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = SafeAreaProviderCompat;
var React = _interopRequireWildcard(__webpack_require__(16689));
var _reactNative = __webpack_require__(83849);
var _reactNativeSafeAreaContext = __webpack_require__(30971);
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
const {
  width = 0,
  height = 0
} = _reactNative.Dimensions.get('window');

// To support SSR on web, we need to have empty insets for initial values
// Otherwise there can be mismatch between SSR and client output
// We also need to specify empty values to support tests environments
const initialMetrics = _reactNative.Platform.OS === 'web' || _reactNativeSafeAreaContext.initialWindowMetrics == null ? {
  frame: {
    x: 0,
    y: 0,
    width,
    height
  },
  insets: {
    top: 0,
    left: 0,
    right: 0,
    bottom: 0
  }
} : _reactNativeSafeAreaContext.initialWindowMetrics;
function SafeAreaProviderCompat(_ref) {
  let {
    children,
    style
  } = _ref;
  return /*#__PURE__*/React.createElement(_reactNativeSafeAreaContext.SafeAreaInsetsContext.Consumer, null, insets => {
    if (insets) {
      // If we already have insets, don't wrap the stack in another safe area provider
      // This avoids an issue with updates at the cost of potentially incorrect values
      // https://github.com/react-navigation/react-navigation/issues/174
      return /*#__PURE__*/React.createElement(_reactNative.View, {
        style: [styles.container, style]
      }, children);
    }
    return /*#__PURE__*/React.createElement(_reactNativeSafeAreaContext.SafeAreaProvider, {
      initialMetrics: initialMetrics,
      style: style
    }, children);
  });
}
SafeAreaProviderCompat.initialMetrics = initialMetrics;
const styles = _reactNative.StyleSheet.create({
  container: {
    flex: 1
  }
});
//# sourceMappingURL=SafeAreaProviderCompat.js.map

/***/ }),

/***/ 11489:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = Screen;
var _native = __webpack_require__(33779);
var React = _interopRequireWildcard(__webpack_require__(16689));
var _reactNative = __webpack_require__(83849);
var _reactNativeSafeAreaContext = __webpack_require__(30971);
var _Background = _interopRequireDefault(__webpack_require__(73552));
var _getDefaultHeaderHeight = _interopRequireDefault(__webpack_require__(453));
var _HeaderHeightContext = _interopRequireDefault(__webpack_require__(53005));
var _HeaderShownContext = _interopRequireDefault(__webpack_require__(73441));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function Screen(props) {
  const dimensions = (0, _reactNativeSafeAreaContext.useSafeAreaFrame)();
  const insets = (0, _reactNativeSafeAreaContext.useSafeAreaInsets)();
  const isParentHeaderShown = React.useContext(_HeaderShownContext.default);
  const parentHeaderHeight = React.useContext(_HeaderHeightContext.default);
  const {
    focused,
    modal = false,
    header,
    headerShown = true,
    headerTransparent,
    headerStatusBarHeight = isParentHeaderShown ? 0 : insets.top,
    navigation,
    route,
    children,
    style
  } = props;
  const [headerHeight, setHeaderHeight] = React.useState(() => (0, _getDefaultHeaderHeight.default)(dimensions, modal, headerStatusBarHeight));
  return /*#__PURE__*/React.createElement(_Background.default, {
    accessibilityElementsHidden: !focused,
    importantForAccessibility: focused ? 'auto' : 'no-hide-descendants',
    style: [styles.container, style]
  }, /*#__PURE__*/React.createElement(_reactNative.View, {
    style: styles.content
  }, /*#__PURE__*/React.createElement(_HeaderShownContext.default.Provider, {
    value: isParentHeaderShown || headerShown !== false
  }, /*#__PURE__*/React.createElement(_HeaderHeightContext.default.Provider, {
    value: headerShown ? headerHeight : parentHeaderHeight ?? 0
  }, children))), headerShown ? /*#__PURE__*/React.createElement(_native.NavigationContext.Provider, {
    value: navigation
  }, /*#__PURE__*/React.createElement(_native.NavigationRouteContext.Provider, {
    value: route
  }, /*#__PURE__*/React.createElement(_reactNative.View, {
    onLayout: e => {
      const {
        height
      } = e.nativeEvent.layout;
      setHeaderHeight(height);
    },
    style: headerTransparent ? styles.absolute : null
  }, header))) : null);
}
const styles = _reactNative.StyleSheet.create({
  container: {
    flex: 1,
    flexDirection: 'column-reverse'
  },
  // This is necessary to avoid applying 'column-reverse' to screen content
  content: {
    flex: 1
  },
  absolute: {
    position: 'absolute',
    top: 0,
    left: 0,
    right: 0
  }
});
//# sourceMappingURL=Screen.js.map

/***/ }),

/***/ 57545:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = getNamedContext;
var React = _interopRequireWildcard(__webpack_require__(16689));
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
const contexts = '__react_navigation__elements_contexts';
// We use a global variable to keep our contexts so that we can reuse same contexts across packages
global[contexts] = global[contexts] ?? new Map();
function getNamedContext(name, initialValue) {
  let context = global[contexts].get(name);
  if (context) {
    return context;
  }
  context = /*#__PURE__*/React.createContext(initialValue);
  context.displayName = name;
  global[contexts].set(name, context);
  return context;
}
//# sourceMappingURL=getNamedContext.js.map

/***/ }),

/***/ 46651:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
var _exportNames = {
  Assets: true,
  Background: true,
  getDefaultHeaderHeight: true,
  getHeaderTitle: true,
  Header: true,
  HeaderBackButton: true,
  HeaderBackContext: true,
  HeaderBackground: true,
  HeaderHeightContext: true,
  HeaderShownContext: true,
  HeaderTitle: true,
  useHeaderHeight: true,
  MissingIcon: true,
  PlatformPressable: true,
  ResourceSavingView: true,
  SafeAreaProviderCompat: true,
  Screen: true
};
exports.Assets = void 0;
Object.defineProperty(exports, "Background", ({
  enumerable: true,
  get: function () {
    return _Background.default;
  }
}));
Object.defineProperty(exports, "Header", ({
  enumerable: true,
  get: function () {
    return _Header.default;
  }
}));
Object.defineProperty(exports, "HeaderBackButton", ({
  enumerable: true,
  get: function () {
    return _HeaderBackButton.default;
  }
}));
Object.defineProperty(exports, "HeaderBackContext", ({
  enumerable: true,
  get: function () {
    return _HeaderBackContext.default;
  }
}));
Object.defineProperty(exports, "HeaderBackground", ({
  enumerable: true,
  get: function () {
    return _HeaderBackground.default;
  }
}));
Object.defineProperty(exports, "HeaderHeightContext", ({
  enumerable: true,
  get: function () {
    return _HeaderHeightContext.default;
  }
}));
Object.defineProperty(exports, "HeaderShownContext", ({
  enumerable: true,
  get: function () {
    return _HeaderShownContext.default;
  }
}));
Object.defineProperty(exports, "HeaderTitle", ({
  enumerable: true,
  get: function () {
    return _HeaderTitle.default;
  }
}));
Object.defineProperty(exports, "MissingIcon", ({
  enumerable: true,
  get: function () {
    return _MissingIcon.default;
  }
}));
Object.defineProperty(exports, "PlatformPressable", ({
  enumerable: true,
  get: function () {
    return _PlatformPressable.default;
  }
}));
Object.defineProperty(exports, "ResourceSavingView", ({
  enumerable: true,
  get: function () {
    return _ResourceSavingView.default;
  }
}));
Object.defineProperty(exports, "SafeAreaProviderCompat", ({
  enumerable: true,
  get: function () {
    return _SafeAreaProviderCompat.default;
  }
}));
Object.defineProperty(exports, "Screen", ({
  enumerable: true,
  get: function () {
    return _Screen.default;
  }
}));
Object.defineProperty(exports, "getDefaultHeaderHeight", ({
  enumerable: true,
  get: function () {
    return _getDefaultHeaderHeight.default;
  }
}));
Object.defineProperty(exports, "getHeaderTitle", ({
  enumerable: true,
  get: function () {
    return _getHeaderTitle.default;
  }
}));
Object.defineProperty(exports, "useHeaderHeight", ({
  enumerable: true,
  get: function () {
    return _useHeaderHeight.default;
  }
}));
var _Background = _interopRequireDefault(__webpack_require__(73552));
var _getDefaultHeaderHeight = _interopRequireDefault(__webpack_require__(453));
var _getHeaderTitle = _interopRequireDefault(__webpack_require__(79264));
var _Header = _interopRequireDefault(__webpack_require__(52270));
var _HeaderBackButton = _interopRequireDefault(__webpack_require__(26153));
var _HeaderBackContext = _interopRequireDefault(__webpack_require__(64986));
var _HeaderBackground = _interopRequireDefault(__webpack_require__(71094));
var _HeaderHeightContext = _interopRequireDefault(__webpack_require__(53005));
var _HeaderShownContext = _interopRequireDefault(__webpack_require__(73441));
var _HeaderTitle = _interopRequireDefault(__webpack_require__(10516));
var _useHeaderHeight = _interopRequireDefault(__webpack_require__(71039));
var _MissingIcon = _interopRequireDefault(__webpack_require__(65696));
var _PlatformPressable = _interopRequireDefault(__webpack_require__(91146));
var _ResourceSavingView = _interopRequireDefault(__webpack_require__(49199));
var _SafeAreaProviderCompat = _interopRequireDefault(__webpack_require__(92550));
var _Screen = _interopRequireDefault(__webpack_require__(11489));
var _types = __webpack_require__(91263);
Object.keys(_types).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _types[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _types[key];
    }
  });
});
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const Assets = [
// eslint-disable-next-line import/no-commonjs
__webpack_require__(32383),
// eslint-disable-next-line import/no-commonjs
__webpack_require__(15517)];
exports.Assets = Assets;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 91263:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
//# sourceMappingURL=types.js.map

/***/ }),

/***/ 10477:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
var __webpack_unused_export__;


__webpack_unused_export__ = ({
  value: true
});
__webpack_unused_export__ = ({
  enumerable: true,
  get: function () {
    return _NativeStackView.default;
  }
});
Object.defineProperty(exports, "bO", ({
  enumerable: true,
  get: function () {
    return _createNativeStackNavigator.default;
  }
}));
var _createNativeStackNavigator = _interopRequireDefault(__webpack_require__(69702));
var _NativeStackView = _interopRequireDefault(__webpack_require__(24168));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 69702:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _native = __webpack_require__(33779);
var React = _interopRequireWildcard(__webpack_require__(16689));
var _NativeStackView = _interopRequireDefault(__webpack_require__(24168));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }
function NativeStackNavigator(_ref) {
  let {
    id,
    initialRouteName,
    children,
    screenListeners,
    screenOptions,
    ...rest
  } = _ref;
  const {
    state,
    descriptors,
    navigation,
    NavigationContent
  } = (0, _native.useNavigationBuilder)(_native.StackRouter, {
    id,
    initialRouteName,
    children,
    screenListeners,
    screenOptions
  });
  React.useEffect(() => {
    var _navigation$addListen;
    return (// @ts-expect-error: there may not be a tab navigator in parent
      navigation === null || navigation === void 0 ? void 0 : (_navigation$addListen = navigation.addListener) === null || _navigation$addListen === void 0 ? void 0 : _navigation$addListen.call(navigation, 'tabPress', e => {
        const isFocused = navigation.isFocused();

        // Run the operation in the next frame so we're sure all listeners have been run
        // This is necessary to know if preventDefault() has been called
        requestAnimationFrame(() => {
          if (state.index > 0 && isFocused && !e.defaultPrevented) {
            // When user taps on already focused tab and we're inside the tab,
            // reset the stack to replicate native behaviour
            navigation.dispatch({
              ..._native.StackActions.popToTop(),
              target: state.key
            });
          }
        });
      })
    );
  }, [navigation, state.index, state.key]);
  return /*#__PURE__*/React.createElement(NavigationContent, null, /*#__PURE__*/React.createElement(_NativeStackView.default, _extends({}, rest, {
    state: state,
    navigation: navigation,
    descriptors: descriptors
  })));
}
var _default = (0, _native.createNavigatorFactory)(NativeStackNavigator);
exports["default"] = _default;
//# sourceMappingURL=createNativeStackNavigator.js.map

/***/ }),

/***/ 24168:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = NativeStackView;
var _elements = __webpack_require__(46651);
var React = _interopRequireWildcard(__webpack_require__(16689));
var _reactNative = __webpack_require__(83849);
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
const TRANSPARENT_PRESENTATIONS = ['transparentModal', 'containedTransparentModal'];
function NativeStackView(_ref) {
  let {
    state,
    descriptors
  } = _ref;
  const parentHeaderBack = React.useContext(_elements.HeaderBackContext);
  return /*#__PURE__*/React.createElement(_elements.SafeAreaProviderCompat, null, /*#__PURE__*/React.createElement(_reactNative.View, {
    style: styles.container
  }, state.routes.map((route, i) => {
    var _state$routes, _state$routes2;
    const isFocused = state.index === i;
    const previousKey = (_state$routes = state.routes[i - 1]) === null || _state$routes === void 0 ? void 0 : _state$routes.key;
    const nextKey = (_state$routes2 = state.routes[i + 1]) === null || _state$routes2 === void 0 ? void 0 : _state$routes2.key;
    const previousDescriptor = previousKey ? descriptors[previousKey] : undefined;
    const nextDescriptor = nextKey ? descriptors[nextKey] : undefined;
    const {
      options,
      navigation,
      render
    } = descriptors[route.key];
    const headerBack = previousDescriptor ? {
      title: (0, _elements.getHeaderTitle)(previousDescriptor.options, previousDescriptor.route.name)
    } : parentHeaderBack;
    const canGoBack = headerBack !== undefined;
    const {
      header,
      headerShown,
      headerTintColor,
      headerBackImageSource,
      headerLeft,
      headerRight,
      headerTitle,
      headerTitleAlign,
      headerTitleStyle,
      headerStyle,
      headerShadowVisible,
      headerTransparent,
      headerBackground,
      headerBackTitle,
      presentation,
      contentStyle
    } = options;
    const nextPresentation = nextDescriptor === null || nextDescriptor === void 0 ? void 0 : nextDescriptor.options.presentation;
    return /*#__PURE__*/React.createElement(_elements.Screen, {
      key: route.key,
      focused: isFocused,
      route: route,
      navigation: navigation,
      headerShown: headerShown,
      headerTransparent: headerTransparent,
      header: header !== undefined ? header({
        back: headerBack,
        options,
        route,
        navigation
      }) : /*#__PURE__*/React.createElement(_elements.Header, {
        title: (0, _elements.getHeaderTitle)(options, route.name),
        headerTintColor: headerTintColor,
        headerLeft: typeof headerLeft === 'function' ? _ref2 => {
          let {
            tintColor
          } = _ref2;
          return headerLeft({
            tintColor,
            canGoBack,
            label: headerBackTitle
          });
        } : headerLeft === undefined && canGoBack ? _ref3 => {
          let {
            tintColor
          } = _ref3;
          return /*#__PURE__*/React.createElement(_elements.HeaderBackButton, {
            tintColor: tintColor,
            backImage: headerBackImageSource !== undefined ? () => /*#__PURE__*/React.createElement(_reactNative.Image, {
              source: headerBackImageSource,
              style: [styles.backImage, {
                tintColor
              }]
            }) : undefined,
            onPress: navigation.goBack,
            canGoBack: canGoBack
          });
        } : headerLeft,
        headerRight: typeof headerRight === 'function' ? _ref4 => {
          let {
            tintColor
          } = _ref4;
          return headerRight({
            tintColor,
            canGoBack
          });
        } : headerRight,
        headerTitle: typeof headerTitle === 'function' ? _ref5 => {
          let {
            children,
            tintColor
          } = _ref5;
          return headerTitle({
            children,
            tintColor
          });
        } : headerTitle,
        headerTitleAlign: headerTitleAlign,
        headerTitleStyle: headerTitleStyle,
        headerTransparent: headerTransparent,
        headerShadowVisible: headerShadowVisible,
        headerBackground: headerBackground,
        headerStyle: headerStyle
      }),
      style: [_reactNative.StyleSheet.absoluteFill, {
        display: isFocused || nextPresentation != null && TRANSPARENT_PRESENTATIONS.includes(nextPresentation) ? 'flex' : 'none'
      }, presentation != null && TRANSPARENT_PRESENTATIONS.includes(presentation) ? {
        backgroundColor: 'transparent'
      } : null]
    }, /*#__PURE__*/React.createElement(_elements.HeaderBackContext.Provider, {
      value: headerBack
    }, /*#__PURE__*/React.createElement(_reactNative.View, {
      style: [styles.contentContainer, contentStyle]
    }, render())));
  })));
}
const styles = _reactNative.StyleSheet.create({
  container: {
    flex: 1
  },
  contentContainer: {
    flex: 1
  },
  backImage: {
    height: 24,
    width: 24,
    margin: 3,
    resizeMode: 'contain'
  }
});
//# sourceMappingURL=NativeStackView.js.map

/***/ }),

/***/ 71163:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = Link;
var React = _interopRequireWildcard(__webpack_require__(16689));
var _reactNative = __webpack_require__(83849);
var _useLinkProps = _interopRequireDefault(__webpack_require__(29648));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
/**
 * Component to render link to another screen using a path.
 * Uses an anchor tag on the web.
 *
 * @param props.to Absolute path to screen (e.g. `/feeds/hot`).
 * @param props.action Optional action to use for in-page navigation. By default, the path is parsed to an action based on linking config.
 * @param props.children Child elements to render the content.
 */
function Link(_ref) {
  let {
    to,
    action,
    ...rest
  } = _ref;
  const props = (0, _useLinkProps.default)({
    to,
    action
  });
  const onPress = e => {
    if ('onPress' in rest) {
      var _rest$onPress;
      (_rest$onPress = rest.onPress) === null || _rest$onPress === void 0 ? void 0 : _rest$onPress.call(rest, e);
    }
    props.onPress(e);
  };
  return /*#__PURE__*/React.createElement(_reactNative.Text, {
    ...props,
    ...rest,
    ..._reactNative.Platform.select({
      web: {
        onClick: onPress
      },
      default: {
        onPress
      }
    })
  });
}
//# sourceMappingURL=Link.js.map

/***/ }),

/***/ 63079:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var React = _interopRequireWildcard(__webpack_require__(16689));
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
const LinkingContext = /*#__PURE__*/React.createContext({
  options: undefined
});
LinkingContext.displayName = 'LinkingContext';
var _default = LinkingContext;
exports["default"] = _default;
//# sourceMappingURL=LinkingContext.js.map

/***/ }),

/***/ 54555:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _core = __webpack_require__(93169);
var React = _interopRequireWildcard(__webpack_require__(16689));
var _LinkingContext = _interopRequireDefault(__webpack_require__(63079));
var _DefaultTheme = _interopRequireDefault(__webpack_require__(90858));
var _ThemeProvider = _interopRequireDefault(__webpack_require__(4481));
var _useBackButton = _interopRequireDefault(__webpack_require__(76183));
var _useDocumentTitle = _interopRequireDefault(__webpack_require__(16848));
var _useLinking = _interopRequireDefault(__webpack_require__(57352));
var _useThenable = _interopRequireDefault(__webpack_require__(42078));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }
global.REACT_NAVIGATION_DEVTOOLS = new WeakMap();
/**
 * Container component which holds the navigation state designed for React Native apps.
 * This should be rendered at the root wrapping the whole app.
 *
 * @param props.initialState Initial state object for the navigation tree. When deep link handling is enabled, this will override deep links when specified. Make sure that you don't specify an `initialState` when there's a deep link (`Linking.getInitialURL()`).
 * @param props.onReady Callback which is called after the navigation tree mounts.
 * @param props.onStateChange Callback which is called with the latest navigation state when it changes.
 * @param props.theme Theme object for the navigators.
 * @param props.linking Options for deep linking. Deep link handling is enabled when this prop is provided, unless `linking.enabled` is `false`.
 * @param props.fallback Fallback component to render until we have finished getting initial state when linking is enabled. Defaults to `null`.
 * @param props.documentTitle Options to configure the document title on Web. Updating document title is handled by default unless `documentTitle.enabled` is `false`.
 * @param props.children Child elements to render the content.
 * @param props.ref Ref object which refers to the navigation object containing helper methods.
 */
function NavigationContainerInner(_ref, ref) {
  let {
    theme = _DefaultTheme.default,
    linking,
    fallback = null,
    documentTitle,
    onReady,
    ...rest
  } = _ref;
  const isLinkingEnabled = linking ? linking.enabled !== false : false;
  if (linking !== null && linking !== void 0 && linking.config) {
    (0, _core.validatePathConfig)(linking.config);
  }
  const refContainer = React.useRef(null);
  (0, _useBackButton.default)(refContainer);
  (0, _useDocumentTitle.default)(refContainer, documentTitle);
  const {
    getInitialState
  } = (0, _useLinking.default)(refContainer, {
    independent: rest.independent,
    enabled: isLinkingEnabled,
    prefixes: [],
    ...linking
  });

  // Add additional linking related info to the ref
  // This will be used by the devtools
  React.useEffect(() => {
    if (refContainer.current) {
      REACT_NAVIGATION_DEVTOOLS.set(refContainer.current, {
        get linking() {
          return {
            ...linking,
            enabled: isLinkingEnabled,
            prefixes: (linking === null || linking === void 0 ? void 0 : linking.prefixes) ?? [],
            getStateFromPath: (linking === null || linking === void 0 ? void 0 : linking.getStateFromPath) ?? _core.getStateFromPath,
            getPathFromState: (linking === null || linking === void 0 ? void 0 : linking.getPathFromState) ?? _core.getPathFromState,
            getActionFromState: (linking === null || linking === void 0 ? void 0 : linking.getActionFromState) ?? _core.getActionFromState
          };
        }
      });
    }
  });
  const [isResolved, initialState] = (0, _useThenable.default)(getInitialState);
  React.useImperativeHandle(ref, () => refContainer.current);
  const linkingContext = React.useMemo(() => ({
    options: linking
  }), [linking]);
  const isReady = rest.initialState != null || !isLinkingEnabled || isResolved;
  const onReadyRef = React.useRef(onReady);
  React.useEffect(() => {
    onReadyRef.current = onReady;
  });
  React.useEffect(() => {
    if (isReady) {
      var _onReadyRef$current;
      (_onReadyRef$current = onReadyRef.current) === null || _onReadyRef$current === void 0 ? void 0 : _onReadyRef$current.call(onReadyRef);
    }
  }, [isReady]);
  if (!isReady) {
    // This is temporary until we have Suspense for data-fetching
    // Then the fallback will be handled by a parent `Suspense` component
    return fallback;
  }
  return /*#__PURE__*/React.createElement(_LinkingContext.default.Provider, {
    value: linkingContext
  }, /*#__PURE__*/React.createElement(_ThemeProvider.default, {
    value: theme
  }, /*#__PURE__*/React.createElement(_core.BaseNavigationContainer, _extends({}, rest, {
    initialState: rest.initialState == null ? initialState : rest.initialState,
    ref: refContainer
  }))));
}
const NavigationContainer = /*#__PURE__*/React.forwardRef(NavigationContainerInner);
var _default = NavigationContainer;
exports["default"] = _default;
//# sourceMappingURL=NavigationContainer.js.map

/***/ }),

/***/ 43144:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _core = __webpack_require__(93169);
var React = _interopRequireWildcard(__webpack_require__(16689));
var _ServerContext = _interopRequireDefault(__webpack_require__(50019));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
/**
 * Container component for server rendering.
 *
 * @param props.location Location object to base the initial URL for SSR.
 * @param props.children Child elements to render the content.
 * @param props.ref Ref object which contains helper methods.
 */
var _default = /*#__PURE__*/React.forwardRef(function ServerContainer(_ref, ref) {
  let {
    children,
    location
  } = _ref;
  React.useEffect(() => {
    console.error("'ServerContainer' should only be used on the server with 'react-dom/server' for SSR.");
  }, []);
  const current = {};
  if (ref) {
    const value = {
      getCurrentOptions() {
        return current.options;
      }
    };

    // We write to the `ref` during render instead of `React.useImperativeHandle`
    // This is because `useImperativeHandle` will update the ref after 'commit',
    // and there's no 'commit' phase during SSR.
    // Mutating ref during render is unsafe in concurrent mode, but we don't care about it for SSR.
    if (typeof ref === 'function') {
      ref(value);
    } else {
      // @ts-expect-error: the TS types are incorrect and say that ref.current is readonly
      ref.current = value;
    }
  }
  return /*#__PURE__*/React.createElement(_ServerContext.default.Provider, {
    value: {
      location
    }
  }, /*#__PURE__*/React.createElement(_core.CurrentRenderContext.Provider, {
    value: current
  }, children));
});
exports["default"] = _default;
//# sourceMappingURL=ServerContainer.js.map

/***/ }),

/***/ 50019:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var React = _interopRequireWildcard(__webpack_require__(16689));
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
const ServerContext = /*#__PURE__*/React.createContext(undefined);
var _default = ServerContext;
exports["default"] = _default;
//# sourceMappingURL=ServerContext.js.map

/***/ }),

/***/ 35500:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = createMemoryHistory;
var _nonSecure = __webpack_require__(77869);
function createMemoryHistory() {
  let index = 0;
  let items = [];

  // Pending callbacks for `history.go(n)`
  // We might modify the callback stored if it was interrupted, so we have a ref to identify it
  const pending = [];
  const interrupt = () => {
    // If another history operation was performed we need to interrupt existing ones
    // This makes sure that calls such as `history.replace` after `history.go` don't happen
    // Since otherwise it won't be correct if something else has changed
    pending.forEach(it => {
      const cb = it.cb;
      it.cb = () => cb(true);
    });
  };
  const history = {
    get index() {
      var _window$history$state;
      // We store an id in the state instead of an index
      // Index could get out of sync with in-memory values if page reloads
      const id = (_window$history$state = window.history.state) === null || _window$history$state === void 0 ? void 0 : _window$history$state.id;
      if (id) {
        const index = items.findIndex(item => item.id === id);
        return index > -1 ? index : 0;
      }
      return 0;
    },
    get(index) {
      return items[index];
    },
    backIndex(_ref) {
      let {
        path
      } = _ref;
      // We need to find the index from the element before current to get closest path to go back to
      for (let i = index - 1; i >= 0; i--) {
        const item = items[i];
        if (item.path === path) {
          return i;
        }
      }
      return -1;
    },
    push(_ref2) {
      let {
        path,
        state
      } = _ref2;
      interrupt();
      const id = (0, _nonSecure.nanoid)();

      // When a new entry is pushed, all the existing entries after index will be inaccessible
      // So we remove any existing entries after the current index to clean them up
      items = items.slice(0, index + 1);
      items.push({
        path,
        state,
        id
      });
      index = items.length - 1;

      // We pass empty string for title because it's ignored in all browsers except safari
      // We don't store state object in history.state because:
      // - browsers have limits on how big it can be, and we don't control the size
      // - while not recommended, there could be non-serializable data in state
      window.history.pushState({
        id
      }, '', path);
    },
    replace(_ref3) {
      var _window$history$state2;
      let {
        path,
        state
      } = _ref3;
      interrupt();
      const id = ((_window$history$state2 = window.history.state) === null || _window$history$state2 === void 0 ? void 0 : _window$history$state2.id) ?? (0, _nonSecure.nanoid)();

      // Need to keep the hash part of the path if there was no previous history entry
      // or the previous history entry had the same path
      let pathWithHash = path;
      if (!items.length || items.findIndex(item => item.id === id) < 0) {
        // There are two scenarios for creating an array with only one history record:
        // - When loaded id not found in the items array, this function by default will replace
        //   the first item. We need to keep only the new updated object, otherwise it will break
        //   the page when navigating forward in history.
        // - This is the first time any state modifications are done
        //   So we need to push the entry as there's nothing to replace
        pathWithHash = pathWithHash + location.hash;
        items = [{
          path: pathWithHash,
          state,
          id
        }];
        index = 0;
      } else {
        if (items[index].path === path) {
          pathWithHash = pathWithHash + location.hash;
        }
        items[index] = {
          path,
          state,
          id
        };
      }
      window.history.replaceState({
        id
      }, '', pathWithHash);
    },
    // `history.go(n)` is asynchronous, there are couple of things to keep in mind:
    // - it won't do anything if we can't go `n` steps, the `popstate` event won't fire.
    // - each `history.go(n)` call will trigger a separate `popstate` event with correct location.
    // - the `popstate` event fires before the next frame after calling `history.go(n)`.
    // This method differs from `history.go(n)` in the sense that it'll go back as many steps it can.
    go(n) {
      interrupt();

      // To guard against unexpected navigation out of the app we will assume that browser history is only as deep as the length of our memory
      // history. If we don't have an item to navigate to then update our index and navigate as far as we can without taking the user out of the app.
      const nextIndex = index + n;
      const lastItemIndex = items.length - 1;
      if (n < 0 && !items[nextIndex]) {
        // Attempted to navigate beyond the first index. Negating the current index will align the browser history with the first item.
        n = -index;
        index = 0;
      } else if (n > 0 && nextIndex > lastItemIndex) {
        // Attempted to navigate past the last index. Calculate how many indices away from the last index and go there.
        n = lastItemIndex - index;
        index = lastItemIndex;
      } else {
        index = nextIndex;
      }
      if (n === 0) {
        return;
      }

      // When we call `history.go`, `popstate` will fire when there's history to go back to
      // So we need to somehow handle following cases:
      // - There's history to go back, `history.go` is called, and `popstate` fires
      // - `history.go` is called multiple times, we need to resolve on respective `popstate`
      // - No history to go back, but `history.go` was called, browser has no API to detect it
      return new Promise((resolve, reject) => {
        const done = interrupted => {
          clearTimeout(timer);
          if (interrupted) {
            reject(new Error('History was changed during navigation.'));
            return;
          }

          // There seems to be a bug in Chrome regarding updating the title
          // If we set a title just before calling `history.go`, the title gets lost
          // However the value of `document.title` is still what we set it to
          // It's just not displayed in the tab bar
          // To update the tab bar, we need to reset the title to something else first (e.g. '')
          // And set the title to what it was before so it gets applied
          // It won't work without setting it to empty string coz otherwise title isn't changing
          // Which means that the browser won't do anything after setting the title
          const {
            title
          } = window.document;
          window.document.title = '';
          window.document.title = title;
          resolve();
        };
        pending.push({
          ref: done,
          cb: done
        });

        // If navigation didn't happen within 100ms, assume that it won't happen
        // This may not be accurate, but hopefully it won't take so much time
        // In Chrome, navigation seems to happen instantly in next microtask
        // But on Firefox, it seems to take much longer, around 50ms from our testing
        // We're using a hacky timeout since there doesn't seem to be way to know for sure
        const timer = setTimeout(() => {
          const index = pending.findIndex(it => it.ref === done);
          if (index > -1) {
            pending[index].cb();
            pending.splice(index, 1);
          }
        }, 100);
        const onPopState = () => {
          var _window$history$state3;
          const id = (_window$history$state3 = window.history.state) === null || _window$history$state3 === void 0 ? void 0 : _window$history$state3.id;
          const currentIndex = items.findIndex(item => item.id === id);

          // Fix createMemoryHistory.index variable's value
          // as it may go out of sync when navigating in the browser.
          index = Math.max(currentIndex, 0);
          const last = pending.pop();
          window.removeEventListener('popstate', onPopState);
          last === null || last === void 0 ? void 0 : last.cb();
        };
        window.addEventListener('popstate', onPopState);
        window.history.go(n);
      });
    },
    // The `popstate` event is triggered when history changes, except `pushState` and `replaceState`
    // If we call `history.go(n)` ourselves, we don't want it to trigger the listener
    // Here we normalize it so that only external changes (e.g. user pressing back/forward) trigger the listener
    listen(listener) {
      const onPopState = () => {
        if (pending.length) {
          // This was triggered by `history.go(n)`, we shouldn't call the listener
          return;
        }
        listener();
      };
      window.addEventListener('popstate', onPopState);
      return () => window.removeEventListener('popstate', onPopState);
    }
  };
  return history;
}
//# sourceMappingURL=createMemoryHistory.js.map

/***/ }),

/***/ 33779:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
var _exportNames = {
  Link: true,
  LinkingContext: true,
  NavigationContainer: true,
  ServerContainer: true,
  DarkTheme: true,
  DefaultTheme: true,
  ThemeProvider: true,
  useTheme: true,
  useLinkBuilder: true,
  useLinkProps: true,
  useLinkTo: true,
  useScrollToTop: true
};
Object.defineProperty(exports, "DarkTheme", ({
  enumerable: true,
  get: function () {
    return _DarkTheme.default;
  }
}));
Object.defineProperty(exports, "DefaultTheme", ({
  enumerable: true,
  get: function () {
    return _DefaultTheme.default;
  }
}));
Object.defineProperty(exports, "Link", ({
  enumerable: true,
  get: function () {
    return _Link.default;
  }
}));
Object.defineProperty(exports, "LinkingContext", ({
  enumerable: true,
  get: function () {
    return _LinkingContext.default;
  }
}));
Object.defineProperty(exports, "NavigationContainer", ({
  enumerable: true,
  get: function () {
    return _NavigationContainer.default;
  }
}));
Object.defineProperty(exports, "ServerContainer", ({
  enumerable: true,
  get: function () {
    return _ServerContainer.default;
  }
}));
Object.defineProperty(exports, "ThemeProvider", ({
  enumerable: true,
  get: function () {
    return _ThemeProvider.default;
  }
}));
Object.defineProperty(exports, "useLinkBuilder", ({
  enumerable: true,
  get: function () {
    return _useLinkBuilder.default;
  }
}));
Object.defineProperty(exports, "useLinkProps", ({
  enumerable: true,
  get: function () {
    return _useLinkProps.default;
  }
}));
Object.defineProperty(exports, "useLinkTo", ({
  enumerable: true,
  get: function () {
    return _useLinkTo.default;
  }
}));
Object.defineProperty(exports, "useScrollToTop", ({
  enumerable: true,
  get: function () {
    return _useScrollToTop.default;
  }
}));
Object.defineProperty(exports, "useTheme", ({
  enumerable: true,
  get: function () {
    return _useTheme.default;
  }
}));
var _Link = _interopRequireDefault(__webpack_require__(71163));
var _LinkingContext = _interopRequireDefault(__webpack_require__(63079));
var _NavigationContainer = _interopRequireDefault(__webpack_require__(54555));
var _ServerContainer = _interopRequireDefault(__webpack_require__(43144));
var _DarkTheme = _interopRequireDefault(__webpack_require__(44979));
var _DefaultTheme = _interopRequireDefault(__webpack_require__(90858));
var _ThemeProvider = _interopRequireDefault(__webpack_require__(4481));
var _useTheme = _interopRequireDefault(__webpack_require__(60115));
var _types = __webpack_require__(59368);
Object.keys(_types).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _types[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _types[key];
    }
  });
});
var _useLinkBuilder = _interopRequireDefault(__webpack_require__(95355));
var _useLinkProps = _interopRequireDefault(__webpack_require__(29648));
var _useLinkTo = _interopRequireDefault(__webpack_require__(52563));
var _useScrollToTop = _interopRequireDefault(__webpack_require__(22494));
var _core = __webpack_require__(93169);
Object.keys(_core).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _core[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _core[key];
    }
  });
});
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 44979:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
const DarkTheme = {
  dark: true,
  colors: {
    primary: 'rgb(10, 132, 255)',
    background: 'rgb(1, 1, 1)',
    card: 'rgb(18, 18, 18)',
    text: 'rgb(229, 229, 231)',
    border: 'rgb(39, 39, 41)',
    notification: 'rgb(255, 69, 58)'
  }
};
var _default = DarkTheme;
exports["default"] = _default;
//# sourceMappingURL=DarkTheme.js.map

/***/ }),

/***/ 90858:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
const DefaultTheme = {
  dark: false,
  colors: {
    primary: 'rgb(0, 122, 255)',
    background: 'rgb(242, 242, 242)',
    card: 'rgb(255, 255, 255)',
    text: 'rgb(28, 28, 30)',
    border: 'rgb(216, 216, 216)',
    notification: 'rgb(255, 59, 48)'
  }
};
var _default = DefaultTheme;
exports["default"] = _default;
//# sourceMappingURL=DefaultTheme.js.map

/***/ }),

/***/ 38089:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var React = _interopRequireWildcard(__webpack_require__(16689));
var _DefaultTheme = _interopRequireDefault(__webpack_require__(90858));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
const ThemeContext = /*#__PURE__*/React.createContext(_DefaultTheme.default);
ThemeContext.displayName = 'ThemeContext';
var _default = ThemeContext;
exports["default"] = _default;
//# sourceMappingURL=ThemeContext.js.map

/***/ }),

/***/ 4481:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = ThemeProvider;
var React = _interopRequireWildcard(__webpack_require__(16689));
var _ThemeContext = _interopRequireDefault(__webpack_require__(38089));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function ThemeProvider(_ref) {
  let {
    value,
    children
  } = _ref;
  return /*#__PURE__*/React.createElement(_ThemeContext.default.Provider, {
    value: value
  }, children);
}
//# sourceMappingURL=ThemeProvider.js.map

/***/ }),

/***/ 60115:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = useTheme;
var React = _interopRequireWildcard(__webpack_require__(16689));
var _ThemeContext = _interopRequireDefault(__webpack_require__(38089));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function useTheme() {
  const theme = React.useContext(_ThemeContext.default);
  return theme;
}
//# sourceMappingURL=useTheme.js.map

/***/ }),

/***/ 59368:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
//# sourceMappingURL=types.js.map

/***/ }),

/***/ 76183:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = useBackButton;
var React = _interopRequireWildcard(__webpack_require__(16689));
var _reactNative = __webpack_require__(83849);
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function useBackButton(ref) {
  React.useEffect(() => {
    const subscription = _reactNative.BackHandler.addEventListener('hardwareBackPress', () => {
      const navigation = ref.current;
      if (navigation == null) {
        return false;
      }
      if (navigation.canGoBack()) {
        navigation.goBack();
        return true;
      }
      return false;
    });
    return () => subscription.remove();
  }, [ref]);
}
//# sourceMappingURL=useBackButton.js.map

/***/ }),

/***/ 16848:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = useDocumentTitle;
var React = _interopRequireWildcard(__webpack_require__(16689));
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
/**
 * Set the document title for the active screen
 */
function useDocumentTitle(ref) {
  let {
    enabled = true,
    formatter = (options, route) => (options === null || options === void 0 ? void 0 : options.title) ?? (route === null || route === void 0 ? void 0 : route.name)
  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  React.useEffect(() => {
    if (!enabled) {
      return;
    }
    const navigation = ref.current;
    if (navigation) {
      const title = formatter(navigation.getCurrentOptions(), navigation.getCurrentRoute());
      document.title = title;
    }
    return navigation === null || navigation === void 0 ? void 0 : navigation.addListener('options', e => {
      const title = formatter(e.data.options, navigation === null || navigation === void 0 ? void 0 : navigation.getCurrentRoute());
      document.title = title;
    });
  });
}
//# sourceMappingURL=useDocumentTitle.js.map

/***/ }),

/***/ 95355:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = useLinkBuilder;
var _core = __webpack_require__(93169);
var React = _interopRequireWildcard(__webpack_require__(16689));
var _LinkingContext = _interopRequireDefault(__webpack_require__(63079));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
const getRootStateForNavigate = (navigation, state) => {
  const parent = navigation.getParent();
  if (parent) {
    const parentState = parent.getState();
    return getRootStateForNavigate(parent, {
      index: 0,
      routes: [{
        ...parentState.routes[parentState.index],
        state: state
      }]
    });
  }
  return state;
};

/**
 * Build destination link for a navigate action.
 * Useful for showing anchor tags on the web for buttons that perform navigation.
 */
function useLinkBuilder() {
  const navigation = React.useContext(_core.NavigationHelpersContext);
  const linking = React.useContext(_LinkingContext.default);
  const buildLink = React.useCallback((name, params) => {
    const {
      options
    } = linking;
    if ((options === null || options === void 0 ? void 0 : options.enabled) === false) {
      return undefined;
    }
    const state = navigation ? getRootStateForNavigate(navigation, {
      index: 0,
      routes: [{
        name,
        params
      }]
    }) :
    // If we couldn't find a navigation object in context, we're at root
    // So we'll construct a basic state object to use
    {
      index: 0,
      routes: [{
        name,
        params
      }]
    };
    const path = options !== null && options !== void 0 && options.getPathFromState ? options.getPathFromState(state, options === null || options === void 0 ? void 0 : options.config) : (0, _core.getPathFromState)(state, options === null || options === void 0 ? void 0 : options.config);
    return path;
  }, [linking, navigation]);
  return buildLink;
}
//# sourceMappingURL=useLinkBuilder.js.map

/***/ }),

/***/ 29648:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = useLinkProps;
var _core = __webpack_require__(93169);
var React = _interopRequireWildcard(__webpack_require__(16689));
var _reactNative = __webpack_require__(83849);
var _LinkingContext = _interopRequireDefault(__webpack_require__(63079));
var _useLinkTo = _interopRequireDefault(__webpack_require__(52563));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
const getStateFromParams = params => {
  if (params !== null && params !== void 0 && params.state) {
    return params.state;
  }
  if (params !== null && params !== void 0 && params.screen) {
    return {
      routes: [{
        name: params.screen,
        params: params.params,
        // @ts-expect-error
        state: params.screen ? getStateFromParams(params.params) : undefined
      }]
    };
  }
  return undefined;
};

/**
 * Hook to get props for an anchor tag so it can work with in page navigation.
 *
 * @param props.to Absolute path to screen (e.g. `/feeds/hot`).
 * @param props.action Optional action to use for in-page navigation. By default, the path is parsed to an action based on linking config.
 */
function useLinkProps(_ref) {
  let {
    to,
    action
  } = _ref;
  const root = React.useContext(_core.NavigationContainerRefContext);
  const navigation = React.useContext(_core.NavigationHelpersContext);
  const {
    options
  } = React.useContext(_LinkingContext.default);
  const linkTo = (0, _useLinkTo.default)();
  const onPress = e => {
    var _e$currentTarget;
    let shouldHandle = false;
    if (_reactNative.Platform.OS !== 'web' || !e) {
      shouldHandle = e ? !e.defaultPrevented : true;
    } else if (!e.defaultPrevented &&
    // onPress prevented default
    // @ts-expect-error: these properties exist on web, but not in React Native
    !(e.metaKey || e.altKey || e.ctrlKey || e.shiftKey) && (
    // ignore clicks with modifier keys
    // @ts-expect-error: these properties exist on web, but not in React Native
    e.button == null || e.button === 0) &&
    // ignore everything but left clicks
    // @ts-expect-error: these properties exist on web, but not in React Native
    [undefined, null, '', 'self'].includes((_e$currentTarget = e.currentTarget) === null || _e$currentTarget === void 0 ? void 0 : _e$currentTarget.target) // let browser handle "target=_blank" etc.
    ) {
      e.preventDefault();
      shouldHandle = true;
    }
    if (shouldHandle) {
      if (action) {
        if (navigation) {
          navigation.dispatch(action);
        } else if (root) {
          root.dispatch(action);
        } else {
          throw new Error("Couldn't find a navigation object. Is your component inside NavigationContainer?");
        }
      } else {
        linkTo(to);
      }
    }
  };
  const getPathFromStateHelper = (options === null || options === void 0 ? void 0 : options.getPathFromState) ?? _core.getPathFromState;
  const href = typeof to === 'string' ? to : getPathFromStateHelper({
    routes: [{
      name: to.screen,
      // @ts-expect-error
      params: to.params,
      // @ts-expect-error
      state: getStateFromParams(to.params)
    }]
  }, options === null || options === void 0 ? void 0 : options.config);
  return {
    href,
    accessibilityRole: 'link',
    onPress
  };
}
//# sourceMappingURL=useLinkProps.js.map

/***/ }),

/***/ 52563:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = useLinkTo;
var _core = __webpack_require__(93169);
var React = _interopRequireWildcard(__webpack_require__(16689));
var _LinkingContext = _interopRequireDefault(__webpack_require__(63079));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function useLinkTo() {
  const navigation = React.useContext(_core.NavigationContainerRefContext);
  const linking = React.useContext(_LinkingContext.default);
  const linkTo = React.useCallback(to => {
    if (navigation === undefined) {
      throw new Error("Couldn't find a navigation object. Is your component inside NavigationContainer?");
    }
    if (typeof to !== 'string') {
      // @ts-expect-error: This is fine
      navigation.navigate(to.screen, to.params);
      return;
    }
    if (!to.startsWith('/')) {
      throw new Error(`The path must start with '/' (${to}).`);
    }
    const {
      options
    } = linking;
    const state = options !== null && options !== void 0 && options.getStateFromPath ? options.getStateFromPath(to, options.config) : (0, _core.getStateFromPath)(to, options === null || options === void 0 ? void 0 : options.config);
    if (state) {
      const action = (0, _core.getActionFromState)(state, options === null || options === void 0 ? void 0 : options.config);
      if (action !== undefined) {
        navigation.dispatch(action);
      } else {
        navigation.reset(state);
      }
    } else {
      throw new Error('Failed to parse the path to a navigation state.');
    }
  }, [linking, navigation]);
  return linkTo;
}
//# sourceMappingURL=useLinkTo.js.map

/***/ }),

/***/ 57352:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = useLinking;
var _core = __webpack_require__(93169);
var _fastDeepEqual = _interopRequireDefault(__webpack_require__(12404));
var React = _interopRequireWildcard(__webpack_require__(16689));
var _createMemoryHistory = _interopRequireDefault(__webpack_require__(35500));
var _ServerContext = _interopRequireDefault(__webpack_require__(50019));
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
/**
 * Find the matching navigation state that changed between 2 navigation states
 * e.g.: a -> b -> c -> d and a -> b -> c -> e -> f, if history in b changed, b is the matching state
 */
const findMatchingState = (a, b) => {
  if (a === undefined || b === undefined || a.key !== b.key) {
    return [undefined, undefined];
  }

  // Tab and drawer will have `history` property, but stack will have history in `routes`
  const aHistoryLength = a.history ? a.history.length : a.routes.length;
  const bHistoryLength = b.history ? b.history.length : b.routes.length;
  const aRoute = a.routes[a.index];
  const bRoute = b.routes[b.index];
  const aChildState = aRoute.state;
  const bChildState = bRoute.state;

  // Stop here if this is the state object that changed:
  // - history length is different
  // - focused routes are different
  // - one of them doesn't have child state
  // - child state keys are different
  if (aHistoryLength !== bHistoryLength || aRoute.key !== bRoute.key || aChildState === undefined || bChildState === undefined || aChildState.key !== bChildState.key) {
    return [a, b];
  }
  return findMatchingState(aChildState, bChildState);
};

/**
 * Run async function in series as it's called.
 */
const series = cb => {
  // Whether we're currently handling a callback
  let handling = false;
  let queue = [];
  const callback = async () => {
    try {
      if (handling) {
        // If we're currently handling a previous event, wait before handling this one
        // Add the callback to the beginning of the queue
        queue.unshift(callback);
        return;
      }
      handling = true;
      await cb();
    } finally {
      handling = false;
      if (queue.length) {
        // If we have queued items, handle the last one
        const last = queue.pop();
        last === null || last === void 0 ? void 0 : last();
      }
    }
  };
  return callback;
};
let linkingHandlers = [];
function useLinking(ref, _ref) {
  let {
    independent,
    enabled = true,
    config,
    getStateFromPath = _core.getStateFromPath,
    getPathFromState = _core.getPathFromState,
    getActionFromState = _core.getActionFromState
  } = _ref;
  React.useEffect(() => {
    if (true) {
      return undefined;
    }
    if (independent) {
      return undefined;
    }
    if (enabled !== false && linkingHandlers.length) {
      console.error(['Looks like you have configured linking in multiple places. This is likely an error since deep links should only be handled in one place to avoid conflicts. Make sure that:', "- You don't have multiple NavigationContainers in the app each with 'linking' enabled", '- Only a single instance of the root component is rendered'].join('\n').trim());
    }
    const handler = Symbol();
    if (enabled !== false) {
      linkingHandlers.push(handler);
    }
    return () => {
      const index = linkingHandlers.indexOf(handler);
      if (index > -1) {
        linkingHandlers.splice(index, 1);
      }
    };
  }, [enabled, independent]);
  const [history] = React.useState(_createMemoryHistory.default);

  // We store these options in ref to avoid re-creating getInitialState and re-subscribing listeners
  // This lets user avoid wrapping the items in `React.useCallback` or `React.useMemo`
  // Not re-creating `getInitialState` is important coz it makes it easier for the user to use in an effect
  const enabledRef = React.useRef(enabled);
  const configRef = React.useRef(config);
  const getStateFromPathRef = React.useRef(getStateFromPath);
  const getPathFromStateRef = React.useRef(getPathFromState);
  const getActionFromStateRef = React.useRef(getActionFromState);
  React.useEffect(() => {
    enabledRef.current = enabled;
    configRef.current = config;
    getStateFromPathRef.current = getStateFromPath;
    getPathFromStateRef.current = getPathFromState;
    getActionFromStateRef.current = getActionFromState;
  });
  const server = React.useContext(_ServerContext.default);
  const getInitialState = React.useCallback(() => {
    let value;
    if (enabledRef.current) {
      const location = (server === null || server === void 0 ? void 0 : server.location) ?? (typeof window !== 'undefined' ? window.location : undefined);
      const path = location ? location.pathname + location.search : undefined;
      if (path) {
        value = getStateFromPathRef.current(path, configRef.current);
      }
    }
    const thenable = {
      then(onfulfilled) {
        return Promise.resolve(onfulfilled ? onfulfilled(value) : value);
      },
      catch() {
        return thenable;
      }
    };
    return thenable;
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);
  const previousIndexRef = React.useRef(undefined);
  const previousStateRef = React.useRef(undefined);
  const pendingPopStatePathRef = React.useRef(undefined);
  React.useEffect(() => {
    previousIndexRef.current = history.index;
    return history.listen(() => {
      const navigation = ref.current;
      if (!navigation || !enabled) {
        return;
      }
      const path = location.pathname + location.search;
      const index = history.index;
      const previousIndex = previousIndexRef.current ?? 0;
      previousIndexRef.current = index;
      pendingPopStatePathRef.current = path;

      // When browser back/forward is clicked, we first need to check if state object for this index exists
      // If it does we'll reset to that state object
      // Otherwise, we'll handle it like a regular deep link
      const record = history.get(index);
      if ((record === null || record === void 0 ? void 0 : record.path) === path && record !== null && record !== void 0 && record.state) {
        navigation.resetRoot(record.state);
        return;
      }
      const state = getStateFromPathRef.current(path, configRef.current);

      // We should only dispatch an action when going forward
      // Otherwise the action will likely add items to history, which would mess things up
      if (state) {
        // Make sure that the routes in the state exist in the root navigator
        // Otherwise there's an error in the linking configuration
        const rootState = navigation.getRootState();
        if (state.routes.some(r => !(rootState !== null && rootState !== void 0 && rootState.routeNames.includes(r.name)))) {
          console.warn("The navigation state parsed from the URL contains routes not present in the root navigator. This usually means that the linking configuration doesn't match the navigation structure. See https://reactnavigation.org/docs/configuring-links for more details on how to specify a linking configuration.");
          return;
        }
        if (index > previousIndex) {
          const action = getActionFromStateRef.current(state, configRef.current);
          if (action !== undefined) {
            try {
              navigation.dispatch(action);
            } catch (e) {
              // Ignore any errors from deep linking.
              // This could happen in case of malformed links, navigation object not being initialized etc.
              console.warn(`An error occurred when trying to handle the link '${path}': ${typeof e === 'object' && e != null && 'message' in e ? e.message : e}`);
            }
          } else {
            navigation.resetRoot(state);
          }
        } else {
          navigation.resetRoot(state);
        }
      } else {
        // if current path didn't return any state, we should revert to initial state
        navigation.resetRoot(state);
      }
    });
  }, [enabled, history, ref]);
  React.useEffect(() => {
    var _ref$current;
    if (!enabled) {
      return;
    }
    const getPathForRoute = (route, state) => {
      // If the `route` object contains a `path`, use that path as long as `route.name` and `params` still match
      // This makes sure that we preserve the original URL for wildcard routes
      if (route !== null && route !== void 0 && route.path) {
        const stateForPath = getStateFromPathRef.current(route.path, configRef.current);
        if (stateForPath) {
          const focusedRoute = (0, _core.findFocusedRoute)(stateForPath);
          if (focusedRoute && focusedRoute.name === route.name && (0, _fastDeepEqual.default)(focusedRoute.params, route.params)) {
            return route.path;
          }
        }
      }
      return getPathFromStateRef.current(state, configRef.current);
    };
    if (ref.current) {
      // We need to record the current metadata on the first render if they aren't set
      // This will allow the initial state to be in the history entry
      const state = ref.current.getRootState();
      if (state) {
        const route = (0, _core.findFocusedRoute)(state);
        const path = getPathForRoute(route, state);
        if (previousStateRef.current === undefined) {
          previousStateRef.current = state;
        }
        history.replace({
          path,
          state
        });
      }
    }
    const onStateChange = async () => {
      const navigation = ref.current;
      if (!navigation || !enabled) {
        return;
      }
      const previousState = previousStateRef.current;
      const state = navigation.getRootState();

      // root state may not available, for example when root navigators switch inside the container
      if (!state) {
        return;
      }
      const pendingPath = pendingPopStatePathRef.current;
      const route = (0, _core.findFocusedRoute)(state);
      const path = getPathForRoute(route, state);
      previousStateRef.current = state;
      pendingPopStatePathRef.current = undefined;

      // To detect the kind of state change, we need to:
      // - Find the common focused navigation state in previous and current state
      // - If only the route keys changed, compare history/routes.length to check if we go back/forward/replace
      // - If no common focused navigation state found, it's a replace
      const [previousFocusedState, focusedState] = findMatchingState(previousState, state);
      if (previousFocusedState && focusedState &&
      // We should only handle push/pop if path changed from what was in last `popstate`
      // Otherwise it's likely a change triggered by `popstate`
      path !== pendingPath) {
        const historyDelta = (focusedState.history ? focusedState.history.length : focusedState.routes.length) - (previousFocusedState.history ? previousFocusedState.history.length : previousFocusedState.routes.length);
        if (historyDelta > 0) {
          // If history length is increased, we should pushState
          // Note that path might not actually change here, for example, drawer open should pushState
          history.push({
            path,
            state
          });
        } else if (historyDelta < 0) {
          // If history length is decreased, i.e. entries were removed, we want to go back

          const nextIndex = history.backIndex({
            path
          });
          const currentIndex = history.index;
          try {
            if (nextIndex !== -1 && nextIndex < currentIndex) {
              // An existing entry for this path exists and it's less than current index, go back to that
              await history.go(nextIndex - currentIndex);
            } else {
              // We couldn't find an existing entry to go back to, so we'll go back by the delta
              // This won't be correct if multiple routes were pushed in one go before
              // Usually this shouldn't happen and this is a fallback for that
              await history.go(historyDelta);
            }

            // Store the updated state as well as fix the path if incorrect
            history.replace({
              path,
              state
            });
          } catch (e) {
            // The navigation was interrupted
          }
        } else {
          // If history length is unchanged, we want to replaceState
          history.replace({
            path,
            state
          });
        }
      } else {
        // If no common navigation state was found, assume it's a replace
        // This would happen if the user did a reset/conditionally changed navigators
        history.replace({
          path,
          state
        });
      }
    };

    // We debounce onStateChange coz we don't want multiple state changes to be handled at one time
    // This could happen since `history.go(n)` is asynchronous
    // If `pushState` or `replaceState` were called before `history.go(n)` completes, it'll mess stuff up
    return (_ref$current = ref.current) === null || _ref$current === void 0 ? void 0 : _ref$current.addListener('state', series(onStateChange));
  }, [enabled, history, ref]);
  return {
    getInitialState
  };
}
//# sourceMappingURL=useLinking.js.map

/***/ }),

/***/ 22494:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = useScrollToTop;
var _core = __webpack_require__(93169);
var React = _interopRequireWildcard(__webpack_require__(16689));
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function getScrollableNode(ref) {
  if (ref.current == null) {
    return null;
  }
  if ('scrollToTop' in ref.current || 'scrollTo' in ref.current || 'scrollToOffset' in ref.current || 'scrollResponderScrollTo' in ref.current) {
    // This is already a scrollable node.
    return ref.current;
  } else if ('getScrollResponder' in ref.current) {
    // If the view is a wrapper like FlatList, SectionList etc.
    // We need to use `getScrollResponder` to get access to the scroll responder
    return ref.current.getScrollResponder();
  } else if ('getNode' in ref.current) {
    // When a `ScrollView` is wraped in `Animated.createAnimatedComponent`
    // we need to use `getNode` to get the ref to the actual scrollview.
    // Note that `getNode` is deprecated in newer versions of react-native
    // this is why we check if we already have a scrollable node above.
    return ref.current.getNode();
  } else {
    return ref.current;
  }
}
function useScrollToTop(ref) {
  const navigation = (0, _core.useNavigation)();
  const route = (0, _core.useRoute)();
  React.useEffect(() => {
    let tabNavigations = [];
    let currentNavigation = navigation;

    // If the screen is nested inside multiple tab navigators, we should scroll to top for any of them
    // So we need to find all the parent tab navigators and add the listeners there
    while (currentNavigation) {
      if (currentNavigation.getState().type === 'tab') {
        tabNavigations.push(currentNavigation);
      }
      currentNavigation = currentNavigation.getParent();
    }
    if (tabNavigations.length === 0) {
      return;
    }
    const unsubscribers = tabNavigations.map(tab => {
      return tab.addListener(
      // We don't wanna import tab types here to avoid extra deps
      // in addition, there are multiple tab implementations
      // @ts-expect-error
      'tabPress', e => {
        // We should scroll to top only when the screen is focused
        const isFocused = navigation.isFocused();

        // In a nested stack navigator, tab press resets the stack to first screen
        // So we should scroll to top only when we are on first screen
        const isFirst = tabNavigations.includes(navigation) || navigation.getState().routes[0].key === route.key;

        // Run the operation in the next frame so we're sure all listeners have been run
        // This is necessary to know if preventDefault() has been called
        requestAnimationFrame(() => {
          const scrollable = getScrollableNode(ref);
          if (isFocused && isFirst && scrollable && !e.defaultPrevented) {
            if ('scrollToTop' in scrollable) {
              scrollable.scrollToTop();
            } else if ('scrollTo' in scrollable) {
              scrollable.scrollTo({
                y: 0,
                animated: true
              });
            } else if ('scrollToOffset' in scrollable) {
              scrollable.scrollToOffset({
                offset: 0,
                animated: true
              });
            } else if ('scrollResponderScrollTo' in scrollable) {
              scrollable.scrollResponderScrollTo({
                y: 0,
                animated: true
              });
            }
          }
        });
      });
    });
    return () => {
      unsubscribers.forEach(unsubscribe => unsubscribe());
    };
  }, [navigation, ref, route.key]);
}
//# sourceMappingURL=useScrollToTop.js.map

/***/ }),

/***/ 42078:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = useThenable;
var React = _interopRequireWildcard(__webpack_require__(16689));
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function useThenable(create) {
  const [promise] = React.useState(create);
  let initialState = [false, undefined];

  // Check if our thenable is synchronous
  promise.then(result => {
    initialState = [true, result];
  });
  const [state, setState] = React.useState(initialState);
  const [resolved] = state;
  React.useEffect(() => {
    let cancelled = false;
    const resolve = async () => {
      let result;
      try {
        result = await promise;
      } finally {
        if (!cancelled) {
          setState([true, result]);
        }
      }
    };
    if (!resolved) {
      resolve();
    }
    return () => {
      cancelled = true;
    };
  }, [promise, resolved]);
  return state;
}
//# sourceMappingURL=useThenable.js.map

/***/ }),

/***/ 67763:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _nonSecure = __webpack_require__(77869);
/**
 * Base router object that can be used when writing custom routers.
 * This provides few helper methods to handle common actions such as `RESET`.
 */
const BaseRouter = {
  getStateForAction(state, action) {
    switch (action.type) {
      case 'SET_PARAMS':
        {
          const index = action.source ? state.routes.findIndex(r => r.key === action.source) : state.index;
          if (index === -1) {
            return null;
          }
          return {
            ...state,
            routes: state.routes.map((r, i) => i === index ? {
              ...r,
              params: {
                ...r.params,
                ...action.payload.params
              }
            } : r)
          };
        }
      case 'RESET':
        {
          const nextState = action.payload;
          if (nextState.routes.length === 0 || nextState.routes.some(route => !state.routeNames.includes(route.name))) {
            return null;
          }
          if (nextState.stale === false) {
            if (state.routeNames.length !== nextState.routeNames.length || nextState.routeNames.some(name => !state.routeNames.includes(name))) {
              return null;
            }
            return {
              ...nextState,
              routes: nextState.routes.map(route => route.key ? route : {
                ...route,
                key: `${route.name}-${(0, _nonSecure.nanoid)()}`
              })
            };
          }
          return nextState;
        }
      default:
        return null;
    }
  },
  shouldActionChangeFocus(action) {
    return action.type === 'NAVIGATE';
  }
};
var _default = BaseRouter;
exports["default"] = _default;
//# sourceMappingURL=BaseRouter.js.map

/***/ }),

/***/ 33153:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.goBack = goBack;
exports.navigate = navigate;
exports.reset = reset;
exports.setParams = setParams;
function goBack() {
  return {
    type: 'GO_BACK'
  };
}
// eslint-disable-next-line no-redeclare
function navigate() {
  if (typeof (arguments.length <= 0 ? undefined : arguments[0]) === 'string') {
    return {
      type: 'NAVIGATE',
      payload: {
        name: arguments.length <= 0 ? undefined : arguments[0],
        params: arguments.length <= 1 ? undefined : arguments[1]
      }
    };
  } else {
    const payload = (arguments.length <= 0 ? undefined : arguments[0]) || {};
    if (!payload.hasOwnProperty('key') && !payload.hasOwnProperty('name')) {
      throw new Error('You need to specify name or key when calling navigate with an object as the argument. See https://reactnavigation.org/docs/navigation-actions#navigate for usage.');
    }
    return {
      type: 'NAVIGATE',
      payload
    };
  }
}
function reset(state) {
  return {
    type: 'RESET',
    payload: state
  };
}
function setParams(params) {
  return {
    type: 'SET_PARAMS',
    payload: {
      params
    }
  };
}
//# sourceMappingURL=CommonActions.js.map

/***/ }),

/***/ 16443:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.DrawerActions = void 0;
exports["default"] = DrawerRouter;
var _nonSecure = __webpack_require__(77869);
var _TabRouter = _interopRequireWildcard(__webpack_require__(70493));
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
const DrawerActions = {
  ..._TabRouter.TabActions,
  openDrawer() {
    return {
      type: 'OPEN_DRAWER'
    };
  },
  closeDrawer() {
    return {
      type: 'CLOSE_DRAWER'
    };
  },
  toggleDrawer() {
    return {
      type: 'TOGGLE_DRAWER'
    };
  }
};
exports.DrawerActions = DrawerActions;
function DrawerRouter(_ref) {
  let {
    defaultStatus = 'closed',
    ...rest
  } = _ref;
  const router = (0, _TabRouter.default)(rest);
  const isDrawerInHistory = state => {
    var _state$history;
    return Boolean((_state$history = state.history) === null || _state$history === void 0 ? void 0 : _state$history.some(it => it.type === 'drawer'));
  };
  const addDrawerToHistory = state => {
    if (isDrawerInHistory(state)) {
      return state;
    }
    return {
      ...state,
      history: [...state.history, {
        type: 'drawer',
        status: defaultStatus === 'open' ? 'closed' : 'open'
      }]
    };
  };
  const removeDrawerFromHistory = state => {
    if (!isDrawerInHistory(state)) {
      return state;
    }
    return {
      ...state,
      history: state.history.filter(it => it.type !== 'drawer')
    };
  };
  const openDrawer = state => {
    if (defaultStatus === 'open') {
      return removeDrawerFromHistory(state);
    }
    return addDrawerToHistory(state);
  };
  const closeDrawer = state => {
    if (defaultStatus === 'open') {
      return addDrawerToHistory(state);
    }
    return removeDrawerFromHistory(state);
  };
  return {
    ...router,
    type: 'drawer',
    getInitialState(_ref2) {
      let {
        routeNames,
        routeParamList,
        routeGetIdList
      } = _ref2;
      const state = router.getInitialState({
        routeNames,
        routeParamList,
        routeGetIdList
      });
      return {
        ...state,
        default: defaultStatus,
        stale: false,
        type: 'drawer',
        key: `drawer-${(0, _nonSecure.nanoid)()}`
      };
    },
    getRehydratedState(partialState, _ref3) {
      let {
        routeNames,
        routeParamList,
        routeGetIdList
      } = _ref3;
      if (partialState.stale === false) {
        return partialState;
      }
      let state = router.getRehydratedState(partialState, {
        routeNames,
        routeParamList,
        routeGetIdList
      });
      if (isDrawerInHistory(partialState)) {
        // Re-sync the drawer entry in history to correct it if it was wrong
        state = removeDrawerFromHistory(state);
        state = addDrawerToHistory(state);
      }
      return {
        ...state,
        default: defaultStatus,
        type: 'drawer',
        key: `drawer-${(0, _nonSecure.nanoid)()}`
      };
    },
    getStateForRouteFocus(state, key) {
      const result = router.getStateForRouteFocus(state, key);
      return closeDrawer(result);
    },
    getStateForAction(state, action, options) {
      switch (action.type) {
        case 'OPEN_DRAWER':
          return openDrawer(state);
        case 'CLOSE_DRAWER':
          return closeDrawer(state);
        case 'TOGGLE_DRAWER':
          if (isDrawerInHistory(state)) {
            return removeDrawerFromHistory(state);
          }
          return addDrawerToHistory(state);
        case 'JUMP_TO':
        case 'NAVIGATE':
          {
            const result = router.getStateForAction(state, action, options);
            if (result != null && result.index !== state.index) {
              return closeDrawer(result);
            }
            return result;
          }
        case 'GO_BACK':
          if (isDrawerInHistory(state)) {
            return removeDrawerFromHistory(state);
          }
          return router.getStateForAction(state, action, options);
        default:
          return router.getStateForAction(state, action, options);
      }
    },
    actionCreators: DrawerActions
  };
}
//# sourceMappingURL=DrawerRouter.js.map

/***/ }),

/***/ 41330:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.StackActions = void 0;
exports["default"] = StackRouter;
var _nonSecure = __webpack_require__(77869);
var _BaseRouter = _interopRequireDefault(__webpack_require__(67763));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const StackActions = {
  replace(name, params) {
    return {
      type: 'REPLACE',
      payload: {
        name,
        params
      }
    };
  },
  push(name, params) {
    return {
      type: 'PUSH',
      payload: {
        name,
        params
      }
    };
  },
  pop() {
    let count = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
    return {
      type: 'POP',
      payload: {
        count
      }
    };
  },
  popToTop() {
    return {
      type: 'POP_TO_TOP'
    };
  }
};
exports.StackActions = StackActions;
function StackRouter(options) {
  const router = {
    ..._BaseRouter.default,
    type: 'stack',
    getInitialState(_ref) {
      let {
        routeNames,
        routeParamList
      } = _ref;
      const initialRouteName = options.initialRouteName !== undefined && routeNames.includes(options.initialRouteName) ? options.initialRouteName : routeNames[0];
      return {
        stale: false,
        type: 'stack',
        key: `stack-${(0, _nonSecure.nanoid)()}`,
        index: 0,
        routeNames,
        routes: [{
          key: `${initialRouteName}-${(0, _nonSecure.nanoid)()}`,
          name: initialRouteName,
          params: routeParamList[initialRouteName]
        }]
      };
    },
    getRehydratedState(partialState, _ref2) {
      let {
        routeNames,
        routeParamList
      } = _ref2;
      let state = partialState;
      if (state.stale === false) {
        return state;
      }
      const routes = state.routes.filter(route => routeNames.includes(route.name)).map(route => ({
        ...route,
        key: route.key || `${route.name}-${(0, _nonSecure.nanoid)()}`,
        params: routeParamList[route.name] !== undefined ? {
          ...routeParamList[route.name],
          ...route.params
        } : route.params
      }));
      if (routes.length === 0) {
        const initialRouteName = options.initialRouteName !== undefined ? options.initialRouteName : routeNames[0];
        routes.push({
          key: `${initialRouteName}-${(0, _nonSecure.nanoid)()}`,
          name: initialRouteName,
          params: routeParamList[initialRouteName]
        });
      }
      return {
        stale: false,
        type: 'stack',
        key: `stack-${(0, _nonSecure.nanoid)()}`,
        index: routes.length - 1,
        routeNames,
        routes
      };
    },
    getStateForRouteNamesChange(state, _ref3) {
      let {
        routeNames,
        routeParamList,
        routeKeyChanges
      } = _ref3;
      const routes = state.routes.filter(route => routeNames.includes(route.name) && !routeKeyChanges.includes(route.name));
      if (routes.length === 0) {
        const initialRouteName = options.initialRouteName !== undefined && routeNames.includes(options.initialRouteName) ? options.initialRouteName : routeNames[0];
        routes.push({
          key: `${initialRouteName}-${(0, _nonSecure.nanoid)()}`,
          name: initialRouteName,
          params: routeParamList[initialRouteName]
        });
      }
      return {
        ...state,
        routeNames,
        routes,
        index: Math.min(state.index, routes.length - 1)
      };
    },
    getStateForRouteFocus(state, key) {
      const index = state.routes.findIndex(r => r.key === key);
      if (index === -1 || index === state.index) {
        return state;
      }
      return {
        ...state,
        index,
        routes: state.routes.slice(0, index + 1)
      };
    },
    getStateForAction(state, action, options) {
      const {
        routeParamList
      } = options;
      switch (action.type) {
        case 'REPLACE':
          {
            const index = action.target === state.key && action.source ? state.routes.findIndex(r => r.key === action.source) : state.index;
            if (index === -1) {
              return null;
            }
            const {
              name,
              key,
              params
            } = action.payload;
            if (!state.routeNames.includes(name)) {
              return null;
            }
            return {
              ...state,
              routes: state.routes.map((route, i) => i === index ? {
                key: key !== undefined ? key : `${name}-${(0, _nonSecure.nanoid)()}`,
                name,
                params: routeParamList[name] !== undefined ? {
                  ...routeParamList[name],
                  ...params
                } : params
              } : route)
            };
          }
        case 'PUSH':
          if (state.routeNames.includes(action.payload.name)) {
            const getId = options.routeGetIdList[action.payload.name];
            const id = getId === null || getId === void 0 ? void 0 : getId({
              params: action.payload.params
            });
            const route = id ? state.routes.find(route => route.name === action.payload.name && id === (getId === null || getId === void 0 ? void 0 : getId({
              params: route.params
            }))) : undefined;
            let routes;
            if (route) {
              routes = state.routes.filter(r => r.key !== route.key);
              routes.push({
                ...route,
                params: routeParamList[action.payload.name] !== undefined ? {
                  ...routeParamList[action.payload.name],
                  ...action.payload.params
                } : action.payload.params
              });
            } else {
              routes = [...state.routes, {
                key: `${action.payload.name}-${(0, _nonSecure.nanoid)()}`,
                name: action.payload.name,
                params: routeParamList[action.payload.name] !== undefined ? {
                  ...routeParamList[action.payload.name],
                  ...action.payload.params
                } : action.payload.params
              }];
            }
            return {
              ...state,
              index: routes.length - 1,
              routes
            };
          }
          return null;
        case 'POP':
          {
            const index = action.target === state.key && action.source ? state.routes.findIndex(r => r.key === action.source) : state.index;
            if (index > 0) {
              const count = Math.max(index - action.payload.count + 1, 1);
              const routes = state.routes.slice(0, count).concat(state.routes.slice(index + 1));
              return {
                ...state,
                index: routes.length - 1,
                routes
              };
            }
            return null;
          }
        case 'POP_TO_TOP':
          return router.getStateForAction(state, {
            type: 'POP',
            payload: {
              count: state.routes.length - 1
            }
          }, options);
        case 'NAVIGATE':
          if (action.payload.name !== undefined && !state.routeNames.includes(action.payload.name)) {
            return null;
          }
          if (action.payload.key || action.payload.name) {
            // If the route already exists, navigate to that
            let index = -1;
            const getId =
            // `getId` and `key` can't be used together
            action.payload.key === undefined && action.payload.name !== undefined ? options.routeGetIdList[action.payload.name] : undefined;
            const id = getId === null || getId === void 0 ? void 0 : getId({
              params: action.payload.params
            });
            if (id) {
              index = state.routes.findIndex(route => route.name === action.payload.name && id === (getId === null || getId === void 0 ? void 0 : getId({
                params: route.params
              })));
            } else if (state.routes[state.index].name === action.payload.name && action.payload.key === undefined || state.routes[state.index].key === action.payload.key) {
              index = state.index;
            } else {
              for (let i = state.routes.length - 1; i >= 0; i--) {
                if (state.routes[i].name === action.payload.name && action.payload.key === undefined || state.routes[i].key === action.payload.key) {
                  index = i;
                  break;
                }
              }
            }
            if (index === -1 && action.payload.key && action.payload.name === undefined) {
              return null;
            }
            if (index === -1 && action.payload.name !== undefined) {
              const routes = [...state.routes, {
                key: action.payload.key ?? `${action.payload.name}-${(0, _nonSecure.nanoid)()}`,
                name: action.payload.name,
                path: action.payload.path,
                params: routeParamList[action.payload.name] !== undefined ? {
                  ...routeParamList[action.payload.name],
                  ...action.payload.params
                } : action.payload.params
              }];
              return {
                ...state,
                routes,
                index: routes.length - 1
              };
            }
            const route = state.routes[index];
            let params;
            if (action.payload.merge) {
              params = action.payload.params !== undefined || routeParamList[route.name] !== undefined ? {
                ...routeParamList[route.name],
                ...route.params,
                ...action.payload.params
              } : route.params;
            } else {
              params = routeParamList[route.name] !== undefined ? {
                ...routeParamList[route.name],
                ...action.payload.params
              } : action.payload.params;
            }
            return {
              ...state,
              index,
              routes: [...state.routes.slice(0, index), params !== route.params || action.payload.path && action.payload.path !== route.path ? {
                ...route,
                path: action.payload.path ?? route.path,
                params
              } : state.routes[index]]
            };
          }
          return null;
        case 'GO_BACK':
          if (state.index > 0) {
            return router.getStateForAction(state, {
              type: 'POP',
              payload: {
                count: 1
              },
              target: action.target,
              source: action.source
            }, options);
          }
          return null;
        default:
          return _BaseRouter.default.getStateForAction(state, action);
      }
    },
    actionCreators: StackActions
  };
  return router;
}
//# sourceMappingURL=StackRouter.js.map

/***/ }),

/***/ 70493:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.TabActions = void 0;
exports["default"] = TabRouter;
var _nonSecure = __webpack_require__(77869);
var _BaseRouter = _interopRequireDefault(__webpack_require__(67763));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const TYPE_ROUTE = 'route';
const TabActions = {
  jumpTo(name, params) {
    return {
      type: 'JUMP_TO',
      payload: {
        name,
        params
      }
    };
  }
};
exports.TabActions = TabActions;
const getRouteHistory = (routes, index, backBehavior, initialRouteName) => {
  const history = [{
    type: TYPE_ROUTE,
    key: routes[index].key
  }];
  let initialRouteIndex;
  switch (backBehavior) {
    case 'order':
      for (let i = index; i > 0; i--) {
        history.unshift({
          type: TYPE_ROUTE,
          key: routes[i - 1].key
        });
      }
      break;
    case 'firstRoute':
      if (index !== 0) {
        history.unshift({
          type: TYPE_ROUTE,
          key: routes[0].key
        });
      }
      break;
    case 'initialRoute':
      initialRouteIndex = routes.findIndex(route => route.name === initialRouteName);
      initialRouteIndex = initialRouteIndex === -1 ? 0 : initialRouteIndex;
      if (index !== initialRouteIndex) {
        history.unshift({
          type: TYPE_ROUTE,
          key: routes[initialRouteIndex].key
        });
      }
      break;
    case 'history':
      // The history will fill up on navigation
      break;
  }
  return history;
};
const changeIndex = (state, index, backBehavior, initialRouteName) => {
  let history;
  if (backBehavior === 'history') {
    const currentKey = state.routes[index].key;
    history = state.history.filter(it => it.type === 'route' ? it.key !== currentKey : false).concat({
      type: TYPE_ROUTE,
      key: currentKey
    });
  } else {
    history = getRouteHistory(state.routes, index, backBehavior, initialRouteName);
  }
  return {
    ...state,
    index,
    history
  };
};
function TabRouter(_ref) {
  let {
    initialRouteName,
    backBehavior = 'firstRoute'
  } = _ref;
  const router = {
    ..._BaseRouter.default,
    type: 'tab',
    getInitialState(_ref2) {
      let {
        routeNames,
        routeParamList
      } = _ref2;
      const index = initialRouteName !== undefined && routeNames.includes(initialRouteName) ? routeNames.indexOf(initialRouteName) : 0;
      const routes = routeNames.map(name => ({
        name,
        key: `${name}-${(0, _nonSecure.nanoid)()}`,
        params: routeParamList[name]
      }));
      const history = getRouteHistory(routes, index, backBehavior, initialRouteName);
      return {
        stale: false,
        type: 'tab',
        key: `tab-${(0, _nonSecure.nanoid)()}`,
        index,
        routeNames,
        history,
        routes
      };
    },
    getRehydratedState(partialState, _ref3) {
      var _state$routes, _state$history;
      let {
        routeNames,
        routeParamList
      } = _ref3;
      let state = partialState;
      if (state.stale === false) {
        return state;
      }
      const routes = routeNames.map(name => {
        const route = state.routes.find(r => r.name === name);
        return {
          ...route,
          name,
          key: route && route.name === name && route.key ? route.key : `${name}-${(0, _nonSecure.nanoid)()}`,
          params: routeParamList[name] !== undefined ? {
            ...routeParamList[name],
            ...(route ? route.params : undefined)
          } : route ? route.params : undefined
        };
      });
      const index = Math.min(Math.max(routeNames.indexOf((_state$routes = state.routes[(state === null || state === void 0 ? void 0 : state.index) ?? 0]) === null || _state$routes === void 0 ? void 0 : _state$routes.name), 0), routes.length - 1);
      const history = ((_state$history = state.history) === null || _state$history === void 0 ? void 0 : _state$history.filter(it => routes.find(r => r.key === it.key))) ?? [];
      return changeIndex({
        stale: false,
        type: 'tab',
        key: `tab-${(0, _nonSecure.nanoid)()}`,
        index,
        routeNames,
        history,
        routes
      }, index, backBehavior, initialRouteName);
    },
    getStateForRouteNamesChange(state, _ref4) {
      let {
        routeNames,
        routeParamList,
        routeKeyChanges
      } = _ref4;
      const routes = routeNames.map(name => state.routes.find(r => r.name === name && !routeKeyChanges.includes(r.name)) || {
        name,
        key: `${name}-${(0, _nonSecure.nanoid)()}`,
        params: routeParamList[name]
      });
      const index = Math.max(0, routeNames.indexOf(state.routes[state.index].name));
      let history = state.history.filter(
      // Type will always be 'route' for tabs, but could be different in a router extending this (e.g. drawer)
      it => it.type !== 'route' || routes.find(r => r.key === it.key));
      if (!history.length) {
        history = getRouteHistory(routes, index, backBehavior, initialRouteName);
      }
      return {
        ...state,
        history,
        routeNames,
        routes,
        index
      };
    },
    getStateForRouteFocus(state, key) {
      const index = state.routes.findIndex(r => r.key === key);
      if (index === -1 || index === state.index) {
        return state;
      }
      return changeIndex(state, index, backBehavior, initialRouteName);
    },
    getStateForAction(state, action, _ref5) {
      let {
        routeParamList,
        routeGetIdList
      } = _ref5;
      switch (action.type) {
        case 'JUMP_TO':
        case 'NAVIGATE':
          {
            let index = -1;
            if (action.type === 'NAVIGATE' && action.payload.key) {
              index = state.routes.findIndex(route => route.key === action.payload.key);
            } else {
              index = state.routes.findIndex(route => route.name === action.payload.name);
            }
            if (index === -1) {
              return null;
            }
            return changeIndex({
              ...state,
              routes: state.routes.map((route, i) => {
                if (i !== index) {
                  return route;
                }
                const getId = routeGetIdList[route.name];
                const currentId = getId === null || getId === void 0 ? void 0 : getId({
                  params: route.params
                });
                const nextId = getId === null || getId === void 0 ? void 0 : getId({
                  params: action.payload.params
                });
                const key = currentId === nextId ? route.key : `${route.name}-${(0, _nonSecure.nanoid)()}`;
                let params;
                if (action.type === 'NAVIGATE' && action.payload.merge && currentId === nextId) {
                  params = action.payload.params !== undefined || routeParamList[route.name] !== undefined ? {
                    ...routeParamList[route.name],
                    ...route.params,
                    ...action.payload.params
                  } : route.params;
                } else {
                  params = routeParamList[route.name] !== undefined ? {
                    ...routeParamList[route.name],
                    ...action.payload.params
                  } : action.payload.params;
                }
                const path = action.type === 'NAVIGATE' && action.payload.path != null ? action.payload.path : route.path;
                return params !== route.params || path !== route.path ? {
                  ...route,
                  key,
                  path,
                  params
                } : route;
              })
            }, index, backBehavior, initialRouteName);
          }
        case 'GO_BACK':
          {
            if (state.history.length === 1) {
              return null;
            }
            const previousKey = state.history[state.history.length - 2].key;
            const index = state.routes.findIndex(route => route.key === previousKey);
            if (index === -1) {
              return null;
            }
            return {
              ...state,
              history: state.history.slice(0, -1),
              index
            };
          }
        default:
          return _BaseRouter.default.getStateForAction(state, action);
      }
    },
    shouldActionChangeFocus(action) {
      return action.type === 'NAVIGATE';
    },
    actionCreators: TabActions
  };
  return router;
}
//# sourceMappingURL=TabRouter.js.map

/***/ }),

/***/ 55789:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
var _exportNames = {
  CommonActions: true,
  BaseRouter: true,
  DrawerActions: true,
  DrawerRouter: true,
  StackActions: true,
  StackRouter: true,
  TabActions: true,
  TabRouter: true
};
Object.defineProperty(exports, "BaseRouter", ({
  enumerable: true,
  get: function () {
    return _BaseRouter.default;
  }
}));
exports.CommonActions = void 0;
Object.defineProperty(exports, "DrawerActions", ({
  enumerable: true,
  get: function () {
    return _DrawerRouter.DrawerActions;
  }
}));
Object.defineProperty(exports, "DrawerRouter", ({
  enumerable: true,
  get: function () {
    return _DrawerRouter.default;
  }
}));
Object.defineProperty(exports, "StackActions", ({
  enumerable: true,
  get: function () {
    return _StackRouter.StackActions;
  }
}));
Object.defineProperty(exports, "StackRouter", ({
  enumerable: true,
  get: function () {
    return _StackRouter.default;
  }
}));
Object.defineProperty(exports, "TabActions", ({
  enumerable: true,
  get: function () {
    return _TabRouter.TabActions;
  }
}));
Object.defineProperty(exports, "TabRouter", ({
  enumerable: true,
  get: function () {
    return _TabRouter.default;
  }
}));
var CommonActions = _interopRequireWildcard(__webpack_require__(33153));
exports.CommonActions = CommonActions;
var _BaseRouter = _interopRequireDefault(__webpack_require__(67763));
var _DrawerRouter = _interopRequireWildcard(__webpack_require__(16443));
var _StackRouter = _interopRequireWildcard(__webpack_require__(41330));
var _TabRouter = _interopRequireWildcard(__webpack_require__(70493));
var _types = __webpack_require__(1858);
Object.keys(_types).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _types[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _types[key];
    }
  });
});
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 1858:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
//# sourceMappingURL=types.js.map

/***/ }),

/***/ 33083:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var createAnimations_exports = {};
__export(createAnimations_exports, {
  AnimatedText: () => AnimatedText,
  AnimatedView: () => AnimatedView,
  createAnimations: () => createAnimations,
  useAnimatedNumber: () => useAnimatedNumber,
  useAnimatedNumberReaction: () => useAnimatedNumberReaction,
  useAnimatedNumberStyle: () => useAnimatedNumberStyle
});
module.exports = __toCommonJS(createAnimations_exports);
var import_use_presence = __webpack_require__(33193);
var import_web = __webpack_require__(17187);
var import_react = __webpack_require__(16689);
var import_react_native = __webpack_require__(83849);
const animatedStyleKey = {
  transform: true,
  opacity: true
};
const AnimatedView = import_react_native.Animated.View;
const AnimatedText = import_react_native.Animated.Text;
function useAnimatedNumber(initial) {
  const state = (0, import_web.useSafeRef)(
    null
  );
  if (!state.current) {
    state.current = {
      composite: null,
      val: new import_react_native.Animated.Value(initial),
      strategy: { type: "spring" }
    };
  }
  return {
    getInstance() {
      return state.current.val;
    },
    getValue() {
      return state.current.val["_value"];
    },
    stop() {
      var _a;
      (_a = state.current.composite) == null ? void 0 : _a.stop();
      state.current.composite = null;
    },
    setValue(next, { type, ...config } = { type: "spring" }) {
      var _a, _b;
      const val = state.current.val;
      if (type === "direct") {
        val.setValue(next);
      } else if (type === "spring") {
        (_a = state.current.composite) == null ? void 0 : _a.stop();
        const composite = import_react_native.Animated.spring(val, {
          ...config,
          toValue: next,
          useNativeDriver: !import_web.isWeb
        });
        composite.start();
        state.current.composite = composite;
      } else {
        (_b = state.current.composite) == null ? void 0 : _b.stop();
        const composite = import_react_native.Animated.timing(val, {
          ...config,
          toValue: next,
          useNativeDriver: !import_web.isWeb
        });
        composite.start();
        state.current.composite = composite;
      }
    }
  };
}
function useAnimatedNumberReaction(value, cb) {
  const onChange = (0, import_web.useEvent)((current) => {
    cb(current.value);
  });
  (0, import_react.useEffect)(() => {
    const id = value.getInstance().addListener(onChange);
    return () => {
      value.getInstance().removeListener(id);
    };
  }, [value, onChange]);
}
function useAnimatedNumberStyle(value, getStyle) {
  return getStyle(value.getInstance());
}
function createAnimations(animations) {
  AnimatedView["displayName"] = "AnimatedView";
  AnimatedText["displayName"] = "AnimatedText";
  return {
    isReactNative: true,
    animations,
    View: AnimatedView,
    Text: AnimatedText,
    useAnimatedNumber,
    useAnimatedNumberReaction,
    useAnimatedNumberStyle,
    usePresence: import_use_presence.usePresence,
    useAnimations: ({ props, onDidAnimate, style, state, presence }) => {
      const isExiting = (presence == null ? void 0 : presence[0]) === false;
      const sendExitComplete = presence == null ? void 0 : presence[1];
      const mergedStyles = style;
      const animateStyles = (0, import_web.useSafeRef)({});
      const animatedTranforms = (0, import_web.useSafeRef)([]);
      const animationsState = (0, import_web.useSafeRef)(null);
      if (!animationsState.current) {
        animationsState.current = /* @__PURE__ */ new WeakMap();
      }
      const args = [
        JSON.stringify(mergedStyles),
        JSON.stringify(state),
        isExiting,
        !!onDidAnimate
      ];
      const res = (0, import_react.useMemo)(() => {
        var _a;
        const runners = [];
        const completions = [];
        const nonAnimatedStyle = {};
        for (const key in mergedStyles) {
          const val = mergedStyles[key];
          if (!animatedStyleKey[key]) {
            nonAnimatedStyle[key] = val;
            continue;
          }
          if (key !== "transform") {
            animateStyles.current[key] = update(key, animateStyles.current[key], val);
            continue;
          }
          if (!val)
            continue;
          for (const [index, transform] of val.entries()) {
            if (!transform)
              continue;
            const tkey = Object.keys(transform)[0];
            const currentTransform = (_a = animatedTranforms.current[index]) == null ? void 0 : _a[tkey];
            animatedTranforms.current[index] = {
              [tkey]: update(tkey, currentTransform, transform[tkey])
            };
            animatedTranforms.current = [...animatedTranforms.current];
          }
        }
        const animatedStyle = {
          ...Object.fromEntries(
            Object.entries(animateStyles.current).map(([k, v]) => {
              var _a2;
              return [
                k,
                ((_a2 = animationsState.current.get(v)) == null ? void 0 : _a2.interopolation) || v
              ];
            })
          ),
          transform: animatedTranforms.current.map((r) => {
            var _a2;
            const key = Object.keys(r)[0];
            const val = ((_a2 = animationsState.current.get(r[key])) == null ? void 0 : _a2.interopolation) || r[key];
            return { [key]: val };
          })
        };
        return {
          runners,
          completions,
          style: [nonAnimatedStyle, animatedStyle]
        };
        function update(key, animated, valIn) {
          const [val, type] = getValue(valIn);
          const value = animated || new import_react_native.Animated.Value(val);
          if (import_web.isWeb) {
            if (animated && val === animated["_value"]) {
              return value;
            }
          }
          let interpolateArgs;
          if (type) {
            const curInterpolation = animationsState.current.get(value);
            interpolateArgs = getInterpolated(
              (curInterpolation == null ? void 0 : curInterpolation.current) ?? value["_value"],
              val,
              type
            );
            animationsState.current.set(value, {
              interopolation: value.interpolate(interpolateArgs),
              current: val
            });
          }
          if (value) {
            const animationConfig = getAnimationConfig(key, animations, props.animation);
            let resolve;
            const promise = new Promise((res2) => {
              resolve = res2;
            });
            completions.push(promise);
            runners.push(() => {
              value.stopAnimation();
              import_react_native.Animated[animationConfig.type || "spring"](value, {
                toValue: val,
                useNativeDriver: !import_web.isWeb,
                ...animationConfig
              }).start(({ finished }) => {
                if (finished) {
                  resolve();
                }
              });
            });
          }
          if (false) {}
          return value;
        }
      }, args);
      (0, import_web.useIsomorphicLayoutEffect)(() => {
        res.runners.forEach((r) => r());
        let cancel = false;
        Promise.all(res.completions).then(() => {
          if (cancel)
            return;
          onDidAnimate == null ? void 0 : onDidAnimate();
          if (isExiting) {
            sendExitComplete == null ? void 0 : sendExitComplete();
          }
        });
        return () => {
          cancel = true;
        };
      }, args);
      if (false) {}
      return res;
    }
  };
}
function getInterpolated(current, next, postfix = "deg") {
  if (next === current) {
    current = next - 1e-9;
  }
  const inputRange = [current, next];
  const outputRange = [`${current}${postfix}`, `${next}${postfix}`];
  if (next < current) {
    inputRange.reverse();
    outputRange.reverse();
  }
  return {
    inputRange,
    outputRange
  };
}
function getAnimationConfig(key, animations, animation) {
  if (typeof animation === "string") {
    return animations[animation];
  }
  let type = "";
  let extraConf;
  if (Array.isArray(animation)) {
    type = animation[0];
    const conf = animation[1] && animation[1][key];
    if (conf) {
      if (typeof conf === "string") {
        type = conf;
      } else {
        type = conf.type || type;
        extraConf = conf;
      }
    }
  } else {
    const val = animation == null ? void 0 : animation[key];
    type = val == null ? void 0 : val.type;
    extraConf = val;
  }
  const found = animations[type];
  if (!found) {
    throw new Error(`No animation of type "${type}" for key "${key}"`);
  }
  return {
    ...found,
    ...extraConf
  };
}
function getValue(input) {
  if (typeof input !== "string") {
    return [input];
  }
  const [_, number, after] = input.match(/([-0-9]+)(deg|%|px)/) ?? [];
  return [+number, after];
}
// Annotate the CommonJS export names for ESM import in node:
0 && (0);
//# sourceMappingURL=createAnimations.js.map


/***/ }),

/***/ 18675:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __reExport = (target, mod, secondTarget) => (__copyProps(target, mod, "default"), secondTarget && __copyProps(secondTarget, mod, "default"));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var src_exports = {};
module.exports = __toCommonJS(src_exports);
var import_polyfill = __webpack_require__(43901);
__reExport(src_exports, __webpack_require__(33083), module.exports);
//# sourceMappingURL=index.js.map


/***/ }),

/***/ 43901:
/***/ (() => {

"use strict";

if (typeof requestAnimationFrame === "undefined") {
  globalThis["requestAnimationFrame"] = setImmediate;
}
//# sourceMappingURL=polyfill.js.map


/***/ }),

/***/ 72026:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  zx: () => (/* binding */ Button2)
});

// UNUSED EXPORTS: ButtonFrame, ButtonText, buttonStaticConfig, useButton

// EXTERNAL MODULE: ./node_modules/react/jsx-runtime.js
var jsx_runtime = __webpack_require__(85893);
// EXTERNAL MODULE: ./node_modules/@tamagui/core/dist/cjs/index.js
var cjs = __webpack_require__(86872);
;// CONCATENATED MODULE: ./node_modules/@tamagui/font-size/dist/jsx/getFontSize.js

const getFontSize = (inSize, opts)=>{
    const res = getFontSizeVariable(inSize, opts);
    if ((0,cjs.isVariable)(res)) {
        return +res.val;
    }
    return res ? +res : 16;
};
const getFontSizeVariable = (inSize, opts)=>{
    const token = getFontSizeToken(inSize, opts);
    if (!token) {
        return inSize;
    }
    const conf = (0,cjs.getConfig)();
    return conf.fontsParsed[opts?.font || "$body"].size[token];
};
const getFontSizeToken = (inSize, opts)=>{
    if (typeof inSize === "number") {
        return null;
    }
    const relativeSize = opts?.relativeSize || 0;
    const conf = (0,cjs.getConfig)();
    const fontSize = conf.fontsParsed[opts?.font || "$body"].size;
    const size = inSize || ("$true" in fontSize ? "$true" : "$4");
    const sizeTokens = Object.keys(fontSize);
    let foundIndex = sizeTokens.indexOf(size);
    if (foundIndex === -1) {
        if (size.endsWith(".5")) {
            foundIndex = sizeTokens.indexOf(size.replace(".5", ""));
        }
    }
    if (false) {}
    const tokenIndex = Math.min(Math.max(0, foundIndex + relativeSize), sizeTokens.length - 1);
    return sizeTokens[tokenIndex] ?? size;
};
 //# sourceMappingURL=getFontSize.js.map

// EXTERNAL MODULE: ./node_modules/@tamagui/get-button-sized/dist/cjs/index.js
var dist_cjs = __webpack_require__(56394);
// EXTERNAL MODULE: ./node_modules/@tamagui/helpers-tamagui/dist/cjs/index.js
var helpers_tamagui_dist_cjs = __webpack_require__(6724);
// EXTERNAL MODULE: ./node_modules/@tamagui/stacks/dist/esm/Stacks.js
var Stacks = __webpack_require__(42023);
// EXTERNAL MODULE: ./node_modules/@tamagui/stacks/dist/esm/getElevation.js
var getElevation = __webpack_require__(55689);
;// CONCATENATED MODULE: ./node_modules/@tamagui/stacks/dist/esm/variants.js

const elevate = {
  true: (_, extras) => {
    return (0,getElevation/* getElevation */.y)(extras.props["size"], extras);
  }
};
const bordered = (val, { props }) => {
  return {
    // TODO size it with size in '...size'
    borderWidth: typeof val === "number" ? val : 1,
    borderColor: "$borderColor",
    ...props.hoverTheme && {
      hoverStyle: {
        borderColor: "$borderColorHover"
      }
    },
    ...props.pressTheme && {
      pressStyle: {
        borderColor: "$borderColorPress"
      }
    },
    ...props.focusTheme && {
      focusStyle: {
        borderColor: "$borderColorFocus"
      }
    }
  };
};
const padded = {
  true: (_, extras) => {
    const { tokens, props } = extras;
    return {
      padding: tokens.space[props.size] || tokens.space["$true"]
    };
  }
};
const radiused = {
  true: (_, extras) => {
    const { tokens, props } = extras;
    return {
      borderRadius: tokens.radius[props.size] || tokens.radius["$true"]
    };
  }
};
const circular = {
  true: (_, { props, tokens }) => {
    const size = tokens.size[props.size];
    return {
      width: size,
      height: size,
      maxWidth: size,
      maxHeight: size,
      minWidth: size,
      minHeight: size,
      borderRadius: 1e5,
      padding: 0
    };
  }
};
const hoverTheme = {
  true: {
    hoverStyle: {
      backgroundColor: "$backgroundHover",
      borderColor: "$borderColorHover"
    }
  },
  false: {}
};
const pressTheme = {
  true: {
    cursor: "pointer",
    pressStyle: {
      backgroundColor: "$backgroundPress",
      borderColor: "$borderColorPress"
    }
  },
  false: {}
};
const focusTheme = {
  true: {
    focusStyle: {
      backgroundColor: "$backgroundFocus",
      borderColor: "$borderColorFocus"
    }
  },
  false: {}
};

//# sourceMappingURL=variants.js.map

;// CONCATENATED MODULE: ./node_modules/@tamagui/stacks/dist/esm/ThemeableStack.js



const chromelessStyle = {
  backgroundColor: "transparent",
  borderColor: "transparent",
  shadowColor: "transparent"
};
const ThemeableStack = (0,cjs.styled)(Stacks/* YStack */.FA, {
  name: "SizableStack",
  variants: {
    backgrounded: {
      true: {
        backgroundColor: "$background"
      }
    },
    radiused: radiused,
    hoverTheme: hoverTheme,
    pressTheme: pressTheme,
    focusTheme: focusTheme,
    circular: circular,
    padded: padded,
    elevate: elevate,
    bordered: bordered,
    transparent: {
      true: {
        backgroundColor: "transparent"
      }
    },
    chromeless: {
      true: chromelessStyle,
      all: {
        ...chromelessStyle,
        hoverStyle: chromelessStyle,
        pressStyle: chromelessStyle,
        focusStyle: chromelessStyle
      }
    }
  }
});

//# sourceMappingURL=ThemeableStack.js.map

// EXTERNAL MODULE: ./node_modules/@tamagui/get-font-sized/dist/cjs/index.js
var get_font_sized_dist_cjs = __webpack_require__(94773);
// EXTERNAL MODULE: ./node_modules/@tamagui/web/dist/cjs/index.js
var web_dist_cjs = __webpack_require__(17187);
;// CONCATENATED MODULE: ./node_modules/@tamagui/text/dist/esm/SizableText.js


const SizableText = (0,web_dist_cjs.styled)(web_dist_cjs.Text, {
  name: "SizableText",
  fontFamily: "$body",
  variants: {
    size: get_font_sized_dist_cjs.getFontSized
  },
  defaultVariants: {
    size: "$true"
  }
});

//# sourceMappingURL=SizableText.js.map

// EXTERNAL MODULE: external "react"
var external_react_ = __webpack_require__(16689);
var external_react_default = /*#__PURE__*/__webpack_require__.n(external_react_);
;// CONCATENATED MODULE: ./node_modules/@tamagui/text/dist/esm/wrapChildrenInText.js


function wrapChildrenInText(TextComponent, propsIn, extraProps) {
  const {
    children,
    textProps,
    size,
    noTextWrap,
    color,
    fontFamily,
    fontSize,
    fontWeight,
    letterSpacing,
    textAlign
  } = propsIn;
  if (noTextWrap || !children) {
    return [children];
  }
  const allChildren = external_react_default().Children.toArray(children);
  const nextChildren = [];
  let lastIsString = false;
  const props = {
    ...extraProps
  };
  if (color)
    props.color = color;
  if (fontFamily)
    props.fontFamily = fontFamily;
  if (fontSize)
    props.fontSize = fontSize;
  if (fontWeight)
    props.fontWeight = fontWeight;
  if (letterSpacing)
    props.letterSpacing = letterSpacing;
  if (textAlign)
    props.textAlign = textAlign;
  if (size)
    props.size = size;
  function concatStringChildren() {
    if (!lastIsString)
      return;
    const index = nextChildren.length - 1;
    const childrenStrings = nextChildren[index];
    nextChildren[index] = /* @__PURE__ */ (0,jsx_runtime.jsx)(TextComponent, { ...props, ...textProps, children: childrenStrings }, index);
  }
  for (const child of allChildren) {
    const last = nextChildren[nextChildren.length - 1];
    const isString = typeof child === "string";
    if (isString) {
      if (lastIsString) {
        last.push(child);
      } else {
        nextChildren.push([child]);
      }
    } else {
      concatStringChildren();
      nextChildren.push(child);
    }
    lastIsString = isString;
  }
  concatStringChildren();
  return nextChildren;
}

//# sourceMappingURL=wrapChildrenInText.js.map

;// CONCATENATED MODULE: ./node_modules/@tamagui/button/dist/esm/Button.js








const NAME = "Button";
const ButtonFrame = (0,web_dist_cjs.styled)(ThemeableStack, {
  name: NAME,
  tag: "button",
  justifyContent: "center",
  alignItems: "center",
  flexWrap: "nowrap",
  flexDirection: "row",
  cursor: "pointer",
  variants: {
    defaultStyle: {
      true: {
        focusable: true,
        hoverTheme: true,
        pressTheme: true,
        backgrounded: true,
        borderWidth: 1,
        borderColor: "transparent",
        pressStyle: {
          borderColor: "transparent"
        },
        hoverStyle: {
          borderColor: "transparent"
        },
        focusStyle: {
          borderColor: "$borderColorFocus"
        }
      }
    },
    size: {
      "...size": dist_cjs.getButtonSized
    },
    active: {
      true: {
        hoverStyle: {
          backgroundColor: "$background"
        }
      }
    },
    disabled: {
      true: {
        pointerEvents: "none"
      }
    }
  },
  defaultVariants: {
    size: "$true"
  }
});
const ButtonText = (0,web_dist_cjs.styled)(SizableText, {
  name: "ButtonText",
  userSelect: "none",
  cursor: "pointer",
  // flexGrow 1 leads to inconsistent native style where text pushes to start of view
  flexGrow: 0,
  flexShrink: 1,
  ellipse: true,
  variants: {
    defaultStyle: {
      true: {
        color: "$color"
      }
    }
  }
});
const ButtonComponent = (0,external_react_.forwardRef)(function Button(props, ref) {
  const {
    props: { unstyled, ...buttonProps }
  } = useButton(props);
  return /* @__PURE__ */ (0,jsx_runtime.jsx)(ButtonFrame, { defaultStyle: !unstyled, ...buttonProps, ref });
});
const buttonStaticConfig = {
  inlineProps: /* @__PURE__ */ new Set([
    // text props go here (can't really optimize them, but we never fully extract button anyway)
    // may be able to remove this entirely, as the compiler / runtime have gotten better
    "color",
    "fontWeight",
    "fontSize",
    "fontFamily",
    "letterSpacing",
    "textAlign",
    "unstyled"
  ])
};
const Button2 = ButtonFrame.extractable(
  (0,web_dist_cjs.themeable)(ButtonComponent, ButtonFrame.staticConfig),
  buttonStaticConfig
);
function useButton(propsIn, { Text = ButtonText } = { Text: ButtonText }) {
  const {
    children,
    icon,
    iconAfter,
    noTextWrap,
    theme: themeName,
    space,
    spaceFlex,
    scaleIcon = 1,
    scaleSpace = 0.66,
    separator,
    // text props
    color,
    fontWeight,
    letterSpacing,
    fontSize,
    fontFamily,
    textAlign,
    textProps,
    ...rest
  } = propsIn;
  const isNested = web_dist_cjs.isRSC ? false : (0,external_react_.useContext)(web_dist_cjs.ButtonNestingContext);
  const propsActive = (0,web_dist_cjs.useMediaPropsActive)(propsIn);
  const size = propsActive.size || "$true";
  const iconSize = (typeof size === "number" ? size * 0.5 : getFontSize(size)) * scaleIcon;
  const getThemedIcon = (0,helpers_tamagui_dist_cjs.useGetThemedIcon)({ size: iconSize, color });
  const [themedIcon, themedIconAfter] = [icon, iconAfter].map(getThemedIcon);
  const spaceSize = propsActive.space ?? (0,web_dist_cjs.getVariableValue)(iconSize) * scaleSpace;
  const contents = wrapChildrenInText(
    Text,
    propsActive,
    Text === ButtonText ? {
      defaultStyle: !propsIn.unstyled
    } : void 0
  );
  const inner = (0,web_dist_cjs.spacedChildren)({
    // a bit arbitrary but scaling to font size is necessary so long as button does
    space: spaceSize,
    spaceFlex,
    separator,
    direction: propsActive.flexDirection === "column" || propsActive.flexDirection === "column-reverse" ? "vertical" : "horizontal",
    children: [themedIcon, ...contents, themedIconAfter]
  });
  const tag = isNested ? "span" : (
    // defaults to <a /> when accessibilityRole = link
    // see https://github.com/tamagui/tamagui/issues/505
    propsIn.accessibilityRole === "link" ? "a" : void 0
  );
  const props = {
    ...propsActive.disabled && {
      // in rnw - false still has keyboard tabIndex, undefined = not actually focusable
      focusable: void 0,
      // even with tabIndex unset, it will keep focusStyle on web so disable it here
      focusStyle: {
        borderColor: "$background"
      }
    },
    tag,
    ...rest,
    children: web_dist_cjs.isRSC ? inner : /* @__PURE__ */ (0,jsx_runtime.jsx)(web_dist_cjs.ButtonNestingContext.Provider, { value: true, children: inner })
  };
  return {
    spaceSize,
    isNested,
    props
  };
}

//# sourceMappingURL=Button.js.map


/***/ }),

/***/ 90212:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var compose_refs_exports = {};
__export(compose_refs_exports, {
  composeRefs: () => composeRefs,
  useComposedRefs: () => useComposedRefs
});
module.exports = __toCommonJS(compose_refs_exports);
var React = __toESM(__webpack_require__(16689));
function setRef(ref, value) {
  if (typeof ref === "function") {
    ref(value);
  } else if (ref) {
    ;
    ref.current = value;
  }
}
function composeRefs(...refs) {
  return (node) => refs.forEach((ref) => setRef(ref, node));
}
function useComposedRefs(...refs) {
  return React.useCallback(composeRefs(...refs), refs);
}
// Annotate the CommonJS export names for ESM import in node:
0 && (0);
//# sourceMappingURL=compose-refs.js.map


/***/ }),

/***/ 95915:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __reExport = (target, mod, secondTarget) => (__copyProps(target, mod, "default"), secondTarget && __copyProps(secondTarget, mod, "default"));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var src_exports = {};
module.exports = __toCommonJS(src_exports);
__reExport(src_exports, __webpack_require__(90212), module.exports);
//# sourceMappingURL=index.js.map


/***/ }),

/***/ 14810:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var src_exports = {};
__export(src_exports, {
  isChrome: () => isChrome,
  isClient: () => isClient,
  isRSC: () => isRSC,
  isServer: () => isServer,
  isTouchable: () => isTouchable,
  isWeb: () => isWeb,
  isWebTouchable: () => isWebTouchable,
  isWindowDefined: () => isWindowDefined,
  useIsomorphicLayoutEffect: () => useIsomorphicLayoutEffect
});
module.exports = __toCommonJS(src_exports);
var import_react = __webpack_require__(16689);
const import_meta = {};
const isWeb = "web" === "web";
const isWindowDefined = typeof window !== "undefined";
const isServer = isWeb && !isWindowDefined;
const isClient = isWeb && isWindowDefined;
const isRSC = process.env.ENABLE_RSC ? (
  // note this is statically analyzed so no funny business, just access it without optional chaining
  // @ts-ignore
  import_meta.env ? (
    // @ts-ignore
    import_meta.env.SSR
  ) : false
) : false;
const idFn = () => {
};
const useIsomorphicLayoutEffect = isRSC ? idFn : isServer ? import_react.useEffect : import_react.useLayoutEffect;
const isChrome = typeof navigator !== "undefined" && /Chrome/.test(navigator.userAgent || "");
const isWebTouchable = isClient && ("ontouchstart" in window || navigator.maxTouchPoints > 0);
const isTouchable = !isWeb || isWebTouchable;
if (false) {}
// Annotate the CommonJS export names for ESM import in node:
0 && (0);
//# sourceMappingURL=index.js.map


/***/ }),

/***/ 93691:
/***/ ((module) => {

"use strict";

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var getBoundingClientRect_exports = {};
__export(getBoundingClientRect_exports, {
  getBoundingClientRect: () => getBoundingClientRect
});
module.exports = __toCommonJS(getBoundingClientRect_exports);
const getBoundingClientRect = (node) => {
  var _a;
  if (!node || node.nodeType !== 1)
    return;
  return (_a = node.getBoundingClientRect) == null ? void 0 : _a.call(node);
};
// Annotate the CommonJS export names for ESM import in node:
0 && (0);
//# sourceMappingURL=getBoundingClientRect.js.map


/***/ }),

/***/ 71023:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var getRect_exports = {};
__export(getRect_exports, {
  getRect: () => getRect
});
module.exports = __toCommonJS(getRect_exports);
var import_getBoundingClientRect = __webpack_require__(93691);
const getRect = (node) => {
  const rect = (0, import_getBoundingClientRect.getBoundingClientRect)(node);
  if (!rect)
    return;
  const { x, y, top, left } = rect;
  return { x, y, width: node.offsetWidth, height: node.offsetHeight, top, left };
};
// Annotate the CommonJS export names for ESM import in node:
0 && (0);
//# sourceMappingURL=getRect.js.map


/***/ }),

/***/ 18987:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var useElementLayout_exports = {};
__export(useElementLayout_exports, {
  measureLayout: () => measureLayout,
  useElementLayout: () => useElementLayout
});
module.exports = __toCommonJS(useElementLayout_exports);
var import_constants = __webpack_require__(14810);
var import_use_event = __webpack_require__(90951);
var import_getBoundingClientRect = __webpack_require__(93691);
var import_getRect = __webpack_require__(71023);
const LayoutHandlers = /* @__PURE__ */ new WeakMap();
let resizeObserver = null;
if (typeof window !== "undefined" && "ResizeObserver" in window) {
  resizeObserver = new ResizeObserver((entries) => {
    for (const { target } of entries) {
      const onLayout = LayoutHandlers.get(target);
      if (typeof onLayout !== "function")
        return;
      measureLayout(target, null, (x, y, width, height, left, top) => {
        onLayout({
          nativeEvent: {
            layout: { x, y, width, height, left, top },
            target
          },
          timeStamp: Date.now()
        });
      });
    }
  });
}
const measureLayout = (node, relativeTo, callback) => {
  const relativeNode = relativeTo || (node == null ? void 0 : node.parentNode);
  if (relativeNode instanceof HTMLElement) {
    setTimeout(() => {
      const relativeRect = (0, import_getBoundingClientRect.getBoundingClientRect)(relativeNode);
      const { height, left, top, width } = (0, import_getRect.getRect)(node);
      const x = left - relativeRect.left;
      const y = top - relativeRect.top;
      callback(x, y, width, height, left, top);
    }, 0);
  }
};
const idFn = () => {
};
function useElementLayout(ref, onLayout) {
  const hasLayoutEvent = !!onLayout;
  const onLayoutEvent = (0, import_use_event.useEvent)(onLayout || idFn);
  (0, import_constants.useIsomorphicLayoutEffect)(() => {
    if (!resizeObserver || !hasLayoutEvent)
      return;
    const node = ref.current;
    if (!node)
      return;
    LayoutHandlers.set(node, onLayoutEvent);
    resizeObserver.observe(node);
    return () => {
      resizeObserver == null ? void 0 : resizeObserver.unobserve(node);
    };
  }, [ref, hasLayoutEvent]);
}
// Annotate the CommonJS export names for ESM import in node:
0 && (0);
//# sourceMappingURL=useElementLayout.js.map


/***/ }),

/***/ 55344:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var usePlatformMethods_exports = {};
__export(usePlatformMethods_exports, {
  usePlatformMethods: () => usePlatformMethods
});
module.exports = __toCommonJS(usePlatformMethods_exports);
var import_web = __webpack_require__(17187);
var import_getRect = __webpack_require__(71023);
var import_useElementLayout = __webpack_require__(18987);
function usePlatformMethods(hostRef) {
  (0, import_web.useIsomorphicLayoutEffect)(() => {
    const node = hostRef.current;
    if (!node)
      return;
    node.measure = (callback) => (0, import_useElementLayout.measureLayout)(node, null, callback);
    node.measureLayout = (relativeToNode, success) => (0, import_useElementLayout.measureLayout)(node, relativeToNode, success);
    node.measureInWindow = (callback) => {
      if (!node)
        return;
      setTimeout(() => {
        const { height, left, top, width } = (0, import_getRect.getRect)(node);
        callback(left, top, width, height);
      }, 0);
    };
  }, [hostRef]);
}
// Annotate the CommonJS export names for ESM import in node:
0 && (0);
//# sourceMappingURL=usePlatformMethods.js.map


/***/ }),

/***/ 86872:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __reExport = (target, mod, secondTarget) => (__copyProps(target, mod, "default"), secondTarget && __copyProps(secondTarget, mod, "default"));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var src_exports = {};
__export(src_exports, {
  Stack: () => Stack,
  Text: () => Text
});
module.exports = __toCommonJS(src_exports);
var import_react_native_use_responder_events = __webpack_require__(94245);
var import_web = __webpack_require__(17187);
var import_useElementLayout = __webpack_require__(18987);
var import_usePlatformMethods = __webpack_require__(55344);
var import_Pressability = __webpack_require__(5468);
__reExport(src_exports, __webpack_require__(17187), module.exports);
const Stack = import_web.Stack;
const Text = import_web.Text;
(0, import_web.setupHooks)({
  getBaseViews() {
    const native = __webpack_require__(83849);
    return {
      View: native.View || native.default.View,
      Text: native.Text || native.default.Text
    };
  },
  usePropsTransform(elementType, propsIn, hostRef) {
    const {
      // event props
      onMoveShouldSetResponder,
      onMoveShouldSetResponderCapture,
      onResponderEnd,
      onResponderGrant,
      onResponderMove,
      onResponderReject,
      onResponderRelease,
      onResponderStart,
      onResponderTerminate,
      onResponderTerminationRequest,
      onScrollShouldSetResponder,
      onScrollShouldSetResponderCapture,
      onSelectionChangeShouldSetResponder,
      onSelectionChangeShouldSetResponderCapture,
      onStartShouldSetResponder,
      onStartShouldSetResponderCapture,
      // android
      collapsable,
      focusable,
      // deprecated,
      accessible,
      accessibilityDisabled,
      onLayout,
      hrefAttrs,
      ...viewProps
    } = propsIn;
    if (!import_web.isRSC) {
      (0, import_usePlatformMethods.usePlatformMethods)(hostRef);
      (0, import_useElementLayout.useElementLayout)(hostRef, onLayout);
      (0, import_react_native_use_responder_events.useResponderEvents)(hostRef, {
        onMoveShouldSetResponder,
        onMoveShouldSetResponderCapture,
        onResponderEnd,
        onResponderGrant,
        onResponderMove,
        onResponderReject,
        onResponderRelease,
        onResponderStart,
        onResponderTerminate,
        onResponderTerminationRequest,
        onScrollShouldSetResponder,
        onScrollShouldSetResponderCapture,
        onSelectionChangeShouldSetResponder,
        onSelectionChangeShouldSetResponderCapture,
        onStartShouldSetResponder,
        onStartShouldSetResponderCapture
      });
    }
    if (viewProps.href !== void 0 && hrefAttrs !== void 0) {
      const { download, rel, target } = hrefAttrs;
      if (download != null) {
        viewProps.download = download;
      }
      if (rel != null) {
        viewProps.rel = rel;
      }
      if (typeof target === "string") {
        viewProps.target = target.charAt(0) !== "_" ? `_${target}` : target;
      }
    }
    if (!viewProps.tabIndex) {
      const _focusable = focusable !== void 0 ? focusable : accessible;
      const role = viewProps.role;
      if (_focusable === false) {
        viewProps.tabIndex = "-1";
      }
      if (
        // These native elements are focusable by default
        elementType === "a" || elementType === "button" || elementType === "input" || elementType === "select" || elementType === "textarea"
      ) {
        if (_focusable === false || accessibilityDisabled === true) {
          viewProps.tabIndex = "-1";
        }
      } else if (
        // These roles are made focusable by default
        role === "button" || role === "checkbox" || role === "link" || role === "radio" || role === "textbox" || role === "switch"
      ) {
        if (_focusable !== false) {
          viewProps.tabIndex = "0";
        }
      }
      if (_focusable === true) {
        viewProps.tabIndex = "0";
      }
    }
    return viewProps;
  },
  useEvents(viewProps, events, { pseudos }, setStateShallow) {
    if (false) {}
  }
});
const dontComposePressabilityKeys = {
  onClick: true
};
// Annotate the CommonJS export names for ESM import in node:
0 && (0);
//# sourceMappingURL=index.js.map


/***/ }),

/***/ 5468:
/***/ ((module) => {

"use strict";

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var Pressability_exports = {};
__export(Pressability_exports, {
  Pressability: () => Pressability,
  usePressability: () => usePressability
});
module.exports = __toCommonJS(Pressability_exports);
const Pressability = {};
const usePressability = {};
// Annotate the CommonJS export names for ESM import in node:
0 && (0);
//# sourceMappingURL=Pressability.js.map


/***/ }),

/***/ 56394:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var src_exports = {};
__export(src_exports, {
  getButtonSized: () => getButtonSized
});
module.exports = __toCommonJS(src_exports);
var import_get_size = __webpack_require__(75495);
const getButtonSized = (val, { tokens }) => {
  if (typeof val === "number") {
    return {
      paddingHorizontal: val * 0.25,
      height: val,
      borderRadius: val * 0.2
    };
  }
  const ySize = (0, import_get_size.getSize)(val, 0);
  const xSize = (0, import_get_size.stepTokenUpOrDown)("space", val);
  const radiusToken = tokens.radius[val] ?? tokens.radius["$true"];
  return {
    paddingHorizontal: xSize,
    height: ySize,
    borderRadius: radiusToken
  };
};
// Annotate the CommonJS export names for ESM import in node:
0 && (0);
//# sourceMappingURL=index.js.map


/***/ }),

/***/ 94773:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var src_exports = {};
__export(src_exports, {
  getFontSized: () => getFontSized
});
module.exports = __toCommonJS(src_exports);
var import_core = __webpack_require__(86872);
const getFontSized = (sizeTokenIn = "$true", { fonts, props }) => {
  var _a, _b, _c;
  const family = (0, import_core.getVariableValue)(props.fontFamily) || "$body";
  const font = fonts[family] || fonts["$body"];
  if (!font) {
    if (false) {}
    return {};
  }
  const fontFamily = font.family;
  const sizeToken = sizeTokenIn === "$true" ? getDefaultSizeToken(font) : sizeTokenIn;
  const fontSize = props.fontSize || font.size[sizeToken];
  const lineHeight = props.lineHeight || font.lineHeight[sizeToken];
  const fontWeight = props.fontWeight || font.weight[sizeToken];
  const letterSpacing = props.letterSpacing || font.letterSpacing[sizeToken];
  const fontStyle = props.fontStyle || ((_a = font.style) == null ? void 0 : _a[sizeToken]);
  const textTransform = props.textTransform || ((_b = font.transform) == null ? void 0 : _b[sizeToken]);
  const color = props.color || ((_c = font.color) == null ? void 0 : _c[sizeToken]);
  const style = {
    color,
    fontStyle,
    textTransform,
    fontFamily,
    fontWeight,
    letterSpacing,
    fontSize,
    lineHeight
  };
  if (false) {}
  return style;
};
const cache = /* @__PURE__ */ new WeakMap();
function getDefaultSizeToken(font) {
  if (typeof font === "object" && cache.has(font)) {
    return cache.get(font);
  }
  const sizeTokens = "$true" in font.size ? font.size : (0, import_core.getTokens)().size;
  const sizeDefault = sizeTokens["$true"];
  const sizeDefaultSpecific = sizeDefault ? Object.keys(sizeTokens).find(
    (x) => x !== "$true" && sizeTokens[x]["val"] === sizeDefault["val"]
  ) : null;
  if (!sizeDefault || !sizeDefaultSpecific) {
    if (false) {}
    return Object.keys(font.size)[3];
  }
  cache.set(font, sizeDefaultSpecific);
  return sizeDefaultSpecific;
}
// Annotate the CommonJS export names for ESM import in node:
0 && (0);
//# sourceMappingURL=index.js.map


/***/ }),

/***/ 75495:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var src_exports = {};
__export(src_exports, {
  getSize: () => getSize,
  stepTokenUpOrDown: () => stepTokenUpOrDown
});
module.exports = __toCommonJS(src_exports);
var import_core = __webpack_require__(86872);
const getSize = (size, shift = 0, bounds = [0]) => {
  return stepTokenUpOrDown("size", size, shift, bounds);
};
const stepTokenUpOrDown = (type, name = "$true", shift = 0, bounds = [0]) => {
  const tokens = (0, import_core.getTokens)({ prefixed: true })[type];
  const keysOrdered = import_core.tokensKeysOrdered.get(tokens) || Object.keys(tokens);
  const min = bounds[0] ?? 0;
  const max = bounds[1] ?? keysOrdered.length - 1;
  const currentIndex = keysOrdered.indexOf(name);
  if (name === "$true") {
    shift += shift === 0 ? 0 : shift > 0 ? 1 : -1;
  }
  const index = Math.min(max, Math.max(min, currentIndex + shift));
  const key = keysOrdered[index];
  return tokens[key] || tokens["$true"];
};
// Annotate the CommonJS export names for ESM import in node:
0 && (0);
//# sourceMappingURL=index.js.map


/***/ }),

/***/ 78844:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var getSpace_exports = {};
__export(getSpace_exports, {
  getSpace: () => getSpace
});
module.exports = __toCommonJS(getSpace_exports);
var import_core = __webpack_require__(86872);
const getSpace = (token, sizeUpOrDownBy = 0) => {
  const spaces = (0, import_core.getTokens)().space;
  const spaceNames = Object.keys(spaces);
  const key = spaceNames[Math.max(0, spaceNames.indexOf(String(token || "$true")) + sizeUpOrDownBy)];
  return spaces[key] || spaces["$true"];
};
// Annotate the CommonJS export names for ESM import in node:
0 && (0);
//# sourceMappingURL=getSpace.js.map


/***/ }),

/***/ 6724:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __reExport = (target, mod, secondTarget) => (__copyProps(target, mod, "default"), secondTarget && __copyProps(secondTarget, mod, "default"));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var src_exports = {};
module.exports = __toCommonJS(src_exports);
__reExport(src_exports, __webpack_require__(37513), module.exports);
__reExport(src_exports, __webpack_require__(13129), module.exports);
__reExport(src_exports, __webpack_require__(78844), module.exports);
__reExport(src_exports, __webpack_require__(91153), module.exports);
__reExport(src_exports, __webpack_require__(74532), module.exports);
//# sourceMappingURL=index.js.map


/***/ }),

/***/ 13129:
/***/ ((module) => {

"use strict";

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var prevent_exports = {};
__export(prevent_exports, {
  prevent: () => prevent
});
module.exports = __toCommonJS(prevent_exports);
const prevent = (e) => [e.preventDefault(), e.stopPropagation()];
// Annotate the CommonJS export names for ESM import in node:
0 && (0);
//# sourceMappingURL=prevent.js.map


/***/ }),

/***/ 91153:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var useCurrentColor_exports = {};
__export(useCurrentColor_exports, {
  useCurrentColor: () => useCurrentColor
});
module.exports = __toCommonJS(useCurrentColor_exports);
var import_core = __webpack_require__(86872);
const useCurrentColor = (colorProp) => {
  const theme = (0, import_core.useTheme)();
  return (0, import_core.variableToString)(theme[colorProp] || colorProp || theme.color);
};
// Annotate the CommonJS export names for ESM import in node:
0 && (0);
//# sourceMappingURL=useCurrentColor.js.map


/***/ }),

/***/ 74532:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var useGetThemedIcon_exports = {};
__export(useGetThemedIcon_exports, {
  useGetThemedIcon: () => useGetThemedIcon
});
module.exports = __toCommonJS(useGetThemedIcon_exports);
var import_react = __webpack_require__(16689);
var import_useCurrentColor = __webpack_require__(91153);
const useGetThemedIcon = (props) => {
  const color = (0, import_useCurrentColor.useCurrentColor)(props.color);
  return (el) => {
    if (!el)
      return el;
    if ((0, import_react.isValidElement)(el)) {
      return (0, import_react.cloneElement)(el, {
        ...props,
        // @ts-expect-error
        ...el.props
      });
    }
    return (0, import_react.createElement)(el, props);
  };
};
// Annotate the CommonJS export names for ESM import in node:
0 && (0);
//# sourceMappingURL=useGetThemedIcon.js.map


/***/ }),

/***/ 35833:
/***/ ((module) => {

"use strict";

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var clamp_exports = {};
__export(clamp_exports, {
  clamp: () => clamp
});
module.exports = __toCommonJS(clamp_exports);
function clamp(value, [min, max]) {
  return Math.min(max, Math.max(min, value));
}
// Annotate the CommonJS export names for ESM import in node:
0 && (0);
//# sourceMappingURL=clamp.js.map


/***/ }),

/***/ 83608:
/***/ ((module) => {

"use strict";

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var composeEventHandlers_exports = {};
__export(composeEventHandlers_exports, {
  composeEventHandlers: () => composeEventHandlers
});
module.exports = __toCommonJS(composeEventHandlers_exports);
function composeEventHandlers(og, next, { checkDefaultPrevented = true } = {}) {
  if (!og || !next) {
    return next || og;
  }
  return function composedEventHandler(event) {
    og == null ? void 0 : og(event);
    if (!event || !(checkDefaultPrevented && "defaultPrevented" in event) || // @ts-ignore
    "defaultPrevented" in event && !event.defaultPrevented) {
      return next == null ? void 0 : next(event);
    }
  };
}
// Annotate the CommonJS export names for ESM import in node:
0 && (0);
//# sourceMappingURL=composeEventHandlers.js.map


/***/ }),

/***/ 26039:
/***/ ((module) => {

"use strict";

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var concatClassName_exports = {};
__export(concatClassName_exports, {
  concatClassName: () => concatClassName
});
module.exports = __toCommonJS(concatClassName_exports);
function concatClassName(_cn) {
  const args = arguments;
  const usedPrefixes = [];
  let final = "";
  const len = args.length;
  let propObjects = null;
  for (let x = len; x >= 0; x--) {
    const cns = args[x];
    if (!cns)
      continue;
    if (!Array.isArray(cns) && typeof cns !== "string") {
      propObjects = propObjects || [];
      propObjects.push(cns);
      continue;
    }
    const names = Array.isArray(cns) ? cns : cns.split(" ");
    const numNames = names.length;
    for (let i = numNames - 1; i >= 0; i--) {
      const name = names[i];
      if (!name || name === " ")
        continue;
      if (name[0] !== "_") {
        final = name + " " + final;
        continue;
      }
      const splitIndex = name.indexOf("-");
      if (splitIndex < 1) {
        final = name + " " + final;
        continue;
      }
      const nextChar = name[splitIndex + 1];
      const isMediaQuery = nextChar === "_";
      const styleKey = name.slice(1, name.lastIndexOf("-"));
      const mediaKey = isMediaQuery ? name.slice(splitIndex + 2, splitIndex + 7) : null;
      const uid = mediaKey ? styleKey + mediaKey : styleKey;
      if (usedPrefixes.indexOf(uid) > -1) {
        continue;
      }
      usedPrefixes.push(uid);
      const propName = styleKey;
      if (propName && propObjects) {
        if (propObjects.some((po) => {
          if (mediaKey) {
            const propKey = pseudoInvert[mediaKey];
            return po && po[propKey] && propName in po[propKey] && po[propKey] !== null;
          }
          const res = po && propName in po && po[propName] !== null;
          return res;
        })) {
          continue;
        }
      }
      final = name + " " + final;
    }
  }
  return final;
}
const pseudoInvert = {
  hover: "hoverStyle",
  focus: "focusStyle",
  press: "pressStyle"
};
// Annotate the CommonJS export names for ESM import in node:
0 && (0);
//# sourceMappingURL=concatClassName.js.map


/***/ }),

/***/ 37513:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __reExport = (target, mod, secondTarget) => (__copyProps(target, mod, "default"), secondTarget && __copyProps(secondTarget, mod, "default"));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var src_exports = {};
module.exports = __toCommonJS(src_exports);
__reExport(src_exports, __webpack_require__(35833), module.exports);
__reExport(src_exports, __webpack_require__(83608), module.exports);
__reExport(src_exports, __webpack_require__(26039), module.exports);
__reExport(src_exports, __webpack_require__(13531), module.exports);
__reExport(src_exports, __webpack_require__(42234), module.exports);
__reExport(src_exports, __webpack_require__(14837), module.exports);
//# sourceMappingURL=index.js.map


/***/ }),

/***/ 42234:
/***/ ((module) => {

"use strict";

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var types_exports = {};
module.exports = __toCommonJS(types_exports);
//# sourceMappingURL=types.js.map


/***/ }),

/***/ 13531:
/***/ ((module) => {

"use strict";

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var validStyleProps_exports = {};
__export(validStyleProps_exports, {
  stylePropsAll: () => stylePropsAll,
  stylePropsText: () => stylePropsText,
  stylePropsTextOnly: () => stylePropsTextOnly,
  stylePropsTransform: () => stylePropsTransform,
  stylePropsView: () => stylePropsView,
  validPseudoKeys: () => validPseudoKeys,
  validStyles: () => validStyles,
  validStylesOnBaseProps: () => validStylesOnBaseProps
});
module.exports = __toCommonJS(validStyleProps_exports);
const stylePropsTransform = Object.freeze({
  x: true,
  y: true,
  scale: true,
  perspective: true,
  scaleX: true,
  scaleY: true,
  skewX: true,
  skewY: true,
  matrix: true,
  rotate: true,
  rotateY: true,
  rotateX: true,
  rotateZ: true
});
const validStylesOnBaseProps = Object.freeze({
  placeholderTextColor: true
});
const stylePropsView = Object.freeze({
  backfaceVisibility: true,
  backgroundColor: true,
  borderBottomColor: true,
  borderBottomEndRadius: true,
  borderBottomLeftRadius: true,
  borderBottomRightRadius: true,
  borderBottomStartRadius: true,
  borderBottomWidth: true,
  borderColor: true,
  borderEndColor: true,
  borderLeftColor: true,
  borderLeftWidth: true,
  borderRadius: true,
  borderRightColor: true,
  borderRightWidth: true,
  borderStartColor: true,
  borderStyle: true,
  borderTopColor: true,
  borderTopEndRadius: true,
  borderTopLeftRadius: true,
  borderTopRightRadius: true,
  borderTopStartRadius: true,
  borderTopWidth: true,
  borderWidth: true,
  opacity: true,
  transform: true,
  alignContent: true,
  alignItems: true,
  alignSelf: true,
  aspectRatio: true,
  borderEndWidth: true,
  borderStartWidth: true,
  bottom: true,
  display: true,
  end: true,
  flex: true,
  flexBasis: true,
  flexDirection: true,
  flexGrow: true,
  flexShrink: true,
  flexWrap: true,
  gap: true,
  gapColumn: true,
  gapRow: true,
  height: true,
  justifyContent: true,
  left: true,
  margin: true,
  marginBottom: true,
  marginEnd: true,
  marginHorizontal: true,
  marginLeft: true,
  marginRight: true,
  marginStart: true,
  marginTop: true,
  marginVertical: true,
  maxHeight: true,
  maxWidth: true,
  minHeight: true,
  minWidth: true,
  overflow: true,
  padding: true,
  paddingBottom: true,
  paddingEnd: true,
  paddingHorizontal: true,
  paddingLeft: true,
  paddingRight: true,
  paddingStart: true,
  paddingTop: true,
  paddingVertical: true,
  position: true,
  right: true,
  start: true,
  top: true,
  width: true,
  zIndex: true,
  direction: true,
  shadowColor: true,
  shadowOffset: true,
  shadowOpacity: true,
  shadowRadius: true,
  ...validStylesOnBaseProps,
  ...stylePropsTransform,
  // allow a few web only ones
  ... true && {
    // RN doesn't support specific border styles per-edge
    borderBottomStyle: true,
    borderTopStyle: true,
    borderLeftStyle: true,
    borderRightStyle: true,
    overflowX: true,
    overflowY: true,
    userSelect: true,
    cursor: true,
    contain: true,
    pointerEvents: true,
    boxSizing: true,
    boxShadow: true,
    outlineColor: true,
    outlineStyle: true,
    outlineOffset: true,
    outlineWidth: true
  }
});
const stylePropsTextOnly = Object.freeze({
  color: true,
  fontFamily: true,
  fontSize: true,
  fontStyle: true,
  fontWeight: true,
  letterSpacing: true,
  lineHeight: true,
  textAlign: true,
  textDecorationLine: true,
  textDecorationStyle: true,
  textDecorationColor: true,
  textShadowColor: true,
  textShadowOffset: true,
  textShadowRadius: true,
  textTransform: true,
  // allow some web only ones
  ... true && {
    whiteSpace: true,
    wordWrap: true,
    textOverflow: true,
    textDecorationDistance: true,
    userSelect: true,
    selectable: true,
    cursor: true,
    WebkitLineClamp: true,
    WebkitBoxOrient: true
  }
});
const stylePropsText = Object.freeze({
  ...stylePropsView,
  ...stylePropsTextOnly
});
const stylePropsAll = stylePropsText;
const validPseudoKeys = Object.freeze({
  enterStyle: true,
  exitStyle: true,
  hoverStyle: true,
  pressStyle: true,
  focusStyle: true
});
const validStyles = Object.freeze({
  ...validPseudoKeys,
  ...stylePropsView
});
// Annotate the CommonJS export names for ESM import in node:
0 && (0);
//# sourceMappingURL=validStyleProps.js.map


/***/ }),

/***/ 90251:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __reExport = (target, mod, secondTarget) => (__copyProps(target, mod, "default"), secondTarget && __copyProps(secondTarget, mod, "default"));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var NextTheme_exports = {};
module.exports = __toCommonJS(NextTheme_exports);
__reExport(NextTheme_exports, __webpack_require__(75687), module.exports);
__reExport(NextTheme_exports, __webpack_require__(55896), module.exports);
__reExport(NextTheme_exports, __webpack_require__(40392), module.exports);
__reExport(NextTheme_exports, __webpack_require__(46905), module.exports);
__reExport(NextTheme_exports, __webpack_require__(71440), module.exports);
__reExport(NextTheme_exports, __webpack_require__(3169), module.exports);
__reExport(NextTheme_exports, __webpack_require__(26423), module.exports);
__reExport(NextTheme_exports, __webpack_require__(1705), module.exports);
//# sourceMappingURL=NextTheme.js.map


/***/ }),

/***/ 75687:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var NextThemeProvider_exports = {};
__export(NextThemeProvider_exports, {
  NextThemeProvider: () => NextThemeProvider
});
module.exports = __toCommonJS(NextThemeProvider_exports);
var import_jsx_runtime = __webpack_require__(85893);
var import_use_event = __webpack_require__(90951);
var import_head = __toESM(__webpack_require__(40968));
var React = __toESM(__webpack_require__(16689));
var import_react = __webpack_require__(16689);
var import_constants = __webpack_require__(71440);
var import_helpers = __webpack_require__(46905);
var import_ThemeSettingContext = __webpack_require__(55896);
var import_useIsomorphicLayoutEffect = __webpack_require__(55285);
const NextThemeProvider = ({
  forcedTheme,
  disableTransitionOnChange = true,
  enableSystem = true,
  enableColorScheme = true,
  storageKey = "theme",
  themes = import_constants.colorSchemes,
  defaultTheme = enableSystem ? "system" : "light",
  attribute = "class",
  skipNextHead,
  onChangeTheme,
  value = {
    dark: "t_dark",
    light: "t_light"
  },
  children
}) => {
  const [theme, setThemeState] = (0, import_react.useState)(() => (0, import_helpers.getTheme)(storageKey, defaultTheme));
  const [resolvedTheme, setResolvedTheme] = (0, import_react.useState)(() => (0, import_helpers.getTheme)(storageKey));
  const attrs = !value ? themes : Object.values(value);
  const handleMediaQuery = (0, import_use_event.useEvent)((e) => {
    const systemTheme2 = (0, import_helpers.getSystemTheme)(e);
    React.startTransition(() => {
      setResolvedTheme(systemTheme2);
    });
    if (theme === "system" && !forcedTheme) {
      handleChangeTheme(systemTheme2, false);
    }
  });
  const mediaListener = (0, import_react.useRef)(handleMediaQuery);
  mediaListener.current = handleMediaQuery;
  const handleChangeTheme = (0, import_use_event.useEvent)((theme2, updateStorage = true, updateDOM = true) => {
    let name = (value == null ? void 0 : value[theme2]) || theme2;
    if (updateStorage) {
      try {
        localStorage.setItem(storageKey, theme2);
      } catch (e) {
      }
    }
    if (theme2 === "system" && enableSystem) {
      const resolved = (0, import_helpers.getSystemTheme)();
      name = (value == null ? void 0 : value[resolved]) || resolved;
    }
    onChangeTheme == null ? void 0 : onChangeTheme(name.replace("t_", ""));
    if (updateDOM) {
      const d = document.documentElement;
      if (attribute === "class") {
        d.classList.remove(...attrs);
        d.classList.add(name);
      } else {
        d.setAttribute(attribute, name);
      }
    }
  });
  (0, import_useIsomorphicLayoutEffect.useIsomorphicLayoutEffect)(() => {
    const handler = (...args) => mediaListener.current(...args);
    const media = window.matchMedia(import_constants.MEDIA);
    media.addListener(handler);
    handler(media);
    return () => {
      media.removeListener(handler);
    };
  }, []);
  const set = (0, import_use_event.useEvent)((newTheme) => {
    if (forcedTheme) {
      handleChangeTheme(newTheme, true, false);
    } else {
      handleChangeTheme(newTheme);
    }
    setThemeState(newTheme);
  });
  (0, import_react.useEffect)(() => {
    const handleStorage = (e) => {
      if (e.key !== storageKey) {
        return;
      }
      const theme2 = e.newValue || defaultTheme;
      set(theme2);
    };
    window.addEventListener("storage", handleStorage);
    return () => {
      window.removeEventListener("storage", handleStorage);
    };
  }, [defaultTheme, set, storageKey]);
  (0, import_useIsomorphicLayoutEffect.useIsomorphicLayoutEffect)(() => {
    if (!enableColorScheme)
      return;
    const colorScheme = (
      // If theme is forced to light or dark, use that
      forcedTheme && import_constants.colorSchemes.includes(forcedTheme) ? forcedTheme : (
        // If regular theme is light or dark
        theme && import_constants.colorSchemes.includes(theme) ? theme : (
          // If theme is system, use the resolved version
          theme === "system" ? resolvedTheme || null : null
        )
      )
    );
    const userPrefers = typeof window !== "undefined" && window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light";
    const wePrefer = colorScheme || "light";
    if (userPrefers !== wePrefer || wePrefer === "dark") {
      document.documentElement.style.setProperty("color-scheme", colorScheme);
    }
  }, [enableColorScheme, theme, resolvedTheme, forcedTheme]);
  const toggle = (0, import_use_event.useEvent)(() => {
    const order = resolvedTheme === "dark" ? ["system", "light", "dark"] : ["system", "dark", "light"];
    const next = order[(order.indexOf(theme) + 1) % order.length];
    set(next);
  });
  const contextResolvedTheme = theme === "system" ? resolvedTheme : theme;
  const systemTheme = enableSystem ? resolvedTheme : void 0;
  const contextValue = (0, import_react.useMemo)(() => {
    const value2 = {
      theme,
      current: theme,
      set,
      toggle,
      forcedTheme,
      resolvedTheme: contextResolvedTheme,
      themes: enableSystem ? [...themes, "system"] : themes,
      systemTheme
    };
    return value2;
  }, [
    theme,
    set,
    toggle,
    forcedTheme,
    contextResolvedTheme,
    enableSystem,
    themes,
    systemTheme
  ]);
  return /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(import_ThemeSettingContext.ThemeSettingContext.Provider, { value: contextValue, children: [
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
      ThemeScript,
      {
        ...{
          forcedTheme,
          storageKey,
          systemTheme: resolvedTheme,
          attribute,
          value,
          enableSystem,
          defaultTheme,
          attrs,
          skipNextHead
        }
      }
    ),
    (0, import_react.useMemo)(() => children, [children])
  ] });
};
const ThemeScript = (0, import_react.memo)(
  ({
    forcedTheme,
    storageKey,
    attribute,
    enableSystem,
    defaultTheme,
    value,
    attrs,
    skipNextHead
  }) => {
    const optimization = (() => {
      if (attribute === "class") {
        const removeClasses = attrs.map((t) => `d.remove('${t}')`).join(";");
        return `var d=document.documentElement.classList;${removeClasses};`;
      } else {
        return `var d=document.documentElement;`;
      }
    })();
    const updateDOM = (name, literal) => {
      name = (value == null ? void 0 : value[name]) || name;
      const val = literal ? name : `'${name}'`;
      if (attribute === "class") {
        return `d.add(${val})`;
      }
      return `d.setAttribute('${attribute}', ${val})`;
    };
    const defaultSystem = defaultTheme === "system";
    const contents = /* @__PURE__ */ (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, { children: forcedTheme ? /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
      "script",
      {
        dangerouslySetInnerHTML: {
          // These are minified via Terser and then updated by hand, don't recommend
          __html: `!function(){${optimization}${updateDOM(forcedTheme)}}()`
        }
      },
      "next-themes-script"
    ) : enableSystem ? /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
      "script",
      {
        dangerouslySetInnerHTML: {
          __html: `!function(){try {${optimization}var e=localStorage.getItem('${storageKey}');${!defaultSystem ? updateDOM(defaultTheme) + ";" : ""}if("system"===e||(!e&&${defaultSystem})){var t="${import_constants.MEDIA}",m=window.matchMedia(t);m.media!==t||m.matches?${updateDOM(
            "dark"
          )}:${updateDOM("light")}}else if(e) ${value ? `var x=${JSON.stringify(value)};` : ""}${updateDOM(value ? "x[e]" : "e", true)}}catch(e){}}()`
        }
      },
      "next-themes-script"
    ) : /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
      "script",
      {
        dangerouslySetInnerHTML: {
          __html: `!function(){try{${optimization}var e=localStorage.getItem("${storageKey}");if(e){${value ? `var x=${JSON.stringify(value)};` : ""}${updateDOM(value ? "x[e]" : "e", true)}}else{${updateDOM(
            defaultTheme
          )};}}catch(t){}}();`
        }
      },
      "next-themes-script"
    ) });
    if (skipNextHead)
      return contents;
    return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(import_head.default, { children: contents });
  },
  (prevProps, nextProps) => {
    if (prevProps.forcedTheme !== nextProps.forcedTheme)
      return false;
    return true;
  }
);
// Annotate the CommonJS export names for ESM import in node:
0 && (0);
//# sourceMappingURL=NextThemeProvider.js.map


/***/ }),

/***/ 55896:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var ThemeSettingContext_exports = {};
__export(ThemeSettingContext_exports, {
  ThemeSettingContext: () => ThemeSettingContext
});
module.exports = __toCommonJS(ThemeSettingContext_exports);
var import_react = __webpack_require__(16689);
const ThemeSettingContext = (0, import_react.createContext)({
  toggle: () => {
  },
  set: (_) => {
  },
  themes: []
});
// Annotate the CommonJS export names for ESM import in node:
0 && (0);
//# sourceMappingURL=ThemeSettingContext.js.map


/***/ }),

/***/ 40392:
/***/ ((module) => {

"use strict";

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var UseThemeProps_exports = {};
module.exports = __toCommonJS(UseThemeProps_exports);
//# sourceMappingURL=UseThemeProps.js.map


/***/ }),

/***/ 71440:
/***/ ((module) => {

"use strict";

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var constants_exports = {};
__export(constants_exports, {
  MEDIA: () => MEDIA,
  colorSchemes: () => colorSchemes,
  constants: () => constants
});
module.exports = __toCommonJS(constants_exports);
const constants = {};
const colorSchemes = ["light", "dark"];
const MEDIA = "(prefers-color-scheme: dark)";
// Annotate the CommonJS export names for ESM import in node:
0 && (0);
//# sourceMappingURL=constants.js.map


/***/ }),

/***/ 46905:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var helpers_exports = {};
__export(helpers_exports, {
  getSystemTheme: () => getSystemTheme,
  getTheme: () => getTheme,
  helpers: () => helpers
});
module.exports = __toCommonJS(helpers_exports);
var import_constants = __webpack_require__(71440);
const helpers = {};
const getTheme = (key, fallback) => {
  if (typeof window === "undefined")
    return void 0;
  let theme;
  try {
    theme = localStorage.getItem(key) || void 0;
  } catch (e) {
  }
  return theme || fallback;
};
const getSystemTheme = (e) => {
  if (!e) {
    e = window.matchMedia(import_constants.MEDIA);
  }
  const isDark = e.matches;
  const systemTheme = isDark ? "dark" : "light";
  return systemTheme;
};
// Annotate the CommonJS export names for ESM import in node:
0 && (0);
//# sourceMappingURL=helpers.js.map


/***/ }),

/***/ 70552:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __reExport = (target, mod, secondTarget) => (__copyProps(target, mod, "default"), secondTarget && __copyProps(secondTarget, mod, "default"));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var src_exports = {};
module.exports = __toCommonJS(src_exports);
__reExport(src_exports, __webpack_require__(90251), module.exports);
//# sourceMappingURL=index.js.map


/***/ }),

/***/ 26423:
/***/ ((module) => {

"use strict";

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var types_exports = {};
module.exports = __toCommonJS(types_exports);
//# sourceMappingURL=types.js.map


/***/ }),

/***/ 55285:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var useIsomorphicLayoutEffect_exports = {};
__export(useIsomorphicLayoutEffect_exports, {
  useIsomorphicLayoutEffect: () => useIsomorphicLayoutEffect
});
module.exports = __toCommonJS(useIsomorphicLayoutEffect_exports);
var import_react = __webpack_require__(16689);
const useIsomorphicLayoutEffect = typeof window !== "undefined" ? import_react.useLayoutEffect : import_react.useEffect;
// Annotate the CommonJS export names for ESM import in node:
0 && (0);
//# sourceMappingURL=useIsomorphicLayoutEffect.js.map


/***/ }),

/***/ 1705:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var useRootTheme_exports = {};
__export(useRootTheme_exports, {
  useRootTheme: () => useRootTheme
});
module.exports = __toCommonJS(useRootTheme_exports);
var React = __toESM(__webpack_require__(16689));
var import_react = __webpack_require__(16689);
const useRootTheme = () => {
  const [val, setVal] = (0, import_react.useState)("light");
  if (typeof document !== "undefined") {
    (0, import_react.useLayoutEffect)(() => {
      const classes = [...document.documentElement.classList];
      const isDark = classes.includes("t_dark");
      React.startTransition(() => {
        setVal(isDark ? "dark" : "light");
      });
    }, []);
  }
  return [val, setVal];
};
// Annotate the CommonJS export names for ESM import in node:
0 && (0);
//# sourceMappingURL=useRootTheme.js.map


/***/ }),

/***/ 3169:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var useTheme_exports = {};
__export(useTheme_exports, {
  useTheme: () => useTheme,
  useThemeSetting: () => useThemeSetting
});
module.exports = __toCommonJS(useTheme_exports);
var import_react = __webpack_require__(16689);
var import_ThemeSettingContext = __webpack_require__(55896);
const useTheme = () => (0, import_react.useContext)(import_ThemeSettingContext.ThemeSettingContext);
const useThemeSetting = () => (0, import_react.useContext)(import_ThemeSettingContext.ThemeSettingContext);
// Annotate the CommonJS export names for ESM import in node:
0 && (0);
//# sourceMappingURL=useTheme.js.map


/***/ }),

/***/ 17285:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var src_exports = {};
__export(src_exports, {
  default: () => src_default,
  names: () => import_names2.names,
  normalizeCSSColor: () => normalizeCSSColor,
  rgba: () => rgba
});
module.exports = __toCommonJS(src_exports);
var import_names = __webpack_require__(23302);
var import_names2 = __webpack_require__(23302);
function normalizeCSSColor(color) {
  let match = null;
  if (color in import_names.names) {
    return import_names.names[color];
  }
  if (typeof color === "number") {
    if (color >>> 0 === color && color >= 0 && color <= 4294967295) {
      return color;
    }
    return null;
  }
  if (match = matchers.hex6.exec(color)) {
    return parseInt(match[1] + "ff", 16) >>> 0;
  }
  if (match = matchers.rgb.exec(color)) {
    return (parse255(match[1]) << 24 | // r
    parse255(match[2]) << 16 | // g
    parse255(match[3]) << 8 | // b
    255) >>> // a
    0;
  }
  if (match = matchers.rgba.exec(color)) {
    return (parse255(match[1]) << 24 | // r
    parse255(match[2]) << 16 | // g
    parse255(match[3]) << 8 | // b
    parse1(match[4])) >>> // a
    0;
  }
  if (match = matchers.hex3.exec(color)) {
    return parseInt(
      match[1] + match[1] + // r
      match[2] + match[2] + // g
      match[3] + match[3] + // b
      "ff",
      // a
      16
    ) >>> 0;
  }
  if (match = matchers.hex8.exec(color)) {
    return parseInt(match[1], 16) >>> 0;
  }
  if (match = matchers.hex4.exec(color)) {
    return parseInt(
      match[1] + match[1] + // r
      match[2] + match[2] + // g
      match[3] + match[3] + // b
      match[4] + match[4],
      // a
      16
    ) >>> 0;
  }
  if (match = matchers.hsl.exec(color)) {
    return (hslToRgb(
      parse360(match[1]),
      // h
      parsePercentage(match[2]),
      // s
      parsePercentage(match[3])
      // l
    ) | 255) >>> // a
    0;
  }
  if (match = matchers.hsla.exec(color)) {
    return (hslToRgb(
      parse360(match[1]),
      // h
      parsePercentage(match[2]),
      // s
      parsePercentage(match[3])
      // l
    ) | parse1(match[4])) >>> // a
    0;
  }
  return null;
}
function hue2rgb(p, q, t) {
  if (t < 0) {
    t += 1;
  }
  if (t > 1) {
    t -= 1;
  }
  if (t < 1 / 6) {
    return p + (q - p) * 6 * t;
  }
  if (t < 1 / 2) {
    return q;
  }
  if (t < 2 / 3) {
    return p + (q - p) * (2 / 3 - t) * 6;
  }
  return p;
}
function hslToRgb(h, s, l) {
  var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
  var p = 2 * l - q;
  var r = hue2rgb(p, q, h + 1 / 3);
  var g = hue2rgb(p, q, h);
  var b = hue2rgb(p, q, h - 1 / 3);
  return Math.round(r * 255) << 24 | Math.round(g * 255) << 16 | Math.round(b * 255) << 8;
}
var NUMBER = "[-+]?\\d*\\.?\\d+";
var PERCENTAGE = NUMBER + "%";
function call(...args) {
  return "\\(\\s*(" + args.join(")\\s*,\\s*(") + ")\\s*\\)";
}
var matchers = {
  rgb: new RegExp("rgb" + call(NUMBER, NUMBER, NUMBER)),
  rgba: new RegExp("rgba" + call(NUMBER, NUMBER, NUMBER, NUMBER)),
  hsl: new RegExp("hsl" + call(NUMBER, PERCENTAGE, PERCENTAGE)),
  hsla: new RegExp("hsla" + call(NUMBER, PERCENTAGE, PERCENTAGE, NUMBER)),
  hex3: /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
  hex4: /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
  hex6: /^#([0-9a-fA-F]{6})$/,
  hex8: /^#([0-9a-fA-F]{8})$/
};
function parse255(str) {
  var int = parseInt(str, 10);
  if (int < 0) {
    return 0;
  }
  if (int > 255) {
    return 255;
  }
  return int;
}
function parse360(str) {
  var int = parseFloat(str);
  return (int % 360 + 360) % 360 / 360;
}
function parse1(str) {
  var num = parseFloat(str);
  if (num < 0) {
    return 0;
  }
  if (num > 1) {
    return 255;
  }
  return Math.round(num * 255);
}
function parsePercentage(str) {
  const int = parseFloat(str, 10);
  if (int < 0) {
    return 0;
  }
  if (int > 100) {
    return 1;
  }
  return int / 100;
}
function rgba(colorInt) {
  var r = Math.round((colorInt & 4278190080) >>> 24);
  var g = Math.round((colorInt & 16711680) >>> 16);
  var b = Math.round((colorInt & 65280) >>> 8);
  var a = ((colorInt & 255) >>> 0) / 255;
  return {
    r,
    g,
    b,
    a
  };
}
var src_default = normalizeCSSColor;
// Annotate the CommonJS export names for ESM import in node:
0 && (0);
//# sourceMappingURL=index.js.map


/***/ }),

/***/ 23302:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var names_exports = {};
__export(names_exports, {
  names: () => names
});
module.exports = __toCommonJS(names_exports);
const names = {
  // keep the basics
  transparent: 0,
  white: 4294967295,
  black: 255
};
if (process.env.INCLUDE_CSS_COLOR_NAMES || "web" === "native") {
  const allNames = (__webpack_require__(55575).names);
  Object.assign(names, allNames);
}
// Annotate the CommonJS export names for ESM import in node:
0 && (0);
//# sourceMappingURL=names.js.map


/***/ }),

/***/ 55575:
/***/ ((module) => {

"use strict";

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var names_native_exports = {};
__export(names_native_exports, {
  names: () => names
});
module.exports = __toCommonJS(names_native_exports);
const names = {
  transparent: 0,
  // http://www.w3.org/TR/css3-color/#svg-color
  aliceblue: 4042850303,
  antiquewhite: 4209760255,
  aqua: 16777215,
  aquamarine: 2147472639,
  azure: 4043309055,
  beige: 4126530815,
  bisque: 4293182719,
  black: 255,
  blanchedalmond: 4293643775,
  blue: 65535,
  blueviolet: 2318131967,
  brown: 2771004159,
  burlywood: 3736635391,
  burntsienna: 3934150143,
  cadetblue: 1604231423,
  chartreuse: 2147418367,
  chocolate: 3530104575,
  coral: 4286533887,
  cornflowerblue: 1687547391,
  cornsilk: 4294499583,
  crimson: 3692313855,
  cyan: 16777215,
  darkblue: 35839,
  darkcyan: 9145343,
  darkgoldenrod: 3095792639,
  darkgray: 2846468607,
  darkgreen: 6553855,
  darkgrey: 2846468607,
  darkkhaki: 3182914559,
  darkmagenta: 2332068863,
  darkolivegreen: 1433087999,
  darkorange: 4287365375,
  darkorchid: 2570243327,
  darkred: 2332033279,
  darksalmon: 3918953215,
  darkseagreen: 2411499519,
  darkslateblue: 1211993087,
  darkslategray: 793726975,
  darkslategrey: 793726975,
  darkturquoise: 13554175,
  darkviolet: 2483082239,
  deeppink: 4279538687,
  deepskyblue: 12582911,
  dimgray: 1768516095,
  dimgrey: 1768516095,
  dodgerblue: 512819199,
  firebrick: 2988581631,
  floralwhite: 4294635775,
  forestgreen: 579543807,
  fuchsia: 4278255615,
  gainsboro: 3705462015,
  ghostwhite: 4177068031,
  gold: 4292280575,
  goldenrod: 3668254975,
  gray: 2155905279,
  green: 8388863,
  greenyellow: 2919182335,
  grey: 2155905279,
  honeydew: 4043305215,
  hotpink: 4285117695,
  indianred: 3445382399,
  indigo: 1258324735,
  ivory: 4294963455,
  khaki: 4041641215,
  lavender: 3873897215,
  lavenderblush: 4293981695,
  lawngreen: 2096890111,
  lemonchiffon: 4294626815,
  lightblue: 2916673279,
  lightcoral: 4034953471,
  lightcyan: 3774873599,
  lightgoldenrodyellow: 4210742015,
  lightgray: 3553874943,
  lightgreen: 2431553791,
  lightgrey: 3553874943,
  lightpink: 4290167295,
  lightsalmon: 4288707327,
  lightseagreen: 548580095,
  lightskyblue: 2278488831,
  lightslategray: 2005441023,
  lightslategrey: 2005441023,
  lightsteelblue: 2965692159,
  lightyellow: 4294959359,
  lime: 16711935,
  limegreen: 852308735,
  linen: 4210091775,
  magenta: 4278255615,
  maroon: 2147483903,
  mediumaquamarine: 1724754687,
  mediumblue: 52735,
  mediumorchid: 3126187007,
  mediumpurple: 2473647103,
  mediumseagreen: 1018393087,
  mediumslateblue: 2070474495,
  mediumspringgreen: 16423679,
  mediumturquoise: 1221709055,
  mediumvioletred: 3340076543,
  midnightblue: 421097727,
  mintcream: 4127193855,
  mistyrose: 4293190143,
  moccasin: 4293178879,
  navajowhite: 4292783615,
  navy: 33023,
  oldlace: 4260751103,
  olive: 2155872511,
  olivedrab: 1804477439,
  orange: 4289003775,
  orangered: 4282712319,
  orchid: 3664828159,
  palegoldenrod: 4008225535,
  palegreen: 2566625535,
  paleturquoise: 2951671551,
  palevioletred: 3681588223,
  papayawhip: 4293907967,
  peachpuff: 4292524543,
  peru: 3448061951,
  pink: 4290825215,
  plum: 3718307327,
  powderblue: 2967529215,
  purple: 2147516671,
  rebeccapurple: 1714657791,
  red: 4278190335,
  rosybrown: 3163525119,
  royalblue: 1097458175,
  saddlebrown: 2336560127,
  salmon: 4202722047,
  sandybrown: 4104413439,
  seagreen: 780883967,
  seashell: 4294307583,
  sienna: 2689740287,
  silver: 3233857791,
  skyblue: 2278484991,
  slateblue: 1784335871,
  slategray: 1887473919,
  slategrey: 1887473919,
  snow: 4294638335,
  springgreen: 16744447,
  steelblue: 1182971135,
  tan: 3535047935,
  teal: 8421631,
  thistle: 3636451583,
  tomato: 4284696575,
  turquoise: 1088475391,
  violet: 4001558271,
  wheat: 4125012991,
  white: 4294967295,
  whitesmoke: 4126537215,
  yellow: 4294902015,
  yellowgreen: 2597139199
};
// Annotate the CommonJS export names for ESM import in node:
0 && (0);
//# sourceMappingURL=names.native.js.map


/***/ }),

/***/ 65190:
/***/ (() => {

if (typeof globalThis['__DEV__'] === 'undefined') {
  globalThis['__DEV__'] = "production" === 'development'
}


/***/ }),

/***/ 55980:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var GorhomPortal_exports = {};
__export(GorhomPortal_exports, {
  ACTIONS: () => ACTIONS,
  INITIAL_STATE: () => INITIAL_STATE,
  PortalHost: () => PortalHost,
  PortalItem: () => PortalItem,
  PortalProvider: () => PortalProvider,
  usePortal: () => usePortal
});
module.exports = __toCommonJS(GorhomPortal_exports);
var import_jsx_runtime = __webpack_require__(85893);
var import_core = __webpack_require__(86872);
var import_react = __toESM(__webpack_require__(16689));
var ACTIONS = /* @__PURE__ */ ((ACTIONS2) => {
  ACTIONS2[ACTIONS2["REGISTER_HOST"] = 0] = "REGISTER_HOST";
  ACTIONS2[ACTIONS2["DEREGISTER_HOST"] = 1] = "DEREGISTER_HOST";
  ACTIONS2[ACTIONS2["ADD_UPDATE_PORTAL"] = 2] = "ADD_UPDATE_PORTAL";
  ACTIONS2[ACTIONS2["REMOVE_PORTAL"] = 3] = "REMOVE_PORTAL";
  return ACTIONS2;
})(ACTIONS || {});
const INITIAL_STATE = {};
const registerHost = (state, hostName) => {
  if (!(hostName in state)) {
    state[hostName] = [];
  }
  return state;
};
const deregisterHost = (state, hostName) => {
  delete state[hostName];
  return state;
};
const addUpdatePortal = (state, hostName, portalName, node) => {
  if (!(hostName in state)) {
    state = registerHost(state, hostName);
  }
  const index = state[hostName].findIndex((item) => item.name === portalName);
  if (index !== -1) {
    state[hostName][index].node = node;
  } else {
    state[hostName].push({
      name: portalName,
      node
    });
  }
  return state;
};
const removePortal = (state, hostName, portalName) => {
  if (!(hostName in state)) {
    console.log(
      `Failed to remove portal '${portalName}', '${hostName}' was not registered!`
    );
    return state;
  }
  const index = state[hostName].findIndex((item) => item.name === portalName);
  if (index !== -1)
    state[hostName].splice(index, 1);
  return state;
};
const reducer = (state, action) => {
  const { type } = action;
  switch (type) {
    case 0 /* REGISTER_HOST */:
      return registerHost({ ...state }, action.hostName);
    case 1 /* DEREGISTER_HOST */:
      return deregisterHost({ ...state }, action.hostName);
    case 2 /* ADD_UPDATE_PORTAL */:
      return addUpdatePortal(
        { ...state },
        action.hostName,
        action.portalName,
        action.node
      );
    case 3 /* REMOVE_PORTAL */:
      return removePortal(
        { ...state },
        action.hostName,
        action.portalName
      );
    default:
      return state;
  }
};
const PortalStateContext = (0, import_react.createContext)(null);
const PortalDispatchContext = (0, import_react.createContext)(null);
const usePortalState = (hostName) => {
  const state = (0, import_react.useContext)(PortalStateContext);
  if (state === null) {
    throw new Error(
      "'PortalStateContext' cannot be null, please add 'PortalProvider' to the root component."
    );
  }
  return state[hostName] || [];
};
const usePortal = (hostName = "root") => {
  const dispatch = (0, import_react.useContext)(PortalDispatchContext);
  if (dispatch === null) {
    throw new Error(
      "'PortalDispatchContext' cannot be null, please add 'PortalProvider' to the root component."
    );
  }
  const registerHost2 = (0, import_react.useCallback)(() => {
    dispatch({
      type: 0 /* REGISTER_HOST */,
      hostName
    });
  }, []);
  const deregisterHost2 = (0, import_react.useCallback)(() => {
    dispatch({
      type: 1 /* DEREGISTER_HOST */,
      hostName
    });
  }, []);
  const addUpdatePortal2 = (0, import_react.useCallback)((name, node) => {
    dispatch({
      type: 2 /* ADD_UPDATE_PORTAL */,
      hostName,
      portalName: name,
      node
    });
  }, []);
  const removePortal2 = (0, import_react.useCallback)((name) => {
    dispatch({
      type: 3 /* REMOVE_PORTAL */,
      hostName,
      portalName: name
    });
  }, []);
  return {
    registerHost: registerHost2,
    deregisterHost: deregisterHost2,
    addPortal: addUpdatePortal2,
    updatePortal: addUpdatePortal2,
    removePortal: removePortal2
  };
};
const PortalProviderComponent = ({
  rootHostName = "root",
  shouldAddRootHost = true,
  children
}) => {
  const [state, dispatch] = (0, import_react.useReducer)(reducer, INITIAL_STATE);
  const transitionDispatch = (0, import_react.useMemo)(() => {
    const next = (value) => {
      (0, import_react.startTransition)(() => {
        dispatch(value);
      });
    };
    return next;
  }, [dispatch]);
  return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(PortalDispatchContext.Provider, { value: transitionDispatch, children: /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(PortalStateContext.Provider, { value: state, children: [
    children,
    shouldAddRootHost && /* @__PURE__ */ (0, import_jsx_runtime.jsx)(PortalHost, { name: rootHostName })
  ] }) });
};
const PortalProvider = (0, import_react.memo)(PortalProviderComponent);
PortalProvider.displayName = "PortalProvider";
const PortalHostComponent = (props) => {
  const { name, forwardProps } = props;
  const isServer = !(0, import_core.useDidFinishSSR)();
  const state = usePortalState(name);
  const { registerHost: registerHost2, deregisterHost: deregisterHost2 } = usePortal(props.name);
  (0, import_react.useEffect)(() => {
    if (isServer)
      return;
    registerHost2();
    return () => {
      deregisterHost2();
    };
  }, [isServer]);
  if (forwardProps) {
    return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, { children: state.map((item) => {
      let next = item.node;
      if (forwardProps) {
        return import_react.default.Children.map(next, (child) => {
          return import_react.default.isValidElement(child) ? import_react.default.cloneElement(child, { key: child.key, ...forwardProps }) : child;
        });
      }
      return next;
    }) });
  }
  return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, { children: state.map((item) => item.node) });
};
const PortalHost = (0, import_react.memo)(PortalHostComponent);
PortalHost.displayName = "PortalHost";
const PortalComponent = (props) => {
  const {
    name: _providedName,
    hostName,
    handleOnMount: _providedHandleOnMount,
    handleOnUnmount: _providedHandleOnUnmount,
    handleOnUpdate: _providedHandleOnUpdate,
    children
  } = props;
  const { addPortal: addUpdatePortal2, removePortal: removePortal2 } = usePortal(hostName);
  const id = (0, import_react.useId)();
  const name = _providedName || id;
  const handleOnMount = (0, import_core.useEvent)(() => {
    if (_providedHandleOnMount) {
      _providedHandleOnMount(() => addUpdatePortal2(name, children));
    } else {
      addUpdatePortal2(name, children);
    }
  });
  const handleOnUnmount = (0, import_core.useEvent)(() => {
    if (_providedHandleOnUnmount) {
      _providedHandleOnUnmount(() => removePortal2(name));
    } else {
      removePortal2(name);
    }
  });
  const handleOnUpdate = (0, import_core.useEvent)(() => {
    if (_providedHandleOnUpdate) {
      _providedHandleOnUpdate(() => addUpdatePortal2(name, children));
    } else {
      addUpdatePortal2(name, children);
    }
  });
  (0, import_core.useIsomorphicLayoutEffect)(() => {
    handleOnMount();
    return () => {
      handleOnUnmount();
    };
  }, []);
  (0, import_react.useEffect)(() => {
    handleOnUpdate();
  }, [children]);
  return null;
};
const PortalItem = (0, import_react.memo)(PortalComponent);
PortalItem.displayName = "Portal";
// Annotate the CommonJS export names for ESM import in node:
0 && (0);
//# sourceMappingURL=GorhomPortal.js.map


/***/ }),

/***/ 21228:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var Portal_exports = {};
__export(Portal_exports, {
  Portal: () => Portal
});
module.exports = __toCommonJS(Portal_exports);
var import_jsx_runtime = __webpack_require__(85893);
var import_polyfill_dev = __webpack_require__(65190);
var import_core = __webpack_require__(86872);
var import_stacks = __webpack_require__(90094);
var React = __toESM(__webpack_require__(16689));
var import_react_dom = __webpack_require__(66405);
const Portal = ({ host = ((_a) => (_a = globalThis.document) == null ? void 0 : _a.body)(), ...props }) => {
  const contents = /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
    import_stacks.YStack,
    {
      contain: "strict",
      fullscreen: true,
      position: import_core.isWeb ? "fixed" : "absolute",
      maxWidth: import_core.isWeb ? "100vw" : "100%",
      maxHeight: import_core.isWeb ? "100vh" : "100%",
      pointerEvents: "none",
      ...props
    }
  );
  const [hostElement, setHostElement] = React.useState(null);
  (0, import_core.useIsomorphicLayoutEffect)(() => {
    setHostElement(host);
  }, [host]);
  if (hostElement) {
    return (0, import_react_dom.createPortal)(contents, hostElement);
  }
  return null;
};
// Annotate the CommonJS export names for ESM import in node:
0 && (0);
//# sourceMappingURL=Portal.js.map


/***/ }),

/***/ 45458:
/***/ ((module) => {

"use strict";

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var PortalProps_exports = {};
module.exports = __toCommonJS(PortalProps_exports);
//# sourceMappingURL=PortalProps.js.map


/***/ }),

/***/ 38696:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __reExport = (target, mod, secondTarget) => (__copyProps(target, mod, "default"), secondTarget && __copyProps(secondTarget, mod, "default"));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var src_exports = {};
module.exports = __toCommonJS(src_exports);
__reExport(src_exports, __webpack_require__(21228), module.exports);
__reExport(src_exports, __webpack_require__(45458), module.exports);
__reExport(src_exports, __webpack_require__(55980), module.exports);
//# sourceMappingURL=index.js.map


/***/ }),

/***/ 62087:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var createMedia_exports = {};
__export(createMedia_exports, {
  createMedia: () => createMedia
});
module.exports = __toCommonJS(createMedia_exports);
var import_web = __webpack_require__(17187);
var import_matchMedia = __webpack_require__(28010);
function createMedia(media) {
  (0, import_web.setupMatchMedia)(import_matchMedia.matchMedia);
  return media;
}
// Annotate the CommonJS export names for ESM import in node:
0 && (0);
//# sourceMappingURL=createMedia.js.map


/***/ }),

/***/ 82440:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __reExport = (target, mod, secondTarget) => (__copyProps(target, mod, "default"), secondTarget && __copyProps(secondTarget, mod, "default"));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var src_exports = {};
module.exports = __toCommonJS(src_exports);
__reExport(src_exports, __webpack_require__(62087), module.exports);
__reExport(src_exports, __webpack_require__(28010), module.exports);
//# sourceMappingURL=index.js.map


/***/ }),

/***/ 28010:
/***/ ((module) => {

"use strict";

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var matchMedia_exports = {};
__export(matchMedia_exports, {
  matchMedia: () => matchMedia
});
module.exports = __toCommonJS(matchMedia_exports);
const matchMedia = globalThis["matchMedia"];
// Annotate the CommonJS export names for ESM import in node:
0 && (0);
//# sourceMappingURL=matchMedia.js.map


/***/ }),

/***/ 87837:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var src_exports = {};
__export(src_exports, {
  Circle: () => Circle,
  ClipPath: () => ClipPath,
  Defs: () => Defs,
  Ellipse: () => Ellipse,
  ForeignObject: () => ForeignObject,
  G: () => G,
  Image: () => Image,
  Line: () => Line,
  LinearGradient: () => LinearGradient,
  Marker: () => Marker,
  Mask: () => Mask,
  Path: () => Path,
  Pattern: () => Pattern,
  Polygon: () => Polygon,
  Polyline: () => Polyline,
  RadialGradient: () => RadialGradient,
  Rect: () => Rect,
  Shape: () => Shape,
  Stop: () => Stop,
  Svg: () => Svg,
  Symbol: () => Symbol2,
  TSpan: () => TSpan,
  Text: () => Text,
  TextPath: () => TextPath,
  Use: () => Use,
  default: () => src_default
});
module.exports = __toCommonJS(src_exports);
var import_react = __webpack_require__(16689);
const Circle = (p) => (0, import_react.createElement)("circle", p);
const ClipPath = (p) => (0, import_react.createElement)("clipPath", p);
const Defs = (p) => (0, import_react.createElement)("defs", p);
const Ellipse = (p) => (0, import_react.createElement)("ellipse", p);
const ForeignObject = (p) => (0, import_react.createElement)("foreignObject", p);
const G = (p) => (0, import_react.createElement)("g", p);
const Image = (p) => (0, import_react.createElement)("image", p);
const Line = (p) => (0, import_react.createElement)("line", p);
const LinearGradient = (p) => (0, import_react.createElement)("linearGradient", p);
const Marker = (p) => (0, import_react.createElement)("marker", p);
const Mask = (p) => (0, import_react.createElement)("mask", p);
const Path = (p) => (0, import_react.createElement)("path", p);
const Pattern = (p) => (0, import_react.createElement)("pattern", p);
const Polygon = (p) => (0, import_react.createElement)("polygon", p);
const Polyline = (p) => (0, import_react.createElement)("polyline", p);
const RadialGradient = (p) => (0, import_react.createElement)("radialGradient", p);
const Rect = (p) => (0, import_react.createElement)("rect", p);
const Shape = (p) => (0, import_react.createElement)("shape", p);
const Stop = (p) => (0, import_react.createElement)("stop", p);
const Svg = (p) => (0, import_react.createElement)("svg", p);
const Symbol2 = (p) => (0, import_react.createElement)("symbol", p);
const Text = (p) => (0, import_react.createElement)("text", p);
const TextPath = (p) => (0, import_react.createElement)("clipPath", p);
const TSpan = (p) => (0, import_react.createElement)("tSpan", p);
const Use = (p) => (0, import_react.createElement)("use", p);
var src_default = {
  Circle,
  ClipPath,
  Defs,
  Ellipse,
  ForeignObject,
  G,
  Image,
  Line,
  LinearGradient,
  Marker,
  Mask,
  Path,
  Pattern,
  Polygon,
  Polyline,
  RadialGradient,
  Rect,
  Shape,
  Stop,
  Svg,
  Symbol: Symbol2,
  Text,
  TextPath,
  TSpan,
  Use
};
// Annotate the CommonJS export names for ESM import in node:
0 && (0);
//# sourceMappingURL=index.js.map


/***/ }),

/***/ 77379:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var ResponderSystem_exports = {};
__export(ResponderSystem_exports, {
  addNode: () => addNode,
  attachListeners: () => attachListeners,
  getResponderNode: () => getResponderNode,
  removeNode: () => removeNode,
  terminateResponder: () => terminateResponder
});
module.exports = __toCommonJS(ResponderSystem_exports);
var import_createResponderEvent = __toESM(__webpack_require__(38278));
var import_ResponderTouchHistoryStore = __webpack_require__(59512);
var import_types = __webpack_require__(10529);
var import_utils = __webpack_require__(32222);
var import_utils2 = __webpack_require__(32222);
const emptyObject = {};
const startRegistration = [
  "onStartShouldSetResponderCapture",
  "onStartShouldSetResponder",
  { bubbles: true }
];
const moveRegistration = [
  "onMoveShouldSetResponderCapture",
  "onMoveShouldSetResponder",
  { bubbles: true }
];
const scrollRegistration = [
  "onScrollShouldSetResponderCapture",
  "onScrollShouldSetResponder",
  { bubbles: false }
];
const shouldSetResponderEvents = {
  touchstart: startRegistration,
  mousedown: startRegistration,
  touchmove: moveRegistration,
  mousemove: moveRegistration,
  scroll: scrollRegistration
};
const emptyResponder = { id: null, idPath: null, node: null };
const responderListenersMap = /* @__PURE__ */ new Map();
let isEmulatingMouseEvents = false;
let trackedTouchCount = 0;
let currentResponder = {
  id: null,
  node: null,
  idPath: null
};
const responderTouchHistoryStore = new import_ResponderTouchHistoryStore.ResponderTouchHistoryStore();
function changeCurrentResponder(responder) {
  currentResponder = responder;
}
function getResponderConfig(id) {
  const config = responderListenersMap.get(id);
  return config != null ? config : emptyObject;
}
function eventListener(domEvent) {
  const eventType = domEvent.type;
  const eventTarget = domEvent.target;
  if (eventType === "touchstart") {
    isEmulatingMouseEvents = true;
  }
  if (eventType === "touchmove" || trackedTouchCount > 1) {
    isEmulatingMouseEvents = false;
  }
  if (
    // Ignore browser emulated mouse events
    eventType === "mousedown" && isEmulatingMouseEvents || eventType === "mousemove" && isEmulatingMouseEvents || // Ignore mousemove if a mousedown didn't occur first
    eventType === "mousemove" && trackedTouchCount < 1
  ) {
    return;
  }
  if (isEmulatingMouseEvents && eventType === "mouseup") {
    if (trackedTouchCount === 0) {
      isEmulatingMouseEvents = false;
    }
    return;
  }
  const isStartEvent = (0, import_types.isStartish)(eventType) && (0, import_utils2.isPrimaryPointerDown)(domEvent);
  const isMoveEvent = (0, import_types.isMoveish)(eventType);
  const isEndEvent = (0, import_types.isEndish)(eventType);
  const isScrollEvent = (0, import_types.isScroll)(eventType);
  const isSelectionChangeEvent = (0, import_types.isSelectionChange)(eventType);
  const responderEvent = (0, import_createResponderEvent.default)(domEvent, responderTouchHistoryStore);
  if (isStartEvent || isMoveEvent || isEndEvent) {
    if (domEvent.touches) {
      trackedTouchCount = domEvent.touches.length;
    } else {
      if (isStartEvent) {
        trackedTouchCount = 1;
      } else if (isEndEvent) {
        trackedTouchCount = 0;
      }
    }
    responderTouchHistoryStore.recordTouchTrack(
      eventType,
      responderEvent.nativeEvent
    );
  }
  let eventPaths = (0, import_utils2.getResponderPaths)(domEvent);
  let wasNegotiated = false;
  let wantsResponder;
  if (isStartEvent || isMoveEvent || isScrollEvent && trackedTouchCount > 0) {
    const currentResponderIdPath = currentResponder.idPath;
    const eventIdPath = eventPaths.idPath;
    if (currentResponderIdPath != null && eventIdPath != null) {
      const lowestCommonAncestor = (0, import_utils2.getLowestCommonAncestor)(
        currentResponderIdPath,
        eventIdPath
      );
      if (lowestCommonAncestor != null) {
        const indexOfLowestCommonAncestor = eventIdPath.indexOf(lowestCommonAncestor);
        const index = indexOfLowestCommonAncestor + (lowestCommonAncestor === currentResponder.id ? 1 : 0);
        eventPaths = {
          idPath: eventIdPath.slice(index),
          nodePath: eventPaths.nodePath.slice(index)
        };
      } else {
        eventPaths = null;
      }
    }
    if (eventPaths != null) {
      wantsResponder = findWantsResponder(eventPaths, domEvent, responderEvent);
      if (wantsResponder != null) {
        attemptTransfer(responderEvent, wantsResponder);
        wasNegotiated = true;
      }
    }
  }
  if (currentResponder.id != null && currentResponder.node != null) {
    const { id, node } = currentResponder;
    const {
      onResponderStart,
      onResponderMove,
      onResponderEnd,
      onResponderRelease,
      onResponderTerminate,
      onResponderTerminationRequest
    } = getResponderConfig(id);
    responderEvent.bubbles = false;
    responderEvent.cancelable = false;
    responderEvent.currentTarget = node;
    if (isStartEvent) {
      if (onResponderStart != null) {
        responderEvent.dispatchConfig.registrationName = "onResponderStart";
        onResponderStart(responderEvent);
      }
    } else if (isMoveEvent) {
      if (onResponderMove != null) {
        responderEvent.dispatchConfig.registrationName = "onResponderMove";
        onResponderMove(responderEvent);
      }
    } else {
      const isTerminateEvent = (0, import_types.isCancelish)(eventType) || // native context menu
      eventType === "contextmenu" || // window blur
      eventType === "blur" && eventTarget === window || // responder (or ancestors) blur
      eventType === "blur" && eventTarget.contains(node) && domEvent.relatedTarget !== node || // native scroll without using a pointer
      isScrollEvent && trackedTouchCount === 0 || // native scroll on node that is parent of the responder (allow siblings to scroll)
      isScrollEvent && eventTarget.contains(node) && eventTarget !== node || // native select/selectionchange on node
      isSelectionChangeEvent && (0, import_utils2.hasValidSelection)(domEvent);
      const isReleaseEvent = isEndEvent && !isTerminateEvent && !(0, import_utils2.hasTargetTouches)(node, domEvent.touches);
      if (isEndEvent) {
        if (onResponderEnd != null) {
          responderEvent.dispatchConfig.registrationName = "onResponderEnd";
          onResponderEnd(responderEvent);
        }
      }
      if (isReleaseEvent) {
        if (onResponderRelease != null) {
          responderEvent.dispatchConfig.registrationName = "onResponderRelease";
          onResponderRelease(responderEvent);
        }
        changeCurrentResponder(emptyResponder);
      }
      if (isTerminateEvent) {
        let shouldTerminate = true;
        if (eventType === "contextmenu" || eventType === "scroll" || eventType === "selectionchange") {
          if (wasNegotiated) {
            shouldTerminate = false;
          } else if (onResponderTerminationRequest != null) {
            responderEvent.dispatchConfig.registrationName = "onResponderTerminationRequest";
            if (onResponderTerminationRequest(responderEvent) === false) {
              shouldTerminate = false;
            }
          }
        }
        if (shouldTerminate) {
          if (onResponderTerminate != null) {
            responderEvent.dispatchConfig.registrationName = "onResponderTerminate";
            onResponderTerminate(responderEvent);
          }
          changeCurrentResponder(emptyResponder);
          isEmulatingMouseEvents = false;
          trackedTouchCount = 0;
        }
      }
    }
  }
}
function findWantsResponder(eventPaths, domEvent, responderEvent) {
  const shouldSetCallbacks = shouldSetResponderEvents[domEvent.type];
  if (shouldSetCallbacks != null) {
    const { idPath, nodePath } = eventPaths;
    const shouldSetCallbackCaptureName = shouldSetCallbacks[0];
    const shouldSetCallbackBubbleName = shouldSetCallbacks[1];
    const { bubbles } = shouldSetCallbacks[2];
    const check = function(id, node, callbackName) {
      const config = getResponderConfig(id);
      const shouldSetCallback = config[callbackName];
      if (shouldSetCallback != null) {
        responderEvent.currentTarget = node;
        if (shouldSetCallback(responderEvent) === true) {
          const prunedIdPath = idPath.slice(idPath.indexOf(id));
          return { id, node, idPath: prunedIdPath };
        }
      }
    };
    for (let i = idPath.length - 1; i >= 0; i--) {
      const id = idPath[i];
      const node = nodePath[i];
      const result = check(id, node, shouldSetCallbackCaptureName);
      if (result != null) {
        return result;
      }
      if (responderEvent.isPropagationStopped() === true) {
        return;
      }
    }
    if (bubbles) {
      for (let i = 0; i < idPath.length; i++) {
        const id = idPath[i];
        const node = nodePath[i];
        const result = check(id, node, shouldSetCallbackBubbleName);
        if (result != null) {
          return result;
        }
        if (responderEvent.isPropagationStopped() === true) {
          return;
        }
      }
    } else {
      const id = idPath[0];
      const node = nodePath[0];
      const target = domEvent.target;
      if (target === node) {
        return check(id, node, shouldSetCallbackBubbleName);
      }
    }
  }
}
function attemptTransfer(responderEvent, wantsResponder) {
  const { id: currentId, node: currentNode } = currentResponder;
  const { id, node } = wantsResponder;
  const { onResponderGrant, onResponderReject } = getResponderConfig(id);
  responderEvent.bubbles = false;
  responderEvent.cancelable = false;
  responderEvent.currentTarget = node;
  if (currentId == null) {
    if (onResponderGrant != null) {
      responderEvent.currentTarget = node;
      responderEvent.dispatchConfig.registrationName = "onResponderGrant";
      onResponderGrant(responderEvent);
    }
    changeCurrentResponder(wantsResponder);
  } else {
    const { onResponderTerminate, onResponderTerminationRequest } = getResponderConfig(currentId);
    let allowTransfer = true;
    if (onResponderTerminationRequest != null) {
      responderEvent.currentTarget = currentNode;
      responderEvent.dispatchConfig.registrationName = "onResponderTerminationRequest";
      if (onResponderTerminationRequest(responderEvent) === false) {
        allowTransfer = false;
      }
    }
    if (allowTransfer) {
      if (onResponderTerminate != null) {
        responderEvent.currentTarget = currentNode;
        responderEvent.dispatchConfig.registrationName = "onResponderTerminate";
        onResponderTerminate(responderEvent);
      }
      if (onResponderGrant != null) {
        responderEvent.currentTarget = node;
        responderEvent.dispatchConfig.registrationName = "onResponderGrant";
        onResponderGrant(responderEvent);
      }
      changeCurrentResponder(wantsResponder);
    } else {
      if (onResponderReject != null) {
        responderEvent.currentTarget = node;
        responderEvent.dispatchConfig.registrationName = "onResponderReject";
        onResponderReject(responderEvent);
      }
    }
  }
}
const documentEventsCapturePhase = ["blur", "scroll"];
const documentEventsBubblePhase = [
  // mouse
  "mousedown",
  "mousemove",
  "mouseup",
  "dragstart",
  // touch
  "touchstart",
  "touchmove",
  "touchend",
  "touchcancel",
  // other
  "contextmenu",
  "select",
  "selectionchange"
];
const isTamaguiResponderActive = Symbol();
function attachListeners() {
  if (import_utils.canUseDOM && !window[isTamaguiResponderActive]) {
    window.addEventListener("blur", eventListener);
    documentEventsBubblePhase.forEach((eventType) => {
      document.addEventListener(eventType, eventListener);
    });
    documentEventsCapturePhase.forEach((eventType) => {
      document.addEventListener(eventType, eventListener, true);
    });
    window[isTamaguiResponderActive] = true;
  }
}
function addNode(id, node, config) {
  (0, import_utils2.setResponderId)(node, id);
  responderListenersMap.set(id, config);
}
function removeNode(id) {
  if (currentResponder.id === id) {
    terminateResponder();
  }
  if (responderListenersMap.has(id)) {
    responderListenersMap.delete(id);
  }
}
function terminateResponder() {
  const { id, node } = currentResponder;
  if (id != null && node != null) {
    const { onResponderTerminate } = getResponderConfig(id);
    if (onResponderTerminate != null) {
      const event = (0, import_createResponderEvent.default)({}, responderTouchHistoryStore);
      event.currentTarget = node;
      onResponderTerminate(event);
    }
    changeCurrentResponder(emptyResponder);
  }
  isEmulatingMouseEvents = false;
  trackedTouchCount = 0;
}
function getResponderNode() {
  return currentResponder.node;
}
// Annotate the CommonJS export names for ESM import in node:
0 && (0);
//# sourceMappingURL=ResponderSystem.js.map


/***/ }),

/***/ 59512:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var ResponderTouchHistoryStore_exports = {};
__export(ResponderTouchHistoryStore_exports, {
  ResponderTouchHistoryStore: () => ResponderTouchHistoryStore
});
module.exports = __toCommonJS(ResponderTouchHistoryStore_exports);
var import_types = __webpack_require__(10529);
const MAX_TOUCH_BANK = 20;
function timestampForTouch(touch) {
  return touch["timeStamp"] || touch.timestamp;
}
function createTouchRecord(touch) {
  return {
    touchActive: true,
    startPageX: touch.pageX,
    startPageY: touch.pageY,
    startTimeStamp: timestampForTouch(touch),
    currentPageX: touch.pageX,
    currentPageY: touch.pageY,
    currentTimeStamp: timestampForTouch(touch),
    previousPageX: touch.pageX,
    previousPageY: touch.pageY,
    previousTimeStamp: timestampForTouch(touch)
  };
}
function resetTouchRecord(touchRecord, touch) {
  touchRecord.touchActive = true;
  touchRecord.startPageX = touch.pageX;
  touchRecord.startPageY = touch.pageY;
  touchRecord.startTimeStamp = timestampForTouch(touch);
  touchRecord.currentPageX = touch.pageX;
  touchRecord.currentPageY = touch.pageY;
  touchRecord.currentTimeStamp = timestampForTouch(touch);
  touchRecord.previousPageX = touch.pageX;
  touchRecord.previousPageY = touch.pageY;
  touchRecord.previousTimeStamp = timestampForTouch(touch);
}
function getTouchIdentifier({ identifier }) {
  if (identifier == null) {
    console.error("Touch object is missing identifier.");
  }
  if (false) {}
  return identifier;
}
function recordTouchStart(touch, touchHistory) {
  const identifier = getTouchIdentifier(touch);
  const touchRecord = touchHistory.touchBank[identifier];
  if (touchRecord) {
    resetTouchRecord(touchRecord, touch);
  } else {
    touchHistory.touchBank[identifier] = createTouchRecord(touch);
  }
  touchHistory.mostRecentTimeStamp = timestampForTouch(touch);
}
function recordTouchMove(touch, touchHistory) {
  const touchRecord = touchHistory.touchBank[getTouchIdentifier(touch)];
  if (touchRecord) {
    touchRecord.touchActive = true;
    touchRecord.previousPageX = touchRecord.currentPageX;
    touchRecord.previousPageY = touchRecord.currentPageY;
    touchRecord.previousTimeStamp = touchRecord.currentTimeStamp;
    touchRecord.currentPageX = touch.pageX;
    touchRecord.currentPageY = touch.pageY;
    touchRecord.currentTimeStamp = timestampForTouch(touch);
    touchHistory.mostRecentTimeStamp = timestampForTouch(touch);
  } else {
    console.warn(
      "Cannot record touch move without a touch start.\n",
      `Touch Move: ${printTouch(touch)}
`,
      `Touch Bank: ${printTouchBank(touchHistory)}`
    );
  }
}
function recordTouchEnd(touch, touchHistory) {
  const touchRecord = touchHistory.touchBank[getTouchIdentifier(touch)];
  if (touchRecord) {
    touchRecord.touchActive = false;
    touchRecord.previousPageX = touchRecord.currentPageX;
    touchRecord.previousPageY = touchRecord.currentPageY;
    touchRecord.previousTimeStamp = touchRecord.currentTimeStamp;
    touchRecord.currentPageX = touch.pageX;
    touchRecord.currentPageY = touch.pageY;
    touchRecord.currentTimeStamp = timestampForTouch(touch);
    touchHistory.mostRecentTimeStamp = timestampForTouch(touch);
  } else {
    console.warn(
      "Cannot record touch end without a touch start.\n",
      `Touch End: ${printTouch(touch)}
`,
      `Touch Bank: ${printTouchBank(touchHistory)}`
    );
  }
}
function printTouch(touch) {
  return JSON.stringify({
    identifier: touch.identifier,
    pageX: touch.pageX,
    pageY: touch.pageY,
    timestamp: timestampForTouch(touch)
  });
}
function printTouchBank(touchHistory) {
  const { touchBank } = touchHistory;
  let printed = JSON.stringify(touchBank.slice(0, MAX_TOUCH_BANK));
  if (touchBank.length > MAX_TOUCH_BANK) {
    printed += ` (original size: ${touchBank.length})`;
  }
  return printed;
}
class ResponderTouchHistoryStore {
  constructor() {
    this._touchHistory = {
      touchBank: [],
      //Array<TouchRecord>
      numberActiveTouches: 0,
      // If there is only one active touch, we remember its location. This prevents
      // us having to loop through all of the touches all the time in the most
      // common case.
      indexOfSingleActiveTouch: -1,
      mostRecentTimeStamp: 0
    };
  }
  recordTouchTrack(topLevelType, nativeEvent) {
    const touchHistory = this._touchHistory;
    if ((0, import_types.isMoveish)(topLevelType)) {
      nativeEvent.changedTouches.forEach(
        (touch) => recordTouchMove(touch, touchHistory)
      );
    } else if ((0, import_types.isStartish)(topLevelType)) {
      nativeEvent.changedTouches.forEach(
        (touch) => recordTouchStart(touch, touchHistory)
      );
      touchHistory.numberActiveTouches = nativeEvent.touches.length;
      if (touchHistory.numberActiveTouches === 1) {
        touchHistory.indexOfSingleActiveTouch = nativeEvent.touches[0].identifier;
      }
    } else if ((0, import_types.isEndish)(topLevelType)) {
      nativeEvent.changedTouches.forEach(
        (touch) => recordTouchEnd(touch, touchHistory)
      );
      touchHistory.numberActiveTouches = nativeEvent.touches.length;
      if (touchHistory.numberActiveTouches === 1) {
        const { touchBank } = touchHistory;
        for (let i = 0; i < touchBank.length; i++) {
          const touchTrackToCheck = touchBank[i];
          if (touchTrackToCheck == null ? void 0 : touchTrackToCheck.touchActive) {
            touchHistory.indexOfSingleActiveTouch = i;
            break;
          }
        }
        if (false) {}
      }
    }
  }
  get touchHistory() {
    return this._touchHistory;
  }
}
// Annotate the CommonJS export names for ESM import in node:
0 && (0);
//# sourceMappingURL=ResponderTouchHistoryStore.js.map


/***/ }),

/***/ 38278:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var createResponderEvent_exports = {};
__export(createResponderEvent_exports, {
  default: () => createResponderEvent
});
module.exports = __toCommonJS(createResponderEvent_exports);
var import_utils = __webpack_require__(32222);
const emptyFunction = () => {
};
const emptyObject = {};
const emptyArray = [];
function normalizeIdentifier(identifier) {
  return identifier > 20 ? identifier % 20 : identifier;
}
function createResponderEvent(domEvent, responderTouchHistoryStore) {
  let rect;
  let propagationWasStopped = false;
  let changedTouches;
  let touches;
  const domEventChangedTouches = domEvent.changedTouches;
  const domEventType = domEvent.type;
  const metaKey = domEvent.metaKey === true;
  const shiftKey = domEvent.shiftKey === true;
  const force = (domEventChangedTouches == null ? void 0 : domEventChangedTouches[0].force) || 0;
  const identifier = normalizeIdentifier((domEventChangedTouches == null ? void 0 : domEventChangedTouches[0].identifier) || 0);
  const clientX = (domEventChangedTouches == null ? void 0 : domEventChangedTouches[0].clientX) || domEvent.clientX;
  const clientY = (domEventChangedTouches == null ? void 0 : domEventChangedTouches[0].clientY) || domEvent.clientY;
  const pageX = (domEventChangedTouches == null ? void 0 : domEventChangedTouches[0].pageX) || domEvent.pageX;
  const pageY = (domEventChangedTouches == null ? void 0 : domEventChangedTouches[0].pageY) || domEvent.pageY;
  const preventDefault = typeof domEvent.preventDefault === "function" ? domEvent.preventDefault.bind(domEvent) : emptyFunction;
  const timestamp = domEvent.timeStamp;
  function normalizeTouches(touches2) {
    return Array.prototype.slice.call(touches2).map((touch) => {
      return {
        force: touch.force,
        identifier: normalizeIdentifier(touch.identifier),
        get locationX() {
          return locationX(touch.clientX);
        },
        get locationY() {
          return locationY(touch.clientY);
        },
        pageX: touch.pageX,
        pageY: touch.pageY,
        target: touch.target,
        timestamp
      };
    });
  }
  if (domEventChangedTouches != null) {
    changedTouches = normalizeTouches(domEventChangedTouches);
    touches = normalizeTouches(domEvent.touches);
  } else {
    const emulatedTouches = [
      {
        force,
        identifier,
        get locationX() {
          return locationX(clientX);
        },
        get locationY() {
          return locationY(clientY);
        },
        pageX,
        pageY,
        target: domEvent.target,
        timestamp
      }
    ];
    changedTouches = emulatedTouches;
    touches = domEventType === "mouseup" || domEventType === "dragstart" ? emptyArray : emulatedTouches;
  }
  const responderEvent = {
    bubbles: true,
    cancelable: true,
    // `currentTarget` is set before dispatch
    currentTarget: null,
    defaultPrevented: domEvent.defaultPrevented,
    dispatchConfig: emptyObject,
    eventPhase: domEvent.eventPhase,
    isDefaultPrevented() {
      return domEvent.defaultPrevented;
    },
    isPropagationStopped() {
      return propagationWasStopped;
    },
    isTrusted: domEvent.isTrusted,
    nativeEvent: {
      altKey: false,
      ctrlKey: false,
      metaKey,
      shiftKey,
      changedTouches,
      force,
      identifier,
      get locationX() {
        return locationX(clientX);
      },
      get locationY() {
        return locationY(clientY);
      },
      pageX,
      pageY,
      target: domEvent.target,
      timestamp,
      touches,
      type: domEventType
    },
    persist: emptyFunction,
    preventDefault,
    stopPropagation() {
      propagationWasStopped = true;
    },
    target: domEvent.target,
    timeStamp: timestamp,
    touchHistory: responderTouchHistoryStore.touchHistory
  };
  function locationX(x) {
    rect = rect || (0, import_utils.getBoundingClientRect)(responderEvent.currentTarget);
    if (rect) {
      return x - rect.left;
    }
  }
  function locationY(y) {
    rect = rect || (0, import_utils.getBoundingClientRect)(responderEvent.currentTarget);
    if (rect) {
      return y - rect.top;
    }
  }
  return responderEvent;
}
// Annotate the CommonJS export names for ESM import in node:
0 && (0);
//# sourceMappingURL=createResponderEvent.js.map


/***/ }),

/***/ 94245:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __reExport = (target, mod, secondTarget) => (__copyProps(target, mod, "default"), secondTarget && __copyProps(secondTarget, mod, "default"));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var src_exports = {};
module.exports = __toCommonJS(src_exports);
__reExport(src_exports, __webpack_require__(23955), module.exports);
//# sourceMappingURL=index.js.map


/***/ }),

/***/ 10529:
/***/ ((module) => {

"use strict";

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var types_exports = {};
__export(types_exports, {
  BLUR: () => BLUR,
  CONTEXT_MENU: () => CONTEXT_MENU,
  FOCUS_OUT: () => FOCUS_OUT,
  MOUSE_CANCEL: () => MOUSE_CANCEL,
  MOUSE_DOWN: () => MOUSE_DOWN,
  MOUSE_MOVE: () => MOUSE_MOVE,
  MOUSE_UP: () => MOUSE_UP,
  SCROLL: () => SCROLL,
  SELECT: () => SELECT,
  SELECTION_CHANGE: () => SELECTION_CHANGE,
  TOUCH_CANCEL: () => TOUCH_CANCEL,
  TOUCH_END: () => TOUCH_END,
  TOUCH_MOVE: () => TOUCH_MOVE,
  TOUCH_START: () => TOUCH_START,
  isCancelish: () => isCancelish,
  isEndish: () => isEndish,
  isMoveish: () => isMoveish,
  isScroll: () => isScroll,
  isSelectionChange: () => isSelectionChange,
  isStartish: () => isStartish
});
module.exports = __toCommonJS(types_exports);
const BLUR = "blur";
const CONTEXT_MENU = "contextmenu";
const FOCUS_OUT = "focusout";
const MOUSE_DOWN = "mousedown";
const MOUSE_MOVE = "mousemove";
const MOUSE_UP = "mouseup";
const MOUSE_CANCEL = "dragstart";
const TOUCH_START = "touchstart";
const TOUCH_MOVE = "touchmove";
const TOUCH_END = "touchend";
const TOUCH_CANCEL = "touchcancel";
const SCROLL = "scroll";
const SELECT = "select";
const SELECTION_CHANGE = "selectionchange";
function isStartish(eventType) {
  return eventType === TOUCH_START || eventType === MOUSE_DOWN;
}
function isMoveish(eventType) {
  return eventType === TOUCH_MOVE || eventType === MOUSE_MOVE;
}
function isEndish(eventType) {
  return eventType === TOUCH_END || eventType === MOUSE_UP || isCancelish(eventType);
}
function isCancelish(eventType) {
  return eventType === TOUCH_CANCEL || eventType === MOUSE_CANCEL;
}
function isScroll(eventType) {
  return eventType === SCROLL;
}
function isSelectionChange(eventType) {
  return eventType === SELECT || eventType === SELECTION_CHANGE;
}
// Annotate the CommonJS export names for ESM import in node:
0 && (0);
//# sourceMappingURL=types.js.map


/***/ }),

/***/ 23955:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __reExport = (target, mod, secondTarget) => (__copyProps(target, mod, "default"), secondTarget && __copyProps(secondTarget, mod, "default"));
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var useResponderEvents_exports = {};
__export(useResponderEvents_exports, {
  useResponderEvents: () => useResponderEvents
});
module.exports = __toCommonJS(useResponderEvents_exports);
var React = __toESM(__webpack_require__(16689));
var ResponderSystem = __toESM(__webpack_require__(77379));
__reExport(useResponderEvents_exports, __webpack_require__(32222), module.exports);
const emptyObject = {};
function useResponderEvents(hostRef, config = emptyObject) {
  const id = React.useId();
  const isAttachedRef = React.useRef(false);
  React.useEffect(() => {
    ResponderSystem.attachListeners();
    return () => {
      ResponderSystem.removeNode(id);
    };
  }, [id]);
  React.useEffect(() => {
    const {
      onMoveShouldSetResponder,
      onMoveShouldSetResponderCapture,
      onScrollShouldSetResponder,
      onScrollShouldSetResponderCapture,
      onSelectionChangeShouldSetResponder,
      onSelectionChangeShouldSetResponderCapture,
      onStartShouldSetResponder,
      onStartShouldSetResponderCapture
    } = config;
    const requiresResponderSystem = onMoveShouldSetResponder != null || onMoveShouldSetResponderCapture != null || onScrollShouldSetResponder != null || onScrollShouldSetResponderCapture != null || onSelectionChangeShouldSetResponder != null || onSelectionChangeShouldSetResponderCapture != null || onStartShouldSetResponder != null || onStartShouldSetResponderCapture != null;
    const node = hostRef.current;
    if (requiresResponderSystem) {
      ResponderSystem.addNode(id, node, config);
      isAttachedRef.current = true;
    } else if (isAttachedRef.current) {
      ResponderSystem.removeNode(id);
      isAttachedRef.current = false;
    }
  }, [config, hostRef, id]);
  if (false) {}
}
// Annotate the CommonJS export names for ESM import in node:
0 && (0);
//# sourceMappingURL=useResponderEvents.js.map


/***/ }),

/***/ 32222:
/***/ ((module) => {

"use strict";

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var utils_exports = {};
__export(utils_exports, {
  canUseDOM: () => canUseDOM,
  getBoundingClientRect: () => getBoundingClientRect,
  getLowestCommonAncestor: () => getLowestCommonAncestor,
  getResponderPaths: () => getResponderPaths,
  hasTargetTouches: () => hasTargetTouches,
  hasValidSelection: () => hasValidSelection,
  isPrimaryPointerDown: () => isPrimaryPointerDown,
  isSelectionValid: () => isSelectionValid,
  setResponderId: () => setResponderId
});
module.exports = __toCommonJS(utils_exports);
const keyName = "__reactResponderId";
const canUseDOM = !!(typeof window !== "undefined" && window.document && window.document.createElement);
const getBoundingClientRect = (node) => {
  if (!node)
    return;
  if (node.nodeType !== 1)
    return;
  if (node.getBoundingClientRect) {
    return node.getBoundingClientRect();
  }
};
function getEventPath(domEvent) {
  var _a;
  if (domEvent.type === "selectionchange") {
    const target = (_a = window.getSelection()) == null ? void 0 : _a.anchorNode;
    return composedPathFallback(target);
  } else {
    const path = domEvent.composedPath != null ? domEvent.composedPath() : composedPathFallback(domEvent.target);
    return path;
  }
}
function composedPathFallback(target) {
  const path = [];
  while (target != null && target !== document.body) {
    path.push(target);
    target = target.parentNode;
  }
  return path;
}
function getResponderId(node) {
  if (node != null) {
    return node[keyName];
  }
  return null;
}
function setResponderId(node, id) {
  if (node != null) {
    node[keyName] = id;
  }
}
function getResponderPaths(domEvent) {
  const idPath = [];
  const nodePath = [];
  const eventPath = getEventPath(domEvent);
  for (let i = 0; i < eventPath.length; i++) {
    const node = eventPath[i];
    const id = getResponderId(node);
    if (id != null) {
      idPath.push(id);
      nodePath.push(node);
    }
  }
  return { idPath, nodePath };
}
function getLowestCommonAncestor(pathA, pathB) {
  let pathALength = pathA.length;
  let pathBLength = pathB.length;
  if (
    // If either path is empty
    pathALength === 0 || pathBLength === 0 || // If the last elements aren't the same there can't be a common ancestor
    // that is connected to the responder system
    pathA[pathALength - 1] !== pathB[pathBLength - 1]
  ) {
    return null;
  }
  let itemA = pathA[0];
  let indexA = 0;
  let itemB = pathB[0];
  let indexB = 0;
  if (pathALength - pathBLength > 0) {
    indexA = pathALength - pathBLength;
    itemA = pathA[indexA];
    pathALength = pathBLength;
  }
  if (pathBLength - pathALength > 0) {
    indexB = pathBLength - pathALength;
    itemB = pathB[indexB];
    pathBLength = pathALength;
  }
  let depth = pathALength;
  while (depth--) {
    if (itemA === itemB) {
      return itemA;
    }
    itemA = pathA[indexA++];
    itemB = pathB[indexB++];
  }
  return null;
}
function hasTargetTouches(target, touches) {
  if (!touches || touches.length === 0) {
    return false;
  }
  for (let i = 0; i < touches.length; i++) {
    const node = touches[i].target;
    if (node != null) {
      if (target.contains(node)) {
        return true;
      }
    }
  }
  return false;
}
function hasValidSelection(domEvent) {
  if (domEvent.type === "selectionchange") {
    return isSelectionValid();
  }
  return domEvent.type === "select";
}
function isPrimaryPointerDown(domEvent) {
  const { altKey, button, buttons, ctrlKey, type } = domEvent;
  const isTouch = type === "touchstart" || type === "touchmove";
  const isPrimaryMouseDown = type === "mousedown" && (button === 0 || buttons === 1);
  const isPrimaryMouseMove = type === "mousemove" && buttons === 1;
  const noModifiers = altKey === false && ctrlKey === false;
  if (isTouch || isPrimaryMouseDown && noModifiers || isPrimaryMouseMove && noModifiers) {
    return true;
  }
  return false;
}
function isSelectionValid() {
  const selection = window.getSelection();
  if (!selection)
    return false;
  const string = selection.toString();
  const anchorNode = selection.anchorNode;
  const focusNode = selection.focusNode;
  const isTextNode = anchorNode && anchorNode.nodeType === window.Node.TEXT_NODE || focusNode && focusNode.nodeType === window.Node.TEXT_NODE;
  return string.length >= 1 && string !== "\n" && !!isTextNode;
}
// Annotate the CommonJS export names for ESM import in node:
0 && (0);
//# sourceMappingURL=utils.js.map


/***/ }),

/***/ 14837:
/***/ ((module) => {

"use strict";

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var src_exports = {};
__export(src_exports, {
  isValidCSSCharCode: () => isValidCSSCharCode,
  simpleHash: () => simpleHash
});
module.exports = __toCommonJS(src_exports);
const simpleHash = (str, hashMin = 10) => {
  let hash = 0;
  let valids = "";
  const len = str.length;
  for (let i = 0; i < len; i++) {
    const char = str.charCodeAt(i);
    if (isValidCSSCharCode(char) && len <= hashMin) {
      valids += str[i];
    } else {
      hash = (hash << 5) - hash + char;
      hash &= hash;
    }
  }
  return valids + (hash ? new Uint32Array([hash])[0].toString(36) : "");
};
function isValidCSSCharCode(code) {
  return (
    // A-Z
    code >= 65 && code <= 90 || // a-z
    code >= 97 && code <= 122 || // _
    code === 95 || // -
    code === 45 || // 0-9
    code >= 48 && code <= 57
  );
}
// Annotate the CommonJS export names for ESM import in node:
0 && (0);
//# sourceMappingURL=index.js.map


/***/ }),

/***/ 43038:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var SizableStack_exports = {};
__export(SizableStack_exports, {
  SizableStack: () => SizableStack
});
module.exports = __toCommonJS(SizableStack_exports);
var import_core = __webpack_require__(86872);
var import_get_button_sized = __webpack_require__(56394);
var import_Stacks = __webpack_require__(61646);
var import_variants = __webpack_require__(44807);
const SizableStack = (0, import_core.styled)(import_Stacks.YStack, {
  name: "SizableStack",
  backgroundColor: "$background",
  flexDirection: "row",
  flexShrink: 1,
  variants: {
    hoverTheme: import_variants.hoverTheme,
    pressTheme: import_variants.pressTheme,
    focusTheme: import_variants.focusTheme,
    circular: import_variants.circular,
    elevate: import_variants.elevate,
    bordered: import_variants.bordered,
    size: {
      "...size": import_get_button_sized.getButtonSized
    }
  }
});
// Annotate the CommonJS export names for ESM import in node:
0 && (0);
//# sourceMappingURL=SizableStack.js.map


/***/ }),

/***/ 61646:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var Stacks_exports = {};
__export(Stacks_exports, {
  XStack: () => XStack,
  YStack: () => YStack,
  ZStack: () => ZStack,
  fullscreenStyle: () => fullscreenStyle
});
module.exports = __toCommonJS(Stacks_exports);
var import_core = __webpack_require__(86872);
var import_getElevation = __webpack_require__(29821);
const fullscreenStyle = {
  position: "absolute",
  top: 0,
  left: 0,
  right: 0,
  bottom: 0
};
const variants = {
  fullscreen: {
    true: fullscreenStyle
  },
  elevation: {
    "...size": import_getElevation.getElevation
  }
};
const YStack = (0, import_core.styled)(import_core.Stack, {
  flexDirection: "column",
  name: "YStack",
  variants
});
const XStack = (0, import_core.styled)(import_core.Stack, {
  flexDirection: "row",
  name: "XStack",
  variants
});
const ZStack = (0, import_core.styled)(
  YStack,
  {
    name: "ZStack",
    position: "relative"
  },
  {
    neverFlatten: true,
    isZStack: true
  }
);
// Annotate the CommonJS export names for ESM import in node:
0 && (0);
//# sourceMappingURL=Stacks.js.map


/***/ }),

/***/ 46848:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var ThemeableStack_exports = {};
__export(ThemeableStack_exports, {
  ThemeableStack: () => ThemeableStack
});
module.exports = __toCommonJS(ThemeableStack_exports);
var import_core = __webpack_require__(86872);
var import_Stacks = __webpack_require__(61646);
var import_variants = __webpack_require__(44807);
const chromelessStyle = {
  backgroundColor: "transparent",
  borderColor: "transparent",
  shadowColor: "transparent"
};
const ThemeableStack = (0, import_core.styled)(import_Stacks.YStack, {
  name: "SizableStack",
  variants: {
    backgrounded: {
      true: {
        backgroundColor: "$background"
      }
    },
    radiused: import_variants.radiused,
    hoverTheme: import_variants.hoverTheme,
    pressTheme: import_variants.pressTheme,
    focusTheme: import_variants.focusTheme,
    circular: import_variants.circular,
    padded: import_variants.padded,
    elevate: import_variants.elevate,
    bordered: import_variants.bordered,
    transparent: {
      true: {
        backgroundColor: "transparent"
      }
    },
    chromeless: {
      true: chromelessStyle,
      all: {
        ...chromelessStyle,
        hoverStyle: chromelessStyle,
        pressStyle: chromelessStyle,
        focusStyle: chromelessStyle
      }
    }
  }
});
// Annotate the CommonJS export names for ESM import in node:
0 && (0);
//# sourceMappingURL=ThemeableStack.js.map


/***/ }),

/***/ 29821:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var getElevation_exports = {};
__export(getElevation_exports, {
  getElevation: () => getElevation,
  getSizedElevation: () => getSizedElevation
});
module.exports = __toCommonJS(getElevation_exports);
var import_core = __webpack_require__(86872);
const getElevation = (size, extras) => {
  if (!size)
    return;
  const { tokens } = extras;
  const token = tokens.size[size];
  const sizeNum = (0, import_core.isVariable)(token) ? +token.val : size;
  return getSizedElevation(sizeNum, extras);
};
const getSizedElevation = (val, { theme, tokens }) => {
  let num = 0;
  if (val === true) {
    const val2 = (0, import_core.getVariableValue)(tokens.size["true"]);
    if (typeof val2 === "number") {
      num = val2;
    } else {
      num = 10;
    }
  } else {
    num = +val;
  }
  if (false) {}
  const [height, shadowRadius] = [Math.round(num / 4 + 1), Math.round(num / 2 + 2)];
  const shadow = {
    shadowColor: theme.shadowColor,
    shadowRadius,
    shadowOffset: { height, width: 0 }
  };
  return shadow;
};
// Annotate the CommonJS export names for ESM import in node:
0 && (0);
//# sourceMappingURL=getElevation.js.map


/***/ }),

/***/ 90094:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __reExport = (target, mod, secondTarget) => (__copyProps(target, mod, "default"), secondTarget && __copyProps(secondTarget, mod, "default"));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var src_exports = {};
module.exports = __toCommonJS(src_exports);
__reExport(src_exports, __webpack_require__(61646), module.exports);
__reExport(src_exports, __webpack_require__(43038), module.exports);
__reExport(src_exports, __webpack_require__(46848), module.exports);
//# sourceMappingURL=index.js.map


/***/ }),

/***/ 44807:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var variants_exports = {};
__export(variants_exports, {
  bordered: () => bordered,
  circular: () => circular,
  elevate: () => elevate,
  focusTheme: () => focusTheme,
  hoverTheme: () => hoverTheme,
  padded: () => padded,
  pressTheme: () => pressTheme,
  radiused: () => radiused
});
module.exports = __toCommonJS(variants_exports);
var import_getElevation = __webpack_require__(29821);
const elevate = {
  true: (_, extras) => {
    return (0, import_getElevation.getElevation)(extras.props["size"], extras);
  }
};
const bordered = (val, { props }) => {
  return {
    // TODO size it with size in '...size'
    borderWidth: typeof val === "number" ? val : 1,
    borderColor: "$borderColor",
    ...props.hoverTheme && {
      hoverStyle: {
        borderColor: "$borderColorHover"
      }
    },
    ...props.pressTheme && {
      pressStyle: {
        borderColor: "$borderColorPress"
      }
    },
    ...props.focusTheme && {
      focusStyle: {
        borderColor: "$borderColorFocus"
      }
    }
  };
};
const padded = {
  true: (_, extras) => {
    const { tokens, props } = extras;
    return {
      padding: tokens.space[props.size] || tokens.space["$true"]
    };
  }
};
const radiused = {
  true: (_, extras) => {
    const { tokens, props } = extras;
    return {
      borderRadius: tokens.radius[props.size] || tokens.radius["$true"]
    };
  }
};
const circular = {
  true: (_, { props, tokens }) => {
    const size = tokens.size[props.size];
    return {
      width: size,
      height: size,
      maxWidth: size,
      maxHeight: size,
      minWidth: size,
      minHeight: size,
      borderRadius: 1e5,
      padding: 0
    };
  }
};
const hoverTheme = {
  true: {
    hoverStyle: {
      backgroundColor: "$backgroundHover",
      borderColor: "$borderColorHover"
    }
  },
  false: {}
};
const pressTheme = {
  true: {
    cursor: "pointer",
    pressStyle: {
      backgroundColor: "$backgroundPress",
      borderColor: "$borderColorPress"
    }
  },
  false: {}
};
const focusTheme = {
  true: {
    focusStyle: {
      backgroundColor: "$backgroundFocus",
      borderColor: "$borderColorFocus"
    }
  },
  false: {}
};
// Annotate the CommonJS export names for ESM import in node:
0 && (0);
//# sourceMappingURL=variants.js.map


/***/ }),

/***/ 42023:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   FA: () => (/* binding */ YStack)
/* harmony export */ });
/* unused harmony exports XStack, ZStack, fullscreenStyle */
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(86872);
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_tamagui_core__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _getElevation_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(55689);


const fullscreenStyle = {
  position: "absolute",
  top: 0,
  left: 0,
  right: 0,
  bottom: 0
};
const variants = {
  fullscreen: {
    true: fullscreenStyle
  },
  elevation: {
    "...size": _getElevation_js__WEBPACK_IMPORTED_MODULE_0__/* .getElevation */ .y
  }
};
const YStack = (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_1__.styled)(_tamagui_core__WEBPACK_IMPORTED_MODULE_1__.Stack, {
  flexDirection: "column",
  name: "YStack",
  variants
});
const XStack = (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_1__.styled)(_tamagui_core__WEBPACK_IMPORTED_MODULE_1__.Stack, {
  flexDirection: "row",
  name: "XStack",
  variants
});
const ZStack = (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_1__.styled)(
  YStack,
  {
    name: "ZStack",
    position: "relative"
  },
  {
    neverFlatten: true,
    isZStack: true
  }
);

//# sourceMappingURL=Stacks.js.map


/***/ }),

/***/ 55689:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   y: () => (/* binding */ getElevation)
/* harmony export */ });
/* unused harmony export getSizedElevation */
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(86872);
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_tamagui_core__WEBPACK_IMPORTED_MODULE_0__);

const getElevation = (size, extras) => {
  if (!size)
    return;
  const { tokens } = extras;
  const token = tokens.size[size];
  const sizeNum = (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_0__.isVariable)(token) ? +token.val : size;
  return getSizedElevation(sizeNum, extras);
};
const getSizedElevation = (val, { theme, tokens }) => {
  let num = 0;
  if (val === true) {
    const val2 = (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_0__.getVariableValue)(tokens.size["true"]);
    if (typeof val2 === "number") {
      num = val2;
    } else {
      num = 10;
    }
  } else {
    num = +val;
  }
  if (false) {}
  const [height, shadowRadius] = [Math.round(num / 4 + 1), Math.round(num / 2 + 2)];
  const shadow = {
    shadowColor: theme.shadowColor,
    shadowRadius,
    shadowOffset: { height, width: 0 }
  };
  return shadow;
};

//# sourceMappingURL=getElevation.js.map


/***/ }),

/***/ 77030:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  n: () => (/* binding */ themes)
});

;// CONCATENATED MODULE: ./node_modules/@tamagui/create-theme/dist/esm/index.js
const THEME_INFO = /* @__PURE__ */ new WeakMap();
function createTheme(palette, definition, options) {
  const theme = {
    ...Object.fromEntries(
      Object.entries(definition).map(([key, offset]) => {
        return [key, getValue(palette, offset)];
      })
    ),
    ...options == null ? void 0 : options.nonInheritedValues
  };
  THEME_INFO.set(theme, { palette, definition, cache: /* @__PURE__ */ new Map() });
  return theme;
}
const getValue = (palette, value) => {
  if (typeof value === "string")
    return value;
  const max = palette.length - 1;
  const isPositive = value === 0 ? !isMinusZero(value) : value >= 0;
  const next = isPositive ? value : max + value;
  const index = Math.min(Math.max(0, next), max);
  return palette[index];
};
function addChildren(themes, getChildren) {
  const out = { ...themes };
  for (const key in themes) {
    const subThemes = getChildren(key, themes[key]);
    for (const sKey in subThemes) {
      out[`${key}_${sKey}`] = subThemes[sKey];
    }
  }
  return out;
}
const createShiftMask = ({ inverse } = {}) => {
  return (template, { skip, max: maxIn, palette, min = 0, strength = 1 }) => {
    const values = Object.entries(template);
    const max = maxIn ?? (palette ? Object.values(palette).length - 1 : Infinity);
    const out = {};
    for (const [key, value] of values) {
      if (typeof value === "string")
        continue;
      if (skip && key in skip) {
        continue;
      }
      const isPositive = value === 0 ? !isMinusZero(value) : value >= 0;
      const direction = isPositive ? 1 : -1;
      const invert = inverse ? -1 : 1;
      const next = value + strength * direction * invert;
      const clamped = isPositive ? Math.max(min, Math.min(max, next)) : Math.min(-min, Math.max(-max, next));
      out[key] = clamped;
    }
    return out;
  };
};
const createWeakenMask = () => createShiftMask();
const createStrengthenMask = () => createShiftMask({ inverse: true });
function isMinusZero(value) {
  return 1 / value === -Infinity;
}
const MaskKeyCache = /* @__PURE__ */ new WeakMap();
function applyMask(theme, mask, options = {}) {
  const info = THEME_INFO.get(theme);
  if (!info) {
    throw new Error(
       false ? 0 : `\u274C Err2`
    );
  }
  const maskKey = MaskKeyCache.get(mask) ?? `${Math.random()}`;
  MaskKeyCache.set(mask, maskKey);
  const key = `${maskKey}${JSON.stringify(options)}`;
  if (info.cache.has(key)) {
    return info.cache.get(key);
  }
  const template = mask(info.definition, {
    palette: info.palette,
    ...options
  });
  const next = createTheme(info.palette, template);
  info.cache.set(key, next);
  return next;
}
if (false) {}

//# sourceMappingURL=index.js.map

// EXTERNAL MODULE: ./node_modules/@tamagui/themes/dist/esm/tokens.js + 16 modules
var tokens = __webpack_require__(94668);
;// CONCATENATED MODULE: ./node_modules/@tamagui/themes/dist/esm/themes.js


const lightTransparent = "rgba(255,255,255,0)";
const darkTransparent = "rgba(10,10,10,0)";
const palettes = {
  dark: [
    darkTransparent,
    "#050505",
    "#151515",
    "#191919",
    "#232323",
    "#282828",
    "#323232",
    "#424242",
    "#494949",
    "#545454",
    "#626262",
    "#a5a5a5",
    "#fff",
    lightTransparent
  ],
  light: [
    lightTransparent,
    "#fff",
    "#f9f9f9",
    "hsl(0, 0%, 97.3%)",
    "hsl(0, 0%, 95.1%)",
    "hsl(0, 0%, 94.0%)",
    "hsl(0, 0%, 92.0%)",
    "hsl(0, 0%, 89.5%)",
    "hsl(0, 0%, 81.0%)",
    "hsl(0, 0%, 56.1%)",
    "hsl(0, 0%, 50.3%)",
    "hsl(0, 0%, 42.5%)",
    "hsl(0, 0%, 9.0%)",
    darkTransparent
  ]
};
const templateColors = {
  color1: 1,
  color2: 2,
  color3: 3,
  color4: 4,
  color5: 5,
  color6: 6,
  color7: 7,
  color8: 8,
  color9: 9,
  color10: 10,
  color11: 11,
  color12: 12
};
const templateShadows = {
  shadowColor: 1,
  shadowColorHover: 1,
  shadowColorPress: 2,
  shadowColorFocus: 2
};
const skip = {
  ...templateColors,
  ...templateShadows
};
const template = {
  ...skip,
  // the background, color, etc keys here work like generics - they make it so you
  // can publish components for others to use without mandating a specific color scale
  // the @tamagui/button Button component looks for `$background`, so you set the
  // dark_red_Button theme to have a stronger background than the dark_red theme.
  background: 2,
  backgroundHover: 3,
  backgroundPress: 1,
  backgroundFocus: 2,
  backgroundStrong: 1,
  backgroundTransparent: 0,
  color: -1,
  colorHover: -2,
  colorPress: -1,
  colorFocus: -2,
  colorTransparent: -0,
  borderColor: 4,
  borderColorHover: 5,
  borderColorPress: 3,
  borderColorFocus: 4,
  placeholderColor: -4
};
const lightShadowColor = "rgba(0,0,0,0.02)";
const lightShadowColorStrong = "rgba(0,0,0,0.066)";
const darkShadowColor = "rgba(0,0,0,0.2)";
const darkShadowColorStrong = "rgba(0,0,0,0.3)";
const lightShadows = {
  shadowColor: lightShadowColorStrong,
  shadowColorHover: lightShadowColorStrong,
  shadowColorPress: lightShadowColor,
  shadowColorFocus: lightShadowColor
};
const darkShadows = {
  shadowColor: darkShadowColorStrong,
  shadowColorHover: darkShadowColorStrong,
  shadowColorPress: darkShadowColor,
  shadowColorFocus: darkShadowColor
};
const lightTemplate = {
  ...template,
  // our light color palette is... a bit unique
  borderColor: 6,
  borderColorHover: 7,
  borderColorFocus: 5,
  borderColorPress: 6,
  ...lightShadows
};
const darkTemplate = { ...template, ...darkShadows };
const light = createTheme(palettes.light, lightTemplate);
const dark = createTheme(palettes.dark, darkTemplate);
const baseThemes = {
  light,
  dark
};
const masks = {
  weaker: createWeakenMask(),
  stronger: createStrengthenMask()
};
const maskOptions = {
  skip,
  // avoids the transparent ends
  max: palettes.light.length - 2,
  min: 1
};
const allThemes = addChildren(baseThemes, (name, theme) => {
  const isLight = name === "light";
  const inverseName = isLight ? "dark" : "light";
  const inverseTheme = baseThemes[inverseName];
  const transparent = (hsl, opacity = 0) => hsl.replace(`%)`, `%, ${opacity})`).replace(`hsl(`, `hsla(`);
  const [colorThemes, inverseColorThemes] = [
    tokens/* colorTokens */.Jv[name],
    tokens/* colorTokens */.Jv[inverseName]
  ].map((colorSet) => {
    return Object.fromEntries(
      Object.keys(colorSet).map((color) => {
        const colorPalette = Object.values(colorSet[color]);
        const [head, tail] = [
          colorPalette.slice(0, 6),
          colorPalette.slice(colorPalette.length - 5)
        ];
        const palette = [
          transparent(colorPalette[0]),
          ...head,
          ...tail,
          theme.color,
          transparent(colorPalette[colorPalette.length - 1])
        ];
        const colorTheme = createTheme(
          palette,
          isLight ? {
            ...lightTemplate,
            // light color themes are a bit less sensitive
            borderColor: 4,
            borderColorHover: 5,
            borderColorFocus: 4,
            borderColorPress: 4
          } : darkTemplate
        );
        return [color, colorTheme];
      })
    );
  });
  const allColorThemes = addChildren(colorThemes, (colorName, colorTheme) => {
    const inverse = inverseColorThemes[colorName];
    return {
      ...getAltThemes(colorTheme, inverse),
      ...getComponentThemes(colorTheme, inverse)
    };
  });
  const baseActiveTheme = applyMask(colorThemes.blue, masks.weaker, {
    ...maskOptions,
    strength: 4
  });
  const baseSubThemes = {
    ...getAltThemes(theme, inverseTheme, baseActiveTheme),
    ...getComponentThemes(theme, inverseTheme)
  };
  return {
    ...baseSubThemes,
    ...allColorThemes
  };
  function getAltThemes(theme2, inverse, activeTheme) {
    const maskOptionsAlt = {
      ...maskOptions,
      skip: templateShadows
    };
    const alt1 = applyMask(theme2, masks.weaker, maskOptionsAlt);
    const alt2 = applyMask(alt1, masks.weaker, maskOptionsAlt);
    const active = activeTheme ?? applyMask(theme2, masks.weaker, {
      ...maskOptions,
      strength: 4
    });
    return addChildren({ alt1, alt2, active }, (_, subTheme) => {
      return getComponentThemes(subTheme, subTheme === inverse ? theme2 : inverse);
    });
  }
  function getComponentThemes(theme2, inverse) {
    const weaker1 = applyMask(theme2, masks.weaker, maskOptions);
    const weaker2 = applyMask(weaker1, masks.weaker, maskOptions);
    const stronger1 = applyMask(theme2, masks.stronger, maskOptions);
    const inverse1 = applyMask(inverse, masks.weaker, maskOptions);
    const inverse2 = applyMask(inverse1, masks.weaker, maskOptions);
    const strongerBorderLighterBackground = isLight ? {
      ...stronger1,
      borderColor: weaker1.borderColor,
      borderColorHover: weaker1.borderColorHover,
      borderColorPress: weaker1.borderColorPress,
      borderColorFocus: weaker1.borderColorFocus
    } : {
      ...theme2,
      borderColor: weaker1.borderColor,
      borderColorHover: weaker1.borderColorHover,
      borderColorPress: weaker1.borderColorPress,
      borderColorFocus: weaker1.borderColorFocus
    };
    return {
      Card: weaker1,
      Button: weaker2,
      Checkbox: weaker2,
      DrawerFrame: weaker1,
      SliderTrack: stronger1,
      SliderTrackActive: weaker2,
      SliderThumb: inverse1,
      Progress: weaker1,
      ProgressIndicator: inverse,
      Switch: weaker2,
      SwitchThumb: inverse2,
      TooltipArrow: weaker1,
      TooltipContent: weaker2,
      Input: strongerBorderLighterBackground,
      TextArea: strongerBorderLighterBackground,
      Tooltip: inverse1
    };
  }
});
const themes = {
  ...allThemes,
  // bring back the full type, the rest use a subset to avoid clogging up ts,
  // tamagui will be smart and use the top level themes as the type for useTheme() etc
  light: createTheme(palettes.light, lightTemplate, { nonInheritedValues: tokens/* lightColors */.C0 }),
  dark: createTheme(palettes.dark, darkTemplate, { nonInheritedValues: tokens/* darkColors */._5 })
};

//# sourceMappingURL=themes.js.map


/***/ }),

/***/ 94668:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  Jv: () => (/* binding */ colorTokens),
  _5: () => (/* binding */ darkColors),
  C0: () => (/* binding */ lightColors),
  TV: () => (/* binding */ tokens)
});

// UNUSED EXPORTS: color, radius, size, space, zIndex

;// CONCATENATED MODULE: ./node_modules/@tamagui/colors/dist/esm/light/blue.js
const blue = {
  blue1: "hsl(206, 100%, 99.2%)",
  blue2: "hsl(210, 100%, 98.0%)",
  blue3: "hsl(209, 100%, 96.5%)",
  blue4: "hsl(210, 98.8%, 94.0%)",
  blue5: "hsl(209, 95.0%, 90.1%)",
  blue6: "hsl(209, 81.2%, 84.5%)",
  blue7: "hsl(208, 77.5%, 76.9%)",
  blue8: "hsl(206, 81.9%, 65.3%)",
  blue9: "hsl(206, 100%, 50.0%)",
  blue10: "hsl(208, 100%, 47.3%)",
  blue11: "hsl(211, 100%, 43.2%)",
  blue12: "hsl(211, 100%, 15.0%)"
};

//# sourceMappingURL=blue.js.map

;// CONCATENATED MODULE: ./node_modules/@tamagui/colors/dist/esm/light/gray.js
const gray = {
  gray1: "hsl(0, 0%, 99.0%)",
  gray2: "hsl(0, 0%, 97.3%)",
  gray3: "hsl(0, 0%, 95.1%)",
  gray4: "hsl(0, 0%, 93.0%)",
  gray5: "hsl(0, 0%, 90.9%)",
  gray6: "hsl(0, 0%, 88.7%)",
  gray7: "hsl(0, 0%, 85.8%)",
  gray8: "hsl(0, 0%, 78.0%)",
  gray9: "hsl(0, 0%, 56.1%)",
  gray10: "hsl(0, 0%, 52.3%)",
  gray11: "hsl(0, 0%, 43.5%)",
  gray12: "hsl(0, 0%, 9.0%)"
};

//# sourceMappingURL=gray.js.map

;// CONCATENATED MODULE: ./node_modules/@tamagui/colors/dist/esm/light/green.js
const green = {
  green1: "hsl(136, 50.0%, 98.9%)",
  green2: "hsl(138, 62.5%, 96.9%)",
  green3: "hsl(139, 55.2%, 94.5%)",
  green4: "hsl(140, 48.7%, 91.0%)",
  green5: "hsl(141, 43.7%, 86.0%)",
  green6: "hsl(143, 40.3%, 79.0%)",
  green7: "hsl(146, 38.5%, 69.0%)",
  green8: "hsl(151, 40.2%, 54.1%)",
  green9: "hsl(151, 55.0%, 41.5%)",
  green10: "hsl(152, 57.5%, 37.6%)",
  green11: "hsl(153, 67.0%, 28.5%)",
  green12: "hsl(155, 40.0%, 14.0%)"
};

//# sourceMappingURL=green.js.map

;// CONCATENATED MODULE: ./node_modules/@tamagui/colors/dist/esm/light/orange.js
const orange = {
  orange1: "hsl(24, 70.0%, 99.0%)",
  orange2: "hsl(24, 83.3%, 97.6%)",
  orange3: "hsl(24, 100%, 95.3%)",
  orange4: "hsl(25, 100%, 92.2%)",
  orange5: "hsl(25, 100%, 88.2%)",
  orange6: "hsl(25, 100%, 82.8%)",
  orange7: "hsl(24, 100%, 75.3%)",
  orange8: "hsl(24, 94.5%, 64.3%)",
  orange9: "hsl(24, 94.0%, 50.0%)",
  orange10: "hsl(24, 100%, 46.5%)",
  orange11: "hsl(24, 100%, 37.0%)",
  orange12: "hsl(15, 60.0%, 17.0%)"
};

//# sourceMappingURL=orange.js.map

;// CONCATENATED MODULE: ./node_modules/@tamagui/colors/dist/esm/light/pink.js
const pink = {
  pink1: "hsl(322, 100%, 99.4%)",
  pink2: "hsl(323, 100%, 98.4%)",
  pink3: "hsl(323, 86.3%, 96.5%)",
  pink4: "hsl(323, 78.7%, 94.2%)",
  pink5: "hsl(323, 72.2%, 91.1%)",
  pink6: "hsl(323, 66.3%, 86.6%)",
  pink7: "hsl(323, 62.0%, 80.1%)",
  pink8: "hsl(323, 60.3%, 72.4%)",
  pink9: "hsl(322, 65.0%, 54.5%)",
  pink10: "hsl(322, 63.9%, 50.7%)",
  pink11: "hsl(322, 75.0%, 46.0%)",
  pink12: "hsl(320, 70.0%, 13.5%)"
};

//# sourceMappingURL=pink.js.map

;// CONCATENATED MODULE: ./node_modules/@tamagui/colors/dist/esm/light/purple.js
const purple = {
  purple1: "hsl(280, 65.0%, 99.4%)",
  purple2: "hsl(276, 100%, 99.0%)",
  purple3: "hsl(276, 83.1%, 97.0%)",
  purple4: "hsl(275, 76.4%, 94.7%)",
  purple5: "hsl(275, 70.8%, 91.8%)",
  purple6: "hsl(274, 65.4%, 87.8%)",
  purple7: "hsl(273, 61.0%, 81.7%)",
  purple8: "hsl(272, 60.0%, 73.5%)",
  purple9: "hsl(272, 51.0%, 54.0%)",
  purple10: "hsl(272, 46.8%, 50.3%)",
  purple11: "hsl(272, 50.0%, 45.8%)",
  purple12: "hsl(272, 66.0%, 16.0%)"
};

//# sourceMappingURL=purple.js.map

;// CONCATENATED MODULE: ./node_modules/@tamagui/colors/dist/esm/light/red.js
const red = {
  red1: "hsl(359, 100%, 99.4%)",
  red2: "hsl(359, 100%, 98.6%)",
  red3: "hsl(360, 100%, 96.8%)",
  red4: "hsl(360, 97.9%, 94.8%)",
  red5: "hsl(360, 90.2%, 91.9%)",
  red6: "hsl(360, 81.7%, 87.8%)",
  red7: "hsl(359, 74.2%, 81.7%)",
  red8: "hsl(359, 69.5%, 74.3%)",
  red9: "hsl(358, 75.0%, 59.0%)",
  red10: "hsl(358, 69.4%, 55.2%)",
  red11: "hsl(358, 65.0%, 48.7%)",
  red12: "hsl(354, 50.0%, 14.6%)"
};

//# sourceMappingURL=red.js.map

;// CONCATENATED MODULE: ./node_modules/@tamagui/colors/dist/esm/light/yellow.js
const yellow = {
  yellow1: "hsl(60, 54.0%, 98.5%)",
  yellow2: "hsl(52, 100%, 95.5%)",
  yellow3: "hsl(55, 100%, 90.9%)",
  yellow4: "hsl(54, 100%, 86.6%)",
  yellow5: "hsl(52, 97.9%, 82.0%)",
  yellow6: "hsl(50, 89.4%, 76.1%)",
  yellow7: "hsl(47, 80.4%, 68.0%)",
  yellow8: "hsl(48, 100%, 46.1%)",
  yellow9: "hsl(53, 92.0%, 50.0%)",
  yellow10: "hsl(50, 100%, 48.5%)",
  yellow11: "hsl(42, 100%, 29.0%)",
  yellow12: "hsl(40, 55.0%, 13.5%)"
};

//# sourceMappingURL=yellow.js.map

;// CONCATENATED MODULE: ./node_modules/@tamagui/colors/dist/esm/dark/blue.js
const blue_blue = {
  blue1: "hsl(212, 35.0%, 9.2%)",
  blue2: "hsl(216, 50.0%, 11.8%)",
  blue3: "hsl(214, 59.4%, 15.3%)",
  blue4: "hsl(214, 65.8%, 17.9%)",
  blue5: "hsl(213, 71.2%, 20.2%)",
  blue6: "hsl(212, 77.4%, 23.1%)",
  blue7: "hsl(211, 85.1%, 27.4%)",
  blue8: "hsl(211, 89.7%, 34.1%)",
  blue9: "hsl(206, 100%, 50.0%)",
  blue10: "hsl(209, 100%, 60.6%)",
  blue11: "hsl(210, 100%, 66.1%)",
  blue12: "hsl(206, 98.0%, 95.8%)"
};

//# sourceMappingURL=blue.js.map

;// CONCATENATED MODULE: ./node_modules/@tamagui/colors/dist/esm/dark/gray.js
const gray_gray = {
  gray1: "hsl(0, 0%, 8.5%)",
  gray2: "hsl(0, 0%, 11.0%)",
  gray3: "hsl(0, 0%, 13.6%)",
  gray4: "hsl(0, 0%, 15.8%)",
  gray5: "hsl(0, 0%, 17.9%)",
  gray6: "hsl(0, 0%, 20.5%)",
  gray7: "hsl(0, 0%, 24.3%)",
  gray8: "hsl(0, 0%, 31.2%)",
  gray9: "hsl(0, 0%, 43.9%)",
  gray10: "hsl(0, 0%, 49.4%)",
  gray11: "hsl(0, 0%, 62.8%)",
  gray12: "hsl(0, 0%, 93.0%)"
};

//# sourceMappingURL=gray.js.map

;// CONCATENATED MODULE: ./node_modules/@tamagui/colors/dist/esm/dark/green.js
const green_green = {
  green1: "hsl(146, 30.0%, 7.4%)",
  green2: "hsl(155, 44.2%, 8.4%)",
  green3: "hsl(155, 46.7%, 10.9%)",
  green4: "hsl(154, 48.4%, 12.9%)",
  green5: "hsl(154, 49.7%, 14.9%)",
  green6: "hsl(154, 50.9%, 17.6%)",
  green7: "hsl(153, 51.8%, 21.8%)",
  green8: "hsl(151, 51.7%, 28.4%)",
  green9: "hsl(151, 55.0%, 41.5%)",
  green10: "hsl(151, 49.3%, 46.5%)",
  green11: "hsl(151, 50.0%, 53.2%)",
  green12: "hsl(137, 72.0%, 94.0%)"
};

//# sourceMappingURL=green.js.map

;// CONCATENATED MODULE: ./node_modules/@tamagui/colors/dist/esm/dark/orange.js
const orange_orange = {
  orange1: "hsl(30, 70.0%, 7.2%)",
  orange2: "hsl(28, 100%, 8.4%)",
  orange3: "hsl(26, 91.1%, 11.6%)",
  orange4: "hsl(25, 88.3%, 14.1%)",
  orange5: "hsl(24, 87.6%, 16.6%)",
  orange6: "hsl(24, 88.6%, 19.8%)",
  orange7: "hsl(24, 92.4%, 24.0%)",
  orange8: "hsl(25, 100%, 29.0%)",
  orange9: "hsl(24, 94.0%, 50.0%)",
  orange10: "hsl(24, 100%, 58.5%)",
  orange11: "hsl(24, 100%, 62.2%)",
  orange12: "hsl(24, 97.0%, 93.2%)"
};

//# sourceMappingURL=orange.js.map

;// CONCATENATED MODULE: ./node_modules/@tamagui/colors/dist/esm/dark/pink.js
const pink_pink = {
  pink1: "hsl(318, 25.0%, 9.6%)",
  pink2: "hsl(319, 32.2%, 11.6%)",
  pink3: "hsl(319, 41.0%, 16.0%)",
  pink4: "hsl(320, 45.4%, 18.7%)",
  pink5: "hsl(320, 49.0%, 21.1%)",
  pink6: "hsl(321, 53.6%, 24.4%)",
  pink7: "hsl(321, 61.1%, 29.7%)",
  pink8: "hsl(322, 74.9%, 37.5%)",
  pink9: "hsl(322, 65.0%, 54.5%)",
  pink10: "hsl(323, 72.8%, 59.2%)",
  pink11: "hsl(325, 90.0%, 66.4%)",
  pink12: "hsl(322, 90.0%, 95.8%)"
};

//# sourceMappingURL=pink.js.map

;// CONCATENATED MODULE: ./node_modules/@tamagui/colors/dist/esm/dark/purple.js
const purple_purple = {
  purple1: "hsl(284, 20.0%, 9.6%)",
  purple2: "hsl(283, 30.0%, 11.8%)",
  purple3: "hsl(281, 37.5%, 16.5%)",
  purple4: "hsl(280, 41.2%, 20.0%)",
  purple5: "hsl(279, 43.8%, 23.3%)",
  purple6: "hsl(277, 46.4%, 27.5%)",
  purple7: "hsl(275, 49.3%, 34.6%)",
  purple8: "hsl(272, 52.1%, 45.9%)",
  purple9: "hsl(272, 51.0%, 54.0%)",
  purple10: "hsl(273, 57.3%, 59.1%)",
  purple11: "hsl(275, 80.0%, 71.0%)",
  purple12: "hsl(279, 75.0%, 95.7%)"
};

//# sourceMappingURL=purple.js.map

;// CONCATENATED MODULE: ./node_modules/@tamagui/colors/dist/esm/dark/red.js
const red_red = {
  red1: "hsl(353, 23.0%, 9.8%)",
  red2: "hsl(357, 34.4%, 12.0%)",
  red3: "hsl(356, 43.4%, 16.4%)",
  red4: "hsl(356, 47.6%, 19.2%)",
  red5: "hsl(356, 51.1%, 21.9%)",
  red6: "hsl(356, 55.2%, 25.9%)",
  red7: "hsl(357, 60.2%, 31.8%)",
  red8: "hsl(358, 65.0%, 40.4%)",
  red9: "hsl(358, 75.0%, 59.0%)",
  red10: "hsl(358, 85.3%, 64.0%)",
  red11: "hsl(358, 100%, 69.5%)",
  red12: "hsl(351, 89.0%, 96.0%)"
};

//# sourceMappingURL=red.js.map

;// CONCATENATED MODULE: ./node_modules/@tamagui/colors/dist/esm/dark/yellow.js
const yellow_yellow = {
  yellow1: "hsl(45, 100%, 5.5%)",
  yellow2: "hsl(46, 100%, 6.7%)",
  yellow3: "hsl(45, 100%, 8.7%)",
  yellow4: "hsl(45, 100%, 10.4%)",
  yellow5: "hsl(47, 100%, 12.1%)",
  yellow6: "hsl(49, 100%, 14.3%)",
  yellow7: "hsl(49, 90.3%, 18.4%)",
  yellow8: "hsl(50, 100%, 22.0%)",
  yellow9: "hsl(53, 92.0%, 50.0%)",
  yellow10: "hsl(54, 100%, 68.0%)",
  yellow11: "hsl(48, 100%, 47.0%)",
  yellow12: "hsl(53, 100%, 91.0%)"
};

//# sourceMappingURL=yellow.js.map

// EXTERNAL MODULE: ./node_modules/@tamagui/web/dist/cjs/index.js
var cjs = __webpack_require__(17187);
;// CONCATENATED MODULE: ./node_modules/@tamagui/themes/dist/esm/tokens.js


const size = {
  $0: 0,
  "$0.25": 2,
  "$0.5": 4,
  "$0.75": 8,
  $1: 20,
  "$1.5": 24,
  $2: 28,
  "$2.5": 32,
  $3: 36,
  "$3.5": 40,
  $4: 44,
  $true: 44,
  "$4.5": 48,
  $5: 52,
  $6: 64,
  $7: 74,
  $8: 84,
  $9: 94,
  $10: 104,
  $11: 124,
  $12: 144,
  $13: 164,
  $14: 184,
  $15: 204,
  $16: 224,
  $17: 224,
  $18: 244,
  $19: 264,
  $20: 284
};
const spaces = Object.entries(size).map(([k, v]) => {
  return [k, sizeToSpace(v)];
});
function sizeToSpace(v) {
  if (v === 0)
    return 0;
  if (v === 2)
    return 0.5;
  if (v === 4)
    return 1;
  if (v === 8)
    return 1.5;
  if (v <= 16)
    return Math.round(v * 0.333);
  return Math.floor(v * 0.7 - 12);
}
const spacesNegative = spaces.map(([k, v]) => [`-${k.slice(1)}`, -v]);
const space = {
  ...Object.fromEntries(spaces),
  ...Object.fromEntries(spacesNegative)
};
const zIndex = {
  0: 0,
  1: 100,
  2: 200,
  3: 300,
  4: 400,
  5: 500
};
const colorTokens = {
  light: {
    blue: blue,
    gray: gray,
    green: green,
    orange: orange,
    pink: pink,
    purple: purple,
    red: red,
    yellow: yellow
  },
  dark: {
    blue: blue_blue,
    gray: gray_gray,
    green: green_green,
    orange: orange_orange,
    pink: pink_pink,
    purple: purple_purple,
    red: red_red,
    yellow: yellow_yellow
  }
};
const darkColors = {
  ...colorTokens.dark.blue,
  ...colorTokens.dark.gray,
  ...colorTokens.dark.green,
  ...colorTokens.dark.orange,
  ...colorTokens.dark.pink,
  ...colorTokens.dark.purple,
  ...colorTokens.dark.red,
  ...colorTokens.dark.yellow
};
const lightColors = {
  ...colorTokens.light.blue,
  ...colorTokens.light.gray,
  ...colorTokens.light.green,
  ...colorTokens.light.orange,
  ...colorTokens.light.pink,
  ...colorTokens.light.purple,
  ...colorTokens.light.red,
  ...colorTokens.light.yellow
};
const color = {
  ...postfixObjKeys(lightColors, "Light"),
  ...postfixObjKeys(darkColors, "Dark")
};
function postfixObjKeys(obj, postfix) {
  return Object.fromEntries(
    Object.entries(obj).map(([k, v]) => [`${k}${postfix}`, v])
  );
}
const radius = {
  0: 0,
  1: 3,
  2: 5,
  3: 7,
  4: 9,
  true: 9,
  5: 10,
  6: 16,
  7: 19,
  8: 22,
  9: 26,
  10: 34,
  11: 42,
  12: 50
};
const tokens = (0,cjs.createTokens)({
  color,
  radius,
  zIndex,
  space,
  size
});

//# sourceMappingURL=tokens.js.map


/***/ }),

/***/ 36527:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var src_exports = {};
__export(src_exports, {
  useDidFinishSSR: () => useDidFinishSSR
});
module.exports = __toCommonJS(src_exports);
var import_constants = __webpack_require__(14810);
var import_react = __webpack_require__(16689);
function useDidFinishSSR() {
  if (import_constants.isServer || import_constants.isRSC) {
    return false;
  }
  const [did, setDid] = (0, import_react.useState)(false);
  (0, import_constants.useIsomorphicLayoutEffect)(() => {
    (0, import_react.startTransition)(() => {
      setDid(true);
    });
  }, []);
  return did;
}
// Annotate the CommonJS export names for ESM import in node:
0 && (0);
//# sourceMappingURL=index.js.map


/***/ }),

/***/ 90951:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __reExport = (target, mod, secondTarget) => (__copyProps(target, mod, "default"), secondTarget && __copyProps(secondTarget, mod, "default"));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var src_exports = {};
module.exports = __toCommonJS(src_exports);
__reExport(src_exports, __webpack_require__(92708), module.exports);
__reExport(src_exports, __webpack_require__(76146), module.exports);
//# sourceMappingURL=index.js.map


/***/ }),

/***/ 92708:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var useEvent_exports = {};
__export(useEvent_exports, {
  useEvent: () => useEvent
});
module.exports = __toCommonJS(useEvent_exports);
var import_useGet = __webpack_require__(76146);
function useEvent(callback) {
  return (0, import_useGet.useGet)(callback, defaultValue, true);
}
const defaultValue = () => {
  throw new Error("Cannot call an event handler while rendering.");
};
// Annotate the CommonJS export names for ESM import in node:
0 && (0);
//# sourceMappingURL=useEvent.js.map


/***/ }),

/***/ 76146:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var useGet_exports = {};
__export(useGet_exports, {
  useGet: () => useGet
});
module.exports = __toCommonJS(useGet_exports);
var import_react = __webpack_require__(16689);
const isWeb = "web" === "web";
const isClient = typeof window !== "undefined";
const useIsomorphicLayoutEffect = !isWeb || isClient ? import_react.useLayoutEffect : import_react.useEffect;
function useGet(currentValue, initialValue, forwardToFunction) {
  const curRef = (0, import_react.useRef)(initialValue ?? currentValue);
  useIsomorphicLayoutEffect(() => {
    curRef.current = currentValue;
  });
  return (0, import_react.useCallback)(
    forwardToFunction ? (...args) => {
      var _a;
      return (_a = curRef.current) == null ? void 0 : _a.apply(null, args);
    } : () => curRef.current,
    []
  );
}
// Annotate the CommonJS export names for ESM import in node:
0 && (0);
//# sourceMappingURL=useGet.js.map


/***/ }),

/***/ 52707:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var src_exports = {};
__export(src_exports, {
  isServerSide: () => isServerSide,
  useForceUpdate: () => useForceUpdate
});
module.exports = __toCommonJS(src_exports);
var import_react = __webpack_require__(16689);
const isServerSide =  true && typeof window === "undefined";
const idFn = () => {
};
function useForceUpdate() {
  return isServerSide ? idFn : (0, import_react.useReducer)((x) => x + 1, 0)[1];
}
// Annotate the CommonJS export names for ESM import in node:
0 && (0);
//# sourceMappingURL=index.js.map


/***/ }),

/***/ 52092:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var PresenceContext_exports = {};
__export(PresenceContext_exports, {
  PresenceContext: () => PresenceContext
});
module.exports = __toCommonJS(PresenceContext_exports);
var import_react = __webpack_require__(16689);
const PresenceContext = (0, import_react.createContext)(null);
// Annotate the CommonJS export names for ESM import in node:
0 && (0);
//# sourceMappingURL=PresenceContext.js.map


/***/ }),

/***/ 33193:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __reExport = (target, mod, secondTarget) => (__copyProps(target, mod, "default"), secondTarget && __copyProps(secondTarget, mod, "default"));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var src_exports = {};
module.exports = __toCommonJS(src_exports);
__reExport(src_exports, __webpack_require__(52092), module.exports);
__reExport(src_exports, __webpack_require__(8400), module.exports);
//# sourceMappingURL=index.js.map


/***/ }),

/***/ 8400:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var usePresence_exports = {};
__export(usePresence_exports, {
  isPresent: () => isPresent,
  useIsPresent: () => useIsPresent,
  usePresence: () => usePresence
});
module.exports = __toCommonJS(usePresence_exports);
var import_react = __webpack_require__(16689);
var import_PresenceContext = __webpack_require__(52092);
function usePresence() {
  const context = (0, import_react.useContext)(import_PresenceContext.PresenceContext);
  if (!context) {
    return [true, null, context];
  }
  const { isPresent: isPresent2, onExitComplete, register } = context;
  const id = (0, import_react.useId)() || "";
  (0, import_react.useEffect)(() => register(id), [id, register]);
  const safeToRemove = () => onExitComplete == null ? void 0 : onExitComplete(id);
  return !isPresent2 && onExitComplete ? [false, safeToRemove, context] : [true, void 0, context];
}
function useIsPresent() {
  return isPresent((0, import_react.useContext)(import_PresenceContext.PresenceContext));
}
function isPresent(context) {
  return context === null ? true : context.isPresent;
}
// Annotate the CommonJS export names for ESM import in node:
0 && (0);
//# sourceMappingURL=usePresence.js.map


/***/ }),

/***/ 5656:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var Tamagui_exports = {};
__export(Tamagui_exports, {
  Tamagui: () => Tamagui,
  getValueFromIdentifier: () => getValueFromIdentifier,
  setIdentifierValue: () => setIdentifierValue
});
module.exports = __toCommonJS(Tamagui_exports);
var Helpers = __toESM(__webpack_require__(37513));
var import_config = __webpack_require__(16265);
var import_insertStyleRule = __webpack_require__(37269);
var import_useMedia = __webpack_require__(85030);
class TamaguiManager {
  constructor() {
    this.Helpers = Helpers;
  }
  get mediaState() {
    return { ...import_useMedia.mediaState };
  }
  get config() {
    return (0, import_config.getConfig)();
  }
  get insertedRules() {
    return (0, import_insertStyleRule.getAllRules)();
  }
  get allSelectors() {
    return (0, import_insertStyleRule.getAllSelectors)();
  }
  get allTransforms() {
    return (0, import_insertStyleRule.getAllTransforms)();
  }
  get identifierToValue() {
    return identifierToValue;
  }
}
const Tamagui = new TamaguiManager();
const identifierToValue = /* @__PURE__ */ new Map();
const getValueFromIdentifier = (identifier) => {
  return identifierToValue.get(identifier);
};
const setIdentifierValue = (identifier, value) => {
  identifierToValue.set(identifier, value);
};
// Annotate the CommonJS export names for ESM import in node:
0 && (0);
//# sourceMappingURL=Tamagui.js.map


/***/ }),

/***/ 3791:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var addTheme_exports = {};
__export(addTheme_exports, {
  addTheme: () => addTheme
});
module.exports = __toCommonJS(addTheme_exports);
var import_constants = __webpack_require__(14810);
var import_config = __webpack_require__(16265);
var import_getThemeCSSRules = __webpack_require__(75099);
var import_themes = __webpack_require__(49055);
function addTheme(props) {
  var _a;
  const config = (0, import_config.getConfig)();
  if (false) {}
  const { name: themeName, theme: themeIn, insertCSS } = props;
  const theme = { ...themeIn };
  for (const key in theme) {
    (0, import_themes.ensureThemeVariable)(theme, key);
  }
  const themeProxied = (0, import_themes.proxyThemeToParents)(themeName, theme, config.themes);
  config.themes[themeName] = themeProxied;
  let cssRules = [];
  if (import_constants.isWeb) {
    if (insertCSS) {
      cssRules = (0, import_getThemeCSSRules.getThemeCSSRules)({
        // @ts-ignore this works but should be fixed types
        config,
        themeName,
        names: [themeName],
        theme
      });
      const id = `t_theme_style_${themeName}`;
      const existing = document.querySelector(`#${id}`);
      const style = document.createElement("style");
      style.id = id;
      style.appendChild(document.createTextNode(cssRules.join("\n")));
      document.head.appendChild(style);
      if (existing) {
        (_a = existing.parentElement) == null ? void 0 : _a.removeChild(existing);
      }
    }
  }
  (0, import_config.updateConfig)("themes", { ...config.themes, [themeName]: themeProxied });
  return {
    theme: themeProxied,
    cssRules
  };
}
// Annotate the CommonJS export names for ESM import in node:
0 && (0);
//# sourceMappingURL=addTheme.js.map


/***/ }),

/***/ 16265:
/***/ ((module) => {

"use strict";

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var config_exports = {};
__export(config_exports, {
  configListeners: () => configListeners,
  getConfig: () => getConfig,
  getFont: () => getFont,
  getThemes: () => getThemes,
  getTokens: () => getTokens,
  onConfiguredOnce: () => onConfiguredOnce,
  setConfig: () => setConfig,
  setConfigFont: () => setConfigFont,
  updateConfig: () => updateConfig,
  useTokens: () => useTokens
});
module.exports = __toCommonJS(config_exports);
let conf;
const setConfig = (next) => {
  conf = next;
  configListeners.forEach((cb) => cb(next));
};
const setConfigFont = (name, font, fontParsed) => {
  if (false) {}
  conf.fonts[name] = font;
  conf.fontsParsed[`$${name}`] = fontParsed;
};
const getConfig = () => {
  if (!conf) {
    throw new Error(
       false ? 0 : "Err0"
    );
  }
  return conf;
};
let cached;
const getTokens = ({
  prefixed
} = {}) => {
  if (!conf)
    throw new Error(`never called createTamagui`);
  if (prefixed === false)
    return conf.tokens;
  if (prefixed === true)
    return conf.tokensParsed;
  return cached ?? (cached = Object.freeze({
    size: {
      ...conf.tokens["size"],
      ...conf.tokensParsed["size"]
    },
    space: {
      ...conf.tokens["space"],
      ...conf.tokensParsed["space"]
    },
    radius: {
      ...conf.tokens["radius"],
      ...conf.tokensParsed["radius"]
    },
    zIndex: {
      ...conf.tokens["zIndex"],
      ...conf.tokensParsed["zIndex"]
    },
    color: {
      ...conf.tokens["color"],
      ...conf.tokensParsed["color"]
    }
  }));
};
const useTokens = () => getTokens();
const getThemes = () => conf.themes;
const configListeners = /* @__PURE__ */ new Set();
const onConfiguredOnce = (cb) => {
  if (conf) {
    cb(conf);
  } else {
    configListeners.add(cb);
  }
};
const updateConfig = (key, value) => {
  Object.assign(key, value);
};
const getFont = (name) => {
  var _a;
  const conf2 = getConfig();
  return conf2.fontsParsed[name] ?? ((_a = Object.entries(conf2.fontsParsed).find(
    ([k]) => {
      var _a2, _b;
      return ((_b = (_a2 = conf2.fontsParsed[k]) == null ? void 0 : _a2.family) == null ? void 0 : _b["val"]) === name;
    }
  )) == null ? void 0 : _a[1]);
};
// Annotate the CommonJS export names for ESM import in node:
0 && (0);
//# sourceMappingURL=config.js.map


/***/ }),

/***/ 36297:
/***/ ((module) => {

"use strict";

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var constants_exports = {};
__export(constants_exports, {
  THEME_CLASSNAME_PREFIX: () => THEME_CLASSNAME_PREFIX,
  THEME_NAME_SEPARATOR: () => THEME_NAME_SEPARATOR,
  stackDefaultStyles: () => stackDefaultStyles,
  webOnlyDefaultStyles: () => webOnlyDefaultStyles
});
module.exports = __toCommonJS(constants_exports);
const THEME_NAME_SEPARATOR = "_";
const THEME_CLASSNAME_PREFIX = "t_";
const webOnlyDefaultStyles = {
  display: "flex",
  flexBasis: "auto",
  boxSizing: "border-box",
  position: "relative",
  minHeight: 0,
  minWidth: 0
};
const stackDefaultStyles = {
  alignItems: "stretch",
  flexShrink: 0,
  ...webOnlyDefaultStyles
};
// Annotate the CommonJS export names for ESM import in node:
0 && (0);
//# sourceMappingURL=constants.js.map


/***/ }),

/***/ 57405:
/***/ ((module) => {

"use strict";

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var isDevTools_exports = {};
__export(isDevTools_exports, {
  isDevTools: () => isDevTools
});
module.exports = __toCommonJS(isDevTools_exports);
const isDevTools = (() => {
  if (false) {}
  return false;
})();
// Annotate the CommonJS export names for ESM import in node:
0 && (0);
//# sourceMappingURL=isDevTools.js.map


/***/ }),

/***/ 16505:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var ButtonNestingContext_exports = {};
__export(ButtonNestingContext_exports, {
  ButtonNestingContext: () => ButtonNestingContext
});
module.exports = __toCommonJS(ButtonNestingContext_exports);
var import_react = __webpack_require__(16689);
const ButtonNestingContext = (0, import_react.createContext)(false);
// Annotate the CommonJS export names for ESM import in node:
0 && (0);
//# sourceMappingURL=ButtonNestingContext.js.map


/***/ }),

/***/ 78027:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var FontLanguageContext_exports = {};
__export(FontLanguageContext_exports, {
  FontLanguageContext: () => FontLanguageContext
});
module.exports = __toCommonJS(FontLanguageContext_exports);
var import_react = __webpack_require__(16689);
const FontLanguageContext = (0, import_react.createContext)(null);
// Annotate the CommonJS export names for ESM import in node:
0 && (0);
//# sourceMappingURL=FontLanguageContext.js.map


/***/ }),

/***/ 11195:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var TextAncestorContext_exports = {};
__export(TextAncestorContext_exports, {
  TextAncestorContext: () => TextAncestorContext
});
module.exports = __toCommonJS(TextAncestorContext_exports);
var import_react = __webpack_require__(16689);
const TextAncestorContext = (0, import_react.createContext)(false);
// Annotate the CommonJS export names for ESM import in node:
0 && (0);
//# sourceMappingURL=TextAncestorContext.js.map


/***/ }),

/***/ 86932:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var createComponent_exports = {};
__export(createComponent_exports, {
  Spacer: () => Spacer,
  Unspaced: () => Unspaced,
  createComponent: () => createComponent,
  defaultComponentState: () => defaultComponentState,
  mouseUps: () => mouseUps,
  spacedChildren: () => spacedChildren
});
module.exports = __toCommonJS(createComponent_exports);
var import_jsx_runtime = __webpack_require__(85893);
var import_compose_refs = __webpack_require__(95915);
var import_constants = __webpack_require__(14810);
var import_helpers = __webpack_require__(37513);
var import_react = __toESM(__webpack_require__(16689));
var import_config = __webpack_require__(16265);
var import_constants2 = __webpack_require__(36297);
var import_FontLanguageContext = __webpack_require__(78027);
var import_TextAncestorContext = __webpack_require__(11195);
var import_createVariable = __webpack_require__(88957);
var import_extendStaticConfig = __webpack_require__(23534);
var import_getSplitStyles = __webpack_require__(41384);
var import_insertStyleRule = __webpack_require__(37269);
var import_mergeProps = __webpack_require__(1458);
var import_proxyThemeVariables = __webpack_require__(22476);
var import_useShallowSetState = __webpack_require__(97312);
var import_useMedia = __webpack_require__(85030);
var import_useServerHooks = __webpack_require__(14425);
var import_useTheme = __webpack_require__(69953);
var import_setupHooks = __webpack_require__(25142);
var import_Slot = __webpack_require__(12897);
var import_Theme = __webpack_require__(49798);
"web";
const defaultComponentState = {
  hover: false,
  press: false,
  pressIn: false,
  focus: false,
  unmounted: true
};
const defaultComponentStateMounted = {
  ...defaultComponentState,
  unmounted: false
};
let tamaguiConfig;
let AnimatedText;
let AnimatedView;
let initialTheme;
const mouseUps = /* @__PURE__ */ new Set();
if (typeof document !== "undefined") {
  const cancelTouches = () => {
    mouseUps.forEach((x) => x());
    mouseUps.clear();
  };
  addEventListener("mouseup", cancelTouches);
  addEventListener("touchend", cancelTouches);
  addEventListener("touchcancel", cancelTouches);
}
function mergeShorthands({ defaultProps }, { shorthands }) {
  for (const key of Object.keys(defaultProps)) {
    defaultProps[shorthands[key] || key] = defaultProps[key];
  }
}
let BaseText;
let BaseView;
let hasSetupBaseViews = false;
function createComponent(configIn, ParentComponent) {
  const staticConfig = (() => {
    const next = (0, import_extendStaticConfig.extendStaticConfig)(configIn, ParentComponent);
    if ("parsed" in next) {
      return next;
    } else {
      return (0, import_extendStaticConfig.parseStaticConfig)(next);
    }
  })();
  const defaultComponentClassName = `is_${staticConfig.componentName}`;
  let tamaguiDefaultProps;
  let defaultTag;
  const component = (0, import_react.forwardRef)((propsIn, forwardedRef) => {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o;
    if (false) {}
    if (false) {}
    let props;
    if (tamaguiDefaultProps && !propsIn.asChild) {
      props = (0, import_mergeProps.mergeProps)(tamaguiDefaultProps, propsIn)[0];
    } else {
      props = propsIn;
    }
    const debugProp = props["debug"];
    const { Component, isText, isZStack } = staticConfig;
    const componentName = props.componentName || staticConfig.componentName;
    const componentClassName = props.asChild ? "" : props.componentName ? `is_${props.componentName}` : defaultComponentClassName;
    const animationsConfig = tamaguiConfig.animations;
    const useAnimations = animationsConfig == null ? void 0 : animationsConfig.useAnimations;
    const avoidClassesWhileAnimating = animationsConfig.isReactNative;
    const hasEnterStyle = !!props.enterStyle;
    const needsMount = Boolean(
      (import_constants.isWeb ? import_constants.isClient : true) && (hasEnterStyle || props.animation)
    );
    const states = (0, import_useServerHooks.useServerState)(
      needsMount ? defaultComponentState : defaultComponentStateMounted
    );
    const state = propsIn.forceStyle ? { ...states[0], [propsIn.forceStyle]: true } : states[0];
    const setState = states[1];
    const setStateShallow = (0, import_useShallowSetState.useShallowSetState)(setState, debugProp, componentName);
    const stateRef = (0, import_react.useRef)(
      void 0
    );
    stateRef.current ?? (stateRef.current = {});
    const isAnimated = (() => {
      const next = !!(!staticConfig.isHOC && useAnimations && (props.animation || props.style && hasAnimatedStyleValue(props.style)));
      if (next && !stateRef.current.hasAnimated) {
        stateRef.current.hasAnimated = true;
      }
      return next || stateRef.current.hasAnimated;
    })();
    const usePresence = (_d = tamaguiConfig.animations) == null ? void 0 : _d.usePresence;
    const presence = !import_constants.isRSC && isAnimated ? usePresence() : null;
    if (isAnimated && presence) {
      const presenceState = presence[2];
      if (presenceState) {
        if (state.unmounted && presenceState.enterVariant) {
          props[presenceState.enterVariant] = true;
        }
        if (!presenceState.isPresent && presenceState.exitVariant) {
          props[presenceState.exitVariant] = true;
        }
      }
    }
    const isReactNative = Boolean(
      staticConfig.isReactNative || isAnimated && tamaguiConfig.animations.isReactNative
    );
    if (false) {}
    const shouldAvoidClasses = !import_constants.isWeb || !!(props.animation && avoidClassesWhileAnimating) || !staticConfig.acceptsClassName;
    const shouldForcePseudo = !!propsIn.forceStyle;
    const noClassNames = shouldAvoidClasses || shouldForcePseudo;
    const themeState = (0, import_useTheme.useThemeWithState)({
      name: props.theme,
      componentName,
      reset: props.reset,
      inverse: props.themeInverse,
      // @ts-expect-error
      disable: props["data-themeable"],
      debug: props.debug,
      shouldUpdate: () => !!stateRef.current.didAccessThemeVariableValue
    });
    const hasTextAncestor = !!(import_constants.isWeb && isText ? (0, import_react.useContext)(import_TextAncestorContext.TextAncestorContext) : false);
    const languageContext = import_constants.isRSC ? null : (0, import_react.useContext)(import_FontLanguageContext.FontLanguageContext);
    const isDisabled = props.disabled ?? ((_e = props.accessibilityState) == null ? void 0 : _e.disabled);
    const isTaggable = !Component || typeof Component === "string";
    const element = import_constants.isWeb ? isTaggable ? props.tag || defaultTag || Component : Component : Component;
    const BaseTextComponent = BaseText || element || "span";
    const BaseViewComponent = BaseView || element || (hasTextAncestor ? "span" : "div");
    let elementType = isText ? (isAnimated ? AnimatedText : null) || BaseTextComponent : (isAnimated ? AnimatedView : null) || BaseViewComponent;
    elementType = Component || elementType;
    const isStringElement = typeof elementType === "string";
    const isExiting = (presence == null ? void 0 : presence[0]) === false;
    const mediaState = (0, import_useMedia.useMedia)(
      // @ts-ignore, we just pass a stable object so we can get it later with
      // should match to the one used in `setMediaShouldUpdate` below
      stateRef,
      debugProp ? { props, staticConfig } : null
    );
    (0, import_createVariable.setDidGetVariableValue)(false);
    const splitStyles = (0, import_getSplitStyles.useSplitStyles)(
      props,
      staticConfig,
      themeState.theme,
      {
        ...state,
        mediaState,
        noClassNames,
        dynamicStylesInline: noClassNames,
        hasTextAncestor,
        resolveVariablesAs: "auto",
        isExiting
      },
      null,
      languageContext || void 0,
      elementType,
      debugProp
    );
    const isMediaSpaced = Array.isArray(splitStyles.hasMedia);
    const shouldListenForMedia = (0, import_createVariable.didGetVariableValue)() || isMediaSpaced || noClassNames && splitStyles.hasMedia === true;
    (0, import_useMedia.setMediaShouldUpdate)(stateRef, {
      enabled: shouldListenForMedia,
      keys: noClassNames && isMediaSpaced ? splitStyles.hasMedia : null
    });
    const hostRef = (0, import_useServerHooks.useServerRef)(null);
    const isAnimatedReactNativeWeb = isAnimated && avoidClassesWhileAnimating;
    if (false) {}
    const {
      viewProps: viewPropsIn,
      pseudos,
      style: splitStylesStyle,
      classNames,
      space
    } = splitStyles;
    const propsWithAnimation = props;
    let animationStyles;
    if (!import_constants.isRSC && isAnimated && useAnimations && !staticConfig.isHOC) {
      const animations = useAnimations({
        props: propsWithAnimation,
        style: splitStylesStyle,
        presence,
        state,
        pseudos: pseudos || null,
        onDidAnimate: props.onDidAnimate,
        hostRef,
        staticConfig
      });
      if (animations) {
        animationStyles = animations.style;
      }
    }
    const {
      asChild,
      children,
      onPress,
      onPressIn,
      onPressOut,
      onHoverIn,
      onHoverOut,
      themeShallow,
      spaceDirection: _spaceDirection,
      disabled: disabledProp,
      onMouseUp,
      onMouseDown,
      onMouseEnter,
      onMouseLeave,
      separator,
      // ignore from here on out
      forceStyle: _forceStyle,
      // @ts-ignore  for next/link compat etc
      onClick,
      theme: _themeProp,
      // @ts-ignore
      defaultVariants,
      ...nonTamaguiProps
    } = viewPropsIn;
    const disabled = ((_f = props.accessibilityState) == null ? void 0 : _f.disabled) || props.accessibilityDisabled;
    let viewProps = nonTamaguiProps;
    if ( true && !isReactNative && !asChild) {
      viewProps = (_h = (_g = import_setupHooks.hooks).usePropsTransform) == null ? void 0 : _h.call(_g, elementType, nonTamaguiProps, hostRef);
    } else {
      viewProps = nonTamaguiProps;
    }
    viewProps.ref = (0, import_compose_refs.useComposedRefs)(hostRef, forwardedRef);
    if (false) {}
    const unPress = (0, import_react.useCallback)(() => {
      setStateShallow({
        press: false,
        pressIn: false
      });
    }, [setStateShallow]);
    if (import_constants.isWeb) {
      (0, import_react.useEffect)(() => {
        return () => {
          mouseUps.delete(unPress);
        };
      }, []);
    }
    const shouldSetMounted = needsMount && state.unmounted;
    (0, import_react.useEffect)(() => {
      if (!shouldSetMounted)
        return;
      if (state.unmounted === true && needsMount) {
        setStateShallow({
          unmounted: false
        });
        return;
      }
      setStateShallow({
        unmounted: false
      });
    }, [shouldSetMounted, state.unmounted]);
    let styles;
    if (isStringElement && shouldAvoidClasses && !shouldForcePseudo) {
      styles = {
        ...animationStyles ?? splitStylesStyle
      };
    } else {
      styles = [animationStyles ?? splitStylesStyle];
      if (shouldForcePseudo) {
        const next = {};
        styles.forEach((style) => Object.assign(next, style));
        Object.assign(splitStyles.style, next);
      }
    }
    let fontFamily = isText ? splitStyles.fontFamily || staticConfig.defaultProps.fontFamily : null;
    if (fontFamily && fontFamily[0] === "$") {
      fontFamily = fontFamily.slice(1);
    }
    const fontFamilyClassName = fontFamily ? `font_${fontFamily}` : "";
    const classList = [
      hasEnterStyle && (state.unmounted && needsMount || !import_constants.isClient) ? "t_will-mount" : "",
      componentName ? componentClassName : "",
      fontFamilyClassName,
      classNames ? Object.values(classNames).join(" ") : ""
    ];
    const className = classList.join(" ");
    if (true) {
      const style = animationStyles ?? splitStyles.style;
      if (isAnimatedReactNativeWeb) {
        viewProps.style = style;
      } else if (isReactNative) {
        const cnStyles = { $$css: true };
        for (const name of className.split(" ")) {
          cnStyles[name] = name;
        }
        viewProps.style = [...Array.isArray(style) ? style : [style], cnStyles];
        if (false) {}
      } else {
        viewProps.className = className;
        viewProps.style = style;
      }
    }
    if (false) {}
    const runtimePressStyle = !disabled && noClassNames && (pseudos == null ? void 0 : pseudos.pressStyle);
    const attachPress = Boolean(
      runtimePressStyle || onPress || onPressOut || onPressIn || onClick
    );
    const runtimeHoverStyle = !disabled && noClassNames && (pseudos == null ? void 0 : pseudos.hoverStyle);
    const isHoverable = import_constants.isWeb && !!(runtimeHoverStyle || onHoverIn || onHoverOut || onMouseEnter || onMouseLeave);
    const handlesPressEvents = !(import_constants.isWeb || asChild);
    const shouldAttach = Boolean(
      attachPress || isHoverable || noClassNames && "pressStyle" in props || import_constants.isWeb && noClassNames && "hoverStyle" in props
    );
    const events = shouldAttach && !import_constants.isRSC && !isDisabled && !asChild ? {
      onPressOut: attachPress ? (e) => {
        unPress();
        onPressOut == null ? void 0 : onPressOut(e);
        onMouseUp == null ? void 0 : onMouseUp(e);
      } : void 0,
      ...isHoverable && {
        onMouseEnter: isHoverable ? (e) => {
          const next = {};
          if (isHoverable) {
            next.hover = true;
          }
          if (state.pressIn) {
            next.press = true;
          }
          if (isHoverable || state.pressIn) {
            setStateShallow(next);
          }
          onHoverIn == null ? void 0 : onHoverIn(e);
          onMouseEnter == null ? void 0 : onMouseEnter(e);
        } : void 0,
        onMouseLeave: isHoverable ? (e) => {
          const next = {};
          mouseUps.add(unPress);
          if (isHoverable) {
            next.hover = false;
          }
          if (state.pressIn) {
            next.press = false;
            next.pressIn = false;
          }
          if (Object.keys(next).length) {
            setStateShallow(next);
          }
          onHoverOut == null ? void 0 : onHoverOut(e);
          onMouseLeave == null ? void 0 : onMouseLeave(e);
        } : void 0
      },
      onPressIn: attachPress ? (e) => {
        setStateShallow({
          press: true,
          pressIn: true,
          hover: false
        });
        onPressIn == null ? void 0 : onPressIn(e);
        onMouseDown == null ? void 0 : onMouseDown(e);
        if (import_constants.isWeb) {
          mouseUps.add(unPress);
        }
      } : void 0,
      onPress: attachPress ? (e) => {
        unPress();
        import_constants.isWeb && (onClick == null ? void 0 : onClick(e));
        onPress == null ? void 0 : onPress(e);
      } : void 0
    } : null;
    if (false) {}
    (_m = (_l = import_setupHooks.hooks).useEvents) == null ? void 0 : _m.call(_l, viewProps, events, splitStyles, setStateShallow);
    const shouldReset = !!(themeShallow && themeState.isNewTheme);
    if (shouldReset) {
      stateRef.current.themeShallow = true;
    }
    let content = !children || asChild ? children : spacedChildren({
      separator,
      children,
      space,
      direction: props.spaceDirection || "both",
      isZStack,
      debug: debugProp
    });
    if (asChild) {
      elementType = import_Slot.Slot;
      viewProps = {
        ...viewProps,
        onPress,
        onPressIn,
        onPressOut
      };
    }
    content = (0, import_react.createElement)(elementType, viewProps, content);
    content = (0, import_Theme.useThemedChildren)(themeState, content, {
      shallow: stateRef.current.themeShallow
      // passPropsToChildren: true,
    });
    if (true) {
      if (events || isAnimatedReactNativeWeb) {
        content = /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
          "span",
          {
            className: `${isAnimatedReactNativeWeb ? className : ""}  _dsp_contents`,
            ...events && {
              onMouseEnter: events.onMouseEnter,
              onMouseLeave: events.onMouseLeave,
              onClick: events.onPress,
              onMouseDown: events.onPressIn,
              onMouseUp: events.onPressOut,
              onTouchStart: events.onPressIn,
              onTouchEnd: events.onPressOut
            },
            children: content
          }
        );
      }
    }
    if (false) {}
    return content;
  });
  if (staticConfig.componentName) {
    component.displayName = staticConfig.componentName;
  }
  (0, import_config.onConfiguredOnce)((conf) => {
    if (!tamaguiConfig) {
      tamaguiConfig = conf;
      if (tamaguiConfig.animations) {
        AnimatedText = tamaguiConfig.animations.Text;
        AnimatedView = tamaguiConfig.animations.View;
      }
      if (!initialTheme) {
        const next = conf.themes[Object.keys(conf.themes)[0]];
        initialTheme = (0, import_proxyThemeVariables.proxyThemeVariables)(next);
        if (false) {}
      }
    }
    mergeShorthands(staticConfig, tamaguiConfig);
    let defaultPropsIn = staticConfig.defaultProps || {};
    const parentNames = [...staticConfig.parentNames || [], staticConfig.componentName];
    if (tamaguiConfig.defaultProps && parentNames && staticConfig.componentName) {
      defaultPropsIn = mergeConfigDefaultProps(
        staticConfig.componentName,
        defaultPropsIn,
        tamaguiConfig.defaultProps,
        parentNames,
        tamaguiConfig
      );
    }
    const debug = defaultPropsIn["debug"];
    const [ourProps, ourClassNames] = (0, import_mergeProps.mergeProps)(defaultPropsIn, {});
    if (ourProps.tag) {
      defaultTag = ourProps.tag;
    }
    const noClassNames = !staticConfig.acceptsClassName;
    const { name, variants, defaultVariants, ...restProps } = ourProps;
    const [defaults, defaultsClassnames] = (0, import_mergeProps.mergeProps)(component.defaultProps, {
      ...defaultVariants,
      ...restProps
    });
    if (!import_constants.isWeb) {
      for (const key in staticConfig.defaultProps) {
        const val = staticConfig.defaultProps[key];
        if (import_helpers.validPseudoKeys[key])
          continue;
        defaults[key] = val;
      }
    }
    tamaguiDefaultProps = defaults;
    if (false) {}
  });
  let res = component;
  if (configIn.memo) {
    res = (0, import_react.memo)(res);
  }
  res.staticConfig = {
    validStyles: staticConfig.validStyles || import_helpers.stylePropsView,
    ...staticConfig
  };
  res.extractable = (Component, conf) => {
    Component.staticConfig = (0, import_extendStaticConfig.extendStaticConfig)(
      {
        Component,
        ...conf,
        neverFlatten: true,
        isHOC: true,
        defaultProps: {
          ...Component.defaultProps,
          ...conf == null ? void 0 : conf.defaultProps
        }
      },
      res
    );
    return Component;
  };
  return res;
}
const Unspaced = (props) => {
  return props.children;
};
Unspaced["isUnspaced"] = true;
const Spacer = createComponent({
  acceptsClassName: true,
  memo: true,
  componentName: "Spacer",
  validStyles: import_helpers.validStyles,
  defaultProps: {
    ...import_constants2.stackDefaultStyles,
    // avoid nesting issues
    tag: "span",
    size: true,
    pointerEvents: "none"
  },
  variants: {
    size: {
      "...size": (size, { tokens }) => {
        size = size === true ? "$true" : size;
        const sizePx = tokens.space[size] ?? size;
        return {
          width: sizePx,
          height: sizePx,
          minWidth: sizePx,
          minHeight: sizePx
        };
      }
    },
    flex: {
      true: {
        flexGrow: 1
      }
    },
    direction: {
      horizontal: {
        height: 0,
        minHeight: 0
      },
      vertical: {
        width: 0,
        minWidth: 0
      },
      both: {}
    }
  }
});
function spacedChildren(props) {
  var _a, _b, _c;
  const { isZStack, children, space, direction, spaceFlex, separator } = props;
  const hasSpace = !!(space || spaceFlex);
  const hasSeparator = !(separator === void 0 || separator === null);
  if (!(hasSpace || hasSeparator || isZStack)) {
    return children;
  }
  const childrenList = import_react.Children.toArray(children);
  const len = childrenList.length;
  if (len <= 1 && !isZStack && !((_b = (_a = childrenList[0]) == null ? void 0 : _a["type"]) == null ? void 0 : _b["shouldForwardSpace"])) {
    return childrenList;
  }
  const final = [];
  for (let [index, child] of childrenList.entries()) {
    const isEmpty = child === null || child === void 0 || Array.isArray(child) && child.length === 0;
    if (!isEmpty && import_react.default.isValidElement(child) && ((_c = child.type) == null ? void 0 : _c["shouldForwardSpace"])) {
      child = import_react.default.cloneElement(child, {
        space,
        spaceFlex,
        separator,
        key: child.key
      });
    }
    if (isEmpty || !child || child["key"] && !isZStack) {
      final.push(child);
    } else {
      final.push(
        /* @__PURE__ */ (0, import_jsx_runtime.jsx)(import_react.Fragment, { children: isZStack ? /* @__PURE__ */ (0, import_jsx_runtime.jsx)(AbsoluteFill, { children: child }) : child }, index)
      );
    }
    if (isUnspaced(child) && index === 0)
      continue;
    if (isZStack)
      continue;
    const next = childrenList[index + 1];
    if (next && !isUnspaced(next)) {
      if (separator) {
        if (hasSpace) {
          final.push(
            createSpacer({
              key: `_${index}_00tmgui`,
              direction,
              space,
              spaceFlex
            })
          );
        }
        final.push(
          import_react.default.isValidElement(separator) ? import_react.default.cloneElement(separator, { key: `sep_${index}` }) : separator
        );
        if (hasSpace) {
          final.push(
            createSpacer({
              key: `_${index}01tmgui`,
              direction,
              space,
              spaceFlex
            })
          );
        }
      } else {
        final.push(
          createSpacer({
            key: `_${index}02tmgui`,
            direction,
            space,
            spaceFlex
          })
        );
      }
    }
  }
  if (false) {}
  return final;
}
function createSpacer({ key, direction, space, spaceFlex }) {
  return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
    Spacer,
    {
      size: space,
      direction,
      ...typeof spaceFlex !== "undefined" && {
        flex: spaceFlex === true ? 1 : spaceFlex === false ? 0 : spaceFlex
      }
    },
    key
  );
}
function isUnspaced(child) {
  const t = child == null ? void 0 : child["type"];
  return (t == null ? void 0 : t["isVisuallyHidden"]) || (t == null ? void 0 : t["isUnspaced"]);
}
const DefaultProps = /* @__PURE__ */ new Map();
function mergeConfigDefaultProps(name, props, configDefaults, parentNames, conf) {
  const len = parentNames.length;
  let prev;
  for (let i = 0; i < len; i++) {
    const n = parentNames[i];
    if (!n)
      continue;
    if (DefaultProps.has(n)) {
      prev = DefaultProps.get(n);
      continue;
    }
    const props2 = configDefaults[n];
    if (!props2) {
      if (prev) {
        DefaultProps.set(n, prev);
      }
      continue;
    }
    prev = (0, import_mergeProps.mergeProps)(prev || {}, props2, false, conf.inverseShorthands)[0];
    DefaultProps.set(n, prev);
  }
  const ourDefaultsMerged = DefaultProps.get(name);
  if (ourDefaultsMerged) {
    return (0, import_mergeProps.mergeProps)(props, ourDefaultsMerged, false, conf.inverseShorthands)[0];
  }
  return props;
}
const AbsoluteFill = createComponent({
  defaultProps: {
    ...import_constants2.stackDefaultStyles,
    flexDirection: "column",
    position: "absolute",
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    pointerEvents: "box-none"
  }
});
function hasAnimatedStyleValue(style) {
  return Object.keys(style).some((k) => {
    const val = style[k];
    return val && typeof val === "object" && "_animation" in val;
  });
}
// Annotate the CommonJS export names for ESM import in node:
0 && (0);
//# sourceMappingURL=createComponent.js.map


/***/ }),

/***/ 74274:
/***/ ((module) => {

"use strict";

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var createFont_exports = {};
__export(createFont_exports, {
  createFont: () => createFont
});
module.exports = __toCommonJS(createFont_exports);
const fontWeights = [
  "100",
  "200",
  "300",
  "400",
  "500",
  "600",
  "700",
  "800",
  "900"
];
const processSection = (section, keys, defaultValue) => {
  if (typeof section === "string")
    return section;
  const sectionKeys = Object.keys(section);
  let fillValue = section[sectionKeys[0]];
  return Object.fromEntries(
    [.../* @__PURE__ */ new Set([...keys, ...sectionKeys])].map((key) => {
      const value = section[key] ?? defaultValue ?? fillValue;
      fillValue = value;
      defaultValue = value;
      return [key, value];
    })
  );
};
const createFont = (font) => {
  const sizeKeys = Object.keys(font.size);
  const processedFont = Object.fromEntries(
    Object.entries(font).map(([key, section]) => {
      return [
        key,
        processSection(
          section,
          key === "face" ? fontWeights : sizeKeys,
          key === "face" ? { normal: font.family } : void 0
        )
      ];
    })
  );
  return Object.freeze(processedFont);
};
// Annotate the CommonJS export names for ESM import in node:
0 && (0);
//# sourceMappingURL=createFont.js.map


/***/ }),

/***/ 99414:
/***/ ((module) => {

"use strict";

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var createShorthands_exports = {};
__export(createShorthands_exports, {
  createShorthands: () => createShorthands
});
module.exports = __toCommonJS(createShorthands_exports);
function createShorthands(shorthands) {
  return Object.freeze(shorthands);
}
// Annotate the CommonJS export names for ESM import in node:
0 && (0);
//# sourceMappingURL=createShorthands.js.map


/***/ }),

/***/ 45502:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var createTamagui_exports = {};
__export(createTamagui_exports, {
  createTamagui: () => createTamagui
});
module.exports = __toCommonJS(createTamagui_exports);
var import_constants = __webpack_require__(14810);
var import_config = __webpack_require__(16265);
var import_createVariables = __webpack_require__(26596);
var import_getThemeCSSRules = __webpack_require__(75099);
var import_insertStyleRule = __webpack_require__(37269);
var import_registerCSSVariable = __webpack_require__(20299);
var import_themes = __webpack_require__(49055);
var import_useMedia = __webpack_require__(85030);
var import_insertFont = __webpack_require__(89459);
var import_Tamagui = __webpack_require__(5656);
const createdConfigs = /* @__PURE__ */ new WeakMap();
function createTamagui(configIn) {
  var _a;
  if (createdConfigs.has(configIn)) {
    return configIn;
  }
  if (false) {}
  (0, import_insertStyleRule.scanAllSheets)();
  (0, import_insertStyleRule.listenForSheetChanges)();
  const fontTokens = Object.fromEntries(
    Object.entries(configIn.fonts).map(([k, v]) => {
      return [k, (0, import_createVariables.createVariables)(v, "f", true)];
    })
  );
  const fontsParsed = (() => {
    const res = {};
    for (const familyName in fontTokens) {
      res[`$${familyName}`] = (0, import_insertFont.parseFont)(fontTokens[familyName]);
    }
    return res;
  })();
  const themeConfig = (() => {
    const themes = { ...configIn.themes };
    const cssRuleSets = [];
    if (import_constants.isWeb) {
      let declarationsToRuleSet2 = function(decs, selector = "") {
        return `:root${selector} {${sep}${[...decs].join(`;${sep}`)}${sep}}`;
      };
      var declarationsToRuleSet = declarationsToRuleSet2;
      const declarations = [];
      const fontDeclarations = {};
      for (const key in configIn.tokens) {
        for (const skey in configIn.tokens[key]) {
          const val = configIn.tokens[key][skey];
          (0, import_registerCSSVariable.registerCSSVariable)(val);
          declarations.push((0, import_registerCSSVariable.variableToCSS)(val));
        }
      }
      for (const key in fontsParsed) {
        const fontParsed = fontsParsed[key];
        const [name, language] = key.includes("_") ? key.split("_") : [key];
        const fontVars = (0, import_insertFont.registerFontVariables)(fontParsed);
        fontDeclarations[key] = {
          name: name.slice(1),
          declarations: fontVars,
          language
        };
      }
      const sep =  false ? 0 : "";
      cssRuleSets.push(declarationsToRuleSet2(declarations));
      if (fontDeclarations) {
        for (const key in fontDeclarations) {
          const { name, declarations: declarations2, language = "default" } = fontDeclarations[key];
          const fontSelector = `.font_${name}`;
          const langSelector = `:root .t_lang-${name}-${language} ${fontSelector}`;
          const selectors = language === "default" ? ` ${fontSelector}, ${langSelector}` : langSelector;
          const specificRuleSet = declarationsToRuleSet2(declarations2, selectors);
          cssRuleSets.push(specificRuleSet);
        }
      }
    }
    const dedupedThemes = {};
    const existing = /* @__PURE__ */ new Map();
    for (const themeName in themes) {
      const rawTheme = themes[themeName];
      const key = JSON.stringify(rawTheme);
      if (existing.has(key)) {
        const e = existing.get(key);
        themes[themeName] = e.theme;
        e.names.push(themeName);
        continue;
      }
      const theme = { ...rawTheme };
      for (const key2 in theme) {
        (0, import_themes.ensureThemeVariable)(theme, key2);
      }
      themes[themeName] = theme;
      dedupedThemes[themeName] = {
        names: [themeName],
        theme
      };
      existing.set(key, dedupedThemes[themeName]);
    }
    let themeRuleSets = [];
    if (import_constants.isWeb || import_constants.isRSC) {
      for (const themeName in dedupedThemes) {
        themeRuleSets = [
          ...themeRuleSets,
          ...(0, import_getThemeCSSRules.getThemeCSSRules)({
            config: configIn,
            themeName,
            ...dedupedThemes[themeName]
          })
        ];
      }
    }
    for (const themeName in themes) {
      themes[themeName] = (0, import_themes.proxyThemeToParents)(themeName, themes[themeName], themes);
    }
    import_registerCSSVariable.tokensValueToVariable.clear();
    return {
      themes,
      cssRuleSets,
      themeRuleSets
    };
  })();
  const tokensParsed = Object.fromEntries(
    Object.entries(configIn.tokens).map(([k, v]) => {
      const val = Object.fromEntries(Object.entries(v).map(([k2, v2]) => [`$${k2}`, v2]));
      import_createVariables.tokensKeysOrdered.set(val, import_createVariables.tokensKeysOrdered.get(v));
      return [k, val];
    })
  );
  const shorthands = configIn.shorthands || {};
  const config = {
    fontLanguages: [],
    animations: {},
    media: {},
    ...configIn,
    // already processed by createTokens()
    tokens: configIn.tokens,
    // vite made this into a function if it wasn't set
    shorthands: { ...shorthands },
    inverseShorthands: shorthands ? Object.fromEntries(Object.entries(shorthands).map(([k, v]) => [v, k])) : {},
    themes: themeConfig.themes,
    fontsParsed,
    themeConfig,
    tokensParsed,
    parsed: true,
    getCSS: (separator = "\n") => {
      return `
._ovs-contain {overscroll-behavior:contain;}
.t_unmounted .t_will-mount {opacity:0;visibility:hidden;}
.is_Text .is_Text {display:inline-flex;}
._dsp_contents {display:contents;}
${themeConfig.cssRuleSets.join(separator)}
${themeConfig.themeRuleSets.join(separator)}
${(0, import_insertStyleRule.getAllRules)().join(separator)}`;
    }
    // const tokens = [...getToken(tokens.size[0])]
    // .spacer-sm + ._dsp_contents._dsp-sm-hidden { margin-left: -var(--${}) }
  };
  (0, import_useMedia.configureMedia)(config);
  (0, import_config.setConfig)(config);
  if (import_config.configListeners.size) {
    import_config.configListeners.forEach((cb) => cb(config));
    import_config.configListeners.clear();
  }
  createdConfigs.set(config, true);
  if (false) {}
  return config;
}
// Annotate the CommonJS export names for ESM import in node:
0 && (0);
//# sourceMappingURL=createTamagui.js.map


/***/ }),

/***/ 72705:
/***/ ((module) => {

"use strict";

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var createTheme_exports = {};
__export(createTheme_exports, {
  createTheme: () => createTheme
});
module.exports = __toCommonJS(createTheme_exports);
const createTheme = (theme) => {
  return theme;
};
// Annotate the CommonJS export names for ESM import in node:
0 && (0);
//# sourceMappingURL=createTheme.js.map


/***/ }),

/***/ 6019:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var createTokens_exports = {};
__export(createTokens_exports, {
  createTokens: () => createTokens
});
module.exports = __toCommonJS(createTokens_exports);
var import_createVariables = __webpack_require__(26596);
function createTokens(tokens2) {
  return (0, import_createVariables.createVariables)(tokens2);
}
const tokens = createTokens({
  size: { 0: 1 },
  space: { 0: 1 },
  radius: { 0: 1 },
  zIndex: { 0: 1 },
  color: { 0: "hi" }
});
// Annotate the CommonJS export names for ESM import in node:
0 && (0);
//# sourceMappingURL=createTokens.js.map


/***/ }),

/***/ 88957:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var createVariable_exports = {};
__export(createVariable_exports, {
  createCSSVariable: () => createCSSVariable,
  createVariable: () => createVariable,
  didGetVariableValue: () => didGetVariableValue,
  getVariable: () => getVariable,
  getVariableName: () => getVariableName,
  getVariableValue: () => getVariableValue,
  getVariableVariable: () => getVariableVariable,
  isVariable: () => isVariable,
  setDidGetVariableValue: () => setDidGetVariableValue,
  variableToString: () => variableToString
});
module.exports = __toCommonJS(createVariable_exports);
var import_constants = __webpack_require__(14810);
var import_helpers = __webpack_require__(37513);
var import_config = __webpack_require__(16265);
const IS_VAR = "isVar";
const createVariable = (props) => {
  if (isVariable(props))
    return props;
  const { key, name, val } = props;
  return {
    [IS_VAR]: true,
    key,
    name: (0, import_helpers.simpleHash)(name, 40),
    val,
    variable: import_constants.isWeb ? createCSSVariable(name) : ""
  };
};
function variableToString(vrble, getValue = false) {
  if (isVariable(vrble)) {
    if (!getValue && import_constants.isWeb && vrble.variable) {
      return vrble.variable;
    }
    return `${vrble.val}`;
  }
  return `${vrble || ""}`;
}
function isVariable(v) {
  return v && typeof v === "object" && IS_VAR in v;
}
function getVariable(nameOrVariable) {
  setDidGetVariableValue(true);
  if (isVariable(nameOrVariable)) {
    return variableToString(nameOrVariable);
  }
  const tokens = (0, import_config.getConfig)().tokensParsed;
  return variableToString(tokens[nameOrVariable] ?? nameOrVariable);
}
let accessed = false;
const setDidGetVariableValue = (val) => accessed = val;
const didGetVariableValue = () => accessed;
function getVariableValue(v) {
  if (isVariable(v)) {
    setDidGetVariableValue(true);
    return v.val;
  }
  return v;
}
function getVariableName(v) {
  if (isVariable(v))
    return v.name;
  return v;
}
function getVariableVariable(v) {
  if (isVariable(v))
    return v.variable;
  return v;
}
const createCSSVariable = (nameProp, includeVar = true) => {
  if (false) {}
  const name = (0, import_helpers.simpleHash)(nameProp, 60);
  return includeVar ? `var(--${name})` : name;
};
// Annotate the CommonJS export names for ESM import in node:
0 && (0);
//# sourceMappingURL=createVariable.js.map


/***/ }),

/***/ 26596:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var createVariables_exports = {};
__export(createVariables_exports, {
  createVariables: () => createVariables,
  tokensKeysOrdered: () => tokensKeysOrdered
});
module.exports = __toCommonJS(createVariables_exports);
var import_helpers = __webpack_require__(37513);
var import_createVariable = __webpack_require__(88957);
const tokensKeysOrdered = /* @__PURE__ */ new WeakMap();
const createVariables = (tokens, parentPath = "", isFont = false) => {
  const res = {};
  let i = 0;
  for (let key in tokens) {
    i++;
    const val = tokens[key];
    if (key[0] === "$") {
      key = key.slice(1);
    }
    if ((0, import_createVariable.isVariable)(val)) {
      res[key] = val;
      continue;
    }
    const niceKey = (0, import_helpers.simpleHash)(key);
    let name = isFont ? niceKey.slice(0, 2) : i;
    name = parentPath ? `${parentPath}-${name}` : niceKey;
    if (val && typeof val === "object") {
      res[key] = createVariables(tokens[key], name);
      continue;
    }
    res[key] = (0, import_createVariable.isVariable)(val) ? val : (0, import_createVariable.createVariable)({ val, name, key: niceKey });
  }
  if (parentPath === "size" || parentPath === "space") {
    tokensKeysOrdered.set(res, Object.keys(tokens));
  }
  return res;
};
// Annotate the CommonJS export names for ESM import in node:
0 && (0);
//# sourceMappingURL=createVariables.js.map


/***/ }),

/***/ 21497:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var ThemeManager_exports = {};
__export(ThemeManager_exports, {
  ThemeManager: () => ThemeManager,
  hasNoThemeUpdatingProps: () => hasNoThemeUpdatingProps
});
module.exports = __toCommonJS(ThemeManager_exports);
var import_config = __webpack_require__(16265);
var import_constants = __webpack_require__(36297);
var import_getThemeUnwrapped = __webpack_require__(2023);
const emptyState = { name: "" };
function hasNoThemeUpdatingProps(props) {
  return !(props.name || props.componentName || props.inverse || props.reset);
}
class ThemeManager {
  constructor(props = {}, parentManager) {
    this.props = props;
    this.themeListeners = /* @__PURE__ */ new Set();
    this.parentManager = null;
    this.state = emptyState;
    this._allKeys = null;
    if (parentManager === "root") {
      this.updateState(props, false);
      return;
    }
    if (!parentManager) {
      if (false) {}
      throw `\u274C`;
    }
    this.themeListeners = parentManager.themeListeners;
    if (hasNoThemeUpdatingProps(props)) {
      return parentManager;
    }
    if (parentManager) {
      this.parentManager = parentManager;
    }
    const updatedState = this.getStateIfChanged(props);
    if (updatedState) {
      this.state = updatedState;
      return;
    }
    return parentManager || this;
  }
  updateState(props = this.props || {}, notify = true) {
    const shouldFlush = (() => {
      if (props.forceTheme) {
        this.state.theme = props.forceTheme;
        this.state.name = props.name || "";
        return true;
      }
      const nextState = this.getStateIfChanged(props);
      if (nextState) {
        this.state = nextState;
        return true;
      }
    })();
    if (shouldFlush) {
      this._allKeys = null;
      notify && this.notify();
      return this.state;
    }
  }
  getStateIfChanged(props = this.props, state = this.state, parentManager = this.parentManager) {
    const _ = this.getState(props, parentManager);
    if (state && state !== emptyState && !_) {
      return parentManager == null ? void 0 : parentManager.state;
    }
    if (this.getStateShouldChange(_, state)) {
      return _;
    }
  }
  getStateShouldChange(nextState, state = this.state) {
    if (!(nextState == null ? void 0 : nextState.theme) || nextState.theme === (state == null ? void 0 : state.theme)) {
      return false;
    }
    return true;
  }
  getState(props = this.props, parentManager = this.parentManager) {
    return getState(props, parentManager) || ( false ? 0 : null);
  }
  get allKeys() {
    var _a;
    this._allKeys || (this._allKeys = /* @__PURE__ */ new Set([
      ...((_a = this.parentManager) == null ? void 0 : _a.allKeys) || [],
      ...Object.keys(this.state.theme || {})
    ]));
    return this._allKeys;
  }
  // gets value going up to parents
  getValue(key, state) {
    if (!key)
      return;
    let theme = (state || this.state).theme;
    let manager = this;
    while (theme && manager) {
      if (key in theme) {
        return theme[key];
      }
      manager = manager.parentManager;
      theme = manager == null ? void 0 : manager.state.theme;
    }
    const tokens = (0, import_config.getTokens)();
    if (key in tokens.color) {
      return tokens.color[key];
    }
  }
  notify() {
    this.themeListeners.forEach((cb) => cb(this.state.name, this));
  }
  onChangeTheme(cb) {
    this.themeListeners.add(cb);
    return () => {
      this.themeListeners.delete(cb);
    };
  }
}
function getNextThemeClassName(name, isInverting = false) {
  const next = `t_sub_theme ${import_constants.THEME_CLASSNAME_PREFIX}${name}`;
  if (isInverting) {
    return next + // ensure you invert to base dark as well as specific dark
    // ... logic should likely be elsewhere
    (next.includes("dark_") ? ` t_dark` : next.includes("light_") ? ` t_light` : "");
  }
  return next.replace("light_", "").replace("dark_", "");
}
const cache = /* @__PURE__ */ new WeakMap();
function getState(props, parentManager) {
  var _a, _b, _c;
  const cached = cache.get(props);
  if (cached && cached[0] === parentManager) {
    return cached[1];
  }
  const themes = (0, import_config.getThemes)();
  if (props.name && props.reset) {
    throw new Error("Cannot reset + set new name");
  }
  if (props.reset && !(parentManager == null ? void 0 : parentManager.parentManager)) {
    console.warn("Cannot reset no grandparent exists");
    return null;
  }
  let result = null;
  const nextName = props.reset ? ((_b = (_a = parentManager == null ? void 0 : parentManager.parentManager) == null ? void 0 : _a.state) == null ? void 0 : _b.name) || "" : props.name || "";
  const { componentName } = props;
  const parentName = ((_c = parentManager == null ? void 0 : parentManager.state) == null ? void 0 : _c.name) || "";
  const base = parentName.split(import_constants.THEME_NAME_SEPARATOR);
  const lastSegment = base[base.length - 1];
  const isParentAComponentTheme = parentName && lastSegment[0].toUpperCase() === lastSegment[0];
  if (isParentAComponentTheme) {
    base.pop();
  }
  const parentBaseTheme = isParentAComponentTheme ? base.slice(0, base.length).join(import_constants.THEME_NAME_SEPARATOR) : parentName;
  const max = base.length;
  const min = componentName && !nextName ? max : 0;
  if (false)
    {}
  for (let i = max; i >= min; i--) {
    let prefix = base.slice(0, i).join(import_constants.THEME_NAME_SEPARATOR);
    if (props.inverse) {
      prefix = inverseThemeName(prefix);
    }
    const potentials = [];
    if (prefix && prefix !== parentBaseTheme) {
      potentials.push(prefix);
    }
    if (nextName) {
      potentials.unshift(prefix ? `${prefix}_${nextName}` : nextName);
    }
    if (i === 1) {
      const lastSegment2 = potentials.findIndex((x) => !x.includes("_"));
      if (lastSegment2 > 0) {
        potentials.splice(lastSegment2, 0, nextName);
      }
    }
    if (componentName) {
      if (nextName) {
        potentials.push(
          `${prefix.slice(
            0,
            prefix.indexOf(import_constants.THEME_NAME_SEPARATOR)
          )}_${nextName}_${componentName}`
        );
      }
      potentials.push(`${prefix}_${componentName}`);
      if (nextName) {
        potentials.unshift(`${prefix}_${nextName}_${componentName}`);
      }
    }
    const found = potentials.find((t) => t in themes);
    if (false)
      {}
    if (found) {
      if (found === parentName) {
        break;
      }
      result = {
        name: found,
        theme: (0, import_getThemeUnwrapped.getThemeUnwrapped)(themes[found]),
        className: getNextThemeClassName(found, props.inverse),
        parentName
      };
      break;
    }
  }
  if (parentManager) {
    cache.set(props, [parentManager, result]);
  }
  return result;
}
const inverseThemeName = (themeName) => {
  return themeName.startsWith("light") ? themeName.replace(/^light/, "dark") : themeName.replace(/^dark/, "light");
};
// Annotate the CommonJS export names for ESM import in node:
0 && (0);
//# sourceMappingURL=ThemeManager.js.map


/***/ }),

/***/ 2856:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var ThemeManagerContext_exports = {};
__export(ThemeManagerContext_exports, {
  ThemeManagerContext: () => ThemeManagerContext
});
module.exports = __toCommonJS(ThemeManagerContext_exports);
var import_react = __webpack_require__(16689);
const ThemeManagerContext = (0, import_react.createContext)(null);
// Annotate the CommonJS export names for ESM import in node:
0 && (0);
//# sourceMappingURL=ThemeManagerContext.js.map


/***/ }),

/***/ 44395:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var createMediaStyle_exports = {};
__export(createMediaStyle_exports, {
  MEDIA_SEP: () => MEDIA_SEP,
  createMediaStyle: () => createMediaStyle
});
module.exports = __toCommonJS(createMediaStyle_exports);
var import_useMedia = __webpack_require__(85030);
const MEDIA_SEP = "_";
let prefixes = null;
let selectors = null;
const createMediaStyle = ({ property, identifier, rules }, mediaKey, mediaQueries, negate) => {
  if (!(prefixes && selectors)) {
    const mediaKeys = Object.keys(mediaQueries);
    prefixes = Object.fromEntries(
      mediaKeys.map((key, index) => [key, new Array(index + 1).fill(":root").join("")])
    );
    selectors = Object.fromEntries(
      mediaKeys.map((key) => [key, (0, import_useMedia.mediaObjectToString)(mediaQueries[key])])
    );
  }
  const precendencePrefix = prefixes[mediaKey];
  const mediaSelector = selectors[mediaKey];
  const negKey = negate ? "0" : "";
  const ogPrefix = identifier.slice(0, identifier.indexOf("-") + 1);
  const nextIdentifier = `${identifier.replace(
    ogPrefix,
    `${ogPrefix}${MEDIA_SEP}${mediaKey}${negKey}${MEDIA_SEP}`
  )}`;
  const screenStr = negate ? "not all and" : "";
  const mediaQuery = `${screenStr} ${mediaSelector}`;
  const styleInner = rules.map((rule) => rule.replace(identifier, nextIdentifier)).join(";");
  let styleRule = "";
  if (styleInner.includes("@media")) {
    styleRule = styleInner.replace("{", ` and ${mediaQuery} {`);
  } else {
    styleRule = `@media ${mediaQuery} { ${precendencePrefix} ${styleInner} }`;
  }
  return {
    property,
    rules: [styleRule],
    identifier: nextIdentifier
  };
};
// Annotate the CommonJS export names for ESM import in node:
0 && (0);
//# sourceMappingURL=createMediaStyle.js.map


/***/ }),

/***/ 8542:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var createPropMapper_exports = {};
__export(createPropMapper_exports, {
  createPropMapper: () => createPropMapper,
  getFontFamilyFromNameOrVariable: () => getFontFamilyFromNameOrVariable,
  getPropMappedFontFamily: () => getPropMappedFontFamily,
  getReturnVariablesAs: () => getReturnVariablesAs
});
module.exports = __toCommonJS(createPropMapper_exports);
var import_constants = __webpack_require__(14810);
var import_config = __webpack_require__(16265);
var import_isDevTools = __webpack_require__(57405);
var import_createVariable = __webpack_require__(88957);
var import_expandStyle = __webpack_require__(32549);
var import_expandStyles = __webpack_require__(36152);
var import_getVariantExtras = __webpack_require__(37645);
var import_isObj = __webpack_require__(88356);
var import_mergeProps = __webpack_require__(1458);
const getReturnVariablesAs = (props, state) => {
  return !!props.animation || state.resolveVariablesAs === "value" ? import_constants.isWeb ? "non-color-value" : "value" : "auto";
};
const createPropMapper = (staticConfig) => {
  const variants = staticConfig.variants || {};
  const defaultProps = (0, import_mergeProps.mergeProps)(staticConfig.defaultProps || {}, {}, false)[0];
  let conf;
  const mapper = (key, value, theme, propsIn, state, languageContext, avoidDefaultProps = false, debug) => {
    conf || (conf = (0, import_config.getConfig)());
    const props = state.fallbackProps || propsIn;
    const returnVariablesAs = getReturnVariablesAs(props, state);
    const fontFamily = props[conf.inverseShorthands.fontFamily] || props.fontFamily || defaultProps.fontFamily || propsIn.fontFamily || "$body";
    const variantValue = resolveVariants(
      key,
      value,
      props,
      defaultProps,
      theme,
      variants,
      fontFamily,
      conf,
      returnVariablesAs,
      staticConfig,
      "",
      languageContext,
      avoidDefaultProps,
      debug
    );
    if (variantValue) {
      return variantValue;
    }
    let shouldReturn = value !== void 0 && value !== null;
    if (key in conf.shorthands) {
      shouldReturn = true;
      key = conf.shorthands[key];
    }
    if (value) {
      if (value[0] === "$") {
        value = getToken(
          key,
          value,
          conf,
          theme,
          fontFamily,
          languageContext,
          returnVariablesAs,
          debug
        );
      } else if ((0, import_createVariable.isVariable)(value)) {
        value = resolveVariableValue(key, value, returnVariablesAs);
      }
    }
    if (shouldReturn) {
      return (0, import_expandStyle.expandStyle)(key, value) || [[key, value]];
    }
  };
  return mapper;
};
const resolveVariants = (key, value, props, defaultProps, theme, variants, fontFamily, conf, returnVariablesAs, staticConfig, parentVariantKey, languageContext, avoidDefaultProps = false, debug) => {
  var _a;
  const variant = variants == null ? void 0 : variants[key];
  if (!variant || value === void 0) {
    return;
  }
  let variantValue = getVariantDefinition(variant, key, value, conf);
  if (!variantValue) {
    if (false) {}
    return;
  }
  if (typeof variantValue === "function") {
    const fn = variantValue;
    variantValue = fn(
      value,
      (0, import_getVariantExtras.getVariantExtras)(props, languageContext, theme, defaultProps, avoidDefaultProps)
    );
  }
  let fontFamilyResult;
  if ((0, import_isObj.isObj)(variantValue)) {
    const fontFamilyUpdate = variantValue.fontFamily || variantValue[conf.inverseShorthands.fontFamily];
    if (fontFamilyUpdate) {
      fontFamilyResult = getFontFamilyFromNameOrVariable(fontFamilyUpdate, conf);
    }
    variantValue = resolveTokensAndVariants(
      key,
      variantValue,
      props,
      defaultProps,
      theme,
      variants,
      fontFamilyResult || fontFamily,
      conf,
      returnVariablesAs,
      staticConfig,
      parentVariantKey,
      languageContext,
      avoidDefaultProps,
      debug
    );
  }
  if (variantValue) {
    const next = Object.entries((0, import_expandStyles.expandStyles)(variantValue));
    if (fontFamilyResult && fontFamilyResult[0] === "$") {
      fontFamilyCache.set(next, (0, import_createVariable.getVariableValue)(fontFamilyResult));
    }
    return next;
  }
};
function getFontFamilyFromNameOrVariable(input, conf) {
  if ((0, import_createVariable.isVariable)(input)) {
    const val = variableToFontNameCache.get(input);
    if (val) {
      return val;
    } else {
      for (const key in conf.fontsParsed) {
        const familyVariable = conf.fontsParsed[key].family;
        if ((0, import_createVariable.isVariable)(familyVariable)) {
          variableToFontNameCache.set(familyVariable, key);
          if (familyVariable === input) {
            return key;
          }
        }
      }
    }
  } else if (typeof input === "string") {
    if ((input == null ? void 0 : input[0]) === "$") {
      return input;
    } else {
      if (false) {}
    }
  }
}
const variableToFontNameCache = /* @__PURE__ */ new WeakMap();
const fontFamilyCache = /* @__PURE__ */ new WeakMap();
const getPropMappedFontFamily = (expanded) => {
  return expanded && fontFamilyCache.get(expanded);
};
const resolveTokensAndVariants = (key, value, props, defaultProps, theme, variants, fontFamily, conf, returnVariablesAs, staticConfig, parentVariantKey, languageContext, avoidDefaultProps, debug) => {
  var _a;
  const res = {};
  for (const rKey in value) {
    const fKey = conf.shorthands[rKey] || rKey;
    const val = value[rKey];
    if (fKey in variants) {
      if (parentVariantKey && parentVariantKey === key) {
        res[fKey] = val;
      } else {
        const variantOut = resolveVariants(
          fKey,
          val,
          props,
          defaultProps,
          theme,
          variants,
          fontFamily,
          conf,
          returnVariablesAs,
          staticConfig,
          key,
          languageContext,
          avoidDefaultProps,
          debug
        );
        const { pressStyle, hoverStyle, focusStyle, enterStyle, exitStyle, ...rest } = Object.fromEntries(variantOut);
        const subs = { pressStyle, hoverStyle, focusStyle, enterStyle, exitStyle };
        Object.assign(res, rest);
        for (const key2 in subs) {
          if (subs[key2]) {
            res[key2] ?? (res[key2] = {});
            Object.assign(res[key2], subs[key2]);
          }
        }
      }
      continue;
    }
    if ((0, import_createVariable.isVariable)(val)) {
      res[fKey] = !import_constants.isWeb || returnVariablesAs === "value" ? val.val : val.variable;
      continue;
    }
    if (typeof val === "string") {
      const fVal = val[0] === "$" ? getToken(
        fKey,
        val,
        conf,
        theme,
        fontFamily,
        languageContext,
        returnVariablesAs,
        debug
      ) : val;
      res[fKey] = fVal;
      continue;
    }
    if ((0, import_isObj.isObj)(val)) {
      res[fKey] ?? (res[fKey] = {});
      Object.assign(
        res[fKey],
        resolveTokensAndVariants(
          fKey,
          val,
          props,
          defaultProps,
          theme,
          variants,
          fontFamily,
          conf,
          returnVariablesAs,
          staticConfig,
          key,
          languageContext,
          avoidDefaultProps,
          debug
        )
      );
    } else {
      res[fKey] = val;
    }
    if (false) {}
  }
  return res;
};
const tokenCats = ["size", "color", "radius", "space", "zIndex"].map((name) => ({
  name,
  spreadName: `...${name}`
}));
function getVariantDefinition(variant, key, value, conf) {
  if (typeof variant === "function") {
    return variant;
  }
  if (variant[value]) {
    return variant[value];
  }
  const { tokensParsed } = conf;
  for (const { name, spreadName } of tokenCats) {
    if (variant[spreadName] && value in tokensParsed[name]) {
      return variant[spreadName];
    }
  }
  let fn;
  const type = typeof value;
  if (type === "number") {
    fn = variant[":number"];
  } else if (type === "string") {
    fn = variant[":string"];
  } else if (value === true || value === false) {
    fn = variant[":boolean"];
  }
  return fn || variant["..."] || variant["...size"];
}
const fontShorthand = {
  fontSize: "size",
  fontWeight: "weight"
};
const getToken = (key, value, conf, theme, fontFamily = "$body", languageContext, resolveAs, debug) => {
  var _a, _b, _c;
  const tokensParsed = conf.tokensParsed;
  const fontsParsed = languageContext ? (0, import_getVariantExtras.getFontsForLanguage)(conf.fontsParsed, languageContext) : conf.fontsParsed;
  let valOrVar;
  let hasSet = false;
  if (value in theme) {
    valOrVar = theme[value];
    hasSet = true;
  } else {
    switch (key) {
      case "fontFamily":
        valOrVar = ((_a = fontsParsed[value]) == null ? void 0 : _a.family) || value;
        hasSet = true;
        break;
      case "fontSize":
      case "lineHeight":
      case "letterSpacing":
      case "fontWeight":
        valOrVar = ((_c = (_b = fontsParsed[fontFamily]) == null ? void 0 : _b[fontShorthand[key] || key]) == null ? void 0 : _c[value]) || value;
        hasSet = true;
        break;
    }
    for (const cat in tokenCategories) {
      if (key in tokenCategories[cat]) {
        const res = tokensParsed[cat][value];
        if (res) {
          valOrVar = res;
          hasSet = true;
        }
      }
    }
    if (!hasSet) {
      const spaceVar = tokensParsed.space[value];
      if (spaceVar) {
        valOrVar = spaceVar;
        hasSet = true;
      }
    }
  }
  if (false) {}
  if (hasSet) {
    return resolveVariableValue(key, valOrVar, resolveAs);
  }
  if (false) {}
  return value;
};
function resolveVariableValue(key, valOrVar, resolveAs = "auto") {
  if ((0, import_createVariable.isVariable)(valOrVar)) {
    if (resolveAs === "variable") {
      return valOrVar;
    }
    if (resolveAs === "non-color-value") {
      if (import_constants.isWeb) {
        if (key in tokenCategories.color) {
          return valOrVar.variable;
        }
      }
      return valOrVar.val;
    }
    if (!import_constants.isWeb || resolveAs === "value") {
      return valOrVar.val;
    }
    return valOrVar.variable;
  }
  return valOrVar;
}
const tokenCategories = {
  radius: {
    borderRadius: true,
    borderTopLeftRadius: true,
    borderTopRightRadius: true,
    borderBottomLeftRadius: true,
    borderBottomRightRadius: true
  },
  size: {
    width: true,
    height: true,
    minWidth: true,
    minHeight: true,
    maxWidth: true,
    maxHeight: true
  },
  color: {
    color: true,
    backgroundColor: true,
    borderColor: true,
    borderBottomColor: true,
    borderTopColor: true,
    borderLeftColor: true,
    borderRightColor: true
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (0);
//# sourceMappingURL=createPropMapper.js.map


/***/ }),

/***/ 42706:
/***/ ((module) => {

"use strict";

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var createProxy_exports = {};
__export(createProxy_exports, {
  createProxy: () => createProxy
});
module.exports = __toCommonJS(createProxy_exports);
function createProxy(target, handler) {
  if (false) {}
  return new Proxy(target || {}, handler);
}
// Annotate the CommonJS export names for ESM import in node:
0 && (0);
//# sourceMappingURL=createProxy.js.map


/***/ }),

/***/ 30550:
/***/ ((module) => {

"use strict";

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var defaultOffset_exports = {};
__export(defaultOffset_exports, {
  defaultOffset: () => defaultOffset
});
module.exports = __toCommonJS(defaultOffset_exports);
const defaultOffset = { height: 0, width: 0 };
// Annotate the CommonJS export names for ESM import in node:
0 && (0);
//# sourceMappingURL=defaultOffset.js.map


/***/ }),

/***/ 32549:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all2) => {
  for (var name in all2)
    __defProp(target, name, { get: all2[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var expandStyle_exports = {};
__export(expandStyle_exports, {
  expandStyle: () => expandStyle
});
module.exports = __toCommonJS(expandStyle_exports);
var import_constants = __webpack_require__(14810);
var _a;
function expandStyle(key, value) {
  if (true) {
    if (key === "flex") {
      return [
        ["flexGrow", value],
        ["flexShrink", 1],
        ["flexBasis", "auto"]
      ];
    }
    switch (key) {
      case "textAlignVertical": {
        return [["verticalAlign", value === "center" ? "middle" : value]];
      }
      case "writingDirection": {
        return [["direction", value]];
      }
    }
  }
  const longKey = EXPANSIONS[key];
  if (longKey) {
    return longKey.map((key2) => {
      return [key2, value];
    });
  }
}
const all = ["Top", "Right", "Bottom", "Left"];
const horiz = ["Right", "Left"];
const vert = ["Top", "Bottom"];
const xy = ["X", "Y"];
const EXPANSIONS = {
  borderColor: ["TopColor", "RightColor", "BottomColor", "LeftColor"],
  borderRadius: [
    "TopLeftRadius",
    "TopRightRadius",
    "BottomRightRadius",
    "BottomLeftRadius"
  ],
  borderWidth: ["TopWidth", "RightWidth", "BottomWidth", "LeftWidth"],
  margin: all,
  marginHorizontal: horiz,
  marginVertical: vert,
  overscrollBehavior: xy,
  padding: all,
  paddingHorizontal: horiz,
  paddingVertical: vert,
  ...import_constants.isWeb && {
    // react-native only supports borderStyle
    borderStyle: ["TopStyle", "RightStyle", "BottomStyle", "LeftStyle"],
    // react-native doesn't support X / Y
    overflow: xy
  }
};
for (const parent in EXPANSIONS) {
  const prefix = parent.slice(0, ((_a = /[A-Z]/.exec(parent)) == null ? void 0 : _a.index) ?? parent.length);
  EXPANSIONS[parent] = EXPANSIONS[parent].map((k) => `${prefix}${k}`);
}
// Annotate the CommonJS export names for ESM import in node:
0 && (0);
//# sourceMappingURL=expandStyle.js.map


/***/ }),

/***/ 36152:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var expandStyles_exports = {};
__export(expandStyles_exports, {
  expandStyles: () => expandStyles,
  fixStyles: () => fixStyles
});
module.exports = __toCommonJS(expandStyles_exports);
var import_constants = __webpack_require__(14810);
var import_config = __webpack_require__(16265);
var import_expandStyle = __webpack_require__(32549);
var import_normalizeShadow = __webpack_require__(27234);
var import_normalizeValueWithProperty = __webpack_require__(31053);
var import_pseudoDescriptors = __webpack_require__(45204);
let shorthands = null;
function expandStyles(style, config = (0, import_config.getConfig)()) {
  const res = {};
  for (let key in style) {
    shorthands = shorthands || (config ? config.shorthands : null);
    if (shorthands) {
      key = shorthands[key] || key;
    }
    if (key in import_pseudoDescriptors.pseudoDescriptors) {
      res[key] = expandStyles(style[key]);
      continue;
    }
    const val = (0, import_normalizeValueWithProperty.normalizeValueWithProperty)(style[key], key);
    const out = (0, import_expandStyle.expandStyle)(key, val);
    if (out) {
      Object.assign(res, Object.fromEntries(out));
    } else {
      res[key] = val;
    }
  }
  fixStyles(res);
  return res;
}
function fixStyles(style) {
  if (style.shadowRadius || style.shadowColor || style.shadowOpacity || style.shadowOffset) {
    Object.assign(style, (0, import_normalizeShadow.normalizeShadow)(style));
  }
  for (const key in borderDefaults) {
    if (key in style && !style[borderDefaults[key]]) {
      style[borderDefaults[key]] = "solid";
    }
  }
}
const nativeStyle = import_constants.isWeb ? null : "borderStyle";
const borderDefaults = {
  borderWidth: "borderStyle",
  borderBottomWidth: nativeStyle || "borderBottomStyle",
  borderTopWidth: nativeStyle || "borderTopStyle",
  borderLeftWidth: nativeStyle || "borderLeftStyle",
  borderRightWidth: nativeStyle || "borderRightStyle"
};
// Annotate the CommonJS export names for ESM import in node:
0 && (0);
//# sourceMappingURL=expandStyles.js.map


/***/ }),

/***/ 23534:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var extendStaticConfig_exports = {};
__export(extendStaticConfig_exports, {
  extendStaticConfig: () => extendStaticConfig,
  parseStaticConfig: () => parseStaticConfig
});
module.exports = __toCommonJS(extendStaticConfig_exports);
var import_helpers = __webpack_require__(37513);
var import_createPropMapper = __webpack_require__(8542);
var import_mergeProps = __webpack_require__(1458);
function extendStaticConfig(config, parent) {
  if (!(parent && "staticConfig" in parent)) {
    return parseStaticConfig(config);
  }
  const parentStaticConf = parent.staticConfig;
  const variants = {
    ...parentStaticConf.variants
  };
  if (config.variants) {
    for (const key in config.variants) {
      if (variants[key]) {
        variants[key] = {
          ...variants[key],
          ...config.variants[key]
        };
      } else {
        variants[key] = config.variants[key];
      }
    }
  }
  const parentNames = [...parentStaticConf.parentNames || []];
  if (parentStaticConf.componentName) {
    parentNames.push(parentStaticConf.componentName);
  }
  const deoptProps = config.deoptProps || /* @__PURE__ */ new Set();
  return parseStaticConfig({
    ...parentStaticConf,
    ...config,
    deoptProps,
    variants,
    parentNames,
    validStyles: config.validStyles ? {
      ...parentStaticConf.validStyles,
      ...config.validStyles
    } : parentStaticConf.validStyles || import_helpers.stylePropsView,
    defaultProps: (0, import_mergeProps.mergeProps)(
      {
        ...parentStaticConf.defaultProps,
        ...parentStaticConf.defaultVariants
      },
      {
        ...config.defaultProps,
        ...config.defaultVariants
      }
    )[0]
  });
}
const parseStaticConfig = (config) => {
  const parsed = {
    defaultProps: {},
    ...config,
    parsed: true
  };
  return {
    ...parsed,
    propMapper: (0, import_createPropMapper.createPropMapper)(parsed)
  };
};
// Annotate the CommonJS export names for ESM import in node:
0 && (0);
//# sourceMappingURL=extendStaticConfig.js.map


/***/ }),

/***/ 18045:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var getAnimationDriver_exports = {};
__export(getAnimationDriver_exports, {
  getAnimationDriver: () => getAnimationDriver
});
module.exports = __toCommonJS(getAnimationDriver_exports);
var import_config = __webpack_require__(16265);
function getAnimationDriver() {
  return (0, import_config.getConfig)().animations;
}
// Annotate the CommonJS export names for ESM import in node:
0 && (0);
//# sourceMappingURL=getAnimationDriver.js.map


/***/ }),

/***/ 13642:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var getExpandedShorthands_exports = {};
__export(getExpandedShorthands_exports, {
  getExpandedShorthands: () => getExpandedShorthands
});
module.exports = __toCommonJS(getExpandedShorthands_exports);
var import_config = __webpack_require__(16265);
function getExpandedShorthands(props) {
  const shorthands = (0, import_config.getConfig)().shorthands;
  if (!shorthands)
    return props;
  const res = {};
  for (const key in props) {
    res[shorthands[key] || key] = props[key];
  }
  return res;
}
// Annotate the CommonJS export names for ESM import in node:
0 && (0);
//# sourceMappingURL=getExpandedShorthands.js.map


/***/ }),

/***/ 41384:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var getSplitStyles_exports = {};
__export(getSplitStyles_exports, {
  PROP_SPLIT: () => PROP_SPLIT,
  getSplitStyles: () => getSplitStyles,
  getSubStyle: () => getSubStyle,
  insertSplitStyles: () => insertSplitStyles,
  useSplitStyles: () => useSplitStyles
});
module.exports = __toCommonJS(getSplitStyles_exports);
var import_constants = __webpack_require__(14810);
var import_helpers = __webpack_require__(37513);
var import_react = __webpack_require__(16689);
var import_config = __webpack_require__(16265);
var import_isDevTools = __webpack_require__(57405);
var import_useMedia = __webpack_require__(85030);
var import_createMediaStyle = __webpack_require__(44395);
var import_createPropMapper = __webpack_require__(8542);
var import_expandStyles = __webpack_require__(36152);
var import_getStylesAtomic = __webpack_require__(9161);
var import_insertStyleRule = __webpack_require__(37269);
var import_normalizeValueWithProperty = __webpack_require__(31053);
var import_pseudoDescriptors = __webpack_require__(45204);
const skipProps = {
  animation: true,
  space: true,
  animateOnly: true,
  debug: true,
  componentName: true,
  tag: true
};
if (false) {}
const IS_STATIC = "" === "is_static";
if (false) {}
const accessibilityDirectMap = {};
if (true) {
  const items = {
    Hidden: true,
    ActiveDescendant: true,
    Atomic: true,
    AutoComplete: true,
    Busy: true,
    Checked: true,
    ColumnCount: "colcount",
    ColumnIndex: "colindex",
    ColumnSpan: "colspan",
    Current: true,
    Details: true,
    ErrorMessage: true,
    Expanded: true,
    HasPopup: true,
    Invalid: true,
    Label: true,
    Level: true,
    Modal: true,
    Multiline: true,
    MultiSelectable: true,
    Orientation: true,
    Owns: true,
    Placeholder: true,
    PosInSet: true,
    Pressed: true,
    RoleDescription: true,
    RowCount: true,
    RowIndex: true,
    RowSpan: true,
    Selected: true,
    SetSize: true,
    Sort: true,
    ValueMax: true,
    ValueMin: true,
    ValueNow: true,
    ValueText: true
  };
  for (const key in items) {
    let val = items[key];
    if (val === true) {
      val = key.toLowerCase();
    }
    accessibilityDirectMap[`accessibility${key}`] = `aria-${val}`;
  }
}
let conf;
const PROP_SPLIT = "-";
const accessibilityRoleToWebRole = {
  adjustable: "slider",
  header: "heading",
  image: "img",
  link: "link",
  none: "presentation",
  summary: "region"
};
const isMediaKey = (key) => Boolean(key[0] === "$" && import_useMedia.mediaKeysWithAndWithout$.has(key));
const getSplitStyles = (props, staticConfig, theme, state, parentSplitStyles, languageContext, elementType, debug) => {
  var _a, _b, _c;
  if (cache.has(props)) {
    return cache.get(props);
  }
  conf = conf || (0, import_config.getConfig)();
  const { shorthands } = conf;
  const { variants, propMapper, isReactNative, inlineProps, inlineWhenUnflattened } = staticConfig;
  const validStyleProps = staticConfig.isText ? import_helpers.stylePropsText : import_helpers.validStyles;
  const viewProps = {};
  let pseudos = null;
  let psuedosUsed = null;
  const mediaState = state.mediaState || import_useMedia.mediaState;
  const usedKeys = {};
  const propKeys = Object.keys(props);
  let space = props.space;
  let hasMedia = false;
  const shouldDoClasses = staticConfig.acceptsClassName && (import_constants.isWeb || IS_STATIC) && !state.noClassNames;
  let style = {};
  const flatTransforms = {};
  const len = propKeys.length;
  const rulesToInsert = [];
  const classNames = {};
  let className = "";
  const transforms = {};
  let fontFamily;
  const styleState = {
    classNames,
    conf,
    props,
    state,
    staticConfig,
    style,
    theme,
    usedKeys,
    viewProps,
    languageContext
  };
  if (false) {}
  if (props.className) {
    for (const cn of props.className.split(" ")) {
      if (cn[0] === "_") {
        const [shorthand, mediaOrPseudo] = cn.slice(1).split("-");
        const isMedia = mediaOrPseudo[0] === "_";
        const isPseudo = mediaOrPseudo[0] === "0";
        const isMediaOrPseudo = isMedia || isPseudo;
        let fullKey = shorthands[shorthand];
        if (isMedia) {
          let mediaShortKey = mediaOrPseudo.slice(1);
          mediaShortKey = mediaShortKey.slice(0, mediaShortKey.indexOf("_"));
          fullKey += `${PROP_SPLIT}${mediaShortKey}`;
        } else if (isPseudo) {
          const pseudoShortKey = mediaOrPseudo.slice(1);
          fullKey += `${PROP_SPLIT}${pseudoShortKey}`;
        }
        usedKeys[fullKey] = 1;
        mergeClassName(transforms, classNames, fullKey, cn, isMediaOrPseudo);
      } else if (cn) {
        className += ` ${cn}`;
      }
    }
  }
  for (let i = len - 1; i >= 0; i--) {
    let keyInit = propKeys[i];
    if (keyInit === "className")
      continue;
    let valInit = props[keyInit];
    if (keyInit in shorthands) {
      keyInit = shorthands[keyInit];
    }
    if (false) {}
    if (!staticConfig.isHOC) {
      if (keyInit in skipProps) {
        continue;
      }
    }
    if (keyInit in usedKeys) {
      continue;
    }
    if (typeof valInit === "string" && valInit[0] === "_") {
      if (keyInit in validStyleProps || keyInit.includes("-")) {
        if (shouldDoClasses) {
          classNames[keyInit] = valInit;
        } else {
          style[keyInit] = (0, import_normalizeValueWithProperty.reverseMapClassNameToValue)(keyInit, valInit);
        }
        usedKeys[keyInit] = 1;
        continue;
      }
    }
    if (keyInit === "dataSet") {
      for (const key in valInit) {
        viewProps[`data-${hyphenate(key)}`] = valInit[key];
      }
      continue;
    }
    const isMainStyle = keyInit === "style";
    if (isMainStyle || keyInit.startsWith("_style")) {
      if (!valInit)
        continue;
      const styles = Array.isArray(valInit) ? valInit : [valInit];
      const styleLen = styles.length;
      for (let j = styleLen; j >= 0; j--) {
        const cur = styles[j];
        if (!cur)
          continue;
        for (const key in cur) {
          if (!isMainStyle && usedKeys[key]) {
            continue;
          }
          usedKeys[key] = 1;
          style[key] = cur[key];
        }
      }
      continue;
    }
    if (true) {
      if (keyInit === "disabled" && valInit === true) {
        usedKeys[keyInit] = 1;
        viewProps["aria-disabled"] = true;
        if (elementType === "button" || elementType === "form" || elementType === "input" || elementType === "select" || elementType === "textarea") {
          viewProps.disabled = true;
        }
        if (!(variants == null ? void 0 : variants.disabled)) {
          continue;
        }
      }
      if (keyInit === "testID") {
        usedKeys[keyInit] = 1;
        viewProps[isReactNative ? "testId" : "data-testid"] = valInit;
        continue;
      }
      if (keyInit === "id" || keyInit === "nativeID") {
        usedKeys[keyInit] = 1;
        if (isReactNative) {
          viewProps.nativeID = valInit;
        } else {
          viewProps.id = valInit;
        }
        continue;
      }
      let didUseKeyInit = false;
      if (isReactNative) {
        if (accessibilityDirectMap[keyInit] || keyInit.startsWith("accessibility")) {
          viewProps[keyInit] = valInit;
          usedKeys[keyInit] = 1;
          continue;
        }
      } else {
        didUseKeyInit = true;
        if (accessibilityDirectMap[keyInit]) {
          viewProps[accessibilityDirectMap[keyInit]] = valInit;
        } else {
          switch (keyInit) {
            case "accessibilityRole": {
              if (valInit === "none") {
                viewProps.role = "presentation";
              } else {
                viewProps.role = accessibilityRoleToWebRole[valInit] || valInit;
              }
              continue;
            }
            case "accessibilityLabelledBy":
            case "accessibilityFlowTo":
            case "accessibilityControls":
            case "accessibilityDescribedBy": {
              viewProps[`aria-${keyInit.replace("accessibility", "").toLowerCase()}`] = processIDRefList(valInit);
              continue;
            }
            case "accessibilityKeyShortcuts": {
              if (Array.isArray(valInit)) {
                viewProps["aria-keyshortcuts"] = valInit.join(" ");
              }
              continue;
            }
            case "accessibilityLiveRegion": {
              viewProps["aria-live"] = valInit === "none" ? "off" : valInit;
              continue;
            }
            case "accessibilityReadOnly": {
              viewProps["aria-readonly"] = valInit;
              if (elementType === "input" || elementType === "select" || elementType === "textarea") {
                viewProps.readOnly = true;
              }
              continue;
            }
            case "accessibilityRequired": {
              viewProps["aria-required"] = valInit;
              if (elementType === "input" || elementType === "select" || elementType === "textarea") {
                viewProps.required = valInit;
              }
              continue;
            }
            default: {
              didUseKeyInit = false;
            }
          }
        }
      }
      if (didUseKeyInit) {
        usedKeys[keyInit] = 1;
        continue;
      }
      if (valInit && valInit[0] === "_") {
        const isValidClassName = import_helpers.validStyles[keyInit];
        const isMediaOrPseudo = !isValidClassName && keyInit.includes(PROP_SPLIT) && import_helpers.validStyles[keyInit.split(PROP_SPLIT)[0]];
        if (isValidClassName || isMediaOrPseudo) {
          usedKeys[keyInit] = 1;
          if (false) {}
          mergeClassName(transforms, classNames, keyInit, valInit, isMediaOrPseudo);
          continue;
        }
      }
    }
    let isMedia = isMediaKey(keyInit);
    let isPseudo = keyInit in import_helpers.validPseudoKeys;
    const isHOCShouldPassThrough = staticConfig.isHOC && (isMedia || isPseudo);
    const shouldPassProp = !(isMedia || isPseudo || (variants == null ? void 0 : variants[keyInit]) || keyInit in validStyleProps || keyInit in shorthands);
    const shouldPassThrough = shouldPassProp || isHOCShouldPassThrough;
    if (false) {}
    if (shouldPassThrough) {
      usedKeys[keyInit] = 1;
      viewProps[keyInit] = valInit;
      continue;
    }
    if (false) {}
    const expanded = isMedia || isPseudo ? [[keyInit, valInit]] : propMapper(
      keyInit,
      valInit,
      theme,
      props,
      state,
      languageContext,
      void 0,
      debug
    );
    if (!fontFamily) {
      fontFamily = (0, import_createPropMapper.getPropMappedFontFamily)(expanded);
    }
    if (false) {}
    if (!expanded)
      continue;
    for (const [key, val] of expanded) {
      if (val === void 0)
        continue;
      isMedia = isMediaKey(key);
      isPseudo = key in import_helpers.validPseudoKeys;
      const isMediaOrPseudo = isMedia || isPseudo;
      if (!isMediaOrPseudo && usedKeys[key]) {
        if (false) {}
        continue;
      }
      if ((inlineProps == null ? void 0 : inlineProps.has(key)) || (inlineWhenUnflattened == null ? void 0 : inlineWhenUnflattened.has(key))) {
        usedKeys[key] = 1;
        viewProps[key] = props[key] ?? val;
      }
      if (isPseudo) {
        if (!val)
          continue;
        const pseudoStyleObject = getSubStyle(
          styleState,
          key,
          val,
          true,
          state.noClassNames
        );
        const descriptor = import_pseudoDescriptors.pseudoDescriptors[key];
        const isEnter = descriptor.name === "enter";
        const isExit = descriptor.name === "exit";
        if (!descriptor || isExit && !state.isExiting) {
          continue;
        }
        if (!shouldDoClasses || IS_STATIC) {
          pseudos || (pseudos = {});
          pseudos[key] || (pseudos[key] = {});
          Object.assign(pseudos[key], pseudoStyleObject);
        }
        if (shouldDoClasses && !isEnter && !isExit) {
          const pseudoStyles = (0, import_getStylesAtomic.getAtomicStyle)(pseudoStyleObject, descriptor);
          for (const psuedoStyle of pseudoStyles) {
            const fullKey = `${psuedoStyle.property}${PROP_SPLIT}${descriptor.name}`;
            if (!usedKeys[fullKey]) {
              usedKeys[fullKey] = 1;
              addStyleToInsertRules(rulesToInsert, psuedoStyle);
              mergeClassName(
                transforms,
                classNames,
                fullKey,
                psuedoStyle.identifier,
                isMediaOrPseudo
              );
            }
          }
        } else {
          if (usedKeys[key]) {
            continue;
          }
          let isDisabled = !state[descriptor.stateKey || descriptor.name];
          if (import_constants.isWeb && !import_constants.isClient && isEnter) {
            isDisabled = false;
          }
          if (!isDisabled) {
            if (valInit === staticConfig.defaultProps[keyInit]) {
            } else {
              usedKeys[key] || (usedKeys[key] = 1);
              if (false) {}
            }
          }
          psuedosUsed || (psuedosUsed = {});
          const importance = descriptor.priority;
          for (const pkey in pseudoStyleObject) {
            const val2 = pseudoStyleObject[pkey];
            if (isDisabled) {
              if (!(pkey in usedKeys) && pkey in animatableDefaults) {
                const defaultVal = animatableDefaults[pkey];
                mergeStyle(styleState, flatTransforms, pkey, defaultVal, true);
              }
              continue;
            }
            const curImportance = psuedosUsed[importance] || 0;
            const shouldMerge = importance >= curImportance;
            if (shouldMerge) {
              psuedosUsed[pkey] = importance;
              pseudos || (pseudos = {});
              pseudos[key] || (pseudos[key] = {});
              pseudos[key][pkey] = val2;
              mergeStyle(styleState, flatTransforms, pkey, val2);
            }
            if (false) {}
          }
        }
        continue;
      }
      if (isMedia) {
        if (!val)
          continue;
        hasMedia || (hasMedia = true);
        const mediaStyle = getSubStyle(
          styleState,
          key,
          val,
          // TODO try true like pseudo
          false
        );
        const mediaKeyShort = key.slice(1);
        if (false) {}
        if ("space" in mediaStyle) {
          if (!Array.isArray(hasMedia)) {
            hasMedia = [];
          }
          hasMedia.push(mediaKeyShort);
        }
        if (shouldDoClasses) {
          if ("space" in mediaStyle) {
            delete mediaStyle["space"];
            if (mediaState[mediaKeyShort]) {
              const val2 = valInit.space;
              const importance = (0, import_useMedia.getMediaImportanceIfMoreImportant)(
                mediaKeyShort,
                "space",
                usedKeys
              );
              if (importance) {
                space = val2;
                usedKeys["space"] = importance;
                if (false) {}
              }
            }
          }
          const mediaStyles = (0, import_getStylesAtomic.getStylesAtomic)(mediaStyle);
          for (const style2 of mediaStyles) {
            const out = (0, import_createMediaStyle.createMediaStyle)(style2, mediaKeyShort, import_useMedia.mediaQueryConfig);
            const fullKey = `${style2.property}${PROP_SPLIT}${mediaKeyShort}`;
            if (!usedKeys[fullKey]) {
              usedKeys[fullKey] = 1;
              addStyleToInsertRules(rulesToInsert, out);
              mergeClassName(transforms, classNames, fullKey, out.identifier, true);
            }
          }
        } else if (mediaState[mediaKeyShort]) {
          for (const subKey in mediaStyle) {
            const importance = (0, import_useMedia.getMediaImportanceIfMoreImportant)(
              mediaKeyShort,
              subKey,
              usedKeys
            );
            if (importance === null)
              continue;
            if (subKey === "space") {
              space = valInit.space;
              continue;
            }
            (0, import_useMedia.mergeMediaByImportance)(
              style,
              mediaKeyShort,
              subKey,
              mediaStyle[subKey],
              usedKeys
            );
            if (key === "fontFamily") {
              fontFamily = mediaStyle[key];
            }
          }
        }
        continue;
      }
      if (false) {}
      if (key === "fontFamily" && !fontFamily && valInit && val) {
        fontFamily = valInit[0] === "$" ? valInit : val;
      }
      if (key in validStyleProps) {
        mergeStyle(styleState, flatTransforms, key, val);
        continue;
      }
      if (!variants || !(key in variants)) {
        if (!(key in skipProps)) {
          viewProps[key] = val;
          usedKeys[key] = 1;
        }
      }
    }
  }
  (0, import_expandStyles.fixStyles)(style);
  if (import_constants.isWeb) {
    (0, import_getStylesAtomic.styleToCSS)(style);
  }
  if (false) {}
  if (flatTransforms) {
    if (false) {}
    mergeTransforms(style, flatTransforms, true);
  }
  if (parentSplitStyles) {
    if (true) {
      if (shouldDoClasses) {
        for (const key in parentSplitStyles.classNames) {
          const val = parentSplitStyles.classNames[key];
          if (key in style || key in classNames)
            continue;
          classNames[key] = val;
        }
      }
    }
    if (!shouldDoClasses) {
      for (const key in parentSplitStyles.style) {
        if (key in classNames || key in style)
          continue;
        style[key] = parentSplitStyles.style[key];
      }
    }
  }
  if (true) {
    if (shouldDoClasses) {
      const retainedStyles = {};
      if (style["$$css"]) {
      } else {
        const atomic = (0, import_getStylesAtomic.getStylesAtomic)(style);
        for (const atomicStyle of atomic) {
          const key = atomicStyle.property;
          if (props.animateOnly && props.animateOnly.includes(key)) {
            retainedStyles[key] = atomicStyle.value;
          } else {
            addStyleToInsertRules(rulesToInsert, atomicStyle);
            mergeClassName(transforms, classNames, key, atomicStyle.identifier);
          }
        }
        if (!IS_STATIC) {
          style = retainedStyles;
        }
      }
    }
    if (transforms) {
      for (const namespace in transforms) {
        if (!transforms[namespace]) {
          if (false) {}
          continue;
        }
        const [hash, val] = transforms[namespace];
        const identifier = `_transform${hash}`;
        if (import_constants.isClient && !import_insertStyleRule.insertedTransforms[identifier]) {
          const rule = `.${identifier} { transform: ${val}; }`;
          addStyleToInsertRules(rulesToInsert, {
            identifier,
            rules: [rule],
            property: namespace
          });
        }
        classNames[namespace] = identifier;
      }
    }
  }
  const result = {
    space,
    hasMedia,
    fontFamily,
    viewProps,
    style,
    pseudos,
    classNames,
    rulesToInsert
  };
  if (className) {
    classNames.className = className;
  }
  if (false) {}
  cache.set(props, result);
  return result;
};
function mergeClassName(transforms, classNames, key, val, isMediaOrPseudo = false) {
  if (true) {
    if (!val)
      return;
    if (val[0] === "_" && val.startsWith("_transform-")) {
      const ns = isMediaOrPseudo ? key : "transform";
      let transform = import_insertStyleRule.insertedTransforms[val];
      if (import_constants.isClient && !transform) {
        (0, import_insertStyleRule.scanAllSheets)();
        transform = import_insertStyleRule.insertedTransforms[val];
        if (!transform && import_constants.isWeb && val[0] !== "_") {
          transform = val;
        }
      }
      transforms[ns] || (transforms[ns] = ["", ""]);
      transforms[ns][0] += val.replace("_transform", "");
      if (transform) {
        transforms[ns][1] += transform;
      }
    } else {
      classNames[key] = val;
    }
  }
}
const cache = /* @__PURE__ */ new WeakMap();
function getSubStyleProps(defaultProps, baseProps, specificProps) {
  const key = specificProps || baseProps;
  if (!cache.has(key)) {
    cache.set(key, {
      ...defaultProps,
      ...baseProps,
      ...specificProps
    });
  }
  return cache.get(key);
}
function mergeStyle({ usedKeys, classNames, viewProps, style }, flatTransforms, key, val, dontSetUsed = false) {
  if (!dontSetUsed) {
    usedKeys[key] || (usedKeys[key] = 1);
  }
  if (val && val[0] === "_") {
    classNames[key] = val;
  } else if (key in import_helpers.stylePropsTransform) {
    flatTransforms || (flatTransforms = {});
    flatTransforms[key] = val;
  } else {
    const out = (0, import_normalizeValueWithProperty.normalizeValueWithProperty)(val, key);
    if (key in import_helpers.validStylesOnBaseProps) {
      viewProps[key] = out;
    } else {
      style[key] = out;
    }
  }
}
const getSubStyle = (styleState, subKey, styleIn, avoidDefaultProps, avoidMergeTransform) => {
  const { staticConfig, theme, props, state, conf: conf2, languageContext } = styleState;
  const styleOut = {};
  for (let key in styleIn) {
    const val = styleIn[key];
    key = conf2.shorthands[key] || key;
    const expanded = staticConfig.propMapper(
      key,
      val,
      theme,
      getSubStyleProps(staticConfig.defaultProps, props, props[subKey]),
      state,
      languageContext,
      avoidDefaultProps
    );
    if (!expanded)
      continue;
    for (const [skey, sval] of expanded) {
      if (!avoidMergeTransform && skey in import_helpers.stylePropsTransform) {
        mergeTransform(styleOut, skey, sval);
      } else {
        styleOut[skey] = (0, import_normalizeValueWithProperty.normalizeValueWithProperty)(sval, key);
      }
    }
  }
  (0, import_expandStyles.fixStyles)(styleOut);
  return styleOut;
};
const insertSplitStyles = (...args) => {
  const res = getSplitStyles(...args);
  (0, import_insertStyleRule.insertStyleRules)(res.rulesToInsert);
  return res;
};
const useInsertEffectCompat = import_constants.isWeb ? import_react.useInsertionEffect || import_constants.useIsomorphicLayoutEffect : () => {
};
const useSplitStyles = (...args) => {
  const res = getSplitStyles(...args);
  if (!import_constants.isRSC) {
    useInsertEffectCompat(() => {
      (0, import_insertStyleRule.insertStyleRules)(res.rulesToInsert);
    }, [res.rulesToInsert]);
  }
  return res;
};
function addStyleToInsertRules(rulesToInsert, styleObject) {
  if (true) {
    if (!(0, import_insertStyleRule.shouldInsertStyleRules)(styleObject)) {
      return;
    }
    (0, import_insertStyleRule.updateRules)(styleObject.identifier, styleObject.rules);
    rulesToInsert.push(styleObject);
  }
}
function processIDRefList(idRefList) {
  return Array.isArray(idRefList) ? idRefList.join(" ") : idRefList;
}
const animatableDefaults = {
  opacity: 1,
  scale: 1,
  rotate: "0deg",
  rotateY: "0deg",
  rotateX: "0deg"
};
const lowercaseHyphenate = (match) => `-${match.toLowerCase()}`;
const hyphenate = (str) => str.replace(/[A-Z]/g, lowercaseHyphenate);
const mergeTransform = (obj, key, val, backwards = false) => {
  obj.transform || (obj.transform = []);
  obj.transform[backwards ? "unshift" : "push"]({
    [mapTransformKeys[key] || key]: val
  });
};
const mergeTransforms = (obj, flatTransforms, backwards = false) => {
  Object.entries(flatTransforms).forEach(([key, val]) => {
    mergeTransform(obj, key, val, backwards);
  });
};
const mapTransformKeys = {
  x: "translateX",
  y: "translateY"
};
// Annotate the CommonJS export names for ESM import in node:
0 && (0);
//# sourceMappingURL=getSplitStyles.js.map


/***/ }),

/***/ 9161:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var getStylesAtomic_exports = {};
__export(getStylesAtomic_exports, {
  getAtomicStyle: () => getAtomicStyle,
  getStylesAtomic: () => getStylesAtomic,
  styleToCSS: () => styleToCSS
});
module.exports = __toCommonJS(getStylesAtomic_exports);
var import_helpers = __webpack_require__(37513);
var import_config = __webpack_require__(16265);
var import_defaultOffset = __webpack_require__(30550);
var import_normalizeValueWithProperty = __webpack_require__(31053);
var import_pseudoDescriptors = __webpack_require__(45204);
const pseudosOrdered = [
  import_pseudoDescriptors.pseudoDescriptors.hoverStyle,
  import_pseudoDescriptors.pseudoDescriptors.pressStyle,
  import_pseudoDescriptors.pseudoDescriptors.focusStyle
];
function getStylesAtomic(stylesIn) {
  if (!(stylesIn.hoverStyle || stylesIn.pressStyle || stylesIn.focusStyle)) {
    return getAtomicStyle(stylesIn);
  }
  const { hoverStyle, pressStyle, focusStyle, ...base } = stylesIn;
  let res = [];
  for (const [index, style] of [hoverStyle, pressStyle, focusStyle, base].entries()) {
    if (!style)
      continue;
    const pseudo = pseudosOrdered[index];
    res = [...res, ...getAtomicStyle(style, pseudo)];
  }
  return res;
}
const cache = /* @__PURE__ */ new Map();
function getAtomicStyle(style, pseudo) {
  if (!style)
    return [];
  const key = JSON.stringify(style) + (pseudo ? JSON.stringify(pseudo) : "");
  if (cache.has(key)) {
    return cache.get(key);
  }
  if (cache.size > 800) {
    cache.clear();
  }
  if (false) {}
  const out = generateAtomicStyles(style, pseudo);
  cache.set(key, out);
  return out;
}
let conf;
const generateAtomicStyles = (styleIn, pseudo) => {
  conf = conf || (0, import_config.getConfig)();
  const style = styleIn;
  if (style.transform && Array.isArray(style.transform)) {
    style.transform = style.transform.map(
      // { scale: 2 } => 'scale(2)'
      // { translateX: 20 } => 'translateX(20px)'
      // { matrix: [1,2,3,4,5,6] } => 'matrix(1,2,3,4,5,6)'
      (transform) => {
        const type = Object.keys(transform)[0];
        const value = transform[type];
        if (type === "matrix" || type === "matrix3d") {
          return `${type}(${value.join(",")})`;
        }
        return `${type}(${(0, import_normalizeValueWithProperty.normalizeValueWithProperty)(value, type)})`;
      }
    ).join(" ");
  }
  styleToCSS(style);
  const out = [];
  for (const key in style) {
    const value = (0, import_normalizeValueWithProperty.normalizeValueWithProperty)(style[key], key);
    if (value == null || value == void 0)
      continue;
    const hash = presetHashes[value] ? value : typeof value === "string" ? (0, import_helpers.simpleHash)(value) : `${value}`.replace(".", "dot");
    const pseudoPrefix = pseudo ? `0${pseudo.name}-` : "";
    const shortProp = conf.inverseShorthands[key] || key;
    const identifier = `_${shortProp}-${pseudoPrefix}${hash}`;
    const rules = createAtomicRules(identifier, key, value, pseudo);
    const styleObject = {
      property: key,
      pseudo: pseudo == null ? void 0 : pseudo.name,
      value,
      identifier,
      rules
    };
    out.push(styleObject);
  }
  return out;
};
const presetHashes = {
  none: true
};
function styleToCSS(style) {
  const { shadowOffset, shadowRadius, shadowColor } = style;
  if (style.shadowRadius !== void 0) {
    const offset = shadowOffset || import_defaultOffset.defaultOffset;
    const shadow = `${(0, import_normalizeValueWithProperty.normalizeValueWithProperty)(
      offset.width
    )} ${(0, import_normalizeValueWithProperty.normalizeValueWithProperty)(offset.height)} ${(0, import_normalizeValueWithProperty.normalizeValueWithProperty)(
      shadowRadius
    )} ${shadowColor}`;
    style.boxShadow = style.boxShadow ? `${style.boxShadow}, ${shadow}` : shadow;
    style.shadowOffset = void 0;
    style.shadowRadius = void 0;
    style.shadowColor = void 0;
  }
  const { textShadowColor, textShadowOffset, textShadowRadius } = style;
  if (textShadowColor || textShadowOffset || textShadowRadius) {
    const { height, width } = textShadowOffset || import_defaultOffset.defaultOffset;
    const radius = textShadowRadius || 0;
    const color = (0, import_normalizeValueWithProperty.normalizeValueWithProperty)(textShadowColor, "textShadowColor");
    if (color && (height !== 0 || width !== 0 || radius !== 0)) {
      const blurRadius = (0, import_normalizeValueWithProperty.normalizeValueWithProperty)(radius);
      const offsetX = (0, import_normalizeValueWithProperty.normalizeValueWithProperty)(width);
      const offsetY = (0, import_normalizeValueWithProperty.normalizeValueWithProperty)(height);
      style.textShadow = `${offsetX} ${offsetY} ${blurRadius} ${color}`;
    }
    style.textShadowColor = void 0;
    style.textShadowOffset = void 0;
    style.textShadowRadius = void 0;
  }
}
function createDeclarationBlock(style, important = false) {
  let next = "";
  for (const key in style) {
    const prop = hyphenateStyleName(key);
    const value = style[key];
    next += `${prop}:${value}${important ? " !important" : ""};`;
  }
  return `{${next}}`;
}
const hcache = {};
const toHyphenLower = (match) => `-${match.toLowerCase()}`;
const hyphenateStyleName = (key) => {
  let val = hcache[key];
  if (val)
    return val;
  hcache[key] = val = key.replace(/[A-Z]/g, toHyphenLower);
  return val;
};
const pseudoSelectorPrefixes = (() => {
  const res = {};
  for (const key in import_pseudoDescriptors.pseudoDescriptors) {
    const pseudo = import_pseudoDescriptors.pseudoDescriptors[key];
    res[pseudo.name] = `${[...Array(pseudo.priority)].map(() => ":root").join("")} `;
  }
  return res;
})();
function createAtomicRules(identifier, property, value, pseudo) {
  const selector = pseudo ? `${pseudoSelectorPrefixes[pseudo.name]} .${identifier}:${pseudo.name}` : `.${identifier}`;
  const important = !!pseudo;
  let rules = [];
  switch (property) {
    case "placeholderTextColor": {
      const block = createDeclarationBlock({ color: value, opacity: 1 }, important);
      rules.push(`${selector}::placeholder${block}`);
      break;
    }
    case "backgroundClip":
    case "userSelect": {
      const propertyCapitalized = `${property[0].toUpperCase()}${property.slice(1)}`;
      const webkitProperty = `Webkit${propertyCapitalized}`;
      const block = createDeclarationBlock(
        { [property]: value, [webkitProperty]: value },
        important
      );
      rules.push(`${selector}${block}`);
      break;
    }
    case "pointerEvents": {
      let finalValue = value;
      if (value === "auto" || value === "box-only") {
        finalValue = "auto";
        if (value === "box-only") {
          rules.push(`${selector}>*${boxOnly}`);
        }
      } else if (value === "none" || value === "box-none") {
        finalValue = "none";
        if (value === "box-none") {
          rules.push(`${selector}>*${boxNone}`);
        }
      }
      const block = createDeclarationBlock({ pointerEvents: finalValue }, true);
      rules.push(`${selector}${block}`);
      break;
    }
    default: {
      const block = createDeclarationBlock({ [property]: value }, important);
      rules.push(`${selector}${block}`);
      break;
    }
  }
  if (pseudo && pseudo.name === "hover") {
    rules = rules.map((r) => `@media not all and (hover: none) { ${r} }`);
  }
  return rules;
}
const boxNone = createDeclarationBlock({ pointerEvents: "auto" }, true);
const boxOnly = createDeclarationBlock({ pointerEvents: "none" }, true);
// Annotate the CommonJS export names for ESM import in node:
0 && (0);
//# sourceMappingURL=getStylesAtomic.js.map


/***/ }),

/***/ 75099:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var getThemeCSSRules_exports = {};
__export(getThemeCSSRules_exports, {
  getThemeCSSRules: () => getThemeCSSRules
});
module.exports = __toCommonJS(getThemeCSSRules_exports);
var import_helpers = __webpack_require__(37513);
var import_constants = __webpack_require__(36297);
var import_createVariable = __webpack_require__(88957);
var import_registerCSSVariable = __webpack_require__(20299);
function getThemeCSSRules({
  config,
  themeName,
  theme,
  names
}) {
  const cssRuleSets = [];
  const hasDarkLight = "light" in config.themes && "dark" in config.themes;
  const CNP = `.${import_constants.THEME_CLASSNAME_PREFIX}`;
  let vars = "";
  for (const themeKey in theme) {
    const variable = theme[themeKey];
    let value = null;
    if (!import_registerCSSVariable.tokensValueToVariable.has(variable.val)) {
      value = variable.val;
    } else {
      value = import_registerCSSVariable.tokensValueToVariable.get(variable.val).variable;
    }
    vars += `--${(0, import_helpers.simpleHash)(themeKey, 40)}:${value};`;
  }
  const isDarkOrLightBase = themeName === "dark" || themeName === "light";
  const selectorsSet = new Set(
    names.map((name) => {
      return `${CNP}${name}`;
    })
  );
  if (hasDarkLight) {
    for (const subName of names) {
      const isDark = themeName === "dark" || subName.startsWith("dark_");
      const maxDepth = config.maxDarkLightNesting ?? 3;
      if (!(isDark || subName.startsWith("light_"))) {
        selectorsSet.add(`:root:root ${CNP}${subName}`);
        continue;
      }
      const childSelector = `${CNP}${subName.replace(isDark ? "dark_" : "light_", "")}`;
      const [altLightDark, altSubTheme] = [
        isDark ? ["dark", "light"] : ["light", "dark"],
        isDark ? ["dark", "sub_theme"] : ["light", "sub_theme"]
      ];
      for (const order of [altLightDark, altSubTheme]) {
        if (isDarkOrLightBase) {
          order.reverse();
        }
        const [stronger, weaker] = order;
        const numSelectors = Math.round(maxDepth * 1.5);
        for (let depth = 0; depth < numSelectors; depth++) {
          const isOdd = depth % 2 === 1;
          if (isOdd && depth < 3) {
            continue;
          }
          const parents = new Array(depth + 1).fill(0).map((_, psi) => {
            return `${CNP}${psi % 2 === 0 ? stronger : weaker}`;
          });
          let parentSelectors = parents.length > 1 ? parents.slice(1) : parents;
          if (isOdd) {
            const [_first, second, ...rest] = parentSelectors;
            parentSelectors = [second, ...rest, second];
          }
          const lastParentSelector = parentSelectors[parentSelectors.length - 1];
          const nextChildSelector = childSelector === lastParentSelector ? "" : childSelector;
          selectorsSet.add(`${parentSelectors.join(" ")} ${nextChildSelector}`.trim());
        }
      }
    }
  }
  const selectors = [...selectorsSet];
  const selectorsString = selectors.map((x) => {
    const rootSep = isBaseTheme(x) && config.themeClassNameOnRoot ? "" : " ";
    return `:root${rootSep}${x}`;
  }).join(", ");
  const css = `${selectorsString} {${vars}}`;
  cssRuleSets.push(css);
  if (config.shouldAddPrefersColorThemes) {
    const bgString = (0, import_createVariable.variableToString)(theme.background);
    const fgString = (0, import_createVariable.variableToString)(theme.color);
    const bodyRules = `body{background:${bgString};color:${fgString};}`;
    const isDark = themeName.startsWith("dark");
    const baseName = isDark ? "dark" : "light";
    const lessSpecificSelectors = selectors.map((x) => {
      if (x == darkSelector || x === lightSelector)
        return `:root`;
      return x.replace(/^\.t_(dark|light) /, "").trim();
    }).filter(Boolean).join(", ");
    const themeRules = `${lessSpecificSelectors} {${vars}}`;
    const prefersMediaSelectors = `@media(prefers-color-scheme:${baseName}){
  ${bodyRules}
  ${themeRules}
}`;
    cssRuleSets.push(prefersMediaSelectors);
  }
  return cssRuleSets;
}
const darkSelector = ".t_dark";
const lightSelector = ".t_light";
const isBaseTheme = (x) => x === darkSelector || x === lightSelector || x.startsWith(".t_dark ") || x.startsWith(".t_light ");
// Annotate the CommonJS export names for ESM import in node:
0 && (0);
//# sourceMappingURL=getThemeCSSRules.js.map


/***/ }),

/***/ 37645:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var getVariantExtras_exports = {};
__export(getVariantExtras_exports, {
  getFontsForLanguage: () => getFontsForLanguage,
  getVariantExtras: () => getVariantExtras
});
module.exports = __toCommonJS(getVariantExtras_exports);
var import_config = __webpack_require__(16265);
var import_createProxy = __webpack_require__(42706);
const extrasCache = /* @__PURE__ */ new WeakMap();
function getVariantExtras(props, languageContext, theme, defaultProps, avoidDefaultProps = false) {
  const conf = (0, import_config.getConfig)();
  if (extrasCache.has(props)) {
    return extrasCache.get(props);
  }
  let fonts = conf.fontsParsed;
  if (languageContext) {
    fonts = getFontsForLanguage(conf.fontsParsed, languageContext);
  }
  const next = {
    fonts,
    tokens: conf.tokensParsed,
    theme,
    // TODO do this in splitstlye
    // we avoid passing in default props for media queries because that would confuse things like SizableText.size:
    props: avoidDefaultProps ? props : (0, import_createProxy.createProxy)(props, {
      // handles shorthands
      get(target, key) {
        const shorthand = conf.inverseShorthands[key];
        if (shorthand && Reflect.has(target, shorthand)) {
          return Reflect.get(target, shorthand);
        }
        if (Reflect.has(target, key)) {
          return Reflect.get(target, key);
        }
        if (defaultProps) {
          if (shorthand && Reflect.has(defaultProps, shorthand)) {
            return Reflect.get(defaultProps, shorthand);
          }
          if (Reflect.has(defaultProps, key)) {
            return Reflect.get(defaultProps, key);
          }
        }
      }
    })
  };
  extrasCache.set(props, next);
  return next;
}
const fontLanguageCache = /* @__PURE__ */ new WeakMap();
function getFontsForLanguage(fonts, language) {
  if (fontLanguageCache.has(language)) {
    return fontLanguageCache.get(language);
  }
  const next = {
    ...fonts,
    ...Object.fromEntries(
      Object.entries(language).map(([name, lang]) => {
        if (lang === "default") {
          return [];
        }
        const langKey = `$${name}_${lang}`;
        return [`$${name}`, fonts[langKey]];
      })
    )
  };
  fontLanguageCache.set(language, next);
  return next;
}
// Annotate the CommonJS export names for ESM import in node:
0 && (0);
//# sourceMappingURL=getVariantExtras.js.map


/***/ }),

/***/ 37269:
/***/ ((module) => {

"use strict";

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var insertStyleRule_exports = {};
__export(insertStyleRule_exports, {
  getAllRules: () => getAllRules,
  getAllSelectors: () => getAllSelectors,
  getAllTransforms: () => getAllTransforms,
  insertStyleRules: () => insertStyleRules,
  insertedTransforms: () => insertedTransforms,
  listenForSheetChanges: () => listenForSheetChanges,
  scanAllSheets: () => scanAllSheets,
  shouldInsertStyleRules: () => shouldInsertStyleRules,
  updateRules: () => updateRules
});
module.exports = __toCommonJS(insertStyleRule_exports);
const allSelectors = {};
const allRules = {};
const insertedTransforms = {};
const getAllSelectors = () => allSelectors;
const getAllRules = () => Object.values(allRules);
const getAllTransforms = () => insertedTransforms;
function addTransform(identifier, css, rule) {
  const s = css.indexOf("transform:");
  if (s === -1) {
    if (false) {}
    return false;
  }
  const startI = s + "transform:".length;
  const endI = css.indexOf(";");
  const value = css.slice(startI, endI);
  if (!insertedTransforms[identifier]) {
    insertedTransforms[identifier] = value;
    return true;
  }
  return false;
}
const isClient = typeof document !== "undefined";
const scannedCache = /* @__PURE__ */ new WeakMap();
const totalSheetSelectors = /* @__PURE__ */ new Map();
function listenForSheetChanges() {
  if (!isClient)
    return;
  function handleNode(node, remove = false) {
    if (node instanceof HTMLStyleElement && node.sheet) {
      updateSheetStyles(node.sheet, remove);
    }
  }
  const mo = new MutationObserver((entries) => {
    for (const entry of entries) {
      entry.addedNodes.forEach((node) => handleNode(node));
      entry.removedNodes.forEach((node) => handleNode(node, true));
    }
  });
  mo.observe(document.head, {
    childList: true
  });
}
function scanAllSheets() {
  if (false)
    {}
  if (!isClient)
    return;
  const sheets = document.styleSheets;
  if (!sheets)
    return;
  for (let i = 0; i < sheets.length; i++) {
    const sheet2 = sheets[i];
    if (!sheet2)
      continue;
    updateSheetStyles(sheet2);
  }
}
function track(id, remove = false) {
  const next = (totalSheetSelectors.get(id) || 0) + (remove ? -1 : 1);
  totalSheetSelectors.set(id, next);
  return next;
}
function updateSheetStyles(sheet2, remove = false) {
  var _a, _b;
  let rules;
  try {
    rules = sheet2.cssRules;
  } catch {
    return;
  }
  const firstSelector = (_a = getTamaguiSelector(rules[0])) == null ? void 0 : _a[0];
  if (!firstSelector) {
    return;
  }
  const lastSelector = (_b = getTamaguiSelector(rules[rules.length - 1])) == null ? void 0 : _b[0];
  const cacheKey = `${rules.length}${firstSelector}${lastSelector}`;
  const lastScanned = scannedCache.get(sheet2);
  if (!remove) {
    if (lastScanned === cacheKey) {
      return;
    }
  }
  const len = rules.length;
  for (let i = 0; i < len; i++) {
    const rule = rules[i];
    const response = getTamaguiSelector(rule);
    if (!response) {
      return;
    }
    const [identifier, cssRule] = response;
    const total = track(identifier, remove);
    if (remove) {
      if (total === 0) {
        delete allSelectors[identifier];
      }
    } else {
      if (!(identifier in allSelectors)) {
        const isTransform = identifier.startsWith("_transform");
        const shouldInsert = isTransform ? addTransform(identifier, cssRule.cssText, cssRule) : true;
        if (shouldInsert) {
          allSelectors[identifier] = cssRule.cssText;
        }
      }
    }
  }
  scannedCache.set(sheet2, cacheKey);
}
function getTamaguiSelector(rule) {
  if (rule instanceof CSSStyleRule) {
    const text = rule.selectorText;
    if (text[0] === "." && text[1] === "_") {
      return [text.slice(1), rule];
    }
    if (text.startsWith(":root") && text.includes("._")) {
      return [getIdentifierFromTamaguiSelector(text), rule];
    }
  } else if (rule instanceof CSSMediaRule) {
    if (rule.cssRules.length > 1)
      return null;
    return getTamaguiSelector(rule.cssRules[0]);
  }
  return null;
}
const getIdentifierFromTamaguiSelector = (selector) => selector.replace(/(:root)+\s+/, "").replace(/:[a-z]+$/, "").slice(1);
const sheet = isClient ? document.head.appendChild(document.createElement("style")).sheet : null;
function updateRules(identifier, rules) {
  if (allRules[identifier])
    return false;
  allRules[identifier] = rules.join(" ");
  if (identifier.startsWith("_transform")) {
    return addTransform(identifier, rules[0]);
  }
  return true;
}
function insertStyleRules(rulesToInsert) {
  if (!rulesToInsert.length)
    return;
  if (isClient && !sheet) {
    if (false)
      {}
    return;
  }
  for (const { identifier, rules } of rulesToInsert) {
    if (identifier in allSelectors)
      continue;
    allSelectors[identifier] =  false ? 0 : " ";
    updateRules(identifier, rules);
    if (sheet) {
      for (const rule of rules) {
        try {
          sheet.insertRule(rule, sheet.cssRules.length);
        } catch (err) {
          if (false) {}
        }
      }
    }
  }
}
const IS_STATIC = "" === "is_static";
function shouldInsertStyleRules(styleObject) {
  if (IS_STATIC) {
    return true;
  }
  return !(styleObject.identifier in allSelectors);
}
// Annotate the CommonJS export names for ESM import in node:
0 && (0);
//# sourceMappingURL=insertStyleRule.js.map


/***/ }),

/***/ 88356:
/***/ ((module) => {

"use strict";

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var isObj_exports = {};
__export(isObj_exports, {
  isObj: () => isObj
});
module.exports = __toCommonJS(isObj_exports);
const isObj = (x) => x && !Array.isArray(x) && typeof x === "object";
// Annotate the CommonJS export names for ESM import in node:
0 && (0);
//# sourceMappingURL=isObj.js.map


/***/ }),

/***/ 45701:
/***/ ((module) => {

"use strict";

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var isTamaguiComponent_exports = {};
__export(isTamaguiComponent_exports, {
  isTamaguiComponent: () => isTamaguiComponent
});
module.exports = __toCommonJS(isTamaguiComponent_exports);
function isTamaguiComponent(comp, name) {
  const config = comp == null ? void 0 : comp["staticConfig"];
  return (config == null ? void 0 : config.parsed) && (name ? name === config.componentName : true) || false;
}
// Annotate the CommonJS export names for ESM import in node:
0 && (0);
//# sourceMappingURL=isTamaguiComponent.js.map


/***/ }),

/***/ 10454:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var isTamaguiElement_exports = {};
__export(isTamaguiElement_exports, {
  isTamaguiElement: () => isTamaguiElement
});
module.exports = __toCommonJS(isTamaguiElement_exports);
var import_react = __webpack_require__(16689);
var import_isTamaguiComponent = __webpack_require__(45701);
const isTamaguiElement = (child, name) => {
  return (0, import_react.isValidElement)(child) && (0, import_isTamaguiComponent.isTamaguiComponent)(child.type, name);
};
// Annotate the CommonJS export names for ESM import in node:
0 && (0);
//# sourceMappingURL=isTamaguiElement.js.map


/***/ }),

/***/ 69464:
/***/ ((module) => {

"use strict";

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var matchMedia_exports = {};
__export(matchMedia_exports, {
  matchMedia: () => matchMedia,
  setupMatchMedia: () => setupMatchMedia
});
module.exports = __toCommonJS(matchMedia_exports);
const matchMedia = typeof window !== "undefined" && window.matchMedia || matchMediaFallback;
function matchMediaFallback(_) {
  return {
    addListener() {
    },
    removeListener() {
    },
    matches: false
  };
}
function setupMatchMedia(_) {
}
// Annotate the CommonJS export names for ESM import in node:
0 && (0);
//# sourceMappingURL=matchMedia.js.map


/***/ }),

/***/ 1458:
/***/ ((module) => {

"use strict";

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var mergeProps_exports = {};
__export(mergeProps_exports, {
  mergeProps: () => mergeProps
});
module.exports = __toCommonJS(mergeProps_exports);
const mergeProps = (a, b, leaveOutClassNames = false, inverseShorthands) => {
  const out = {};
  const outCns = leaveOutClassNames ? {} : null;
  for (const key in a) {
    mergeProp(out, outCns, a, b, key, leaveOutClassNames, inverseShorthands);
  }
  for (const key in b) {
    mergeProp(out, outCns, b, void 0, key, leaveOutClassNames, inverseShorthands);
  }
  return [out, outCns];
};
function mergeProp(out, outCns, a, b, key, leaveOutClassNames, inverseShorthands) {
  const val = a[key];
  const shorthand = (inverseShorthands == null ? void 0 : inverseShorthands[key]) || null;
  if (b && (key in b || shorthand && shorthand in b)) {
    return;
  }
  if (shorthand) {
    key = shorthand;
  }
  if (leaveOutClassNames && (val == null ? void 0 : val[0]) === "_") {
    outCns[key] = val;
  } else {
    out[key] = val;
  }
}
// Annotate the CommonJS export names for ESM import in node:
0 && (0);
//# sourceMappingURL=mergeProps.js.map


/***/ }),

/***/ 66106:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var normalizeColor_exports = {};
__export(normalizeColor_exports, {
  names: () => names,
  normalizeColor: () => normalizeColor,
  rgba: () => rgba
});
module.exports = __toCommonJS(normalizeColor_exports);
var import_constants = __webpack_require__(14810);
var NCC = __toESM(__webpack_require__(17285));
const rgba = NCC.rgba;
const names = NCC.names;
const normalizeColor = (color, opacity) => {
  if (!color)
    return;
  if (color[0] === "$")
    return color;
  if (import_constants.isWeb && opacity === 1)
    return color;
  const colorProcessed = NCC.normalizeCSSColor(color);
  if (typeof colorProcessed === "number") {
    const { r, g, b, a } = rgba(colorProcessed);
    const alpha = (opacity ?? a ?? 1).toFixed(2);
    return `rgba(${r},${g},${b},${alpha})`;
  }
  if (false) {}
  return color;
};
// Annotate the CommonJS export names for ESM import in node:
0 && (0);
//# sourceMappingURL=normalizeColor.js.map


/***/ }),

/***/ 27234:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var normalizeShadow_exports = {};
__export(normalizeShadow_exports, {
  normalizeShadow: () => normalizeShadow
});
module.exports = __toCommonJS(normalizeShadow_exports);
var import_defaultOffset = __webpack_require__(30550);
var import_normalizeValueWithProperty = __webpack_require__(31053);
function normalizeShadow({
  shadowColor,
  shadowOffset,
  shadowOpacity = 1,
  shadowRadius
}) {
  const { height, width } = shadowOffset || import_defaultOffset.defaultOffset;
  return {
    shadowOffset: {
      width: (0, import_normalizeValueWithProperty.normalizeValueWithProperty)(width || 0),
      height: (0, import_normalizeValueWithProperty.normalizeValueWithProperty)(height || 0)
    },
    shadowRadius: (0, import_normalizeValueWithProperty.normalizeValueWithProperty)(shadowRadius || 0),
    shadowColor,
    shadowOpacity
  };
}
// Annotate the CommonJS export names for ESM import in node:
0 && (0);
//# sourceMappingURL=normalizeShadow.js.map


/***/ }),

/***/ 50862:
/***/ ((module) => {

"use strict";

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var normalizeStylePropKeys_exports = {};
__export(normalizeStylePropKeys_exports, {
  normalizeStylePropKeys: () => normalizeStylePropKeys
});
module.exports = __toCommonJS(normalizeStylePropKeys_exports);
const normalizeStylePropKeys = {};
// Annotate the CommonJS export names for ESM import in node:
0 && (0);
//# sourceMappingURL=normalizeStylePropKeys.js.map


/***/ }),

/***/ 31053:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var normalizeValueWithProperty_exports = {};
__export(normalizeValueWithProperty_exports, {
  normalizeValueWithProperty: () => normalizeValueWithProperty,
  reverseMapClassNameToValue: () => reverseMapClassNameToValue
});
module.exports = __toCommonJS(normalizeValueWithProperty_exports);
var import_constants = __webpack_require__(14810);
var import_insertStyleRule = __webpack_require__(37269);
var import_normalizeColor = __webpack_require__(66106);
var import_normalizeStylePropKeys = __webpack_require__(50862);
const colorCache = {};
function normalizeValueWithProperty(value, property) {
  if (value in colorCache) {
    return colorCache[value];
  }
  if (property && property in unitlessNumbers) {
    return value;
  }
  let res = value;
  if (property && (property in import_normalizeStylePropKeys.normalizeStylePropKeys || value in import_normalizeColor.names)) {
    res = (0, import_normalizeColor.normalizeColor)(value);
    colorCache[value] = res;
  } else if ( true && typeof value === "number" && (property === void 0 || !(property in unitlessNumbers || property in stringNumbers))) {
    res = `${value}px`;
  } else if (import_constants.isWeb && property !== void 0 && property in stringNumbers) {
    res = `${res}`;
  }
  return res;
}
const stringNumbers = {
  zIndex: true
};
const unitlessNumbers = {
  WebkitLineClamp: true,
  animationIterationCount: true,
  aspectRatio: true,
  borderImageOutset: true,
  borderImageSlice: true,
  borderImageWidth: true,
  columnCount: true,
  flex: true,
  flexGrow: true,
  flexBasis: true,
  flexOrder: true,
  flexPositive: true,
  flexShrink: true,
  flexNegative: true,
  fontWeight: true,
  gridRow: true,
  gridRowEnd: true,
  gridRowGap: true,
  gridRowStart: true,
  gridColumn: true,
  gridColumnEnd: true,
  gridColumnGap: true,
  gridColumnStart: true,
  lineClamp: true,
  opacity: true,
  order: true,
  orphans: true,
  tabSize: true,
  widows: true,
  zoom: true,
  scale: true,
  scaleX: true,
  scaleY: true,
  scaleZ: true,
  shadowOpacity: true
};
const rcache = {};
function reverseMapClassNameToValue(key, className) {
  const selectors = (0, import_insertStyleRule.getAllSelectors)();
  const cssRule = selectors[className];
  if (rcache[cssRule])
    return rcache[cssRule];
  if (!cssRule) {
    return;
  }
  const cssVal = cssRule.replace(/.*:/, "").replace(/;.*/, "").trim();
  let res;
  if (cssVal.startsWith("var(")) {
    res = cssVal;
  } else if (unitlessNumbers[key]) {
    res = +cssVal;
  } else if (cssVal.endsWith("px")) {
    res = +cssVal.replace("px", "");
  } else {
    res = cssVal;
  }
  rcache[cssRule] = res;
  if (false) {}
  return res;
}
// Annotate the CommonJS export names for ESM import in node:
0 && (0);
//# sourceMappingURL=normalizeValueWithProperty.js.map


/***/ }),

/***/ 22476:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var proxyThemeVariables_exports = {};
__export(proxyThemeVariables_exports, {
  proxyThemeVariables: () => proxyThemeVariables
});
module.exports = __toCommonJS(proxyThemeVariables_exports);
var import_createProxy = __webpack_require__(42706);
function proxyThemeVariables(obj) {
  return (0, import_createProxy.createProxy)(obj || {}, {
    has(target, key) {
      return Reflect.has(target, removeStarting$(key));
    },
    get(target, key) {
      return Reflect.get(target, removeStarting$(key));
    }
  });
}
const removeStarting$ = (str) => typeof str === "string" && str[0] === "$" ? str.slice(1) : str;
// Annotate the CommonJS export names for ESM import in node:
0 && (0);
//# sourceMappingURL=proxyThemeVariables.js.map


/***/ }),

/***/ 45204:
/***/ ((module) => {

"use strict";

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var pseudoDescriptors_exports = {};
__export(pseudoDescriptors_exports, {
  pseudoDescriptors: () => pseudoDescriptors
});
module.exports = __toCommonJS(pseudoDescriptors_exports);
const pseudoDescriptors = {
  hoverStyle: {
    name: "hover",
    priority: 1
  },
  pressStyle: {
    name: "active",
    stateKey: "press",
    priority: 2
  },
  focusStyle: {
    name: "focus",
    priority: 3
  },
  enterStyle: {
    name: "enter",
    stateKey: "unmounted",
    priority: 4
  },
  exitStyle: {
    name: "exit",
    stateKey: "isExiting",
    priority: 5
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (0);
//# sourceMappingURL=pseudoDescriptors.js.map


/***/ }),

/***/ 20299:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var registerCSSVariable_exports = {};
__export(registerCSSVariable_exports, {
  registerCSSVariable: () => registerCSSVariable,
  tokensValueToVariable: () => tokensValueToVariable,
  variableToCSS: () => variableToCSS
});
module.exports = __toCommonJS(registerCSSVariable_exports);
var import_createVariable = __webpack_require__(88957);
const registerCSSVariable = (v) => {
  tokensValueToVariable.set(v.val, v);
};
const variableToCSS = (v) => {
  return `--${(0, import_createVariable.createCSSVariable)(v.name, false)}:${typeof v.val === "number" ? `${v.val}px` : v.val}`;
};
const tokensValueToVariable = /* @__PURE__ */ new Map();
// Annotate the CommonJS export names for ESM import in node:
0 && (0);
//# sourceMappingURL=registerCSSVariable.js.map


/***/ }),

/***/ 26819:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var themeable_exports = {};
__export(themeable_exports, {
  themeable: () => themeable
});
module.exports = __toCommonJS(themeable_exports);
var import_jsx_runtime = __webpack_require__(85893);
var import_react = __toESM(__webpack_require__(16689));
var import_Theme = __webpack_require__(49798);
function themeable(component, opts) {
  const withThemeComponent = (0, import_react.forwardRef)(function WithTheme(props, ref) {
    const { themeInverse, theme, componentName, themeReset, ...rest } = props;
    const element = import_react.default.createElement(component, { ...rest, ref });
    return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
      import_Theme.Theme,
      {
        inverse: themeInverse,
        componentName: componentName || (opts == null ? void 0 : opts.componentName),
        name: theme || null,
        "data-themeable": true,
        debug: props.debug,
        reset: props.themeReset,
        children: element
      }
    );
  });
  const withTheme = withThemeComponent;
  withTheme.displayName = `Themed(${(component == null ? void 0 : component.displayName) || (component == null ? void 0 : component.name) || "Anonymous"})`;
  return withTheme;
}
// Annotate the CommonJS export names for ESM import in node:
0 && (0);
//# sourceMappingURL=themeable.js.map


/***/ }),

/***/ 49055:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var themes_exports = {};
__export(themes_exports, {
  ensureThemeVariable: () => ensureThemeVariable,
  proxyThemeToParents: () => proxyThemeToParents
});
module.exports = __toCommonJS(themes_exports);
var import_createVariable = __webpack_require__(88957);
var import_getThemeUnwrapped = __webpack_require__(2023);
function ensureThemeVariable(theme, key) {
  const val = theme[key];
  const themeKey = key;
  if (!(0, import_createVariable.isVariable)(val)) {
    theme[key] = (0, import_createVariable.createVariable)({
      key: themeKey,
      name: themeKey,
      val
    });
  } else {
    if (val.name !== themeKey) {
      theme[key] = (0, import_createVariable.createVariable)({
        key: val.name,
        name: themeKey,
        val: val.val
      });
    }
  }
}
function proxyThemeToParents(themeName, theme, themes) {
  const cur = [];
  const parents = themeName.split("_").slice(0, -1).map((part) => {
    cur.push(part);
    return cur.join("_");
  });
  const numParents = parents.length;
  return new Proxy(theme, {
    get(target, key) {
      if (key === import_getThemeUnwrapped.GetThemeUnwrapped)
        return theme;
      if (numParents && !Reflect.has(target, key)) {
        for (let i = numParents - 1; i >= 0; i--) {
          const parent = themes[parents[i]];
          if (!parent)
            continue;
          if (Reflect.has(parent, key)) {
            return Reflect.get(parent, key);
          }
        }
      }
      return Reflect.get(target, key);
    }
  });
}
// Annotate the CommonJS export names for ESM import in node:
0 && (0);
//# sourceMappingURL=themes.js.map


/***/ }),

/***/ 97312:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var useShallowSetState_exports = {};
__export(useShallowSetState_exports, {
  useShallowSetState: () => useShallowSetState
});
module.exports = __toCommonJS(useShallowSetState_exports);
var import_react = __webpack_require__(16689);
function useShallowSetState(setter, debug, debugName) {
  return (0, import_react.useCallback)(
    (next) => {
      const shouldTransition = Object.keys(next).every(
        (k) => transitionKeys.has(k)
      );
      const run = shouldTransition ? import_react.startTransition : (_) => _();
      run(() => {
        setter((prev) => {
          for (const key in next) {
            if (prev[key] !== next[key]) {
              if (false) {}
              return { ...prev, ...next };
            }
          }
          return prev;
        });
      });
    },
    [setter]
  );
}
const transitionKeys = /* @__PURE__ */ new Set([
  "press",
  "pressIn",
  "focus",
  "unmounted"
]);
// Annotate the CommonJS export names for ESM import in node:
0 && (0);
//# sourceMappingURL=useShallowSetState.js.map


/***/ }),

/***/ 93658:
/***/ ((module) => {

"use strict";

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var withStaticProperties_exports = {};
__export(withStaticProperties_exports, {
  withStaticProperties: () => withStaticProperties
});
module.exports = __toCommonJS(withStaticProperties_exports);
const withStaticProperties = function(component, staticProps) {
  const next = typeof component === "function" ? component : { ...component };
  Object.assign(next, staticProps);
  return next;
};
// Annotate the CommonJS export names for ESM import in node:
0 && (0);
//# sourceMappingURL=withStaticProperties.js.map


/***/ }),

/***/ 2023:
/***/ ((module) => {

"use strict";

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var getThemeUnwrapped_exports = {};
__export(getThemeUnwrapped_exports, {
  GetThemeUnwrapped: () => GetThemeUnwrapped,
  getThemeUnwrapped: () => getThemeUnwrapped
});
module.exports = __toCommonJS(getThemeUnwrapped_exports);
const getThemeUnwrapped = (theme) => {
  return (theme == null ? void 0 : theme[GetThemeUnwrapped]) || theme;
};
const GetThemeUnwrapped = Symbol();
// Annotate the CommonJS export names for ESM import in node:
0 && (0);
//# sourceMappingURL=getThemeUnwrapped.js.map


/***/ }),

/***/ 55159:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var useId_exports = {};
__export(useId_exports, {
  useId: () => import_react.useId
});
module.exports = __toCommonJS(useId_exports);
var import_react = __webpack_require__(16689);
// Annotate the CommonJS export names for ESM import in node:
0 && (0);
//# sourceMappingURL=useId.js.map


/***/ }),

/***/ 25230:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var useIsTouchDevice_exports = {};
__export(useIsTouchDevice_exports, {
  useIsTouchDevice: () => useIsTouchDevice
});
module.exports = __toCommonJS(useIsTouchDevice_exports);
var import_constants = __webpack_require__(14810);
var import_use_did_finish_ssr = __webpack_require__(36527);
const useIsTouchDevice = () => {
  return !import_constants.isWeb ? true : (0, import_use_did_finish_ssr.useDidFinishSSR)() ? import_constants.isTouchable : false;
};
// Annotate the CommonJS export names for ESM import in node:
0 && (0);
//# sourceMappingURL=useIsTouchDevice.js.map


/***/ }),

/***/ 85030:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var useMedia_exports = {};
__export(useMedia_exports, {
  configureMedia: () => configureMedia,
  getInitialMediaState: () => getInitialMediaState,
  getMedia: () => getMedia,
  getMediaImportanceIfMoreImportant: () => getMediaImportanceIfMoreImportant,
  getMediaKeyImportance: () => getMediaKeyImportance,
  mediaKeysWithAndWithout$: () => mediaKeysWithAndWithout$,
  mediaObjectToString: () => mediaObjectToString,
  mediaQueryConfig: () => mediaQueryConfig,
  mediaState: () => mediaState,
  mergeMediaByImportance: () => mergeMediaByImportance,
  setMediaShouldUpdate: () => setMediaShouldUpdate,
  setupMediaListeners: () => setupMediaListeners,
  useMedia: () => useMedia,
  useMediaListeners: () => useMediaListeners,
  useMediaPropsActive: () => useMediaPropsActive
});
module.exports = __toCommonJS(useMedia_exports);
var import_react = __webpack_require__(16689);
var import_config = __webpack_require__(16265);
var import_createProxy = __webpack_require__(42706);
var import_matchMedia = __webpack_require__(69464);
var import_useSafeRef = __webpack_require__(87580);
let mediaState = (
  // development only safeguard
   false ? 0 : {}
);
const mediaQueryConfig = {};
const getMedia = () => mediaState;
const mediaKeysWithAndWithout$ = /* @__PURE__ */ new Set();
let initState;
const getInitialMediaState = () => {
  return ((0, import_config.getConfig)().disableSSR ? mediaState : initState) || {};
};
let mediaKeysOrdered;
const getMediaKeyImportance = (key) => {
  if (false) {}
  return mediaKeysOrdered.indexOf(key) + 2;
};
const dispose = /* @__PURE__ */ new Set();
const configureMedia = (config) => {
  const { media, mediaQueryDefaultActive } = config;
  if (!media)
    return;
  for (const key in media) {
    mediaState[key] = (mediaQueryDefaultActive == null ? void 0 : mediaQueryDefaultActive[key]) || false;
    mediaKeysWithAndWithout$.add(key);
    mediaKeysWithAndWithout$.add(`$${key}`);
  }
  Object.assign(mediaQueryConfig, media);
  initState = { ...mediaState };
  updateCurrentState();
  mediaKeysOrdered = Object.keys(media);
  if (config.disableSSR) {
    setupMediaListeners();
  }
};
function unlisten() {
  dispose.forEach((cb) => cb());
  dispose.clear();
}
let configuredKey = "";
function setupMediaListeners() {
  const nextKey = JSON.stringify(mediaQueryConfig);
  if (nextKey === configuredKey)
    return;
  configuredKey = nextKey;
  unlisten();
  for (const key in mediaQueryConfig) {
    let update2 = function() {
      const next = !!getMatch().matches;
      if (next === mediaState[key])
        return;
      mediaState = { ...mediaState, [key]: next };
      updateCurrentState();
    };
    var update = update2;
    const str = mediaObjectToString(mediaQueryConfig[key]);
    const getMatch = () => (0, import_matchMedia.matchMedia)(str);
    const match = getMatch();
    if (!match) {
      throw new Error("\u26A0\uFE0F No match");
    }
    match.addListener(update2);
    dispose.add(() => {
      match.removeListener(update2);
    });
    update2();
  }
}
function useMediaListeners(config) {
  if (config.disableSSR)
    return;
  (0, import_react.useEffect)(() => {
    setupMediaListeners();
  }, []);
}
const listeners = /* @__PURE__ */ new Set();
let flushing = false;
function updateCurrentState() {
  if (flushing)
    return;
  flushing = true;
  Promise.resolve().then(() => {
    flushing = false;
    (0, import_react.startTransition)(() => {
      listeners.forEach((cb) => cb(mediaState));
    });
  });
}
const shouldUpdate = /* @__PURE__ */ new WeakMap();
function setMediaShouldUpdate(ref, props) {
  return shouldUpdate.set(ref, props);
}
function subscribe(subscriber) {
  listeners.add(subscriber);
  return () => listeners.delete(subscriber);
}
function useMedia(uid, debug) {
  const internal = (0, import_useSafeRef.useSafeRef)(void 0);
  if (!internal.current) {
    internal.current = {
      prev: initState
    };
  }
  const state = (0, import_react.useSyncExternalStore)(
    subscribe,
    () => {
      const { touched, prev } = internal.current;
      const componentState = uid ? shouldUpdate.get(uid) : void 0;
      if ((componentState == null ? void 0 : componentState.enabled) === false) {
        return prev;
      }
      const testKeys = (componentState == null ? void 0 : componentState.keys) ?? ((!componentState || componentState.enabled) && touched ? [...touched] : null);
      const hasntUpdated = testKeys == null ? void 0 : testKeys.every((key) => mediaState[key] === prev[key]);
      if (hasntUpdated) {
        return prev;
      }
      internal.current.prev = mediaState;
      return mediaState;
    },
    () => initState
  );
  return (0, import_react.useMemo)(() => {
    return new Proxy(state, {
      get(_, key) {
        var _a;
        if (typeof key === "string") {
          (_a = internal.current).touched || (_a.touched = /* @__PURE__ */ new Set());
          internal.current.touched.add(key);
        }
        return Reflect.get(state, key);
      }
    });
  }, [state]);
}
function useMediaPropsActive(props) {
  const media = useMedia();
  return (0, import_react.useMemo)(() => {
    const next = {};
    const importancesUsed = {};
    const propNames = Object.keys(props);
    for (let i = propNames.length - 1; i >= 0; i--) {
      const key = propNames[i];
      const val = props[key];
      if (key[0] === "$") {
        const mediaKey = key.slice(1);
        if (!media[mediaKey])
          continue;
        if (val && typeof val === "object") {
          const subKeys = Object.keys(val);
          for (let j = subKeys.length; j--; j >= 0) {
            const subKey = subKeys[j];
            mergeMediaByImportance(next, mediaKey, subKey, val[subKey], importancesUsed);
          }
        }
      } else {
        mergeMediaByImportance(next, "", key, val, importancesUsed);
      }
    }
    return next;
  }, [media, props]);
}
const getMediaImportanceIfMoreImportant = (mediaKey, key, importancesUsed) => {
  const importance = getMediaKeyImportance(mediaKey);
  return !importancesUsed[key] || importance > importancesUsed[key] ? importance : null;
};
function mergeMediaByImportance(onto, mediaKey, key, value, importancesUsed) {
  const importance = getMediaImportanceIfMoreImportant(mediaKey, key, importancesUsed);
  if (importance === null) {
    return false;
  }
  importancesUsed[key] = importance;
  onto[key] = value;
  return true;
}
function camelToHyphen(str) {
  return str.replace(/[A-Z]/g, (m) => `-${m.toLowerCase()}`).toLowerCase();
}
function mediaObjectToString(query) {
  if (typeof query === "string") {
    return query;
  }
  return Object.entries(query).map(([feature, value]) => {
    feature = camelToHyphen(feature);
    if (typeof value === "string") {
      return `(${feature}: ${value})`;
    }
    if (typeof value === "number" && /[height|width]$/.test(feature)) {
      value = `${value}px`;
    }
    return `(${feature}: ${value})`;
  }).join(" and ");
}
// Annotate the CommonJS export names for ESM import in node:
0 && (0);
//# sourceMappingURL=useMedia.js.map


/***/ }),

/***/ 87580:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var useSafeRef_exports = {};
__export(useSafeRef_exports, {
  useSafeRef: () => useSafeRef
});
module.exports = __toCommonJS(useSafeRef_exports);
var import_constants = __webpack_require__(14810);
var import_react = __webpack_require__(16689);
const useSafeRef = (initialValue) => {
  const rawRef = (0, import_react.useRef)();
  if (!rawRef.current) {
    rawRef.current = {
      hold: true,
      next: initialValue,
      cur: initialValue,
      ref: {
        get current() {
          return raw.hold ? raw.cur : raw.next;
        },
        set current(v) {
          if (!raw.hold) {
            raw.next = v;
          }
          raw.cur = v;
        }
      }
    };
  }
  const raw = rawRef.current;
  raw.hold = true;
  raw.cur = raw.next;
  (0, import_constants.useIsomorphicLayoutEffect)(() => {
    raw.hold = false;
    raw.next = raw.cur;
  });
  return raw.ref;
};
// Annotate the CommonJS export names for ESM import in node:
0 && (0);
//# sourceMappingURL=useSafeRef.js.map


/***/ }),

/***/ 14425:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var useServerHooks_exports = {};
__export(useServerHooks_exports, {
  useServerRef: () => useServerRef,
  useServerState: () => useServerState
});
module.exports = __toCommonJS(useServerHooks_exports);
var import_constants = __webpack_require__(14810);
var import_react = __webpack_require__(16689);
const useServerState = import_constants.isRSC ? (val) => [val, idFn] : import_react.useState;
const useServerRef = import_constants.isRSC ? (val) => ({ current: val }) : import_react.useRef;
const idFn = () => {
};
// Annotate the CommonJS export names for ESM import in node:
0 && (0);
//# sourceMappingURL=useServerHooks.js.map


/***/ }),

/***/ 53386:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var useStyle_exports = {};
__export(useStyle_exports, {
  useStyle: () => useStyle
});
module.exports = __toCommonJS(useStyle_exports);
var import_constants = __webpack_require__(14810);
var import_react = __webpack_require__(16689);
var import_FontLanguageContext = __webpack_require__(78027);
var import_TextAncestorContext = __webpack_require__(11195);
var import_getSplitStyles = __webpack_require__(41384);
var import_useMedia = __webpack_require__(85030);
var import_useTheme = __webpack_require__(69953);
function useStyle(base, style, options) {
  const isText = base.staticConfig.isText;
  const hasTextAncestor = !!(import_constants.isWeb && isText ? (0, import_react.useContext)(import_TextAncestorContext.TextAncestorContext) : false);
  const languageContext = import_constants.isRSC ? null : (0, import_react.useContext)(import_FontLanguageContext.FontLanguageContext);
  const theme = (0, import_useTheme.useTheme)();
  const media = (0, import_useMedia.useMedia)();
  const out = (0, import_getSplitStyles.useSplitStyles)(
    style,
    base.staticConfig,
    theme,
    {
      ...options,
      mediaState: media,
      hasTextAncestor,
      resolveVariablesAs: "auto"
    },
    null,
    languageContext || void 0,
    isText ? "span" : "div",
    options == null ? void 0 : options.debug
  );
  return {
    style: Object.keys(out.style).length ? out.style : null,
    classNames: out.classNames
  };
}
// Annotate the CommonJS export names for ESM import in node:
0 && (0);
//# sourceMappingURL=useStyle.js.map


/***/ }),

/***/ 69953:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var useTheme_exports = {};
__export(useTheme_exports, {
  activeThemeManagers: () => activeThemeManagers,
  getThemeProxied: () => getThemeProxied,
  useChangeThemeEffect: () => useChangeThemeEffect,
  useTheme: () => useTheme,
  useThemeWithState: () => useThemeWithState
});
module.exports = __toCommonJS(useTheme_exports);
var import_constants = __webpack_require__(14810);
var import_react = __webpack_require__(16689);
var import_config = __webpack_require__(16265);
var import_isDevTools = __webpack_require__(57405);
var import_createProxy = __webpack_require__(42706);
var import_ThemeManager = __webpack_require__(21497);
var import_ThemeManagerContext = __webpack_require__(2856);
var import_getThemeUnwrapped = __webpack_require__(2023);
var import_useServerHooks = __webpack_require__(14425);
const emptyProps = { name: null };
function getDefaultThemeProxied() {
  const config = (0, import_config.getConfig)();
  const name = Object.keys(config.themes)[0];
  return getThemeProxied({
    theme: config.themes[name],
    name
  });
}
const useTheme = (props = emptyProps) => {
  var _a;
  return (import_constants.isRSC ? null : (_a = useThemeWithState(props)) == null ? void 0 : _a.theme) || getDefaultThemeProxied();
};
const useThemeWithState = (props) => {
  var _a;
  const keys = (0, import_useServerHooks.useServerRef)([]);
  const changedTheme = useChangeThemeEffect(
    props,
    false,
    import_constants.isClient ? () => {
      var _a2;
      return ((_a2 = props.shouldUpdate) == null ? void 0 : _a2.call(props)) ?? keys.current.length === 0;
    } : void 0
  );
  const { themeManager, isNewTheme, theme, name, className } = changedTheme;
  if (false) {}
  if (!changedTheme.theme) {
    if (false) {}
    return null;
  }
  const proxiedTheme = (0, import_react.useMemo)(() => {
    return getThemeProxied(changedTheme);
  }, [theme, isNewTheme, name, className, themeManager]);
  return {
    ...changedTheme,
    theme: proxiedTheme
  };
};
function getThemeProxied({
  theme,
  themeManager,
  keys
}) {
  return (0, import_createProxy.createProxy)(theme, {
    has(_, key) {
      if (typeof key === "string") {
        if (key[0] === "$")
          key = key.slice(1);
        return themeManager == null ? void 0 : themeManager.allKeys.has(key);
      }
      return Reflect.has(theme, key);
    },
    get(_, key) {
      if (key === import_getThemeUnwrapped.GetThemeUnwrapped) {
        return theme;
      }
      if (key === "undefined" || key === "__proto__" || key === "$typeof" || typeof key !== "string" || !themeManager) {
        return Reflect.get(_, key);
      }
      const keyString = key;
      if (key[0] === "$") {
        key = key.slice(1);
      }
      const val = themeManager.getValue(key);
      const currentKeys = keys == null ? void 0 : keys.current;
      if (val && currentKeys) {
        return new Proxy(val, {
          // when they touch the actual value we only track it
          // if its a variable (web), its ignored!
          get(_2, subkey) {
            if (subkey === "val" && !currentKeys.includes(keyString)) {
              currentKeys.push(keyString);
            }
            return Reflect.get(val, subkey);
          }
        });
      }
      return val;
    }
  });
}
const activeThemeManagers = /* @__PURE__ */ new Set();
const useChangeThemeEffect = (props, root = false, disableUpdate) => {
  if (import_constants.isRSC) {
    return {
      ...createState().state,
      themeManager: null
    };
  }
  const parentManager = (0, import_react.useContext)(import_ThemeManagerContext.ThemeManagerContext);
  const {
    debug,
    // @ts-expect-error internal use only
    disable
  } = props;
  if (disable) {
    if (!parentManager)
      throw `\u274C`;
    return {
      ...parentManager.state,
      isNewTheme: false,
      themeManager: parentManager
    };
  }
  const [themeState, setThemeState] = (0, import_react.useState)(createState);
  const { isNewTheme, state, themeManager, mounted } = themeState;
  if (!import_constants.isServer) {
    (0, import_react.useEffect)(() => {
      if (disable)
        return;
      if (props.inverse && !mounted) {
        setThemeState({ ...themeState, mounted: true });
        return;
      }
      activeThemeManagers.add(themeManager);
      return () => {
        activeThemeManagers.delete(themeManager);
      };
    }, [disable, state, isNewTheme, debug]);
  }
  const isInversingOnMount = Boolean(!themeState.mounted && props.inverse);
  const shouldReturnParentState = (0, import_ThemeManager.hasNoThemeUpdatingProps)(props) || isInversingOnMount;
  if (shouldReturnParentState) {
    if (!parentManager)
      throw "impossible";
    if (false)
      {}
    return {
      ...parentManager.state,
      className: isInversingOnMount ? "" : parentManager.state.className,
      themeManager: parentManager,
      isNewTheme: false
    };
  }
  updateState();
  return {
    ...state,
    isNewTheme,
    themeManager
  };
  function createState(prev) {
    if (prev && (disableUpdate == null ? void 0 : disableUpdate())) {
      return prev;
    }
    const _ = new import_ThemeManager.ThemeManager(props, root ? "root" : parentManager);
    const isNewTheme2 = _ !== parentManager;
    const mounted2 = !props.inverse ? true : root || (prev == null ? void 0 : prev.mounted);
    return {
      // ThemeManager returns parentManager if no change
      isNewTheme: isNewTheme2,
      state: { ..._.state },
      themeManager: _,
      mounted: mounted2
    };
  }
  function updateState(updatingManager) {
    if (disableUpdate == null ? void 0 : disableUpdate()) {
      return;
    }
    const manager = updatingManager ?? themeManager;
    const next = manager.getState(props, parentManager);
    const shouldChange = manager.getStateShouldChange(next, isNewTheme ? state : null);
    if (shouldChange) {
      setThemeState(createState);
    } else {
      if (!next && (parentManager == null ? void 0 : parentManager.state.name) !== state.name) {
        setThemeState(createState);
      }
    }
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (0);
//# sourceMappingURL=useTheme.js.map


/***/ }),

/***/ 63114:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var useThemeName_exports = {};
__export(useThemeName_exports, {
  useThemeName: () => useThemeName
});
module.exports = __toCommonJS(useThemeName_exports);
var import_constants = __webpack_require__(14810);
var import_react = __webpack_require__(16689);
var import_config = __webpack_require__(16265);
var import_ThemeManagerContext = __webpack_require__(2856);
function useThemeName(opts) {
  if (import_constants.isRSC) {
    const config = (0, import_config.getConfig)();
    return config.themes[Object.keys(config.themes)[0]];
  }
  const manager = (0, import_react.useContext)(import_ThemeManagerContext.ThemeManagerContext);
  const [name, setName] = (0, import_react.useState)((manager == null ? void 0 : manager.state.name) || "");
  (0, import_constants.useIsomorphicLayoutEffect)(() => {
    if (!manager)
      return;
    setName(manager.state.name);
    return manager.onChangeTheme((next, manager2) => {
      const name2 = (opts == null ? void 0 : opts.parent) ? manager2.state.parentName || next : next;
      if (!name2)
        return;
      setName(name2);
    });
  }, [manager == null ? void 0 : manager.state.name]);
  return name;
}
// Annotate the CommonJS export names for ESM import in node:
0 && (0);
//# sourceMappingURL=useThemeName.js.map


/***/ }),

/***/ 17187:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __reExport = (target, mod, secondTarget) => (__copyProps(target, mod, "default"), secondTarget && __copyProps(secondTarget, mod, "default"));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var src_exports = {};
__export(src_exports, {
  configureMedia: () => import_useMedia.configureMedia,
  getConfig: () => import_config.getConfig,
  getMedia: () => import_useMedia.getMedia,
  getThemes: () => import_config.getThemes,
  getTokens: () => import_config.getTokens,
  mediaObjectToString: () => import_useMedia.mediaObjectToString,
  mediaQueryConfig: () => import_useMedia.mediaQueryConfig,
  mediaState: () => import_useMedia.mediaState,
  onConfiguredOnce: () => import_config.onConfiguredOnce,
  useMedia: () => import_useMedia.useMedia,
  useMediaPropsActive: () => import_useMedia.useMediaPropsActive
});
module.exports = __toCommonJS(src_exports);
__reExport(src_exports, __webpack_require__(5656), module.exports);
__reExport(src_exports, __webpack_require__(86932), module.exports);
__reExport(src_exports, __webpack_require__(99414), module.exports);
__reExport(src_exports, __webpack_require__(72705), module.exports);
__reExport(src_exports, __webpack_require__(45502), module.exports);
__reExport(src_exports, __webpack_require__(74274), module.exports);
__reExport(src_exports, __webpack_require__(6019), module.exports);
__reExport(src_exports, __webpack_require__(88957), module.exports);
__reExport(src_exports, __webpack_require__(26596), module.exports);
__reExport(src_exports, __webpack_require__(89459), module.exports);
__reExport(src_exports, __webpack_require__(3791), module.exports);
__reExport(src_exports, __webpack_require__(83094), module.exports);
__reExport(src_exports, __webpack_require__(86077), module.exports);
__reExport(src_exports, __webpack_require__(70753), module.exports);
__reExport(src_exports, __webpack_require__(83013), module.exports);
var import_config = __webpack_require__(16265);
__reExport(src_exports, __webpack_require__(36297), module.exports);
__reExport(src_exports, __webpack_require__(97312), module.exports);
__reExport(src_exports, __webpack_require__(37645), module.exports);
__reExport(src_exports, __webpack_require__(18045), module.exports);
__reExport(src_exports, __webpack_require__(13642), module.exports);
__reExport(src_exports, __webpack_require__(41384), module.exports);
__reExport(src_exports, __webpack_require__(9161), module.exports);
__reExport(src_exports, __webpack_require__(45204), module.exports);
__reExport(src_exports, __webpack_require__(1458), module.exports);
__reExport(src_exports, __webpack_require__(36152), module.exports);
__reExport(src_exports, __webpack_require__(10454), module.exports);
__reExport(src_exports, __webpack_require__(45701), module.exports);
__reExport(src_exports, __webpack_require__(69464), module.exports);
__reExport(src_exports, __webpack_require__(22476), module.exports);
__reExport(src_exports, __webpack_require__(26819), module.exports);
__reExport(src_exports, __webpack_require__(93658), module.exports);
__reExport(src_exports, __webpack_require__(66106), module.exports);
__reExport(src_exports, __webpack_require__(16505), module.exports);
__reExport(src_exports, __webpack_require__(55159), module.exports);
__reExport(src_exports, __webpack_require__(25230), module.exports);
var import_useMedia = __webpack_require__(85030);
__reExport(src_exports, __webpack_require__(69953), module.exports);
__reExport(src_exports, __webpack_require__(63114), module.exports);
__reExport(src_exports, __webpack_require__(87580), module.exports);
__reExport(src_exports, __webpack_require__(53386), module.exports);
__reExport(src_exports, __webpack_require__(12897), module.exports);
__reExport(src_exports, __webpack_require__(30926), module.exports);
__reExport(src_exports, __webpack_require__(34632), module.exports);
__reExport(src_exports, __webpack_require__(11195), module.exports);
__reExport(src_exports, __webpack_require__(49798), module.exports);
__reExport(src_exports, __webpack_require__(15795), module.exports);
__reExport(src_exports, __webpack_require__(74065), module.exports);
__reExport(src_exports, __webpack_require__(20770), module.exports);
__reExport(src_exports, __webpack_require__(52707), module.exports);
__reExport(src_exports, __webpack_require__(36527), module.exports);
__reExport(src_exports, __webpack_require__(90951), module.exports);
__reExport(src_exports, __webpack_require__(95915), module.exports);
__reExport(src_exports, __webpack_require__(37513), module.exports);
__reExport(src_exports, __webpack_require__(14810), module.exports);
__reExport(src_exports, __webpack_require__(25142), module.exports);
// Annotate the CommonJS export names for ESM import in node:
0 && (0);
//# sourceMappingURL=index.js.map


/***/ }),

/***/ 89459:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var insertFont_exports = {};
__export(insertFont_exports, {
  insertFont: () => insertFont,
  parseFont: () => parseFont,
  registerFontVariables: () => registerFontVariables
});
module.exports = __toCommonJS(insertFont_exports);
var import_config = __webpack_require__(16265);
var import_createFont = __webpack_require__(74274);
var import_createVariables = __webpack_require__(26596);
var import_registerCSSVariable = __webpack_require__(20299);
function insertFont(name, fontIn) {
  const font = (0, import_createFont.createFont)(fontIn);
  const tokened = (0, import_createVariables.createVariables)(font, name);
  const parsed = parseFont(tokened);
  if ( true && typeof document !== "undefined") {
    const fontVars = registerFontVariables(parsed);
    const style = document.createElement("style");
    style.innerText = `:root .font_${name} {${fontVars.join(";")}}`;
    style.setAttribute("data-tamagui-font", name);
    document.head.appendChild(style);
  }
  (0, import_config.setConfigFont)(name, tokened, parsed);
  return parsed;
}
function parseFont(definition) {
  var _a;
  const parsed = {};
  for (const attrKey in definition) {
    const attr = definition[attrKey];
    if (attrKey === "family" || attrKey === "face") {
      parsed[attrKey] = attr;
      continue;
    }
    parsed[attrKey] = {};
    for (const key in attr) {
      let val = attr[key];
      if (((_a = val.val) == null ? void 0 : _a[0]) === "$") {
        val = val.val;
      }
      parsed[attrKey][`$${key}`] = val;
    }
  }
  return parsed;
}
function registerFontVariables(parsedFont) {
  const response = [];
  for (const fkey in parsedFont) {
    if (fkey === "face")
      continue;
    if (fkey === "family") {
      const val = parsedFont[fkey];
      (0, import_registerCSSVariable.registerCSSVariable)(val);
      response.push((0, import_registerCSSVariable.variableToCSS)(val));
    } else {
      for (const fskey in parsedFont[fkey]) {
        const fval = parsedFont[fkey][fskey];
        if (typeof fval === "string") {
        } else {
          const val = parsedFont[fkey][fskey];
          (0, import_registerCSSVariable.registerCSSVariable)(val);
          response.push((0, import_registerCSSVariable.variableToCSS)(val));
        }
      }
    }
  }
  return response;
}
// Annotate the CommonJS export names for ESM import in node:
0 && (0);
//# sourceMappingURL=insertFont.js.map


/***/ }),

/***/ 25142:
/***/ ((module) => {

"use strict";

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var setupHooks_exports = {};
__export(setupHooks_exports, {
  hooks: () => hooks,
  setupHooks: () => setupHooks
});
module.exports = __toCommonJS(setupHooks_exports);
const hooks = {};
function setupHooks(next) {
  Object.assign(hooks, next);
}
// Annotate the CommonJS export names for ESM import in node:
0 && (0);
//# sourceMappingURL=setupHooks.js.map


/***/ }),

/***/ 83013:
/***/ ((module) => {

"use strict";

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var setupReactNative_exports = {};
__export(setupReactNative_exports, {
  ReactNativeStaticConfigs: () => ReactNativeStaticConfigs,
  getReactNativeConfig: () => getReactNativeConfig,
  setupReactNative: () => setupReactNative
});
module.exports = __toCommonJS(setupReactNative_exports);
const ReactNativeStaticConfigs = /* @__PURE__ */ new WeakMap();
function getReactNativeConfig(Component) {
  return ReactNativeStaticConfigs.get(Component);
}
function setupReactNative(rnExports) {
  for (const key in rnExports) {
    if (key[0].toLowerCase() === key[0])
      continue;
    const val = rnExports[key];
    if (val && typeof val === "object") {
      ReactNativeStaticConfigs.set(val, {
        isReactNative: true,
        isText: key === "Text" || key === "TextInput",
        isInput: key === "TextInput" || key === "TextArea",
        inlineProps: key === "Image" ? /* @__PURE__ */ new Set(["src", "width", "height"]) : void 0
      });
    }
  }
}
// Annotate the CommonJS export names for ESM import in node:
0 && (0);
//# sourceMappingURL=setupReactNative.js.map


/***/ }),

/***/ 86077:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var styled_exports = {};
__export(styled_exports, {
  styled: () => styled
});
module.exports = __toCommonJS(styled_exports);
var import_helpers = __webpack_require__(37513);
var import_createComponent = __webpack_require__(86932);
var import_setupReactNative = __webpack_require__(83013);
function styled(Component, options, staticExtractionOptions) {
  if (false) {}
  const parentStaticConfig = "staticConfig" in Component ? Component.staticConfig : null;
  const isTamagui = !!parentStaticConfig;
  const isReactNative = Boolean(
    import_setupReactNative.ReactNativeStaticConfigs.has(Component) || (staticExtractionOptions == null ? void 0 : staticExtractionOptions.isReactNative) || import_setupReactNative.ReactNativeStaticConfigs.has(parentStaticConfig == null ? void 0 : parentStaticConfig.Component) || (parentStaticConfig == null ? void 0 : parentStaticConfig.isReactNative)
  );
  const staticConfigProps = (() => {
    if (options) {
      const {
        variants,
        name,
        defaultVariants,
        acceptsClassName: acceptsClassNameProp,
        ...defaultProps
      } = options;
      if (defaultVariants) {
        Object.assign(defaultProps, defaultVariants);
      }
      const Comp = isReactNative ? (parentStaticConfig == null ? void 0 : parentStaticConfig.Component) || Component : Component;
      const nativeConf = isReactNative && import_setupReactNative.ReactNativeStaticConfigs.get(Comp) || null;
      const isText = Boolean(
        (staticExtractionOptions == null ? void 0 : staticExtractionOptions.isText) || (parentStaticConfig == null ? void 0 : parentStaticConfig.isText)
      );
      const acceptsClassName = acceptsClassNameProp ?? (isTamagui || isReactNative);
      const conf = {
        ...staticExtractionOptions,
        ...!isTamagui && {
          Component: Comp
        },
        // this type gets messed up by options?: Partial<GetProps<ParentComponent>> above
        // take away the Partial<> and it's fine
        variants,
        defaultProps,
        defaultVariants,
        componentName: name,
        isReactNative,
        isText,
        acceptsClassName,
        ...nativeConf
      };
      if (defaultProps.children || !acceptsClassName) {
        conf.neverFlatten = true;
      }
      return conf;
    }
  })();
  const component = (0, import_createComponent.createComponent)(staticConfigProps || {}, Component);
  return component;
}
// Annotate the CommonJS export names for ESM import in node:
0 && (0);
//# sourceMappingURL=styled.js.map


/***/ }),

/***/ 70753:
/***/ ((module) => {

"use strict";

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var types_exports = {};
module.exports = __toCommonJS(types_exports);
//# sourceMappingURL=types.js.map


/***/ }),

/***/ 83094:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var updateTheme_exports = {};
__export(updateTheme_exports, {
  updateTheme: () => updateTheme
});
module.exports = __toCommonJS(updateTheme_exports);
var import_addTheme = __webpack_require__(3791);
var import_useTheme = __webpack_require__(69953);
function updateTheme({
  name,
  theme
}) {
  const next = (0, import_addTheme.addTheme)({ name, theme, insertCSS: true, update: true });
  if (false) {}
  return next;
}
// Annotate the CommonJS export names for ESM import in node:
0 && (0);
//# sourceMappingURL=updateTheme.js.map


/***/ }),

/***/ 74065:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var FontLanguage_exports = {};
__export(FontLanguage_exports, {
  FontLanguage: () => FontLanguage
});
module.exports = __toCommonJS(FontLanguage_exports);
var import_jsx_runtime = __webpack_require__(85893);
const FontLanguage = ({ children, ...props }) => {
  return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
    "div",
    {
      style: {
        display: "contents"
      },
      className: Object.entries(props).map(([name, language]) => `t_lang-${name}-${language}`).join(" "),
      children
    }
  );
};
// Annotate the CommonJS export names for ESM import in node:
0 && (0);
//# sourceMappingURL=FontLanguage.js.map


/***/ }),

/***/ 12897:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var Slot_exports = {};
__export(Slot_exports, {
  Slot: () => Slot,
  Slottable: () => Slottable,
  mergeEvent: () => mergeEvent
});
module.exports = __toCommonJS(Slot_exports);
var import_jsx_runtime = __webpack_require__(85893);
var import_compose_refs = __webpack_require__(95915);
var import_constants = __webpack_require__(14810);
var import_react = __webpack_require__(16689);
const Slot = (0, import_react.forwardRef)(function Slot2(props, forwardedRef) {
  const { children, ...slotProps } = props;
  if ((0, import_react.isValidElement)(children)) {
    const childProps = {
      ...mergeSlotProps(children, slotProps),
      ref: (0, import_compose_refs.composeRefs)(forwardedRef, children.ref)
    };
    return (0, import_react.cloneElement)(children, childProps);
  }
  return import_react.Children.count(children) > 1 ? import_react.Children.only(null) : null;
});
const Slottable = ({ children }) => {
  return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, { children });
};
const pressMap = import_constants.isWeb ? {
  onPress: "onClick",
  onPressOut: "onMouseUp",
  onPressIn: "onMouseDown"
} : {};
function mergeSlotProps(child, slotProps) {
  const childProps = child.props;
  const overrideProps = { ...childProps };
  const isHTMLChild = typeof child.type === "string";
  if (isHTMLChild) {
    for (const key in pressMap) {
      if (key in slotProps) {
        slotProps[pressMap[key]] = slotProps[key];
        delete slotProps[key];
      }
    }
  }
  for (let propName in childProps) {
    const slotPropValue = slotProps[propName];
    const childPropValue = childProps[propName];
    if (isHTMLChild && pressMap[propName]) {
      propName = pressMap[propName];
      delete overrideProps[propName];
    }
    const isHandler = handleRegex.test(propName);
    if (isHandler) {
      overrideProps[propName] = mergeEvent(childPropValue, slotPropValue);
    } else if (propName === "style") {
      overrideProps[propName] = { ...slotPropValue, ...childPropValue };
    } else if (propName === "className") {
      overrideProps[propName] = [slotPropValue, childPropValue].filter(Boolean).join(" ");
    }
  }
  return { ...slotProps, ...overrideProps };
}
const handleRegex = /^on[A-Z]/;
function mergeEvent(a, b) {
  return (...args) => {
    a == null ? void 0 : a(...args);
    b == null ? void 0 : b(...args);
  };
}
// Annotate the CommonJS export names for ESM import in node:
0 && (0);
//# sourceMappingURL=Slot.js.map


/***/ }),

/***/ 30926:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var Stack_exports = {};
__export(Stack_exports, {
  Stack: () => Stack
});
module.exports = __toCommonJS(Stack_exports);
var import_constants = __webpack_require__(36297);
var import_createComponent = __webpack_require__(86932);
const Stack = (0, import_createComponent.createComponent)({
  componentName: "Stack",
  acceptsClassName: true,
  defaultProps: {
    ...import_constants.stackDefaultStyles,
    flexDirection: "column"
  }
});
// Annotate the CommonJS export names for ESM import in node:
0 && (0);
//# sourceMappingURL=Stack.js.map


/***/ }),

/***/ 20770:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var TamaguiProvider_exports = {};
__export(TamaguiProvider_exports, {
  TamaguiProvider: () => TamaguiProvider
});
module.exports = __toCommonJS(TamaguiProvider_exports);
var import_jsx_runtime = __webpack_require__(85893);
var import_constants = __webpack_require__(14810);
var React = __toESM(__webpack_require__(16689));
var import_ButtonNestingContext = __webpack_require__(16505);
var import_TextAncestorContext = __webpack_require__(11195);
var import_useMedia = __webpack_require__(85030);
var import_ThemeProvider = __webpack_require__(15795);
function TamaguiProvider({
  children,
  disableInjectCSS,
  config,
  ...themePropsProvider
}) {
  if (import_constants.isRSC) {
    return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
      "span",
      {
        style: { display: "contents" },
        className: `t_${Object.keys(config.themes)[0] || "light"}`,
        children
      }
    );
  }
  if (!(import_constants.isWeb && import_constants.isServer)) {
    (0, import_useMedia.useMediaListeners)(config);
  }
  if (import_constants.isClient) {
    React.useLayoutEffect(() => {
      if (document.documentElement.classList.contains("t_unmounted")) {
        document.documentElement.classList.remove("t_unmounted");
      }
      if (disableInjectCSS)
        return;
      const style = document.createElement("style");
      style.appendChild(document.createTextNode(config.getCSS()));
      document.head.appendChild(style);
      return () => {
        document.head.removeChild(style);
      };
    }, [config, disableInjectCSS]);
  }
  return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(import_ButtonNestingContext.ButtonNestingContext.Provider, { value: false, children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(import_TextAncestorContext.TextAncestorContext.Provider, { value: false, children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
    import_ThemeProvider.ThemeProvider,
    {
      themeClassNameOnRoot: config.themeClassNameOnRoot,
      disableRootThemeClass: config.disableRootThemeClass,
      ...themePropsProvider,
      defaultTheme: themePropsProvider.defaultTheme ?? Object.keys(config.themes)[0],
      children
    }
  ) }) });
}
// Annotate the CommonJS export names for ESM import in node:
0 && (0);
//# sourceMappingURL=TamaguiProvider.js.map


/***/ }),

/***/ 34632:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var Text_exports = {};
__export(Text_exports, {
  Text: () => Text
});
module.exports = __toCommonJS(Text_exports);
var import_constants = __webpack_require__(14810);
var import_helpers = __webpack_require__(37513);
var import_createComponent = __webpack_require__(86932);
const ellipseStyle = {
  maxWidth: "100%",
  overflow: "hidden",
  textOverflow: "ellipsis",
  whiteSpace: "nowrap"
};
const Text = (0, import_createComponent.createComponent)({
  componentName: "Text",
  acceptsClassName: true,
  isText: true,
  defaultProps: {
    // @ts-ignore
    display: "flex",
    fontFamily: "System",
    ...import_constants.isWeb ? {
      display: "inline",
      boxSizing: "border-box",
      wordWrap: "break-word",
      margin: 0
    } : {
      suppressHighlighting: true
    }
  },
  inlineWhenUnflattened: /* @__PURE__ */ new Set(["fontFamily"]),
  variants: {
    ...import_constants.isWeb && {
      numberOfLines: {
        1: ellipseStyle,
        ":number": (numberOfLines) => numberOfLines >= 1 ? {
          WebkitLineClamp: numberOfLines,
          WebkitBoxOrient: "vertical",
          display: "-webkit-box",
          overflow: "hidden"
        } : null
      }
    },
    // ??
    ellipsizeMode: {
      "...": () => null
    },
    selectable: {
      true: {
        userSelect: "text",
        cursor: "text"
      },
      false: {
        userSelect: "none",
        cursor: "default"
      }
    },
    ellipse: {
      true: import_constants.isWeb ? ellipseStyle : {
        numberOfLines: 1,
        lineBreakMode: "clip"
      }
    }
  },
  deoptProps: new Set(import_constants.isWeb ? [] : ["ellipse"]),
  validStyles: {
    ...import_helpers.validStyles,
    ...import_helpers.stylePropsTextOnly
  }
});
// Annotate the CommonJS export names for ESM import in node:
0 && (0);
//# sourceMappingURL=Text.js.map


/***/ }),

/***/ 49798:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var Theme_exports = {};
__export(Theme_exports, {
  Theme: () => Theme,
  useThemedChildren: () => useThemedChildren
});
module.exports = __toCommonJS(Theme_exports);
var import_jsx_runtime = __webpack_require__(85893);
var import_constants = __webpack_require__(14810);
var import_react = __webpack_require__(16689);
var import_createVariable = __webpack_require__(88957);
var import_ThemeManagerContext = __webpack_require__(2856);
var import_useServerHooks = __webpack_require__(14425);
var import_useTheme = __webpack_require__(69953);
function Theme(props) {
  if (props.disable)
    return props.children;
  const isRoot = !!props["_isRoot"];
  const themeState = (0, import_useTheme.useChangeThemeEffect)(props, isRoot);
  const children = props["data-themeable"] ? import_react.Children.map(
    props.children,
    (child) => (0, import_react.cloneElement)(child, { ["data-themeable"]: true })
  ) : props.children;
  return useThemedChildren(themeState, children, props, isRoot);
}
function useThemedChildren(themeState, children, options, isRoot = false) {
  const { themeManager, isNewTheme, className, theme } = themeState;
  const { shallow, forceClassName } = options;
  const hasEverThemed = (0, import_useServerHooks.useServerRef)(false);
  if (isNewTheme) {
    hasEverThemed.current = true;
  }
  if (isNewTheme || hasEverThemed.current || forceClassName || isRoot) {
    let next = import_react.Children.toArray(children);
    if (shallow && themeManager) {
      next = next.map((child) => {
        return (0, import_react.isValidElement)(child) ? (0, import_react.cloneElement)(
          child,
          void 0,
          /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Theme, { name: themeManager.state.parentName, children: child.props.children })
        ) : child;
      });
    }
    const wrapped = /* @__PURE__ */ (0, import_jsx_runtime.jsx)(import_ThemeManagerContext.ThemeManagerContext.Provider, { value: themeManager, children: next });
    if (forceClassName === false) {
      return wrapped;
    }
    if (import_constants.isWeb && !options.passPropsToChildren) {
      const themeColor = theme && isNewTheme ? (0, import_createVariable.variableToString)(theme.color) : "";
      const colorStyle = {
        color: themeColor
      };
      return /* @__PURE__ */ (0, import_jsx_runtime.jsx)("span", { className: `${className || ""} _dsp_contents`, style: colorStyle, children: wrapped });
    }
    return wrapped;
  }
  return children;
}
// Annotate the CommonJS export names for ESM import in node:
0 && (0);
//# sourceMappingURL=Theme.js.map


/***/ }),

/***/ 15795:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var ThemeProvider_exports = {};
__export(ThemeProvider_exports, {
  ThemeProvider: () => ThemeProvider,
  ThemeProviderRootContext: () => ThemeProviderRootContext
});
module.exports = __toCommonJS(ThemeProvider_exports);
var import_jsx_runtime = __webpack_require__(85893);
var import_constants = __webpack_require__(14810);
var import_react = __webpack_require__(16689);
var import_constants2 = __webpack_require__(36297);
var import_Theme = __webpack_require__(49798);
const ThemeProviderRootContext = (0, import_react.createContext)(null);
const ThemeProvider = (props) => {
  if (import_constants.isClient) {
    (0, import_react.useLayoutEffect)(() => {
      if (props.disableRootThemeClass)
        return;
      const cn = `${import_constants2.THEME_CLASSNAME_PREFIX}${props.defaultTheme}`;
      const target = props.themeClassNameOnRoot ? document.documentElement : document.body;
      target.classList.add(cn);
      return () => {
        target.classList.remove(cn);
      };
    }, [props.defaultTheme, props.disableRootThemeClass, props.themeClassNameOnRoot]);
  }
  return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
    ThemeProviderRootContext.Provider,
    {
      value: (0, import_react.useMemo)(() => {
        return {
          defaultTheme: props.defaultTheme
        };
      }, []),
      children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
        import_Theme.Theme,
        {
          className: props.className,
          name: props.defaultTheme,
          forceClassName: props.disableRootThemeClass ? false : void 0,
          _isRoot: true,
          children: props.children
        }
      )
    }
  );
};
// Annotate the CommonJS export names for ESM import in node:
0 && (0);
//# sourceMappingURL=ThemeProvider.js.map


/***/ }),

/***/ 15517:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({"src":"/_next/static/media/back-icon-mask.4bd551af.png","height":85,"width":50,"blurDataURL":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAICAMAAAAGL8UJAAAAElBMVEXY2NjY2NjY2NjY2NjY2NjY2NjwzJAVAAAABnRSTlP+8AEzQTUoSqluAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAIElEQVR4nGNgYmJmZGAAEwwsIIIBTEDZEHGoGiYmVkYABJwANDa+H0QAAAAASUVORK5CYII=","blurWidth":5,"blurHeight":8});

/***/ }),

/***/ 32383:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({"src":"/_next/static/media/back-icon.9c543624.png","height":96,"width":96,"blurDataURL":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAICAMAAADz0U65AAAAFVBMVEUAAAAAAABMaXEAAAAAAAAAAAAAAADY5gdVAAAAB3RSTlMCQABrUeGc8ibYWgAAAAlwSFlzAAALEwAACxMBAJqcGAAAACpJREFUeJxFi0EOADAQAZnd9v9PbhykLmQgEJEQ65jwDRM+sxPW8KuOe38R9wB/5nLv8AAAAABJRU5ErkJggg==","blurWidth":8,"blurHeight":8});

/***/ }),

/***/ 57182:
/***/ ((__unused_webpack_module, exports) => {

"use strict";
var __webpack_unused_export__;
/**
 * Hoists a name from a module or promised module.
 *
 * @param module the module to hoist the name from
 * @param name the name to hoist
 * @returns the value on the module (or promised module)
 */ 
__webpack_unused_export__ = ({
    value: true
});
Object.defineProperty(exports, "l", ({
    enumerable: true,
    get: function() {
        return hoist;
    }
}));
function hoist(module, name) {
    // If the name is available in the module, return it.
    if (name in module) {
        return module[name];
    }
    // If a property called `then` exists, assume it's a promise and
    // return a promise that resolves to the name.
    if ("then" in module && typeof module.then === "function") {
        return module.then((mod)=>hoist(mod, name));
    }
    // If we're trying to hoise the default export, and the module is a function,
    // return the module itself.
    if (typeof module === "function" && name === "default") {
        return module;
    }
    // Otherwise, return undefined.
    return undefined;
}

//# sourceMappingURL=helpers.js.map

/***/ }),

/***/ 64901:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   e: () => (/* binding */ createInterFont)
/* harmony export */ });
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(86872);
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_tamagui_core__WEBPACK_IMPORTED_MODULE_0__);

const createInterFont = (font = {}, { sizeLineHeight = (size)=>size + 10, sizeSize = (size)=>size * 1 } = {})=>{
    const size = Object.fromEntries(Object.entries({
        ...defaultSizes,
        ...font.size
    }).map(([k, v])=>[
            k,
            sizeSize(+v)
        ]));
    return (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_0__.createFont)({
        family: _tamagui_core__WEBPACK_IMPORTED_MODULE_0__.isWeb ? 'Inter, -apple-system, system-ui, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif' : "Inter",
        lineHeight: Object.fromEntries(Object.entries(size).map(([k, v])=>[
                k,
                sizeLineHeight((0,_tamagui_core__WEBPACK_IMPORTED_MODULE_0__.getVariableValue)(v))
            ])),
        weight: {
            4: "300"
        },
        letterSpacing: {
            4: 0
        },
        ...font,
        size
    });
};
const defaultSizes = {
    1: 11,
    2: 12,
    3: 13,
    4: 14,
    true: 14,
    5: 16,
    6: 18,
    7: 20,
    8: 23,
    9: 30,
    10: 46,
    11: 55,
    12: 62,
    13: 72,
    14: 92,
    15: 114,
    16: 134
};
 //# sourceMappingURL=index.js.map


/***/ }),

/***/ 59297:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   m: () => (/* binding */ createSilkscreenFont)
/* harmony export */ });
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(86872);
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_tamagui_core__WEBPACK_IMPORTED_MODULE_0__);

const createSilkscreenFont = (font = {})=>{
    return (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_0__.createFont)({
        family: _tamagui_core__WEBPACK_IMPORTED_MODULE_0__.isWeb ? "Silkscreen, Fira Code, Monaco, Consolas, Ubuntu Mono, monospace" : "Silkscreen",
        size,
        lineHeight: Object.fromEntries(Object.entries(size).map(([k, v])=>[
                k,
                v * 1.2 + 6
            ])),
        weight: {
            4: "300"
        },
        letterSpacing: {
            4: 1,
            5: 3,
            6: 3,
            9: -2,
            10: -3,
            12: -4
        },
        ...font
    });
};
const size = {
    1: 11,
    2: 12,
    3: 13,
    4: 14,
    5: 15,
    6: 16,
    7: 18,
    8: 21,
    9: 28,
    10: 42,
    11: 52,
    12: 62,
    13: 72,
    14: 92,
    15: 114,
    16: 124
};
 //# sourceMappingURL=index.js.map


/***/ }),

/***/ 31087:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   q: () => (/* binding */ shorthands)
/* harmony export */ });
const shorthands = {
    // web-only
    ussel: "userSelect",
    cur: "cursor",
    // tamagui
    pe: "pointerEvents",
    // text
    col: "color",
    ff: "fontFamily",
    fos: "fontSize",
    fost: "fontStyle",
    fow: "fontWeight",
    ls: "letterSpacing",
    lh: "lineHeight",
    ta: "textAlign",
    tt: "textTransform",
    ww: "wordWrap",
    // view
    ac: "alignContent",
    ai: "alignItems",
    als: "alignSelf",
    b: "bottom",
    bc: "backgroundColor",
    bg: "backgroundColor",
    bbc: "borderBottomColor",
    bblr: "borderBottomLeftRadius",
    bbrr: "borderBottomRightRadius",
    bbw: "borderBottomWidth",
    blc: "borderLeftColor",
    blw: "borderLeftWidth",
    boc: "borderColor",
    br: "borderRadius",
    bs: "borderStyle",
    brw: "borderRightWidth",
    brc: "borderRightColor",
    btc: "borderTopColor",
    btlr: "borderTopLeftRadius",
    btrr: "borderTopRightRadius",
    btw: "borderTopWidth",
    bw: "borderWidth",
    dsp: "display",
    f: "flex",
    fb: "flexBasis",
    fd: "flexDirection",
    fg: "flexGrow",
    fs: "flexShrink",
    fw: "flexWrap",
    h: "height",
    jc: "justifyContent",
    l: "left",
    m: "margin",
    mah: "maxHeight",
    maw: "maxWidth",
    mb: "marginBottom",
    mih: "minHeight",
    miw: "minWidth",
    ml: "marginLeft",
    mr: "marginRight",
    mt: "marginTop",
    mx: "marginHorizontal",
    my: "marginVertical",
    o: "opacity",
    ov: "overflow",
    p: "padding",
    pb: "paddingBottom",
    pl: "paddingLeft",
    pos: "position",
    pr: "paddingRight",
    pt: "paddingTop",
    px: "paddingHorizontal",
    py: "paddingVertical",
    r: "right",
    shac: "shadowColor",
    shar: "shadowRadius",
    shof: "shadowOffset",
    shop: "shadowOpacity",
    t: "top",
    w: "width",
    zi: "zIndex"
};
shorthands["bls"] = "borderLeftStyle";
shorthands["brs"] = "borderRightStyle";
shorthands["bts"] = "borderTopStyle";
shorthands["bbs"] = "borderBottomStyle";
shorthands["bxs"] = "boxSizing";
shorthands["bxsh"] = "boxShadow";
shorthands["ox"] = "overflowX";
shorthands["oy"] = "overflowY";
 //# sourceMappingURL=index.js.map


/***/ }),

/***/ 75280:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   _: () => (/* binding */ createTamagui)
/* harmony export */ });
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(86872);
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_tamagui_core__WEBPACK_IMPORTED_MODULE_0__);

const createTamagui =  true ? _tamagui_core__WEBPACK_IMPORTED_MODULE_0__.createTamagui : 0;
 //# sourceMappingURL=createTamagui.js.map


/***/ }),

/***/ 9012:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $: () => (/* binding */ Spinner)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(85893);
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(86872);
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_tamagui_core__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _tamagui_stacks__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(42023);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(16689);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var react_native__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(83849);





const Spinner = _tamagui_stacks__WEBPACK_IMPORTED_MODULE_2__/* .YStack */ .FA.extractable((0,_tamagui_core__WEBPACK_IMPORTED_MODULE_3__.themeable)(/*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.forwardRef((props, ref)=>{
    const { size, color: colorProp, ...stackProps } = props;
    const theme = (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_3__.useTheme)();
    let color = colorProp;
    if (color && color[0] === "$") {
        color = (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_3__.variableToString)(theme[color]);
    }
    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_tamagui_stacks__WEBPACK_IMPORTED_MODULE_2__/* .YStack */ .FA, {
        ref,
        ...stackProps,
        children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(react_native__WEBPACK_IMPORTED_MODULE_4__.ActivityIndicator, {
            size,
            color
        })
    });
}), {
    componentName: "Spinner"
}));
 //# sourceMappingURL=Spinner.js.map


/***/ }),

/***/ 8913:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   r: () => (/* binding */ TamaguiProvider)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(85893);
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(86872);
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_tamagui_core__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _tamagui_portal__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(38696);
/* harmony import */ var _tamagui_portal__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_tamagui_portal__WEBPACK_IMPORTED_MODULE_1__);



const TamaguiProvider = _tamagui_core__WEBPACK_IMPORTED_MODULE_2__.isRSC ? _tamagui_core__WEBPACK_IMPORTED_MODULE_2__.TamaguiProvider : ({ children, ...props })=>{
    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_tamagui_core__WEBPACK_IMPORTED_MODULE_2__.TamaguiProvider, {
        ...props,
        children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_tamagui_portal__WEBPACK_IMPORTED_MODULE_1__.PortalProvider, {
            shouldAddRootHost: true,
            children
        })
    });
};
 //# sourceMappingURL=TamaguiProvider.js.map


/***/ }),

/***/ 18901:
/***/ ((module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
0 && (0);
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    DOMAttributeNames: function() {
        return DOMAttributeNames;
    },
    isEqualNode: function() {
        return isEqualNode;
    },
    default: function() {
        return initHeadManager;
    }
});
const DOMAttributeNames = {
    acceptCharset: "accept-charset",
    className: "class",
    htmlFor: "for",
    httpEquiv: "http-equiv",
    noModule: "noModule"
};
function reactElementToDOM(param) {
    let { type, props } = param;
    const el = document.createElement(type);
    for(const p in props){
        if (!props.hasOwnProperty(p)) continue;
        if (p === "children" || p === "dangerouslySetInnerHTML") continue;
        // we don't render undefined props to the DOM
        if (props[p] === undefined) continue;
        const attr = DOMAttributeNames[p] || p.toLowerCase();
        if (type === "script" && (attr === "async" || attr === "defer" || attr === "noModule")) {
            el[attr] = !!props[p];
        } else {
            el.setAttribute(attr, props[p]);
        }
    }
    const { children, dangerouslySetInnerHTML } = props;
    if (dangerouslySetInnerHTML) {
        el.innerHTML = dangerouslySetInnerHTML.__html || "";
    } else if (children) {
        el.textContent = typeof children === "string" ? children : Array.isArray(children) ? children.join("") : "";
    }
    return el;
}
function isEqualNode(oldTag, newTag) {
    if (oldTag instanceof HTMLElement && newTag instanceof HTMLElement) {
        const nonce = newTag.getAttribute("nonce");
        // Only strip the nonce if `oldTag` has had it stripped. An element's nonce attribute will not
        // be stripped if there is no content security policy response header that includes a nonce.
        if (nonce && !oldTag.getAttribute("nonce")) {
            const cloneTag = newTag.cloneNode(true);
            cloneTag.setAttribute("nonce", "");
            cloneTag.nonce = nonce;
            return nonce === oldTag.nonce && oldTag.isEqualNode(cloneTag);
        }
    }
    return oldTag.isEqualNode(newTag);
}
let updateElements;
if (false) {} else {
    updateElements = (type, components)=>{
        const headEl = document.getElementsByTagName("head")[0];
        const headCountEl = headEl.querySelector("meta[name=next-head-count]");
        if (false) {}
        const headCount = Number(headCountEl.content);
        const oldTags = [];
        for(let i = 0, j = headCountEl.previousElementSibling; i < headCount; i++, j = (j == null ? void 0 : j.previousElementSibling) || null){
            var _j_tagName;
            if ((j == null ? void 0 : (_j_tagName = j.tagName) == null ? void 0 : _j_tagName.toLowerCase()) === type) {
                oldTags.push(j);
            }
        }
        const newTags = components.map(reactElementToDOM).filter((newTag)=>{
            for(let k = 0, len = oldTags.length; k < len; k++){
                const oldTag = oldTags[k];
                if (isEqualNode(oldTag, newTag)) {
                    oldTags.splice(k, 1);
                    return false;
                }
            }
            return true;
        });
        oldTags.forEach((t)=>{
            var _t_parentNode;
            return (_t_parentNode = t.parentNode) == null ? void 0 : _t_parentNode.removeChild(t);
        });
        newTags.forEach((t)=>headEl.insertBefore(t, headCountEl));
        headCountEl.content = (headCount - oldTags.length + newTags.length).toString();
    };
}
function initHeadManager() {
    return {
        mountedInstances: new Set(),
        updateHead: (head)=>{
            const tags = {};
            head.forEach((h)=>{
                if (// it won't be inlined. In this case revert to the original behavior
                h.type === "link" && h.props["data-optimized-fonts"]) {
                    if (document.querySelector('style[data-href="' + h.props["data-href"] + '"]')) {
                        return;
                    } else {
                        h.props.href = h.props["data-href"];
                        h.props["data-href"] = undefined;
                    }
                }
                const components = tags[h.type] || [];
                components.push(h);
                tags[h.type] = components;
            });
            const titleComponent = tags.title ? tags.title[0] : null;
            let title = "";
            if (titleComponent) {
                const { children } = titleComponent.props;
                title = typeof children === "string" ? children : Array.isArray(children) ? children.join("") : "";
            }
            if (title !== document.title) document.title = title;
            [
                "meta",
                "base",
                "link",
                "style",
                "script"
            ].forEach((type)=>{
                updateElements(type, tags[type] || []);
            });
        }
    };
}
if ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {
    Object.defineProperty(exports.default, "__esModule", {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=head-manager.js.map


/***/ }),

/***/ 60773:
/***/ ((module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
0 && (0);
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    requestIdleCallback: function() {
        return requestIdleCallback;
    },
    cancelIdleCallback: function() {
        return cancelIdleCallback;
    }
});
const requestIdleCallback = typeof self !== "undefined" && self.requestIdleCallback && self.requestIdleCallback.bind(window) || function(cb) {
    let start = Date.now();
    return self.setTimeout(function() {
        cb({
            didTimeout: false,
            timeRemaining: function() {
                return Math.max(0, 50 - (Date.now() - start));
            }
        });
    }, 1);
};
const cancelIdleCallback = typeof self !== "undefined" && self.cancelIdleCallback && self.cancelIdleCallback.bind(window) || function(id) {
    return clearTimeout(id);
};
if ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {
    Object.defineProperty(exports.default, "__esModule", {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=request-idle-callback.js.map


/***/ }),

/***/ 92205:
/***/ ((module, exports, __webpack_require__) => {

"use strict";
/* __next_internal_client_entry_do_not_use__  cjs */ 
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
0 && (0);
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    handleClientScriptLoad: function() {
        return handleClientScriptLoad;
    },
    initScriptLoader: function() {
        return initScriptLoader;
    },
    default: function() {
        return _default;
    }
});
const _interop_require_default = __webpack_require__(50167);
const _interop_require_wildcard = __webpack_require__(28760);
const _reactdom = /*#__PURE__*/ _interop_require_default._(__webpack_require__(66405));
const _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(16689));
const _headmanagercontext = __webpack_require__(92796);
const _headmanager = __webpack_require__(18901);
const _requestidlecallback = __webpack_require__(60773);
const ScriptCache = new Map();
const LoadCache = new Set();
const ignoreProps = [
    "onLoad",
    "onReady",
    "dangerouslySetInnerHTML",
    "children",
    "onError",
    "strategy",
    "stylesheets"
];
const insertStylesheets = (stylesheets)=>{
    // Case 1: Styles for afterInteractive/lazyOnload with appDir injected via handleClientScriptLoad
    //
    // Using ReactDOM.preinit to feature detect appDir and inject styles
    // Stylesheets might have already been loaded if initialized with Script component
    // Re-inject styles here to handle scripts loaded via handleClientScriptLoad
    // ReactDOM.preinit handles dedup and ensures the styles are loaded only once
    if (_reactdom.default.preinit) {
        stylesheets.forEach((stylesheet)=>{
            _reactdom.default.preinit(stylesheet, {
                as: "style"
            });
        });
        return;
    }
    // Case 2: Styles for afterInteractive/lazyOnload with pages injected via handleClientScriptLoad
    //
    // We use this function to load styles when appdir is not detected
    // TODO: Use React float APIs to load styles once available for pages dir
    if (false) {}
};
const loadScript = (props)=>{
    const { src, id, onLoad = ()=>{}, onReady = null, dangerouslySetInnerHTML, children = "", strategy = "afterInteractive", onError, stylesheets } = props;
    const cacheKey = id || src;
    // Script has already loaded
    if (cacheKey && LoadCache.has(cacheKey)) {
        return;
    }
    // Contents of this script are already loading/loaded
    if (ScriptCache.has(src)) {
        LoadCache.add(cacheKey);
        // It is possible that multiple `next/script` components all have same "src", but has different "onLoad"
        // This is to make sure the same remote script will only load once, but "onLoad" are executed in order
        ScriptCache.get(src).then(onLoad, onError);
        return;
    }
    /** Execute after the script first loaded */ const afterLoad = ()=>{
        // Run onReady for the first time after load event
        if (onReady) {
            onReady();
        }
        // add cacheKey to LoadCache when load successfully
        LoadCache.add(cacheKey);
    };
    const el = document.createElement("script");
    const loadPromise = new Promise((resolve, reject)=>{
        el.addEventListener("load", function(e) {
            resolve();
            if (onLoad) {
                onLoad.call(this, e);
            }
            afterLoad();
        });
        el.addEventListener("error", function(e) {
            reject(e);
        });
    }).catch(function(e) {
        if (onError) {
            onError(e);
        }
    });
    if (dangerouslySetInnerHTML) {
        // Casting since lib.dom.d.ts doesn't have TrustedHTML yet.
        el.innerHTML = dangerouslySetInnerHTML.__html || "";
        afterLoad();
    } else if (children) {
        el.textContent = typeof children === "string" ? children : Array.isArray(children) ? children.join("") : "";
        afterLoad();
    } else if (src) {
        el.src = src;
        // do not add cacheKey into LoadCache for remote script here
        // cacheKey will be added to LoadCache when it is actually loaded (see loadPromise above)
        ScriptCache.set(src, loadPromise);
    }
    for (const [k, value] of Object.entries(props)){
        if (value === undefined || ignoreProps.includes(k)) {
            continue;
        }
        const attr = _headmanager.DOMAttributeNames[k] || k.toLowerCase();
        el.setAttribute(attr, value);
    }
    if (strategy === "worker") {
        el.setAttribute("type", "text/partytown");
    }
    el.setAttribute("data-nscript", strategy);
    // Load styles associated with this script
    if (stylesheets) {
        insertStylesheets(stylesheets);
    }
    document.body.appendChild(el);
};
function handleClientScriptLoad(props) {
    const { strategy = "afterInteractive" } = props;
    if (strategy === "lazyOnload") {
        window.addEventListener("load", ()=>{
            (0, _requestidlecallback.requestIdleCallback)(()=>loadScript(props));
        });
    } else {
        loadScript(props);
    }
}
function loadLazyScript(props) {
    if (document.readyState === "complete") {
        (0, _requestidlecallback.requestIdleCallback)(()=>loadScript(props));
    } else {
        window.addEventListener("load", ()=>{
            (0, _requestidlecallback.requestIdleCallback)(()=>loadScript(props));
        });
    }
}
function addBeforeInteractiveToCache() {
    const scripts = [
        ...document.querySelectorAll('[data-nscript="beforeInteractive"]'),
        ...document.querySelectorAll('[data-nscript="beforePageRender"]')
    ];
    scripts.forEach((script)=>{
        const cacheKey = script.id || script.getAttribute("src");
        LoadCache.add(cacheKey);
    });
}
function initScriptLoader(scriptLoaderItems) {
    scriptLoaderItems.forEach(handleClientScriptLoad);
    addBeforeInteractiveToCache();
}
function Script(props) {
    const { id, src = "", onLoad = ()=>{}, onReady = null, strategy = "afterInteractive", onError, stylesheets, ...restProps } = props;
    // Context is available only during SSR
    const { updateScripts, scripts, getIsSsr, appDir, nonce } = (0, _react.useContext)(_headmanagercontext.HeadManagerContext);
    /**
   * - First mount:
   *   1. The useEffect for onReady executes
   *   2. hasOnReadyEffectCalled.current is false, but the script hasn't loaded yet (not in LoadCache)
   *      onReady is skipped, set hasOnReadyEffectCalled.current to true
   *   3. The useEffect for loadScript executes
   *   4. hasLoadScriptEffectCalled.current is false, loadScript executes
   *      Once the script is loaded, the onLoad and onReady will be called by then
   *   [If strict mode is enabled / is wrapped in <OffScreen /> component]
   *   5. The useEffect for onReady executes again
   *   6. hasOnReadyEffectCalled.current is true, so entire effect is skipped
   *   7. The useEffect for loadScript executes again
   *   8. hasLoadScriptEffectCalled.current is true, so entire effect is skipped
   *
   * - Second mount:
   *   1. The useEffect for onReady executes
   *   2. hasOnReadyEffectCalled.current is false, but the script has already loaded (found in LoadCache)
   *      onReady is called, set hasOnReadyEffectCalled.current to true
   *   3. The useEffect for loadScript executes
   *   4. The script is already loaded, loadScript bails out
   *   [If strict mode is enabled / is wrapped in <OffScreen /> component]
   *   5. The useEffect for onReady executes again
   *   6. hasOnReadyEffectCalled.current is true, so entire effect is skipped
   *   7. The useEffect for loadScript executes again
   *   8. hasLoadScriptEffectCalled.current is true, so entire effect is skipped
   */ const hasOnReadyEffectCalled = (0, _react.useRef)(false);
    (0, _react.useEffect)(()=>{
        const cacheKey = id || src;
        if (!hasOnReadyEffectCalled.current) {
            // Run onReady if script has loaded before but component is re-mounted
            if (onReady && cacheKey && LoadCache.has(cacheKey)) {
                onReady();
            }
            hasOnReadyEffectCalled.current = true;
        }
    }, [
        onReady,
        id,
        src
    ]);
    const hasLoadScriptEffectCalled = (0, _react.useRef)(false);
    (0, _react.useEffect)(()=>{
        if (!hasLoadScriptEffectCalled.current) {
            if (strategy === "afterInteractive") {
                loadScript(props);
            } else if (strategy === "lazyOnload") {
                loadLazyScript(props);
            }
            hasLoadScriptEffectCalled.current = true;
        }
    }, [
        props,
        strategy
    ]);
    if (strategy === "beforeInteractive" || strategy === "worker") {
        if (updateScripts) {
            scripts[strategy] = (scripts[strategy] || []).concat([
                {
                    id,
                    src,
                    onLoad,
                    onReady,
                    onError,
                    ...restProps
                }
            ]);
            updateScripts(scripts);
        } else if (getIsSsr && getIsSsr()) {
            // Script has already loaded during SSR
            LoadCache.add(id || src);
        } else if (getIsSsr && !getIsSsr()) {
            loadScript(props);
        }
    }
    // For the app directory, we need React Float to preload these scripts.
    if (appDir) {
        // Injecting stylesheets here handles beforeInteractive and worker scripts correctly
        // For other strategies injecting here ensures correct stylesheet order
        // ReactDOM.preinit handles loading the styles in the correct order,
        // also ensures the stylesheet is loaded only once and in a consistent manner
        //
        // Case 1: Styles for beforeInteractive/worker with appDir - handled here
        // Case 2: Styles for beforeInteractive/worker with pages dir - Not handled yet
        // Case 3: Styles for afterInteractive/lazyOnload with appDir - handled here
        // Case 4: Styles for afterInteractive/lazyOnload with pages dir - handled in insertStylesheets function
        if (stylesheets) {
            stylesheets.forEach((styleSrc)=>{
                _reactdom.default.preinit(styleSrc, {
                    as: "style"
                });
            });
        }
        // Before interactive scripts need to be loaded by Next.js' runtime instead
        // of native <script> tags, because they no longer have `defer`.
        if (strategy === "beforeInteractive") {
            if (!src) {
                // For inlined scripts, we put the content in `children`.
                if (restProps.dangerouslySetInnerHTML) {
                    // Casting since lib.dom.d.ts doesn't have TrustedHTML yet.
                    restProps.children = restProps.dangerouslySetInnerHTML.__html;
                    delete restProps.dangerouslySetInnerHTML;
                }
                return /*#__PURE__*/ _react.default.createElement("script", {
                    nonce: nonce,
                    dangerouslySetInnerHTML: {
                        __html: "(self.__next_s=self.__next_s||[]).push(" + JSON.stringify([
                            0,
                            {
                                ...restProps
                            }
                        ]) + ")"
                    }
                });
            } else {
                // @ts-ignore
                _reactdom.default.preload(src, restProps.integrity ? {
                    as: "script",
                    integrity: restProps.integrity
                } : {
                    as: "script"
                });
                return /*#__PURE__*/ _react.default.createElement("script", {
                    nonce: nonce,
                    dangerouslySetInnerHTML: {
                        __html: "(self.__next_s=self.__next_s||[]).push(" + JSON.stringify([
                            src
                        ]) + ")"
                    }
                });
            }
        } else if (strategy === "afterInteractive") {
            if (src) {
                // @ts-ignore
                _reactdom.default.preload(src, restProps.integrity ? {
                    as: "script",
                    integrity: restProps.integrity
                } : {
                    as: "script"
                });
            }
        }
    }
    return null;
}
Object.defineProperty(Script, "__nextScript", {
    value: true
});
const _default = Script;
if ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {
    Object.defineProperty(exports.default, "__esModule", {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=script.js.map


/***/ }),

/***/ 52488:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
0 && (0);
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    Head: function() {
        return Head;
    },
    NextScript: function() {
        return NextScript;
    },
    Html: function() {
        return Html;
    },
    Main: function() {
        return Main;
    },
    /**
 * `Document` component handles the initial `document` markup and renders only on the server side.
 * Commonly used for implementing server side rendering for `css-in-js` libraries.
 */ default: function() {
        return Document;
    }
});
const _react = /*#__PURE__*/ _interop_require_default(__webpack_require__(16689));
const _constants = __webpack_require__(56724);
const _getpagefiles = __webpack_require__(94140);
const _htmlescape = __webpack_require__(89716);
const _iserror = /*#__PURE__*/ _interop_require_default(__webpack_require__(80676));
const _htmlcontext = __webpack_require__(18743);
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
/** Set of pages that have triggered a large data warning on production mode. */ const largePageDataWarnings = new Set();
function getDocumentFiles(buildManifest, pathname, inAmpMode) {
    const sharedFiles = (0, _getpagefiles.getPageFiles)(buildManifest, "/_app");
    const pageFiles =  true && inAmpMode ? [] : (0, _getpagefiles.getPageFiles)(buildManifest, pathname);
    return {
        sharedFiles,
        pageFiles,
        allFiles: [
            ...new Set([
                ...sharedFiles,
                ...pageFiles
            ])
        ]
    };
}
function getPolyfillScripts(context, props) {
    // polyfills.js has to be rendered as nomodule without async
    // It also has to be the first script to load
    const { assetPrefix, buildManifest, assetQueryString, disableOptimizedLoading, crossOrigin } = context;
    return buildManifest.polyfillFiles.filter((polyfill)=>polyfill.endsWith(".js") && !polyfill.endsWith(".module.js")).map((polyfill)=>/*#__PURE__*/ _react.default.createElement("script", {
            key: polyfill,
            defer: !disableOptimizedLoading,
            nonce: props.nonce,
            crossOrigin: props.crossOrigin || crossOrigin,
            noModule: true,
            src: `${assetPrefix}/_next/${polyfill}${assetQueryString}`
        }));
}
function hasComponentProps(child) {
    return !!child && !!child.props;
}
function AmpStyles({ styles }) {
    if (!styles) return null;
    // try to parse styles from fragment for backwards compat
    const curStyles = Array.isArray(styles) ? styles : [];
    if (styles.props && // @ts-ignore Property 'props' does not exist on type ReactElement
    Array.isArray(styles.props.children)) {
        const hasStyles = (el)=>{
            var _el_props, _el_props_dangerouslySetInnerHTML;
            return el == null ? void 0 : (_el_props = el.props) == null ? void 0 : (_el_props_dangerouslySetInnerHTML = _el_props.dangerouslySetInnerHTML) == null ? void 0 : _el_props_dangerouslySetInnerHTML.__html;
        };
        // @ts-ignore Property 'props' does not exist on type ReactElement
        styles.props.children.forEach((child)=>{
            if (Array.isArray(child)) {
                child.forEach((el)=>hasStyles(el) && curStyles.push(el));
            } else if (hasStyles(child)) {
                curStyles.push(child);
            }
        });
    }
    /* Add custom styles before AMP styles to prevent accidental overrides */ return /*#__PURE__*/ _react.default.createElement("style", {
        "amp-custom": "",
        dangerouslySetInnerHTML: {
            __html: curStyles.map((style)=>style.props.dangerouslySetInnerHTML.__html).join("").replace(/\/\*# sourceMappingURL=.*\*\//g, "").replace(/\/\*@ sourceURL=.*?\*\//g, "")
        }
    });
}
function getDynamicChunks(context, props, files) {
    const { dynamicImports, assetPrefix, isDevelopment, assetQueryString, disableOptimizedLoading, crossOrigin } = context;
    return dynamicImports.map((file)=>{
        if (!file.endsWith(".js") || files.allFiles.includes(file)) return null;
        return /*#__PURE__*/ _react.default.createElement("script", {
            async: !isDevelopment && disableOptimizedLoading,
            defer: !disableOptimizedLoading,
            key: file,
            src: `${assetPrefix}/_next/${encodeURI(file)}${assetQueryString}`,
            nonce: props.nonce,
            crossOrigin: props.crossOrigin || crossOrigin
        });
    });
}
function getScripts(context, props, files) {
    var _buildManifest_lowPriorityFiles;
    const { assetPrefix, buildManifest, isDevelopment, assetQueryString, disableOptimizedLoading, crossOrigin } = context;
    const normalScripts = files.allFiles.filter((file)=>file.endsWith(".js"));
    const lowPriorityScripts = (_buildManifest_lowPriorityFiles = buildManifest.lowPriorityFiles) == null ? void 0 : _buildManifest_lowPriorityFiles.filter((file)=>file.endsWith(".js"));
    return [
        ...normalScripts,
        ...lowPriorityScripts
    ].map((file)=>{
        return /*#__PURE__*/ _react.default.createElement("script", {
            key: file,
            src: `${assetPrefix}/_next/${encodeURI(file)}${assetQueryString}`,
            nonce: props.nonce,
            async: !isDevelopment && disableOptimizedLoading,
            defer: !disableOptimizedLoading,
            crossOrigin: props.crossOrigin || crossOrigin
        });
    });
}
function getPreNextWorkerScripts(context, props) {
    const { assetPrefix, scriptLoader, crossOrigin, nextScriptWorkers } = context;
    // disable `nextScriptWorkers` in edge runtime
    if (!nextScriptWorkers || "nodejs" === "edge") return null;
    try {
        let { partytownSnippet } = require("@builder.io/partytown/integration");
        const children = Array.isArray(props.children) ? props.children : [
            props.children
        ];
        // Check to see if the user has defined their own Partytown configuration
        const userDefinedConfig = children.find((child)=>{
            var _child_props, _child_props_dangerouslySetInnerHTML;
            return hasComponentProps(child) && (child == null ? void 0 : (_child_props = child.props) == null ? void 0 : (_child_props_dangerouslySetInnerHTML = _child_props.dangerouslySetInnerHTML) == null ? void 0 : _child_props_dangerouslySetInnerHTML.__html.length) && "data-partytown-config" in child.props;
        });
        return /*#__PURE__*/ _react.default.createElement(_react.default.Fragment, null, !userDefinedConfig && /*#__PURE__*/ _react.default.createElement("script", {
            "data-partytown-config": "",
            dangerouslySetInnerHTML: {
                __html: `
            partytown = {
              lib: "${assetPrefix}/_next/static/~partytown/"
            };
          `
            }
        }), /*#__PURE__*/ _react.default.createElement("script", {
            "data-partytown": "",
            dangerouslySetInnerHTML: {
                __html: partytownSnippet()
            }
        }), (scriptLoader.worker || []).map((file, index)=>{
            const { strategy, src, children: scriptChildren, dangerouslySetInnerHTML, ...scriptProps } = file;
            let srcProps = {};
            if (src) {
                // Use external src if provided
                srcProps.src = src;
            } else if (dangerouslySetInnerHTML && dangerouslySetInnerHTML.__html) {
                // Embed inline script if provided with dangerouslySetInnerHTML
                srcProps.dangerouslySetInnerHTML = {
                    __html: dangerouslySetInnerHTML.__html
                };
            } else if (scriptChildren) {
                // Embed inline script if provided with children
                srcProps.dangerouslySetInnerHTML = {
                    __html: typeof scriptChildren === "string" ? scriptChildren : Array.isArray(scriptChildren) ? scriptChildren.join("") : ""
                };
            } else {
                throw new Error("Invalid usage of next/script. Did you forget to include a src attribute or an inline script? https://nextjs.org/docs/messages/invalid-script");
            }
            return /*#__PURE__*/ _react.default.createElement("script", {
                ...srcProps,
                ...scriptProps,
                type: "text/partytown",
                key: src || index,
                nonce: props.nonce,
                "data-nscript": "worker",
                crossOrigin: props.crossOrigin || crossOrigin
            });
        }));
    } catch (err) {
        if ((0, _iserror.default)(err) && err.code !== "MODULE_NOT_FOUND") {
            console.warn(`Warning: ${err.message}`);
        }
        return null;
    }
}
function getPreNextScripts(context, props) {
    const { scriptLoader, disableOptimizedLoading, crossOrigin } = context;
    const webWorkerScripts = getPreNextWorkerScripts(context, props);
    const beforeInteractiveScripts = (scriptLoader.beforeInteractive || []).filter((script)=>script.src).map((file, index)=>{
        const { strategy, ...scriptProps } = file;
        return /*#__PURE__*/ _react.default.createElement("script", {
            ...scriptProps,
            key: scriptProps.src || index,
            defer: scriptProps.defer ?? !disableOptimizedLoading,
            nonce: props.nonce,
            "data-nscript": "beforeInteractive",
            crossOrigin: props.crossOrigin || crossOrigin
        });
    });
    return /*#__PURE__*/ _react.default.createElement(_react.default.Fragment, null, webWorkerScripts, beforeInteractiveScripts);
}
function getHeadHTMLProps(props) {
    const { crossOrigin, nonce, ...restProps } = props;
    // This assignment is necessary for additional type checking to avoid unsupported attributes in <head>
    const headProps = restProps;
    return headProps;
}
function getAmpPath(ampPath, asPath) {
    return ampPath || `${asPath}${asPath.includes("?") ? "&" : "?"}amp=1`;
}
function getNextFontLinkTags(nextFontManifest, dangerousAsPath, assetPrefix = "") {
    if (!nextFontManifest) {
        return {
            preconnect: null,
            preload: null
        };
    }
    const appFontsEntry = nextFontManifest.pages["/_app"];
    const pageFontsEntry = nextFontManifest.pages[dangerousAsPath];
    const preloadedFontFiles = [
        ...appFontsEntry ?? [],
        ...pageFontsEntry ?? []
    ];
    // If no font files should preload but there's an entry for the path, add a preconnect tag.
    const preconnectToSelf = !!(preloadedFontFiles.length === 0 && (appFontsEntry || pageFontsEntry));
    return {
        preconnect: preconnectToSelf ? /*#__PURE__*/ _react.default.createElement("link", {
            "data-next-font": nextFontManifest.pagesUsingSizeAdjust ? "size-adjust" : "",
            rel: "preconnect",
            href: "/",
            crossOrigin: "anonymous"
        }) : null,
        preload: preloadedFontFiles ? preloadedFontFiles.map((fontFile)=>{
            const ext = /\.(woff|woff2|eot|ttf|otf)$/.exec(fontFile)[1];
            return /*#__PURE__*/ _react.default.createElement("link", {
                key: fontFile,
                rel: "preload",
                href: `${assetPrefix}/_next/${encodeURI(fontFile)}`,
                as: "font",
                type: `font/${ext}`,
                crossOrigin: "anonymous",
                "data-next-font": fontFile.includes("-s") ? "size-adjust" : ""
            });
        }) : null
    };
}
class Head extends _react.default.Component {
    static #_ = (()=>{
        this.contextType = _htmlcontext.HtmlContext;
    })();
    getCssLinks(files) {
        const { assetPrefix, assetQueryString, dynamicImports, crossOrigin, optimizeCss, optimizeFonts } = this.context;
        const cssFiles = files.allFiles.filter((f)=>f.endsWith(".css"));
        const sharedFiles = new Set(files.sharedFiles);
        // Unmanaged files are CSS files that will be handled directly by the
        // webpack runtime (`mini-css-extract-plugin`).
        let unmangedFiles = new Set([]);
        let dynamicCssFiles = Array.from(new Set(dynamicImports.filter((file)=>file.endsWith(".css"))));
        if (dynamicCssFiles.length) {
            const existing = new Set(cssFiles);
            dynamicCssFiles = dynamicCssFiles.filter((f)=>!(existing.has(f) || sharedFiles.has(f)));
            unmangedFiles = new Set(dynamicCssFiles);
            cssFiles.push(...dynamicCssFiles);
        }
        let cssLinkElements = [];
        cssFiles.forEach((file)=>{
            const isSharedFile = sharedFiles.has(file);
            if (!optimizeCss) {
                cssLinkElements.push(/*#__PURE__*/ _react.default.createElement("link", {
                    key: `${file}-preload`,
                    nonce: this.props.nonce,
                    rel: "preload",
                    href: `${assetPrefix}/_next/${encodeURI(file)}${assetQueryString}`,
                    as: "style",
                    crossOrigin: this.props.crossOrigin || crossOrigin
                }));
            }
            const isUnmanagedFile = unmangedFiles.has(file);
            cssLinkElements.push(/*#__PURE__*/ _react.default.createElement("link", {
                key: file,
                nonce: this.props.nonce,
                rel: "stylesheet",
                href: `${assetPrefix}/_next/${encodeURI(file)}${assetQueryString}`,
                crossOrigin: this.props.crossOrigin || crossOrigin,
                "data-n-g": isUnmanagedFile ? undefined : isSharedFile ? "" : undefined,
                "data-n-p": isUnmanagedFile ? undefined : isSharedFile ? undefined : ""
            }));
        });
        if ( true && optimizeFonts) {
            cssLinkElements = this.makeStylesheetInert(cssLinkElements);
        }
        return cssLinkElements.length === 0 ? null : cssLinkElements;
    }
    getPreloadDynamicChunks() {
        const { dynamicImports, assetPrefix, assetQueryString, crossOrigin } = this.context;
        return dynamicImports.map((file)=>{
            if (!file.endsWith(".js")) {
                return null;
            }
            return /*#__PURE__*/ _react.default.createElement("link", {
                rel: "preload",
                key: file,
                href: `${assetPrefix}/_next/${encodeURI(file)}${assetQueryString}`,
                as: "script",
                nonce: this.props.nonce,
                crossOrigin: this.props.crossOrigin || crossOrigin
            });
        }) // Filter out nulled scripts
        .filter(Boolean);
    }
    getPreloadMainLinks(files) {
        const { assetPrefix, assetQueryString, scriptLoader, crossOrigin } = this.context;
        const preloadFiles = files.allFiles.filter((file)=>{
            return file.endsWith(".js");
        });
        return [
            ...(scriptLoader.beforeInteractive || []).map((file)=>/*#__PURE__*/ _react.default.createElement("link", {
                    key: file.src,
                    nonce: this.props.nonce,
                    rel: "preload",
                    href: file.src,
                    as: "script",
                    crossOrigin: this.props.crossOrigin || crossOrigin
                })),
            ...preloadFiles.map((file)=>/*#__PURE__*/ _react.default.createElement("link", {
                    key: file,
                    nonce: this.props.nonce,
                    rel: "preload",
                    href: `${assetPrefix}/_next/${encodeURI(file)}${assetQueryString}`,
                    as: "script",
                    crossOrigin: this.props.crossOrigin || crossOrigin
                }))
        ];
    }
    getBeforeInteractiveInlineScripts() {
        const { scriptLoader } = this.context;
        const { nonce, crossOrigin } = this.props;
        return (scriptLoader.beforeInteractive || []).filter((script)=>!script.src && (script.dangerouslySetInnerHTML || script.children)).map((file, index)=>{
            const { strategy, children, dangerouslySetInnerHTML, src, ...scriptProps } = file;
            let html = "";
            if (dangerouslySetInnerHTML && dangerouslySetInnerHTML.__html) {
                html = dangerouslySetInnerHTML.__html;
            } else if (children) {
                html = typeof children === "string" ? children : Array.isArray(children) ? children.join("") : "";
            }
            return /*#__PURE__*/ _react.default.createElement("script", {
                ...scriptProps,
                dangerouslySetInnerHTML: {
                    __html: html
                },
                key: scriptProps.id || index,
                nonce: nonce,
                "data-nscript": "beforeInteractive",
                crossOrigin: crossOrigin || undefined
            });
        });
    }
    getDynamicChunks(files) {
        return getDynamicChunks(this.context, this.props, files);
    }
    getPreNextScripts() {
        return getPreNextScripts(this.context, this.props);
    }
    getScripts(files) {
        return getScripts(this.context, this.props, files);
    }
    getPolyfillScripts() {
        return getPolyfillScripts(this.context, this.props);
    }
    makeStylesheetInert(node) {
        return _react.default.Children.map(node, (c)=>{
            var _c_props, _c_props1;
            if ((c == null ? void 0 : c.type) === "link" && (c == null ? void 0 : (_c_props = c.props) == null ? void 0 : _c_props.href) && _constants.OPTIMIZED_FONT_PROVIDERS.some(({ url })=>{
                var _c_props, _c_props_href;
                return c == null ? void 0 : (_c_props = c.props) == null ? void 0 : (_c_props_href = _c_props.href) == null ? void 0 : _c_props_href.startsWith(url);
            })) {
                const newProps = {
                    ...c.props || {},
                    "data-href": c.props.href,
                    href: undefined
                };
                return /*#__PURE__*/ _react.default.cloneElement(c, newProps);
            } else if (c == null ? void 0 : (_c_props1 = c.props) == null ? void 0 : _c_props1.children) {
                const newProps = {
                    ...c.props || {},
                    children: this.makeStylesheetInert(c.props.children)
                };
                return /*#__PURE__*/ _react.default.cloneElement(c, newProps);
            }
            return c;
        // @types/react bug. Returned value from .map will not be `null` if you pass in `[null]`
        }).filter(Boolean);
    }
    render() {
        const { styles, ampPath, inAmpMode, hybridAmp, canonicalBase, __NEXT_DATA__, dangerousAsPath, headTags, unstable_runtimeJS, unstable_JsPreload, disableOptimizedLoading, optimizeCss, optimizeFonts, assetPrefix, nextFontManifest } = this.context;
        const disableRuntimeJS = unstable_runtimeJS === false;
        const disableJsPreload = unstable_JsPreload === false || !disableOptimizedLoading;
        this.context.docComponentsRendered.Head = true;
        let { head } = this.context;
        let cssPreloads = [];
        let otherHeadElements = [];
        if (head) {
            head.forEach((c)=>{
                let metaTag;
                if (this.context.strictNextHead) {
                    metaTag = /*#__PURE__*/ _react.default.createElement("meta", {
                        name: "next-head",
                        content: "1"
                    });
                }
                if (c && c.type === "link" && c.props["rel"] === "preload" && c.props["as"] === "style") {
                    metaTag && cssPreloads.push(metaTag);
                    cssPreloads.push(c);
                } else {
                    if (c) {
                        if (metaTag && (c.type !== "meta" || !c.props["charSet"])) {
                            otherHeadElements.push(metaTag);
                        }
                        otherHeadElements.push(c);
                    }
                }
            });
            head = cssPreloads.concat(otherHeadElements);
        }
        let children = _react.default.Children.toArray(this.props.children).filter(Boolean);
        // show a warning if Head contains <title> (only in development)
        if (false) {}
        if ( true && optimizeFonts && !( true && inAmpMode)) {
            children = this.makeStylesheetInert(children);
        }
        let hasAmphtmlRel = false;
        let hasCanonicalRel = false;
        // show warning and remove conflicting amp head tags
        head = _react.default.Children.map(head || [], (child)=>{
            if (!child) return child;
            const { type, props } = child;
            if ( true && inAmpMode) {
                let badProp = "";
                if (type === "meta" && props.name === "viewport") {
                    badProp = 'name="viewport"';
                } else if (type === "link" && props.rel === "canonical") {
                    hasCanonicalRel = true;
                } else if (type === "script") {
                    // only block if
                    // 1. it has a src and isn't pointing to ampproject's CDN
                    // 2. it is using dangerouslySetInnerHTML without a type or
                    // a type of text/javascript
                    if (props.src && props.src.indexOf("ampproject") < -1 || props.dangerouslySetInnerHTML && (!props.type || props.type === "text/javascript")) {
                        badProp = "<script";
                        Object.keys(props).forEach((prop)=>{
                            badProp += ` ${prop}="${props[prop]}"`;
                        });
                        badProp += "/>";
                    }
                }
                if (badProp) {
                    console.warn(`Found conflicting amp tag "${child.type}" with conflicting prop ${badProp} in ${__NEXT_DATA__.page}. https://nextjs.org/docs/messages/conflicting-amp-tag`);
                    return null;
                }
            } else {
                // non-amp mode
                if (type === "link" && props.rel === "amphtml") {
                    hasAmphtmlRel = true;
                }
            }
            return child;
        // @types/react bug. Returned value from .map will not be `null` if you pass in `[null]`
        });
        const files = getDocumentFiles(this.context.buildManifest, this.context.__NEXT_DATA__.page,  true && inAmpMode);
        const nextFontLinkTags = getNextFontLinkTags(nextFontManifest, dangerousAsPath, assetPrefix);
        return /*#__PURE__*/ _react.default.createElement("head", getHeadHTMLProps(this.props), this.context.isDevelopment && /*#__PURE__*/ _react.default.createElement(_react.default.Fragment, null, /*#__PURE__*/ _react.default.createElement("style", {
            "data-next-hide-fouc": true,
            "data-ampdevmode":  true && inAmpMode ? "true" : undefined,
            dangerouslySetInnerHTML: {
                __html: `body{display:none}`
            }
        }), /*#__PURE__*/ _react.default.createElement("noscript", {
            "data-next-hide-fouc": true,
            "data-ampdevmode":  true && inAmpMode ? "true" : undefined
        }, /*#__PURE__*/ _react.default.createElement("style", {
            dangerouslySetInnerHTML: {
                __html: `body{display:block}`
            }
        }))), head, this.context.strictNextHead ? null : /*#__PURE__*/ _react.default.createElement("meta", {
            name: "next-head-count",
            content: _react.default.Children.count(head || []).toString()
        }), children, optimizeFonts && /*#__PURE__*/ _react.default.createElement("meta", {
            name: "next-font-preconnect"
        }), nextFontLinkTags.preconnect, nextFontLinkTags.preload,  true && inAmpMode && /*#__PURE__*/ _react.default.createElement(_react.default.Fragment, null, /*#__PURE__*/ _react.default.createElement("meta", {
            name: "viewport",
            content: "width=device-width,minimum-scale=1,initial-scale=1"
        }), !hasCanonicalRel && /*#__PURE__*/ _react.default.createElement("link", {
            rel: "canonical",
            href: canonicalBase + (__webpack_require__(76368).cleanAmpPath)(dangerousAsPath)
        }), /*#__PURE__*/ _react.default.createElement("link", {
            rel: "preload",
            as: "script",
            href: "https://cdn.ampproject.org/v0.js"
        }), /*#__PURE__*/ _react.default.createElement(AmpStyles, {
            styles: styles
        }), /*#__PURE__*/ _react.default.createElement("style", {
            "amp-boilerplate": "",
            dangerouslySetInnerHTML: {
                __html: `body{-webkit-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-moz-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-ms-animation:-amp-start 8s steps(1,end) 0s 1 normal both;animation:-amp-start 8s steps(1,end) 0s 1 normal both}@-webkit-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-moz-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-ms-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-o-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}`
            }
        }), /*#__PURE__*/ _react.default.createElement("noscript", null, /*#__PURE__*/ _react.default.createElement("style", {
            "amp-boilerplate": "",
            dangerouslySetInnerHTML: {
                __html: `body{-webkit-animation:none;-moz-animation:none;-ms-animation:none;animation:none}`
            }
        })), /*#__PURE__*/ _react.default.createElement("script", {
            async: true,
            src: "https://cdn.ampproject.org/v0.js"
        })), !( true && inAmpMode) && /*#__PURE__*/ _react.default.createElement(_react.default.Fragment, null, !hasAmphtmlRel && hybridAmp && /*#__PURE__*/ _react.default.createElement("link", {
            rel: "amphtml",
            href: canonicalBase + getAmpPath(ampPath, dangerousAsPath)
        }), this.getBeforeInteractiveInlineScripts(), !optimizeCss && this.getCssLinks(files), !optimizeCss && /*#__PURE__*/ _react.default.createElement("noscript", {
            "data-n-css": this.props.nonce ?? ""
        }), !disableRuntimeJS && !disableJsPreload && this.getPreloadDynamicChunks(), !disableRuntimeJS && !disableJsPreload && this.getPreloadMainLinks(files), !disableOptimizedLoading && !disableRuntimeJS && this.getPolyfillScripts(), !disableOptimizedLoading && !disableRuntimeJS && this.getPreNextScripts(), !disableOptimizedLoading && !disableRuntimeJS && this.getDynamicChunks(files), !disableOptimizedLoading && !disableRuntimeJS && this.getScripts(files), optimizeCss && this.getCssLinks(files), optimizeCss && /*#__PURE__*/ _react.default.createElement("noscript", {
            "data-n-css": this.props.nonce ?? ""
        }), this.context.isDevelopment && // this element is used to mount development styles so the
        // ordering matches production
        // (by default, style-loader injects at the bottom of <head />)
        /*#__PURE__*/ _react.default.createElement("noscript", {
            id: "__next_css__DO_NOT_USE__"
        }), styles || null), /*#__PURE__*/ _react.default.createElement(_react.default.Fragment, {}, ...headTags || []));
    }
}
function handleDocumentScriptLoaderItems(scriptLoader, __NEXT_DATA__, props) {
    var _children_find, _children_find_props, _children_find1, _children_find_props1;
    if (!props.children) return;
    const scriptLoaderItems = [];
    const children = Array.isArray(props.children) ? props.children : [
        props.children
    ];
    const headChildren = (_children_find = children.find((child)=>child.type === Head)) == null ? void 0 : (_children_find_props = _children_find.props) == null ? void 0 : _children_find_props.children;
    const bodyChildren = (_children_find1 = children.find((child)=>child.type === "body")) == null ? void 0 : (_children_find_props1 = _children_find1.props) == null ? void 0 : _children_find_props1.children;
    // Scripts with beforeInteractive can be placed inside Head or <body> so children of both needs to be traversed
    const combinedChildren = [
        ...Array.isArray(headChildren) ? headChildren : [
            headChildren
        ],
        ...Array.isArray(bodyChildren) ? bodyChildren : [
            bodyChildren
        ]
    ];
    _react.default.Children.forEach(combinedChildren, (child)=>{
        var _child_type;
        if (!child) return;
        // When using the `next/script` component, register it in script loader.
        if ((_child_type = child.type) == null ? void 0 : _child_type.__nextScript) {
            if (child.props.strategy === "beforeInteractive") {
                scriptLoader.beforeInteractive = (scriptLoader.beforeInteractive || []).concat([
                    {
                        ...child.props
                    }
                ]);
                return;
            } else if ([
                "lazyOnload",
                "afterInteractive",
                "worker"
            ].includes(child.props.strategy)) {
                scriptLoaderItems.push(child.props);
                return;
            }
        }
    });
    __NEXT_DATA__.scriptLoader = scriptLoaderItems;
}
class NextScript extends _react.default.Component {
    static #_ = (()=>{
        this.contextType = _htmlcontext.HtmlContext;
    })();
    getDynamicChunks(files) {
        return getDynamicChunks(this.context, this.props, files);
    }
    getPreNextScripts() {
        return getPreNextScripts(this.context, this.props);
    }
    getScripts(files) {
        return getScripts(this.context, this.props, files);
    }
    getPolyfillScripts() {
        return getPolyfillScripts(this.context, this.props);
    }
    static getInlineScriptSource(context) {
        const { __NEXT_DATA__, largePageDataBytes } = context;
        try {
            const data = JSON.stringify(__NEXT_DATA__);
            if (largePageDataWarnings.has(__NEXT_DATA__.page)) {
                return (0, _htmlescape.htmlEscapeJsonString)(data);
            }
            const bytes =  false ? 0 : Buffer.from(data).byteLength;
            const prettyBytes = (__webpack_require__(95955)/* ["default"] */ .Z);
            if (largePageDataBytes && bytes > largePageDataBytes) {
                if (true) {
                    largePageDataWarnings.add(__NEXT_DATA__.page);
                }
                console.warn(`Warning: data for page "${__NEXT_DATA__.page}"${__NEXT_DATA__.page === context.dangerousAsPath ? "" : ` (path "${context.dangerousAsPath}")`} is ${prettyBytes(bytes)} which exceeds the threshold of ${prettyBytes(largePageDataBytes)}, this amount of data can reduce performance.\nSee more info here: https://nextjs.org/docs/messages/large-page-data`);
            }
            return (0, _htmlescape.htmlEscapeJsonString)(data);
        } catch (err) {
            if ((0, _iserror.default)(err) && err.message.indexOf("circular structure") !== -1) {
                throw new Error(`Circular structure in "getInitialProps" result of page "${__NEXT_DATA__.page}". https://nextjs.org/docs/messages/circular-structure`);
            }
            throw err;
        }
    }
    render() {
        const { assetPrefix, inAmpMode, buildManifest, unstable_runtimeJS, docComponentsRendered, assetQueryString, disableOptimizedLoading, crossOrigin } = this.context;
        const disableRuntimeJS = unstable_runtimeJS === false;
        docComponentsRendered.NextScript = true;
        if ( true && inAmpMode) {
            if (true) {
                return null;
            }
            const ampDevFiles = [
                ...buildManifest.devFiles,
                ...buildManifest.polyfillFiles,
                ...buildManifest.ampDevFiles
            ];
            return /*#__PURE__*/ _react.default.createElement(_react.default.Fragment, null, disableRuntimeJS ? null : /*#__PURE__*/ _react.default.createElement("script", {
                id: "__NEXT_DATA__",
                type: "application/json",
                nonce: this.props.nonce,
                crossOrigin: this.props.crossOrigin || crossOrigin,
                dangerouslySetInnerHTML: {
                    __html: NextScript.getInlineScriptSource(this.context)
                },
                "data-ampdevmode": true
            }), ampDevFiles.map((file)=>/*#__PURE__*/ _react.default.createElement("script", {
                    key: file,
                    src: `${assetPrefix}/_next/${file}${assetQueryString}`,
                    nonce: this.props.nonce,
                    crossOrigin: this.props.crossOrigin || crossOrigin,
                    "data-ampdevmode": true
                })));
        }
        if (false) {}
        const files = getDocumentFiles(this.context.buildManifest, this.context.__NEXT_DATA__.page,  true && inAmpMode);
        return /*#__PURE__*/ _react.default.createElement(_react.default.Fragment, null, !disableRuntimeJS && buildManifest.devFiles ? buildManifest.devFiles.map((file)=>/*#__PURE__*/ _react.default.createElement("script", {
                key: file,
                src: `${assetPrefix}/_next/${encodeURI(file)}${assetQueryString}`,
                nonce: this.props.nonce,
                crossOrigin: this.props.crossOrigin || crossOrigin
            })) : null, disableRuntimeJS ? null : /*#__PURE__*/ _react.default.createElement("script", {
            id: "__NEXT_DATA__",
            type: "application/json",
            nonce: this.props.nonce,
            crossOrigin: this.props.crossOrigin || crossOrigin,
            dangerouslySetInnerHTML: {
                __html: NextScript.getInlineScriptSource(this.context)
            }
        }), disableOptimizedLoading && !disableRuntimeJS && this.getPolyfillScripts(), disableOptimizedLoading && !disableRuntimeJS && this.getPreNextScripts(), disableOptimizedLoading && !disableRuntimeJS && this.getDynamicChunks(files), disableOptimizedLoading && !disableRuntimeJS && this.getScripts(files));
    }
}
function Html(props) {
    const { inAmpMode, docComponentsRendered, locale, scriptLoader, __NEXT_DATA__ } = (0, _htmlcontext.useHtmlContext)();
    docComponentsRendered.Html = true;
    handleDocumentScriptLoaderItems(scriptLoader, __NEXT_DATA__, props);
    return /*#__PURE__*/ _react.default.createElement("html", {
        ...props,
        lang: props.lang || locale || undefined,
        amp:  true && inAmpMode ? "" : undefined,
        "data-ampdevmode":  true && inAmpMode && "production" !== "production" ? 0 : undefined
    });
}
function Main() {
    const { docComponentsRendered } = (0, _htmlcontext.useHtmlContext)();
    docComponentsRendered.Main = true;
    // @ts-ignore
    return /*#__PURE__*/ _react.default.createElement("next-js-internal-body-render-target", null);
}
class Document extends _react.default.Component {
    /**
   * `getInitialProps` hook returns the context object with the addition of `renderPage`.
   * `renderPage` callback executes `React` rendering logic synchronously to support server-rendering wrappers
   */ static getInitialProps(ctx) {
        return ctx.defaultGetInitialProps(ctx);
    }
    render() {
        return /*#__PURE__*/ _react.default.createElement(Html, null, /*#__PURE__*/ _react.default.createElement(Head, null), /*#__PURE__*/ _react.default.createElement("body", null, /*#__PURE__*/ _react.default.createElement(Main, null), /*#__PURE__*/ _react.default.createElement(NextScript, null)));
    }
}
// Add a special property to the built-in `Document` component so later we can
// identify if a user customized `Document` is used or not.
const InternalFunctionDocument = function InternalFunctionDocument() {
    return /*#__PURE__*/ _react.default.createElement(Html, null, /*#__PURE__*/ _react.default.createElement(Head, null), /*#__PURE__*/ _react.default.createElement("body", null, /*#__PURE__*/ _react.default.createElement(Main, null), /*#__PURE__*/ _react.default.createElement(NextScript, null)));
};
Document[_constants.NEXT_BUILTIN_DOCUMENT] = InternalFunctionDocument; //# sourceMappingURL=_document.js.map


/***/ }),

/***/ 10739:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.ActionType = void 0;
const ActionType = {
    REANIMATED_WORKLET: 1,
    NATIVE_ANIMATED_EVENT: 2,
    JS_FUNCTION_OLD_API: 3,
    JS_FUNCTION_NEW_API: 4
}; // eslint-disable-next-line @typescript-eslint/no-redeclare -- backward compatibility; it can be used as a type and as a value
exports.ActionType = ActionType; //# sourceMappingURL=ActionType.js.map


/***/ }),

/***/ 1166:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.Directions = void 0;
const Directions = {
    RIGHT: 1,
    LEFT: 2,
    UP: 4,
    DOWN: 8
}; // eslint-disable-next-line @typescript-eslint/no-redeclare -- backward compatibility; it can be used as a type and as a value
exports.Directions = Directions; //# sourceMappingURL=Directions.js.map


/***/ }),

/***/ 29551:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.enableExperimentalWebImplementation = enableExperimentalWebImplementation;
exports.enableLegacyWebImplementation = enableLegacyWebImplementation;
exports.isNewWebImplementationEnabled = isNewWebImplementationEnabled;
var _reactNative = __webpack_require__(83849);
let useNewWebImplementation = true;
let getWasCalled = false;
function enableExperimentalWebImplementation(_shouldEnable = true) {}
function enableLegacyWebImplementation(shouldUseLegacyImplementation = true) {
    if (_reactNative.Platform.OS !== "web" || useNewWebImplementation === !shouldUseLegacyImplementation) {
        return;
    }
    if (getWasCalled) {
        console.error("Some parts of this application have already started using the new gesture handler implementation. No changes will be applied. You can try enabling legacy implementation earlier.");
        return;
    }
    useNewWebImplementation = !shouldUseLegacyImplementation;
}
function isNewWebImplementationEnabled() {
    getWasCalled = true;
    return useNewWebImplementation;
} //# sourceMappingURL=EnableNewWebImplementation.js.map


/***/ }),

/***/ 49704:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports["default"] = void 0;
var _react = _interopRequireDefault(__webpack_require__(16689));
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
var _default = /*#__PURE__*/ _react.default.createContext(false);
exports["default"] = _default; //# sourceMappingURL=GestureHandlerRootViewContext.js.map


/***/ }),

/***/ 14858:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports["default"] = void 0;
var _default = {
    get forceTouchAvailable () {
        return false;
    }
};
exports["default"] = _default; //# sourceMappingURL=PlatformConstants.web.js.map


/***/ }),

/***/ 43121:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports["default"] = exports.HammerGestures = exports.Gestures = void 0;
var _react = _interopRequireDefault(__webpack_require__(16689));
var _EnableNewWebImplementation = __webpack_require__(29551);
var _InteractionManager = _interopRequireDefault(__webpack_require__(77125));
var _NodeManager = _interopRequireDefault(__webpack_require__(60596));
var _PanGestureHandler = _interopRequireDefault(__webpack_require__(3383));
var _TapGestureHandler = _interopRequireDefault(__webpack_require__(52412));
var _LongPressGestureHandler = _interopRequireDefault(__webpack_require__(54310));
var _PinchGestureHandler = _interopRequireDefault(__webpack_require__(10074));
var _RotationGestureHandler = _interopRequireDefault(__webpack_require__(44751));
var _FlingGestureHandler = _interopRequireDefault(__webpack_require__(59932));
var _NativeViewGestureHandler = _interopRequireDefault(__webpack_require__(88821));
var _ManualGestureHandler = _interopRequireDefault(__webpack_require__(47242));
var HammerNodeManager = _interopRequireWildcard(__webpack_require__(24359));
var _NativeViewGestureHandler2 = _interopRequireDefault(__webpack_require__(30027));
var _PanGestureHandler2 = _interopRequireDefault(__webpack_require__(54255));
var _TapGestureHandler2 = _interopRequireDefault(__webpack_require__(97833));
var _LongPressGestureHandler2 = _interopRequireDefault(__webpack_require__(46438));
var _PinchGestureHandler2 = _interopRequireDefault(__webpack_require__(88164));
var _RotationGestureHandler2 = _interopRequireDefault(__webpack_require__(61236));
var _FlingGestureHandler2 = _interopRequireDefault(__webpack_require__(49929));
function _getRequireWildcardCache() {
    if (typeof WeakMap !== "function") return null;
    var cache = new WeakMap();
    _getRequireWildcardCache = function() {
        return cache;
    };
    return cache;
}
function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache();
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {};
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
//GestureHandlers
//Hammer Handlers
const Gestures = {
    NativeViewGestureHandler: _NativeViewGestureHandler.default,
    PanGestureHandler: _PanGestureHandler.default,
    TapGestureHandler: _TapGestureHandler.default,
    LongPressGestureHandler: _LongPressGestureHandler.default,
    PinchGestureHandler: _PinchGestureHandler.default,
    RotationGestureHandler: _RotationGestureHandler.default,
    FlingGestureHandler: _FlingGestureHandler.default,
    ManualGestureHandler: _ManualGestureHandler.default
};
exports.Gestures = Gestures;
const HammerGestures = {
    NativeViewGestureHandler: _NativeViewGestureHandler2.default,
    PanGestureHandler: _PanGestureHandler2.default,
    TapGestureHandler: _TapGestureHandler2.default,
    LongPressGestureHandler: _LongPressGestureHandler2.default,
    PinchGestureHandler: _PinchGestureHandler2.default,
    RotationGestureHandler: _RotationGestureHandler2.default,
    FlingGestureHandler: _FlingGestureHandler2.default
};
exports.HammerGestures = HammerGestures;
var _default = {
    handleSetJSResponder (tag, blockNativeResponder) {
        console.warn("handleSetJSResponder: ", tag, blockNativeResponder);
    },
    handleClearJSResponder () {
        console.warn("handleClearJSResponder: ");
    },
    createGestureHandler (handlerName, handlerTag, config) {
        if ((0, _EnableNewWebImplementation.isNewWebImplementationEnabled)()) {
            if (!(handlerName in Gestures)) {
                throw new Error(`react-native-gesture-handler: ${handlerName} is not supported on web.`);
            }
            const GestureClass = Gestures[handlerName];
            _NodeManager.default.createGestureHandler(handlerTag, new GestureClass());
            _InteractionManager.default.getInstance().configureInteractions(_NodeManager.default.getHandler(handlerTag), config);
        } else {
            if (!(handlerName in HammerGestures)) {
                throw new Error(`react-native-gesture-handler: ${handlerName} is not supported on web.`);
            } // @ts-ignore If it doesn't exist, the error is thrown
            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
            const GestureClass = HammerGestures[handlerName]; // eslint-disable-next-line @typescript-eslint/no-unsafe-call
            HammerNodeManager.createGestureHandler(handlerTag, new GestureClass());
        }
        this.updateGestureHandler(handlerTag, config);
    },
    attachGestureHandler (handlerTag, newView, _actionType, propsRef) {
        if (!(newView instanceof HTMLElement || newView instanceof _react.default.Component)) {
            return;
        }
        if ((0, _EnableNewWebImplementation.isNewWebImplementationEnabled)()) {
            //@ts-ignore Types should be HTMLElement or React.Component
            _NodeManager.default.getHandler(handlerTag).init(newView, propsRef);
        } else {
            //@ts-ignore Types should be HTMLElement or React.Component
            HammerNodeManager.getHandler(handlerTag).setView(newView, propsRef);
        }
    },
    updateGestureHandler (handlerTag, newConfig) {
        if ((0, _EnableNewWebImplementation.isNewWebImplementationEnabled)()) {
            _NodeManager.default.getHandler(handlerTag).updateGestureConfig(newConfig);
            _InteractionManager.default.getInstance().configureInteractions(_NodeManager.default.getHandler(handlerTag), newConfig);
        } else {
            HammerNodeManager.getHandler(handlerTag).updateGestureConfig(newConfig);
        }
    },
    getGestureHandlerNode (handlerTag) {
        if ((0, _EnableNewWebImplementation.isNewWebImplementationEnabled)()) {
            return _NodeManager.default.getHandler(handlerTag);
        } else {
            return HammerNodeManager.getHandler(handlerTag);
        }
    },
    dropGestureHandler (handlerTag) {
        if ((0, _EnableNewWebImplementation.isNewWebImplementationEnabled)()) {
            _NodeManager.default.dropGestureHandler(handlerTag);
        } else {
            HammerNodeManager.dropGestureHandler(handlerTag);
        }
    },
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    flushOperations () {}
};
exports["default"] = _default; //# sourceMappingURL=RNGestureHandlerModule.web.js.map


/***/ }),

/***/ 79713:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.RNRenderer = void 0;
const RNRenderer = {
    findHostInstance_DEPRECATED: (_ref)=>null
};
exports.RNRenderer = RNRenderer; //# sourceMappingURL=RNRenderer.web.js.map


/***/ }),

/***/ 10125:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.State = void 0;
// TODO use State from RNModule
const State = {
    UNDETERMINED: 0,
    FAILED: 1,
    BEGAN: 2,
    CANCELLED: 3,
    ACTIVE: 4,
    END: 5
}; // eslint-disable-next-line @typescript-eslint/no-redeclare -- backward compatibility; it can be used as a type and as a value
exports.State = State; //# sourceMappingURL=State.js.map


/***/ }),

/***/ 5887:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.TouchEventType = void 0;
const TouchEventType = {
    UNDETERMINED: 0,
    TOUCHES_DOWN: 1,
    TOUCHES_MOVE: 2,
    TOUCHES_UP: 3,
    TOUCHES_CANCELLED: 4
}; // eslint-disable-next-line @typescript-eslint/no-redeclare -- backward compatibility; it can be used as a type and as a value
exports.TouchEventType = TouchEventType; //# sourceMappingURL=TouchEventType.js.map


/***/ }),

/***/ 57334:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports["default"] = void 0;
var React = _interopRequireWildcard(__webpack_require__(16689));
var _invariant = _interopRequireDefault(__webpack_require__(67644));
var _reactNative = __webpack_require__(83849);
var _PanGestureHandler = __webpack_require__(78673);
var _TapGestureHandler = __webpack_require__(91418);
var _State = __webpack_require__(10125);
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function _getRequireWildcardCache() {
    if (typeof WeakMap !== "function") return null;
    var cache = new WeakMap();
    _getRequireWildcardCache = function() {
        return cache;
    };
    return cache;
}
function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache();
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {};
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
function _defineProperty(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
const DRAG_TOSS = 0.05;
const IDLE = "Idle";
const DRAGGING = "Dragging";
const SETTLING = "Settling";
class DrawerLayout extends React.Component {
    constructor(_props){
        super(_props);
        _defineProperty(this, "openValue", void 0);
        _defineProperty(this, "onGestureEvent", void 0);
        _defineProperty(this, "accessibilityIsModalView", /*#__PURE__*/ React.createRef());
        _defineProperty(this, "pointerEventsView", /*#__PURE__*/ React.createRef());
        _defineProperty(this, "panGestureHandler", /*#__PURE__*/ React.createRef());
        _defineProperty(this, "drawerShown", false);
        _defineProperty(this, "updateAnimatedEvent", (props, state)=>{
            // Event definition is based on
            const { drawerPosition, drawerWidth, drawerType } = props;
            const { dragX: dragXValue, touchX: touchXValue, drawerTranslation, containerWidth } = state;
            let dragX = dragXValue;
            let touchX = touchXValue;
            if (drawerPosition !== "left") {
                // Most of the code is written in a way to handle left-side drawer. In
                // order to handle right-side drawer the only thing we need to do is to
                // reverse events coming from gesture handler in a way they emulate
                // left-side drawer gestures. E.g. dragX is simply -dragX, and touchX is
                // calulcated by subtracing real touchX from the width of the container
                // (such that when touch happens at the right edge the value is simply 0)
                dragX = _reactNative.Animated.multiply(new _reactNative.Animated.Value(-1), dragXValue); // TODO(TS): (for all "as" in this file) make sure we can map this
                touchX = _reactNative.Animated.add(new _reactNative.Animated.Value(containerWidth), _reactNative.Animated.multiply(new _reactNative.Animated.Value(-1), touchXValue)); // TODO(TS): make sure we can map this;
                touchXValue.setValue(containerWidth);
            } else {
                touchXValue.setValue(0);
            } // While closing the drawer when user starts gesture outside of its area (in greyed
            // out part of the window), we want the drawer to follow only once finger reaches the
            // edge of the drawer.
            // E.g. on the diagram below drawer is illustrate by X signs and the greyed out area by
            // dots. The touch gesture starts at '*' and moves left, touch path is indicated by
            // an arrow pointing left
            // 1) +---------------+ 2) +---------------+ 3) +---------------+ 4) +---------------+
            //    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXX|.........|
            //    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXX|.........|
            //    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXX|.........|
            //    |XXXXXXXX|......|    |XXXXXXXX|.<-*..|    |XXXXXXXX|<--*..|    |XXXXX|<-----*..|
            //    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXX|.........|
            //    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXX|.........|
            //    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXX|.........|
            //    +---------------+    +---------------+    +---------------+    +---------------+
            //
            // For the above to work properly we define animated value that will keep
            // start position of the gesture. Then we use that value to calculate how
            // much we need to subtract from the dragX. If the gesture started on the
            // greyed out area we take the distance from the edge of the drawer to the
            // start position. Otherwise we don't subtract at all and the drawer be
            // pulled back as soon as you start the pan.
            //
            // This is used only when drawerType is "front"
            //
            let translationX = dragX;
            if (drawerType === "front") {
                const startPositionX = _reactNative.Animated.add(touchX, _reactNative.Animated.multiply(new _reactNative.Animated.Value(-1), dragX));
                const dragOffsetFromOnStartPosition = startPositionX.interpolate({
                    inputRange: [
                        drawerWidth - 1,
                        drawerWidth,
                        drawerWidth + 1
                    ],
                    outputRange: [
                        0,
                        0,
                        1
                    ]
                });
                translationX = _reactNative.Animated.add(dragX, dragOffsetFromOnStartPosition); // TODO: as above
            }
            this.openValue = _reactNative.Animated.add(translationX, drawerTranslation).interpolate({
                inputRange: [
                    0,
                    drawerWidth
                ],
                outputRange: [
                    0,
                    1
                ],
                extrapolate: "clamp"
            });
            const gestureOptions = {
                useNativeDriver: props.useNativeAnimations
            };
            if (this.props.onDrawerSlide) {
                gestureOptions.listener = (ev)=>{
                    var _this$props$onDrawerS, _this$props;
                    const translationX = Math.floor(Math.abs(ev.nativeEvent.translationX));
                    const position = translationX / this.state.containerWidth;
                    (_this$props$onDrawerS = (_this$props = this.props).onDrawerSlide) === null || _this$props$onDrawerS === void 0 ? void 0 : _this$props$onDrawerS.call(_this$props, position);
                };
            }
            this.onGestureEvent = _reactNative.Animated.event([
                {
                    nativeEvent: {
                        translationX: dragXValue,
                        x: touchXValue
                    }
                }
            ], gestureOptions);
        });
        _defineProperty(this, "handleContainerLayout", ({ nativeEvent })=>{
            this.setState({
                containerWidth: nativeEvent.layout.width
            });
        });
        _defineProperty(this, "emitStateChanged", (newState, drawerWillShow)=>{
            var _this$props$onDrawerS2, _this$props2;
            (_this$props$onDrawerS2 = (_this$props2 = this.props).onDrawerStateChanged) === null || _this$props$onDrawerS2 === void 0 ? void 0 : _this$props$onDrawerS2.call(_this$props2, newState, drawerWillShow);
        });
        _defineProperty(this, "openingHandlerStateChange", ({ nativeEvent })=>{
            if (nativeEvent.oldState === _State.State.ACTIVE) {
                this.handleRelease({
                    nativeEvent
                });
            } else if (nativeEvent.state === _State.State.ACTIVE) {
                this.emitStateChanged(DRAGGING, false);
                this.setState({
                    drawerState: DRAGGING
                });
                if (this.props.keyboardDismissMode === "on-drag") {
                    _reactNative.Keyboard.dismiss();
                }
                if (this.props.hideStatusBar) {
                    _reactNative.StatusBar.setHidden(true, this.props.statusBarAnimation || "slide");
                }
            }
        });
        _defineProperty(this, "onTapHandlerStateChange", ({ nativeEvent })=>{
            if (this.drawerShown && nativeEvent.oldState === _State.State.ACTIVE && this.props.drawerLockMode !== "locked-open") {
                this.closeDrawer();
            }
        });
        _defineProperty(this, "handleRelease", ({ nativeEvent })=>{
            const { drawerWidth, drawerPosition, drawerType } = this.props;
            const { containerWidth } = this.state;
            let { translationX: dragX, velocityX, x: touchX } = nativeEvent;
            if (drawerPosition !== "left") {
                // See description in _updateAnimatedEvent about why events are flipped
                // for right-side drawer
                dragX = -dragX;
                touchX = containerWidth - touchX;
                velocityX = -velocityX;
            }
            const gestureStartX = touchX - dragX;
            let dragOffsetBasedOnStart = 0;
            if (drawerType === "front") {
                dragOffsetBasedOnStart = gestureStartX > drawerWidth ? gestureStartX - drawerWidth : 0;
            }
            const startOffsetX = dragX + dragOffsetBasedOnStart + (this.drawerShown ? drawerWidth : 0);
            const projOffsetX = startOffsetX + DRAG_TOSS * velocityX;
            const shouldOpen = projOffsetX > drawerWidth / 2;
            if (shouldOpen) {
                this.animateDrawer(startOffsetX, drawerWidth, velocityX);
            } else {
                this.animateDrawer(startOffsetX, 0, velocityX);
            }
        });
        _defineProperty(this, "updateShowing", (showing)=>{
            var _this$accessibilityIs, _this$pointerEventsVi, _this$panGestureHandl;
            this.drawerShown = showing;
            (_this$accessibilityIs = this.accessibilityIsModalView.current) === null || _this$accessibilityIs === void 0 ? void 0 : _this$accessibilityIs.setNativeProps({
                accessibilityViewIsModal: showing
            });
            (_this$pointerEventsVi = this.pointerEventsView.current) === null || _this$pointerEventsVi === void 0 ? void 0 : _this$pointerEventsVi.setNativeProps({
                pointerEvents: showing ? "auto" : "none"
            });
            const { drawerPosition, minSwipeDistance, edgeWidth } = this.props;
            const fromLeft = drawerPosition === "left"; // gestureOrientation is 1 if the expected gesture is from left to right and
            // -1 otherwise e.g. when drawer is on the left and is closed we expect left
            // to right gesture, thus orientation will be 1.
            const gestureOrientation = (fromLeft ? 1 : -1) * (this.drawerShown ? -1 : 1); // When drawer is closed we want the hitSlop to be horizontally shorter than
            // the container size by the value of SLOP. This will make it only activate
            // when gesture happens not further than SLOP away from the edge
            const hitSlop = fromLeft ? {
                left: 0,
                width: showing ? undefined : edgeWidth
            } : {
                right: 0,
                width: showing ? undefined : edgeWidth
            }; // @ts-ignore internal API, maybe could be fixed in handler types
            (_this$panGestureHandl = this.panGestureHandler.current) === null || _this$panGestureHandl === void 0 ? void 0 : _this$panGestureHandl.setNativeProps({
                hitSlop,
                activeOffsetX: gestureOrientation * minSwipeDistance
            });
        });
        _defineProperty(this, "animateDrawer", (fromValue, toValue, velocity, speed)=>{
            this.state.dragX.setValue(0);
            this.state.touchX.setValue(this.props.drawerPosition === "left" ? 0 : this.state.containerWidth);
            if (fromValue != null) {
                let nextFramePosition = fromValue;
                if (this.props.useNativeAnimations) {
                    // When using native driver, we predict the next position of the
                    // animation because it takes one frame of a roundtrip to pass RELEASE
                    // event from native driver to JS before we can start animating. Without
                    // it, it is more noticable that the frame is dropped.
                    if (fromValue < toValue && velocity > 0) {
                        nextFramePosition = Math.min(fromValue + velocity / 60.0, toValue);
                    } else if (fromValue > toValue && velocity < 0) {
                        nextFramePosition = Math.max(fromValue + velocity / 60.0, toValue);
                    }
                }
                this.state.drawerTranslation.setValue(nextFramePosition);
            }
            const willShow = toValue !== 0;
            this.updateShowing(willShow);
            this.emitStateChanged(SETTLING, willShow);
            this.setState({
                drawerState: SETTLING
            });
            if (this.props.hideStatusBar) {
                _reactNative.StatusBar.setHidden(willShow, this.props.statusBarAnimation || "slide");
            }
            _reactNative.Animated.spring(this.state.drawerTranslation, {
                velocity,
                bounciness: 0,
                toValue,
                useNativeDriver: this.props.useNativeAnimations,
                speed: speed !== null && speed !== void 0 ? speed : undefined
            }).start(({ finished })=>{
                if (finished) {
                    this.emitStateChanged(IDLE, willShow);
                    this.setState({
                        drawerOpened: willShow
                    });
                    if (this.state.drawerState !== DRAGGING) {
                        // it's possilbe that user started drag while the drawer
                        // was settling, don't override state in this case
                        this.setState({
                            drawerState: IDLE
                        });
                    }
                    if (willShow) {
                        var _this$props$onDrawerO, _this$props3;
                        (_this$props$onDrawerO = (_this$props3 = this.props).onDrawerOpen) === null || _this$props$onDrawerO === void 0 ? void 0 : _this$props$onDrawerO.call(_this$props3);
                    } else {
                        var _this$props$onDrawerC, _this$props4;
                        (_this$props$onDrawerC = (_this$props4 = this.props).onDrawerClose) === null || _this$props$onDrawerC === void 0 ? void 0 : _this$props$onDrawerC.call(_this$props4);
                    }
                }
            });
        });
        _defineProperty(this, "openDrawer", (options = {})=>{
            this.animateDrawer(undefined, this.props.drawerWidth, options.velocity ? options.velocity : 0, options.speed); // We need to force the update, otherwise the overlay is not rerendered and
            // it would not be clickable
            this.forceUpdate();
        });
        _defineProperty(this, "closeDrawer", (options = {})=>{
            // TODO: decide if it should be null or undefined is the proper value
            this.animateDrawer(undefined, 0, options.velocity ? options.velocity : 0, options.speed); // We need to force the update, otherwise the overlay is not rerendered and
            // it would be still clickable
            this.forceUpdate();
        });
        _defineProperty(this, "renderOverlay", ()=>{
            /* Overlay styles */ (0, _invariant.default)(this.openValue, "should be set");
            let overlayOpacity;
            if (this.state.drawerState !== IDLE) {
                overlayOpacity = this.openValue;
            } else {
                overlayOpacity = this.state.drawerOpened ? 1 : 0;
            }
            const dynamicOverlayStyles = {
                opacity: overlayOpacity,
                backgroundColor: this.props.overlayColor
            };
            return /*#__PURE__*/ React.createElement(_TapGestureHandler.TapGestureHandler, {
                onHandlerStateChange: this.onTapHandlerStateChange
            }, /*#__PURE__*/ React.createElement(_reactNative.Animated.View, {
                pointerEvents: this.drawerShown ? "auto" : "none",
                ref: this.pointerEventsView,
                style: [
                    styles.overlay,
                    dynamicOverlayStyles
                ]
            }));
        });
        _defineProperty(this, "renderDrawer", ()=>{
            const { drawerBackgroundColor, drawerWidth, drawerPosition, drawerType, drawerContainerStyle, contentContainerStyle } = this.props;
            const fromLeft = drawerPosition === "left";
            const drawerSlide = drawerType !== "back";
            const containerSlide = drawerType !== "front"; // we rely on row and row-reverse flex directions to position the drawer
            // properly. Apparently for RTL these are flipped which requires us to use
            // the opposite setting for the drawer to appear from left or right
            // according to the drawerPosition prop
            const reverseContentDirection = _reactNative.I18nManager.isRTL ? fromLeft : !fromLeft;
            const dynamicDrawerStyles = {
                backgroundColor: drawerBackgroundColor,
                width: drawerWidth
            };
            const openValue = this.openValue;
            (0, _invariant.default)(openValue, "should be set");
            let containerStyles;
            if (containerSlide) {
                const containerTranslateX = openValue.interpolate({
                    inputRange: [
                        0,
                        1
                    ],
                    outputRange: fromLeft ? [
                        0,
                        drawerWidth
                    ] : [
                        0,
                        -drawerWidth
                    ],
                    extrapolate: "clamp"
                });
                containerStyles = {
                    transform: [
                        {
                            translateX: containerTranslateX
                        }
                    ]
                };
            }
            let drawerTranslateX = 0;
            if (drawerSlide) {
                const closedDrawerOffset = fromLeft ? -drawerWidth : drawerWidth;
                if (this.state.drawerState !== IDLE) {
                    drawerTranslateX = openValue.interpolate({
                        inputRange: [
                            0,
                            1
                        ],
                        outputRange: [
                            closedDrawerOffset,
                            0
                        ],
                        extrapolate: "clamp"
                    });
                } else {
                    drawerTranslateX = this.state.drawerOpened ? 0 : closedDrawerOffset;
                }
            }
            const drawerStyles = {
                transform: [
                    {
                        translateX: drawerTranslateX
                    }
                ],
                flexDirection: reverseContentDirection ? "row-reverse" : "row"
            };
            return /*#__PURE__*/ React.createElement(_reactNative.Animated.View, {
                style: styles.main,
                onLayout: this.handleContainerLayout
            }, /*#__PURE__*/ React.createElement(_reactNative.Animated.View, {
                style: [
                    drawerType === "front" ? styles.containerOnBack : styles.containerInFront,
                    containerStyles,
                    contentContainerStyle
                ],
                importantForAccessibility: this.drawerShown ? "no-hide-descendants" : "yes"
            }, typeof this.props.children === "function" ? this.props.children(this.openValue) : this.props.children, this.renderOverlay()), /*#__PURE__*/ React.createElement(_reactNative.Animated.View, {
                pointerEvents: "box-none",
                ref: this.accessibilityIsModalView,
                accessibilityViewIsModal: this.drawerShown,
                style: [
                    styles.drawerContainer,
                    drawerStyles,
                    drawerContainerStyle
                ]
            }, /*#__PURE__*/ React.createElement(_reactNative.View, {
                style: dynamicDrawerStyles
            }, this.props.renderNavigationView(this.openValue))));
        });
        _defineProperty(this, "setPanGestureRef", (ref)=>{
            var _this$props$onGesture, _this$props5;
            // TODO(TS): make sure it is OK taken from
            // https://github.com/DefinitelyTyped/DefinitelyTyped/issues/31065#issuecomment-596081842
            this.panGestureHandler.current = ref;
            (_this$props$onGesture = (_this$props5 = this.props).onGestureRef) === null || _this$props$onGesture === void 0 ? void 0 : _this$props$onGesture.call(_this$props5, ref);
        });
        const _dragX = new _reactNative.Animated.Value(0);
        const _touchX = new _reactNative.Animated.Value(0);
        const _drawerTranslation = new _reactNative.Animated.Value(0);
        this.state = {
            dragX: _dragX,
            touchX: _touchX,
            drawerTranslation: _drawerTranslation,
            containerWidth: 0,
            drawerState: IDLE,
            drawerOpened: false
        };
        this.updateAnimatedEvent(_props, this.state);
    }
    shouldComponentUpdate(props, state) {
        if (this.props.drawerPosition !== props.drawerPosition || this.props.drawerWidth !== props.drawerWidth || this.props.drawerType !== props.drawerType || this.state.containerWidth !== state.containerWidth) {
            this.updateAnimatedEvent(props, state);
        }
        return true;
    }
    render() {
        const { drawerPosition, drawerLockMode, edgeWidth, minSwipeDistance } = this.props;
        const fromLeft = drawerPosition === "left"; // gestureOrientation is 1 if the expected gesture is from left to right and
        // -1 otherwise e.g. when drawer is on the left and is closed we expect left
        // to right gesture, thus orientation will be 1.
        const gestureOrientation = (fromLeft ? 1 : -1) * (this.drawerShown ? -1 : 1); // When drawer is closed we want the hitSlop to be horizontally shorter than
        // the container size by the value of SLOP. This will make it only activate
        // when gesture happens not further than SLOP away from the edge
        const hitSlop = fromLeft ? {
            left: 0,
            width: this.drawerShown ? undefined : edgeWidth
        } : {
            right: 0,
            width: this.drawerShown ? undefined : edgeWidth
        };
        return /*#__PURE__*/ React.createElement(_PanGestureHandler.PanGestureHandler // @ts-ignore could be fixed in handler types
        , {
            userSelect: this.props.userSelect,
            ref: this.setPanGestureRef,
            hitSlop: hitSlop,
            activeOffsetX: gestureOrientation * minSwipeDistance,
            failOffsetY: [
                -15,
                15
            ],
            onGestureEvent: this.onGestureEvent,
            onHandlerStateChange: this.openingHandlerStateChange,
            enableTrackpadTwoFingerGesture: this.props.enableTrackpadTwoFingerGesture,
            enabled: drawerLockMode !== "locked-closed" && drawerLockMode !== "locked-open"
        }, this.renderDrawer());
    }
}
exports["default"] = DrawerLayout;
_defineProperty(DrawerLayout, "defaultProps", {
    drawerWidth: 200,
    drawerPosition: "left",
    useNativeAnimations: true,
    drawerType: "front",
    edgeWidth: 20,
    minSwipeDistance: 3,
    overlayColor: "rgba(0, 0, 0, 0.7)",
    drawerLockMode: "unlocked",
    enableTrackpadTwoFingerGesture: false
});
_defineProperty(DrawerLayout, "positions", {
    Left: "left",
    Right: "right"
});
const styles = _reactNative.StyleSheet.create({
    drawerContainer: {
        ..._reactNative.StyleSheet.absoluteFillObject,
        zIndex: 1001,
        flexDirection: "row"
    },
    containerInFront: {
        ..._reactNative.StyleSheet.absoluteFillObject,
        zIndex: 1002
    },
    containerOnBack: {
        ..._reactNative.StyleSheet.absoluteFillObject
    },
    main: {
        flex: 1,
        zIndex: 0,
        overflow: "hidden"
    },
    overlay: {
        ..._reactNative.StyleSheet.absoluteFillObject,
        zIndex: 1000
    }
}); //# sourceMappingURL=DrawerLayout.js.map


/***/ }),

/***/ 91142:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "PureNativeButton", ({
    enumerable: true,
    get: function() {
        return _GestureHandlerButton.default;
    }
}));
exports.BorderlessButton = exports.RectButton = exports.BaseButton = exports.RawButton = void 0;
var React = _interopRequireWildcard(__webpack_require__(16689));
var _reactNative = __webpack_require__(83849);
var _createNativeWrapper = _interopRequireDefault(__webpack_require__(54625));
var _GestureHandlerButton = _interopRequireDefault(__webpack_require__(16561));
var _State = __webpack_require__(10125);
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function _getRequireWildcardCache() {
    if (typeof WeakMap !== "function") return null;
    var cache = new WeakMap();
    _getRequireWildcardCache = function() {
        return cache;
    };
    return cache;
}
function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache();
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {};
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
function _extends() {
    _extends = Object.assign || function(target) {
        for(var i = 1; i < arguments.length; i++){
            var source = arguments[i];
            for(var key in source){
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                }
            }
        }
        return target;
    };
    return _extends.apply(this, arguments);
}
function _defineProperty(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
const RawButton = (0, _createNativeWrapper.default)(_GestureHandlerButton.default, {
    shouldCancelWhenOutside: false,
    shouldActivateOnStart: false
});
exports.RawButton = RawButton;
class BaseButton extends React.Component {
    constructor(props){
        super(props);
        _defineProperty(this, "lastActive", void 0);
        _defineProperty(this, "longPressTimeout", void 0);
        _defineProperty(this, "longPressDetected", void 0);
        _defineProperty(this, "handleEvent", ({ nativeEvent })=>{
            const { state, oldState, pointerInside } = nativeEvent;
            const active = pointerInside && state === _State.State.ACTIVE;
            if (active !== this.lastActive && this.props.onActiveStateChange) {
                this.props.onActiveStateChange(active);
            }
            if (!this.longPressDetected && oldState === _State.State.ACTIVE && state !== _State.State.CANCELLED && this.lastActive && this.props.onPress) {
                this.props.onPress(active);
            }
            if (!this.lastActive && // NativeViewGestureHandler sends different events based on platform
            state === (_reactNative.Platform.OS !== "android" ? _State.State.ACTIVE : _State.State.BEGAN) && pointerInside) {
                this.longPressDetected = false;
                if (this.props.onLongPress) {
                    this.longPressTimeout = setTimeout(this.onLongPress, this.props.delayLongPress);
                }
            } else if (state === _State.State.ACTIVE && !pointerInside && this.longPressTimeout !== undefined) {
                clearTimeout(this.longPressTimeout);
                this.longPressTimeout = undefined;
            } else if (this.longPressTimeout !== undefined && (state === _State.State.END || state === _State.State.CANCELLED || state === _State.State.FAILED)) {
                clearTimeout(this.longPressTimeout);
                this.longPressTimeout = undefined;
            }
            this.lastActive = active;
        });
        _defineProperty(this, "onLongPress", ()=>{
            var _this$props$onLongPre, _this$props;
            this.longPressDetected = true;
            (_this$props$onLongPre = (_this$props = this.props).onLongPress) === null || _this$props$onLongPre === void 0 ? void 0 : _this$props$onLongPre.call(_this$props);
        });
        _defineProperty(this, "onHandlerStateChange", (e)=>{
            var _this$props$onHandler, _this$props2;
            (_this$props$onHandler = (_this$props2 = this.props).onHandlerStateChange) === null || _this$props$onHandler === void 0 ? void 0 : _this$props$onHandler.call(_this$props2, e);
            this.handleEvent(e);
        });
        _defineProperty(this, "onGestureEvent", (e)=>{
            var _this$props$onGesture, _this$props3;
            (_this$props$onGesture = (_this$props3 = this.props).onGestureEvent) === null || _this$props$onGesture === void 0 ? void 0 : _this$props$onGesture.call(_this$props3, e);
            this.handleEvent(e); // TODO: maybe it is not correct
        });
        this.lastActive = false;
        this.longPressDetected = false;
    }
    render() {
        const { rippleColor, ...rest } = this.props;
        return /*#__PURE__*/ React.createElement(RawButton, _extends({
            rippleColor: (0, _reactNative.processColor)(rippleColor)
        }, rest, {
            onGestureEvent: this.onGestureEvent,
            onHandlerStateChange: this.onHandlerStateChange
        }));
    }
}
exports.BaseButton = BaseButton;
_defineProperty(BaseButton, "defaultProps", {
    delayLongPress: 600
});
const AnimatedBaseButton = _reactNative.Animated.createAnimatedComponent(BaseButton);
const btnStyles = _reactNative.StyleSheet.create({
    underlay: {
        position: "absolute",
        left: 0,
        right: 0,
        bottom: 0,
        top: 0
    }
});
class RectButton extends React.Component {
    constructor(props){
        super(props);
        _defineProperty(this, "opacity", void 0);
        _defineProperty(this, "onActiveStateChange", (active)=>{
            var _this$props$onActiveS, _this$props4;
            if (_reactNative.Platform.OS !== "android") {
                this.opacity.setValue(active ? this.props.activeOpacity : 0);
            }
            (_this$props$onActiveS = (_this$props4 = this.props).onActiveStateChange) === null || _this$props$onActiveS === void 0 ? void 0 : _this$props$onActiveS.call(_this$props4, active);
        });
        this.opacity = new _reactNative.Animated.Value(0);
    }
    render() {
        const { children, style, ...rest } = this.props;
        const resolvedStyle = _reactNative.StyleSheet.flatten(style !== null && style !== void 0 ? style : {});
        return /*#__PURE__*/ React.createElement(BaseButton, _extends({}, rest, {
            style: resolvedStyle,
            onActiveStateChange: this.onActiveStateChange
        }), /*#__PURE__*/ React.createElement(_reactNative.Animated.View, {
            style: [
                btnStyles.underlay,
                {
                    opacity: this.opacity,
                    backgroundColor: this.props.underlayColor,
                    borderRadius: resolvedStyle.borderRadius,
                    borderTopLeftRadius: resolvedStyle.borderTopLeftRadius,
                    borderTopRightRadius: resolvedStyle.borderTopRightRadius,
                    borderBottomLeftRadius: resolvedStyle.borderBottomLeftRadius,
                    borderBottomRightRadius: resolvedStyle.borderBottomRightRadius
                }
            ]
        }), children);
    }
}
exports.RectButton = RectButton;
_defineProperty(RectButton, "defaultProps", {
    activeOpacity: 0.105,
    underlayColor: "black"
});
class BorderlessButton extends React.Component {
    constructor(props){
        super(props);
        _defineProperty(this, "opacity", void 0);
        _defineProperty(this, "onActiveStateChange", (active)=>{
            var _this$props$onActiveS2, _this$props5;
            if (_reactNative.Platform.OS !== "android") {
                this.opacity.setValue(active ? this.props.activeOpacity : 1);
            }
            (_this$props$onActiveS2 = (_this$props5 = this.props).onActiveStateChange) === null || _this$props$onActiveS2 === void 0 ? void 0 : _this$props$onActiveS2.call(_this$props5, active);
        });
        this.opacity = new _reactNative.Animated.Value(1);
    }
    render() {
        const { children, style, ...rest } = this.props;
        return /*#__PURE__*/ React.createElement(AnimatedBaseButton, _extends({}, rest, {
            onActiveStateChange: this.onActiveStateChange,
            style: [
                style,
                _reactNative.Platform.OS === "ios" && {
                    opacity: this.opacity
                }
            ]
        }), children);
    }
}
exports.BorderlessButton = BorderlessButton;
_defineProperty(BorderlessButton, "defaultProps", {
    activeOpacity: 0.3,
    borderless: true
}); //# sourceMappingURL=GestureButtons.js.map


/***/ }),

/***/ 28226:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.FlatList = exports.RefreshControl = exports.DrawerLayoutAndroid = exports.TextInput = exports.Switch = exports.ScrollView = void 0;
var React = _interopRequireWildcard(__webpack_require__(16689));
var _reactNative = __webpack_require__(83849);
var _createNativeWrapper = _interopRequireDefault(__webpack_require__(54625));
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function _getRequireWildcardCache() {
    if (typeof WeakMap !== "function") return null;
    var cache = new WeakMap();
    _getRequireWildcardCache = function() {
        return cache;
    };
    return cache;
}
function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache();
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {};
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
function _extends() {
    _extends = Object.assign || function(target) {
        for(var i = 1; i < arguments.length; i++){
            var source = arguments[i];
            for(var key in source){
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                }
            }
        }
        return target;
    };
    return _extends.apply(this, arguments);
}
const ScrollView = (0, _createNativeWrapper.default)(_reactNative.ScrollView, {
    disallowInterruption: false
});
exports.ScrollView = ScrollView;
const Switch = (0, _createNativeWrapper.default)(_reactNative.Switch, {
    shouldCancelWhenOutside: false,
    shouldActivateOnStart: true,
    disallowInterruption: true
});
exports.Switch = Switch;
const TextInput = (0, _createNativeWrapper.default)(_reactNative.TextInput);
exports.TextInput = TextInput;
const DrawerLayoutAndroid = ()=>{
    console.warn("DrawerLayoutAndroid is not supported on web!");
    return /*#__PURE__*/ React.createElement(_reactNative.View, null);
}; // RefreshControl is implemented as a functional component, rendering a View
// NativeViewGestureHandler needs to set a ref on its child, which cannot be done
// on functional components
exports.DrawerLayoutAndroid = DrawerLayoutAndroid;
const RefreshControl = (0, _createNativeWrapper.default)(_reactNative.View);
exports.RefreshControl = RefreshControl;
const FlatList = /*#__PURE__*/ React.forwardRef((props, ref)=>/*#__PURE__*/ React.createElement(_reactNative.FlatList, _extends({
        ref: ref
    }, props, {
        renderScrollComponent: (scrollProps)=>/*#__PURE__*/ React.createElement(ScrollView, scrollProps)
    })));
exports.FlatList = FlatList; //# sourceMappingURL=GestureComponents.web.js.map


/***/ }),

/***/ 16561:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports["default"] = void 0;
var React = _interopRequireWildcard(__webpack_require__(16689));
var _reactNative = __webpack_require__(83849);
function _getRequireWildcardCache() {
    if (typeof WeakMap !== "function") return null;
    var cache = new WeakMap();
    _getRequireWildcardCache = function() {
        return cache;
    };
    return cache;
}
function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache();
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {};
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
function _extends() {
    _extends = Object.assign || function(target) {
        for(var i = 1; i < arguments.length; i++){
            var source = arguments[i];
            for(var key in source){
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                }
            }
        }
        return target;
    };
    return _extends.apply(this, arguments);
}
var _default = /*#__PURE__*/ React.forwardRef((props, ref)=>/*#__PURE__*/ React.createElement(_reactNative.View, _extends({
        ref: ref,
        accessibilityRole: "button"
    }, props)));
exports["default"] = _default; //# sourceMappingURL=GestureHandlerButton.web.js.map


/***/ }),

/***/ 40946:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports["default"] = GestureHandlerRootView;
var React = _interopRequireWildcard(__webpack_require__(16689));
var _reactNative = __webpack_require__(83849);
var _GestureHandlerRootViewContext = _interopRequireDefault(__webpack_require__(49704));
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function _getRequireWildcardCache() {
    if (typeof WeakMap !== "function") return null;
    var cache = new WeakMap();
    _getRequireWildcardCache = function() {
        return cache;
    };
    return cache;
}
function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache();
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {};
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
function GestureHandlerRootView(props) {
    return /*#__PURE__*/ React.createElement(_GestureHandlerRootViewContext.default.Provider, {
        value: true
    }, /*#__PURE__*/ React.createElement(_reactNative.View, props));
} //# sourceMappingURL=GestureHandlerRootView.web.js.map


/***/ }),

/***/ 14407:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports["default"] = void 0;
var React = _interopRequireWildcard(__webpack_require__(16689));
var _reactNative = __webpack_require__(83849);
var _PanGestureHandler = __webpack_require__(78673);
var _TapGestureHandler = __webpack_require__(91418);
var _State = __webpack_require__(10125);
function _getRequireWildcardCache() {
    if (typeof WeakMap !== "function") return null;
    var cache = new WeakMap();
    _getRequireWildcardCache = function() {
        return cache;
    };
    return cache;
}
function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache();
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {};
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
function _extends() {
    _extends = Object.assign || function(target) {
        for(var i = 1; i < arguments.length; i++){
            var source = arguments[i];
            for(var key in source){
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                }
            }
        }
        return target;
    };
    return _extends.apply(this, arguments);
}
function _defineProperty(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
const DRAG_TOSS = 0.05;
class Swipeable extends React.Component {
    constructor(_props){
        super(_props);
        _defineProperty(this, "onGestureEvent", void 0);
        _defineProperty(this, "transX", void 0);
        _defineProperty(this, "showLeftAction", void 0);
        _defineProperty(this, "leftActionTranslate", void 0);
        _defineProperty(this, "showRightAction", void 0);
        _defineProperty(this, "rightActionTranslate", void 0);
        _defineProperty(this, "updateAnimatedEvent", (props, state)=>{
            const { friction, overshootFriction } = props;
            const { dragX, rowTranslation, leftWidth = 0, rowWidth = 0 } = state;
            const { rightOffset = rowWidth } = state;
            const rightWidth = Math.max(0, rowWidth - rightOffset);
            const { overshootLeft = leftWidth > 0, overshootRight = rightWidth > 0 } = props;
            const transX = _reactNative.Animated.add(rowTranslation, dragX.interpolate({
                inputRange: [
                    0,
                    friction
                ],
                outputRange: [
                    0,
                    1
                ]
            })).interpolate({
                inputRange: [
                    -rightWidth - 1,
                    -rightWidth,
                    leftWidth,
                    leftWidth + 1
                ],
                outputRange: [
                    -rightWidth - (overshootRight ? 1 / overshootFriction : 0),
                    -rightWidth,
                    leftWidth,
                    leftWidth + (overshootLeft ? 1 / overshootFriction : 0)
                ]
            });
            this.transX = transX;
            this.showLeftAction = leftWidth > 0 ? transX.interpolate({
                inputRange: [
                    -1,
                    0,
                    leftWidth
                ],
                outputRange: [
                    0,
                    0,
                    1
                ]
            }) : new _reactNative.Animated.Value(0);
            this.leftActionTranslate = this.showLeftAction.interpolate({
                inputRange: [
                    0,
                    Number.MIN_VALUE
                ],
                outputRange: [
                    -10000,
                    0
                ],
                extrapolate: "clamp"
            });
            this.showRightAction = rightWidth > 0 ? transX.interpolate({
                inputRange: [
                    -rightWidth,
                    0,
                    1
                ],
                outputRange: [
                    1,
                    0,
                    0
                ]
            }) : new _reactNative.Animated.Value(0);
            this.rightActionTranslate = this.showRightAction.interpolate({
                inputRange: [
                    0,
                    Number.MIN_VALUE
                ],
                outputRange: [
                    -10000,
                    0
                ],
                extrapolate: "clamp"
            });
        });
        _defineProperty(this, "onTapHandlerStateChange", ({ nativeEvent })=>{
            if (nativeEvent.oldState === _State.State.ACTIVE) {
                this.close();
            }
        });
        _defineProperty(this, "onHandlerStateChange", (ev)=>{
            if (ev.nativeEvent.oldState === _State.State.ACTIVE) {
                this.handleRelease(ev);
            }
        });
        _defineProperty(this, "handleRelease", (ev)=>{
            const { velocityX, translationX: dragX } = ev.nativeEvent;
            const { leftWidth = 0, rowWidth = 0, rowState } = this.state;
            const { rightOffset = rowWidth } = this.state;
            const rightWidth = rowWidth - rightOffset;
            const { friction, leftThreshold = leftWidth / 2, rightThreshold = rightWidth / 2 } = this.props;
            const startOffsetX = this.currentOffset() + dragX / friction;
            const translationX = (dragX + DRAG_TOSS * velocityX) / friction;
            let toValue = 0;
            if (rowState === 0) {
                if (translationX > leftThreshold) {
                    toValue = leftWidth;
                } else if (translationX < -rightThreshold) {
                    toValue = -rightWidth;
                }
            } else if (rowState === 1) {
                // swiped to left
                if (translationX > -leftThreshold) {
                    toValue = leftWidth;
                }
            } else {
                // swiped to right
                if (translationX < rightThreshold) {
                    toValue = -rightWidth;
                }
            }
            this.animateRow(startOffsetX, toValue, velocityX / friction);
        });
        _defineProperty(this, "animateRow", (fromValue, toValue, velocityX)=>{
            const { dragX, rowTranslation } = this.state;
            dragX.setValue(0);
            rowTranslation.setValue(fromValue);
            this.setState({
                rowState: Math.sign(toValue)
            });
            _reactNative.Animated.spring(rowTranslation, {
                restSpeedThreshold: 1.7,
                restDisplacementThreshold: 0.4,
                velocity: velocityX,
                bounciness: 0,
                toValue,
                useNativeDriver: this.props.useNativeAnimations,
                ...this.props.animationOptions
            }).start(({ finished })=>{
                if (finished) {
                    if (toValue > 0) {
                        var _this$props$onSwipeab, _this$props, _this$props$onSwipeab2, _this$props2;
                        (_this$props$onSwipeab = (_this$props = this.props).onSwipeableLeftOpen) === null || _this$props$onSwipeab === void 0 ? void 0 : _this$props$onSwipeab.call(_this$props);
                        (_this$props$onSwipeab2 = (_this$props2 = this.props).onSwipeableOpen) === null || _this$props$onSwipeab2 === void 0 ? void 0 : _this$props$onSwipeab2.call(_this$props2, "left", this);
                    } else if (toValue < 0) {
                        var _this$props$onSwipeab3, _this$props3, _this$props$onSwipeab4, _this$props4;
                        (_this$props$onSwipeab3 = (_this$props3 = this.props).onSwipeableRightOpen) === null || _this$props$onSwipeab3 === void 0 ? void 0 : _this$props$onSwipeab3.call(_this$props3);
                        (_this$props$onSwipeab4 = (_this$props4 = this.props).onSwipeableOpen) === null || _this$props$onSwipeab4 === void 0 ? void 0 : _this$props$onSwipeab4.call(_this$props4, "right", this);
                    } else {
                        var _this$props$onSwipeab5, _this$props5;
                        const closingDirection = fromValue > 0 ? "left" : "right";
                        (_this$props$onSwipeab5 = (_this$props5 = this.props).onSwipeableClose) === null || _this$props$onSwipeab5 === void 0 ? void 0 : _this$props$onSwipeab5.call(_this$props5, closingDirection, this);
                    }
                }
            });
            if (toValue > 0) {
                var _this$props$onSwipeab6, _this$props6, _this$props$onSwipeab7, _this$props7;
                (_this$props$onSwipeab6 = (_this$props6 = this.props).onSwipeableLeftWillOpen) === null || _this$props$onSwipeab6 === void 0 ? void 0 : _this$props$onSwipeab6.call(_this$props6);
                (_this$props$onSwipeab7 = (_this$props7 = this.props).onSwipeableWillOpen) === null || _this$props$onSwipeab7 === void 0 ? void 0 : _this$props$onSwipeab7.call(_this$props7, "left");
            } else if (toValue < 0) {
                var _this$props$onSwipeab8, _this$props8, _this$props$onSwipeab9, _this$props9;
                (_this$props$onSwipeab8 = (_this$props8 = this.props).onSwipeableRightWillOpen) === null || _this$props$onSwipeab8 === void 0 ? void 0 : _this$props$onSwipeab8.call(_this$props8);
                (_this$props$onSwipeab9 = (_this$props9 = this.props).onSwipeableWillOpen) === null || _this$props$onSwipeab9 === void 0 ? void 0 : _this$props$onSwipeab9.call(_this$props9, "right");
            } else {
                var _this$props$onSwipeab10, _this$props10;
                const closingDirection = fromValue > 0 ? "left" : "right";
                (_this$props$onSwipeab10 = (_this$props10 = this.props).onSwipeableWillClose) === null || _this$props$onSwipeab10 === void 0 ? void 0 : _this$props$onSwipeab10.call(_this$props10, closingDirection);
            }
        });
        _defineProperty(this, "onRowLayout", ({ nativeEvent })=>{
            this.setState({
                rowWidth: nativeEvent.layout.width
            });
        });
        _defineProperty(this, "currentOffset", ()=>{
            const { leftWidth = 0, rowWidth = 0, rowState } = this.state;
            const { rightOffset = rowWidth } = this.state;
            const rightWidth = rowWidth - rightOffset;
            if (rowState === 1) {
                return leftWidth;
            } else if (rowState === -1) {
                return -rightWidth;
            }
            return 0;
        });
        _defineProperty(this, "close", ()=>{
            this.animateRow(this.currentOffset(), 0);
        });
        _defineProperty(this, "openLeft", ()=>{
            const { leftWidth = 0 } = this.state;
            this.animateRow(this.currentOffset(), leftWidth);
        });
        _defineProperty(this, "openRight", ()=>{
            const { rowWidth = 0 } = this.state;
            const { rightOffset = rowWidth } = this.state;
            const rightWidth = rowWidth - rightOffset;
            this.animateRow(this.currentOffset(), -rightWidth);
        });
        _defineProperty(this, "reset", ()=>{
            const { dragX, rowTranslation } = this.state;
            dragX.setValue(0);
            rowTranslation.setValue(0);
            this.setState({
                rowState: 0
            });
        });
        const _dragX = new _reactNative.Animated.Value(0);
        this.state = {
            dragX: _dragX,
            rowTranslation: new _reactNative.Animated.Value(0),
            rowState: 0,
            leftWidth: undefined,
            rightOffset: undefined,
            rowWidth: undefined
        };
        this.updateAnimatedEvent(_props, this.state);
        this.onGestureEvent = _reactNative.Animated.event([
            {
                nativeEvent: {
                    translationX: _dragX
                }
            }
        ], {
            useNativeDriver: _props.useNativeAnimations
        });
    }
    shouldComponentUpdate(props, state) {
        if (this.props.friction !== props.friction || this.props.overshootLeft !== props.overshootLeft || this.props.overshootRight !== props.overshootRight || this.props.overshootFriction !== props.overshootFriction || this.state.leftWidth !== state.leftWidth || this.state.rightOffset !== state.rightOffset || this.state.rowWidth !== state.rowWidth) {
            this.updateAnimatedEvent(props, state);
        }
        return true;
    }
    render() {
        const { rowState } = this.state;
        const { children, renderLeftActions, renderRightActions, dragOffsetFromLeftEdge = 10, dragOffsetFromRightEdge = 10 } = this.props;
        const left = renderLeftActions && /*#__PURE__*/ React.createElement(_reactNative.Animated.View, {
            style: [
                styles.leftActions,
                // asigned in constructor in `updateAnimatedEvent` but TS cannot spot
                // it for some reason
                {
                    transform: [
                        {
                            translateX: this.leftActionTranslate
                        }
                    ]
                }
            ]
        }, renderLeftActions(this.showLeftAction, this.transX, this), /*#__PURE__*/ React.createElement(_reactNative.View, {
            onLayout: ({ nativeEvent })=>this.setState({
                    leftWidth: nativeEvent.layout.x
                })
        }));
        const right = renderRightActions && /*#__PURE__*/ React.createElement(_reactNative.Animated.View, {
            style: [
                styles.rightActions,
                {
                    transform: [
                        {
                            translateX: this.rightActionTranslate
                        }
                    ]
                }
            ]
        }, renderRightActions(this.showRightAction, this.transX, this), /*#__PURE__*/ React.createElement(_reactNative.View, {
            onLayout: ({ nativeEvent })=>this.setState({
                    rightOffset: nativeEvent.layout.x
                })
        }));
        return /*#__PURE__*/ React.createElement(_PanGestureHandler.PanGestureHandler, _extends({
            activeOffsetX: [
                -dragOffsetFromRightEdge,
                dragOffsetFromLeftEdge
            ]
        }, this.props, {
            onGestureEvent: this.onGestureEvent,
            onHandlerStateChange: this.onHandlerStateChange
        }), /*#__PURE__*/ React.createElement(_reactNative.Animated.View, {
            onLayout: this.onRowLayout,
            style: [
                styles.container,
                this.props.containerStyle
            ]
        }, left, right, /*#__PURE__*/ React.createElement(_TapGestureHandler.TapGestureHandler, {
            enabled: rowState !== 0,
            onHandlerStateChange: this.onTapHandlerStateChange
        }, /*#__PURE__*/ React.createElement(_reactNative.Animated.View, {
            pointerEvents: rowState === 0 ? "auto" : "box-only",
            style: [
                {
                    transform: [
                        {
                            translateX: this.transX
                        }
                    ]
                },
                this.props.childrenContainerStyle
            ]
        }, children))));
    }
}
exports["default"] = Swipeable;
_defineProperty(Swipeable, "defaultProps", {
    friction: 1,
    overshootFriction: 1,
    useNativeAnimations: true
});
const styles = _reactNative.StyleSheet.create({
    container: {
        overflow: "hidden"
    },
    leftActions: {
        ..._reactNative.StyleSheet.absoluteFillObject,
        flexDirection: _reactNative.I18nManager.isRTL ? "row-reverse" : "row"
    },
    rightActions: {
        ..._reactNative.StyleSheet.absoluteFillObject,
        flexDirection: _reactNative.I18nManager.isRTL ? "row" : "row-reverse"
    }
}); //# sourceMappingURL=Swipeable.js.map


/***/ }),

/***/ 57017:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports["default"] = gestureHandlerRootHOC;
var React = _interopRequireWildcard(__webpack_require__(16689));
var _reactNative = __webpack_require__(83849);
var _hoistNonReactStatics = _interopRequireDefault(__webpack_require__(27318));
var _GestureHandlerRootView = _interopRequireDefault(__webpack_require__(40946));
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function _getRequireWildcardCache() {
    if (typeof WeakMap !== "function") return null;
    var cache = new WeakMap();
    _getRequireWildcardCache = function() {
        return cache;
    };
    return cache;
}
function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache();
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {};
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
function gestureHandlerRootHOC(Component, containerStyles) {
    function Wrapper(props) {
        return /*#__PURE__*/ React.createElement(_GestureHandlerRootView.default, {
            style: [
                styles.container,
                containerStyles
            ]
        }, /*#__PURE__*/ React.createElement(Component, props));
    }
    Wrapper.displayName = `gestureHandlerRootHOC(${Component.displayName || Component.name})`; // @ts-ignore - hoistNonReactStatics uses old version of @types/react
    (0, _hoistNonReactStatics.default)(Wrapper, Component);
    return Wrapper;
}
const styles = _reactNative.StyleSheet.create({
    container: {
        flex: 1
    }
}); //# sourceMappingURL=gestureHandlerRootHOC.js.map


/***/ }),

/***/ 20659:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports["default"] = exports.TOUCHABLE_STATE = void 0;
var React = _interopRequireWildcard(__webpack_require__(16689));
var _reactNative = __webpack_require__(83849);
var _State = __webpack_require__(10125);
var _GestureButtons = __webpack_require__(91142);
function _getRequireWildcardCache() {
    if (typeof WeakMap !== "function") return null;
    var cache = new WeakMap();
    _getRequireWildcardCache = function() {
        return cache;
    };
    return cache;
}
function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache();
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {};
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
function _extends() {
    _extends = Object.assign || function(target) {
        for(var i = 1; i < arguments.length; i++){
            var source = arguments[i];
            for(var key in source){
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                }
            }
        }
        return target;
    };
    return _extends.apply(this, arguments);
}
function _defineProperty(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
/**
 * Each touchable is a states' machine which preforms transitions.
 * On very beginning (and on the very end or recognition) touchable is
 * UNDETERMINED. Then it moves to BEGAN. If touchable recognizes that finger
 * travel outside it transits to special MOVED_OUTSIDE state. Gesture recognition
 * finishes in UNDETERMINED state.
 */ const TOUCHABLE_STATE = {
    UNDETERMINED: 0,
    BEGAN: 1,
    MOVED_OUTSIDE: 2
};
exports.TOUCHABLE_STATE = TOUCHABLE_STATE;
/**
 * GenericTouchable is not intented to be used as it is.
 * Should be treated as a source for the rest of touchables
 */ class GenericTouchable extends React.Component {
    constructor(...args){
        super(...args);
        _defineProperty(this, "pressInTimeout", void 0);
        _defineProperty(this, "pressOutTimeout", void 0);
        _defineProperty(this, "longPressTimeout", void 0);
        _defineProperty(this, "longPressDetected", false);
        _defineProperty(this, "pointerInside", true);
        _defineProperty(this, "STATE", TOUCHABLE_STATE.UNDETERMINED);
        _defineProperty(this, "onGestureEvent", ({ nativeEvent: { pointerInside } })=>{
            if (this.pointerInside !== pointerInside) {
                if (pointerInside) {
                    this.onMoveIn();
                } else {
                    this.onMoveOut();
                }
            }
            this.pointerInside = pointerInside;
        });
        _defineProperty(this, "onHandlerStateChange", ({ nativeEvent })=>{
            const { state } = nativeEvent;
            if (state === _State.State.CANCELLED || state === _State.State.FAILED) {
                // Need to handle case with external cancellation (e.g. by ScrollView)
                this.moveToState(TOUCHABLE_STATE.UNDETERMINED);
            } else if (// And Android "Active" state is achieving on first move of a finger, not on press in.
            // On iOS event on "Began" is not delivered.
            state === (_reactNative.Platform.OS !== "android" ? _State.State.ACTIVE : _State.State.BEGAN) && this.STATE === TOUCHABLE_STATE.UNDETERMINED) {
                // Moving inside requires
                this.handlePressIn();
            } else if (state === _State.State.END) {
                const shouldCallOnPress = !this.longPressDetected && this.STATE !== TOUCHABLE_STATE.MOVED_OUTSIDE && this.pressOutTimeout === null;
                this.handleGoToUndetermined();
                if (shouldCallOnPress) {
                    var _this$props$onPress, _this$props;
                    // Calls only inside component whether no long press was called previously
                    (_this$props$onPress = (_this$props = this.props).onPress) === null || _this$props$onPress === void 0 ? void 0 : _this$props$onPress.call(_this$props);
                }
            }
        });
        _defineProperty(this, "onLongPressDetected", ()=>{
            var _this$props$onLongPre, _this$props2;
            this.longPressDetected = true; // checked for in the caller of `onLongPressDetected`, but better to check twice
            (_this$props$onLongPre = (_this$props2 = this.props).onLongPress) === null || _this$props$onLongPre === void 0 ? void 0 : _this$props$onLongPre.call(_this$props2);
        });
    }
    // handlePressIn in called on first touch on traveling inside component.
    // Handles state transition with delay.
    handlePressIn() {
        if (this.props.delayPressIn) {
            this.pressInTimeout = setTimeout(()=>{
                this.moveToState(TOUCHABLE_STATE.BEGAN);
                this.pressInTimeout = null;
            }, this.props.delayPressIn);
        } else {
            this.moveToState(TOUCHABLE_STATE.BEGAN);
        }
        if (this.props.onLongPress) {
            const time = (this.props.delayPressIn || 0) + (this.props.delayLongPress || 0);
            this.longPressTimeout = setTimeout(this.onLongPressDetected, time);
        }
    }
    // Handles state transition with delay.
    handleMoveOutside() {
        if (this.props.delayPressOut) {
            this.pressOutTimeout = this.pressOutTimeout || setTimeout(()=>{
                this.moveToState(TOUCHABLE_STATE.MOVED_OUTSIDE);
                this.pressOutTimeout = null;
            }, this.props.delayPressOut);
        } else {
            this.moveToState(TOUCHABLE_STATE.MOVED_OUTSIDE);
        }
    }
    handleGoToUndetermined() {
        clearTimeout(this.pressOutTimeout); // TODO: maybe it can be undefined
        if (this.props.delayPressOut) {
            this.pressOutTimeout = setTimeout(()=>{
                if (this.STATE === TOUCHABLE_STATE.UNDETERMINED) {
                    this.moveToState(TOUCHABLE_STATE.BEGAN);
                }
                this.moveToState(TOUCHABLE_STATE.UNDETERMINED);
                this.pressOutTimeout = null;
            }, this.props.delayPressOut);
        } else {
            if (this.STATE === TOUCHABLE_STATE.UNDETERMINED) {
                this.moveToState(TOUCHABLE_STATE.BEGAN);
            }
            this.moveToState(TOUCHABLE_STATE.UNDETERMINED);
        }
    }
    componentDidMount() {
        this.reset();
    }
    reset() {
        this.longPressDetected = false;
        this.pointerInside = true;
        clearTimeout(this.pressInTimeout);
        clearTimeout(this.pressOutTimeout);
        clearTimeout(this.longPressTimeout);
        this.pressOutTimeout = null;
        this.longPressTimeout = null;
        this.pressInTimeout = null;
    }
    moveToState(newState) {
        var _this$props$onStateCh, _this$props6;
        if (newState === this.STATE) {
            // Ignore dummy transitions
            return;
        }
        if (newState === TOUCHABLE_STATE.BEGAN) {
            var _this$props$onPressIn, _this$props3;
            // First touch and moving inside
            (_this$props$onPressIn = (_this$props3 = this.props).onPressIn) === null || _this$props$onPressIn === void 0 ? void 0 : _this$props$onPressIn.call(_this$props3);
        } else if (newState === TOUCHABLE_STATE.MOVED_OUTSIDE) {
            var _this$props$onPressOu, _this$props4;
            // Moving outside
            (_this$props$onPressOu = (_this$props4 = this.props).onPressOut) === null || _this$props$onPressOu === void 0 ? void 0 : _this$props$onPressOu.call(_this$props4);
        } else if (newState === TOUCHABLE_STATE.UNDETERMINED) {
            // Need to reset each time on transition to UNDETERMINED
            this.reset();
            if (this.STATE === TOUCHABLE_STATE.BEGAN) {
                var _this$props$onPressOu2, _this$props5;
                // ... and if it happens inside button.
                (_this$props$onPressOu2 = (_this$props5 = this.props).onPressOut) === null || _this$props$onPressOu2 === void 0 ? void 0 : _this$props$onPressOu2.call(_this$props5);
            }
        } // Finally call lister (used by subclasses)
        (_this$props$onStateCh = (_this$props6 = this.props).onStateChange) === null || _this$props$onStateCh === void 0 ? void 0 : _this$props$onStateCh.call(_this$props6, this.STATE, newState); // ... and make transition.
        this.STATE = newState;
    }
    componentWillUnmount() {
        // to prevent memory leaks
        this.reset();
    }
    onMoveIn() {
        if (this.STATE === TOUCHABLE_STATE.MOVED_OUTSIDE) {
            // This call is not throttled with delays (like in RN's implementation).
            this.moveToState(TOUCHABLE_STATE.BEGAN);
        }
    }
    onMoveOut() {
        // long press should no longer be detected
        clearTimeout(this.longPressTimeout);
        this.longPressTimeout = null;
        if (this.STATE === TOUCHABLE_STATE.BEGAN) {
            this.handleMoveOutside();
        }
    }
    render() {
        var _ref, _this$props$touchSoun;
        const hitSlop = (_ref = typeof this.props.hitSlop === "number" ? {
            top: this.props.hitSlop,
            left: this.props.hitSlop,
            bottom: this.props.hitSlop,
            right: this.props.hitSlop
        } : this.props.hitSlop) !== null && _ref !== void 0 ? _ref : undefined;
        const coreProps = {
            accessible: this.props.accessible !== false,
            accessibilityLabel: this.props.accessibilityLabel,
            accessibilityHint: this.props.accessibilityHint,
            accessibilityRole: this.props.accessibilityRole,
            // TODO: check if changed to no 's' correctly, also removed 2 props that are no longer available: `accessibilityComponentType` and `accessibilityTraits`,
            // would be good to check if it is ok for sure, see: https://github.com/facebook/react-native/issues/24016
            accessibilityState: this.props.accessibilityState,
            accessibilityActions: this.props.accessibilityActions,
            onAccessibilityAction: this.props.onAccessibilityAction,
            nativeID: this.props.nativeID,
            onLayout: this.props.onLayout,
            hitSlop: hitSlop
        };
        return /*#__PURE__*/ React.createElement(_GestureButtons.BaseButton, _extends({
            style: this.props.containerStyle,
            onHandlerStateChange: this.props.disabled ? undefined : this.onHandlerStateChange,
            onGestureEvent: this.onGestureEvent,
            hitSlop: hitSlop,
            shouldActivateOnStart: this.props.shouldActivateOnStart,
            disallowInterruption: this.props.disallowInterruption,
            testID: this.props.testID,
            touchSoundDisabled: (_this$props$touchSoun = this.props.touchSoundDisabled) !== null && _this$props$touchSoun !== void 0 ? _this$props$touchSoun : false,
            enabled: !this.props.disabled
        }, this.props.extraButtonProps), /*#__PURE__*/ React.createElement(_reactNative.Animated.View, _extends({}, coreProps, {
            style: this.props.style
        }), this.props.children));
    }
}
exports["default"] = GenericTouchable;
_defineProperty(GenericTouchable, "defaultProps", {
    delayLongPress: 600,
    extraButtonProps: {
        rippleColor: "transparent",
        exclusive: true
    }
}); //# sourceMappingURL=GenericTouchable.js.map


/***/ }),

/***/ 81849:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports["default"] = void 0;
var React = _interopRequireWildcard(__webpack_require__(16689));
var _GenericTouchable = _interopRequireWildcard(__webpack_require__(20659));
var _reactNative = __webpack_require__(83849);
function _getRequireWildcardCache() {
    if (typeof WeakMap !== "function") return null;
    var cache = new WeakMap();
    _getRequireWildcardCache = function() {
        return cache;
    };
    return cache;
}
function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache();
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {};
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
function _extends() {
    _extends = Object.assign || function(target) {
        for(var i = 1; i < arguments.length; i++){
            var source = arguments[i];
            for(var key in source){
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                }
            }
        }
        return target;
    };
    return _extends.apply(this, arguments);
}
function _defineProperty(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
/**
 * TouchableHighlight follows RN's implementation
 */ class TouchableHighlight extends React.Component {
    constructor(props){
        super(props);
        _defineProperty(this, "showUnderlay", ()=>{
            var _this$props$onShowUnd, _this$props;
            if (!this.hasPressHandler()) {
                return;
            }
            this.setState({
                extraChildStyle: {
                    opacity: this.props.activeOpacity
                },
                extraUnderlayStyle: {
                    backgroundColor: this.props.underlayColor
                }
            });
            (_this$props$onShowUnd = (_this$props = this.props).onShowUnderlay) === null || _this$props$onShowUnd === void 0 ? void 0 : _this$props$onShowUnd.call(_this$props);
        });
        _defineProperty(this, "hasPressHandler", ()=>this.props.onPress || this.props.onPressIn || this.props.onPressOut || this.props.onLongPress);
        _defineProperty(this, "hideUnderlay", ()=>{
            var _this$props$onHideUnd, _this$props2;
            this.setState({
                extraChildStyle: null,
                extraUnderlayStyle: null
            });
            (_this$props$onHideUnd = (_this$props2 = this.props).onHideUnderlay) === null || _this$props$onHideUnd === void 0 ? void 0 : _this$props$onHideUnd.call(_this$props2);
        });
        _defineProperty(this, "onStateChange", (_from, to)=>{
            if (to === _GenericTouchable.TOUCHABLE_STATE.BEGAN) {
                this.showUnderlay();
            } else if (to === _GenericTouchable.TOUCHABLE_STATE.UNDETERMINED || to === _GenericTouchable.TOUCHABLE_STATE.MOVED_OUTSIDE) {
                this.hideUnderlay();
            }
        });
        this.state = {
            extraChildStyle: null,
            extraUnderlayStyle: null
        };
    }
    renderChildren() {
        if (!this.props.children) {
            return /*#__PURE__*/ React.createElement(_reactNative.View, null);
        }
        const child = React.Children.only(this.props.children); // TODO: not sure if OK but fixes error
        return /*#__PURE__*/ React.cloneElement(child, {
            style: _reactNative.StyleSheet.compose(child.props.style, this.state.extraChildStyle)
        });
    }
    render() {
        const { style = {}, ...rest } = this.props;
        const { extraUnderlayStyle } = this.state;
        return /*#__PURE__*/ React.createElement(_GenericTouchable.default, _extends({}, rest, {
            style: [
                style,
                extraUnderlayStyle
            ],
            onStateChange: this.onStateChange
        }), this.renderChildren());
    }
}
exports["default"] = TouchableHighlight;
_defineProperty(TouchableHighlight, "defaultProps", {
    ..._GenericTouchable.default.defaultProps,
    activeOpacity: 0.85,
    delayPressOut: 100,
    underlayColor: "black"
}); //# sourceMappingURL=TouchableHighlight.js.map


/***/ }),

/***/ 4376:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports["default"] = void 0;
var _reactNative = __webpack_require__(83849);
var _default = _reactNative.TouchableNativeFeedback;
exports["default"] = _default; //# sourceMappingURL=TouchableNativeFeedback.js.map


/***/ }),

/***/ 44777:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports["default"] = void 0;
var _reactNative = __webpack_require__(83849);
var _GenericTouchable = _interopRequireWildcard(__webpack_require__(20659));
var React = _interopRequireWildcard(__webpack_require__(16689));
function _getRequireWildcardCache() {
    if (typeof WeakMap !== "function") return null;
    var cache = new WeakMap();
    _getRequireWildcardCache = function() {
        return cache;
    };
    return cache;
}
function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache();
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {};
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
function _extends() {
    _extends = Object.assign || function(target) {
        for(var i = 1; i < arguments.length; i++){
            var source = arguments[i];
            for(var key in source){
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                }
            }
        }
        return target;
    };
    return _extends.apply(this, arguments);
}
function _defineProperty(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
/**
 * TouchableOpacity bases on timing animation which has been used in RN's core
 */ class TouchableOpacity extends React.Component {
    constructor(...args){
        super(...args);
        _defineProperty(this, "getChildStyleOpacityWithDefault", ()=>{
            const childStyle = _reactNative.StyleSheet.flatten(this.props.style) || {};
            return childStyle.opacity == null ? 1 : childStyle.opacity.valueOf();
        });
        _defineProperty(this, "opacity", new _reactNative.Animated.Value(this.getChildStyleOpacityWithDefault()));
        _defineProperty(this, "setOpacityTo", (value, duration)=>{
            var _this$props$useNative;
            _reactNative.Animated.timing(this.opacity, {
                toValue: value,
                duration: duration,
                easing: _reactNative.Easing.inOut(_reactNative.Easing.quad),
                useNativeDriver: (_this$props$useNative = this.props.useNativeAnimations) !== null && _this$props$useNative !== void 0 ? _this$props$useNative : true
            }).start();
        });
        _defineProperty(this, "onStateChange", (_from, to)=>{
            if (to === _GenericTouchable.TOUCHABLE_STATE.BEGAN) {
                this.setOpacityTo(this.props.activeOpacity, 0);
            } else if (to === _GenericTouchable.TOUCHABLE_STATE.UNDETERMINED || to === _GenericTouchable.TOUCHABLE_STATE.MOVED_OUTSIDE) {
                this.setOpacityTo(this.getChildStyleOpacityWithDefault(), 150);
            }
        });
    }
    render() {
        const { style = {}, ...rest } = this.props;
        return /*#__PURE__*/ React.createElement(_GenericTouchable.default, _extends({}, rest, {
            style: [
                style,
                {
                    opacity: this.opacity // TODO: fix this
                }
            ],
            onStateChange: this.onStateChange
        }), this.props.children ? this.props.children : /*#__PURE__*/ React.createElement(_reactNative.View, null));
    }
}
exports["default"] = TouchableOpacity;
_defineProperty(TouchableOpacity, "defaultProps", {
    ..._GenericTouchable.default.defaultProps,
    activeOpacity: 0.2
}); //# sourceMappingURL=TouchableOpacity.js.map


/***/ }),

/***/ 80356:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports["default"] = void 0;
var React = _interopRequireWildcard(__webpack_require__(16689));
var _GenericTouchable = _interopRequireDefault(__webpack_require__(20659));
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function _getRequireWildcardCache() {
    if (typeof WeakMap !== "function") return null;
    var cache = new WeakMap();
    _getRequireWildcardCache = function() {
        return cache;
    };
    return cache;
}
function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache();
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {};
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
function _extends() {
    _extends = Object.assign || function(target) {
        for(var i = 1; i < arguments.length; i++){
            var source = arguments[i];
            for(var key in source){
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                }
            }
        }
        return target;
    };
    return _extends.apply(this, arguments);
}
const TouchableWithoutFeedback = /*#__PURE__*/ React.forwardRef((props, ref)=>/*#__PURE__*/ React.createElement(_GenericTouchable.default, _extends({
        ref: ref
    }, props)));
TouchableWithoutFeedback.defaultProps = _GenericTouchable.default.defaultProps;
var _default = TouchableWithoutFeedback;
exports["default"] = _default; //# sourceMappingURL=TouchableWithoutFeedback.js.map


/***/ }),

/***/ 68046:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "TouchableNativeFeedback", ({
    enumerable: true,
    get: function() {
        return _TouchableNativeFeedback.default;
    }
}));
Object.defineProperty(exports, "TouchableWithoutFeedback", ({
    enumerable: true,
    get: function() {
        return _TouchableWithoutFeedback.default;
    }
}));
Object.defineProperty(exports, "TouchableOpacity", ({
    enumerable: true,
    get: function() {
        return _TouchableOpacity.default;
    }
}));
Object.defineProperty(exports, "TouchableHighlight", ({
    enumerable: true,
    get: function() {
        return _TouchableHighlight.default;
    }
}));
var _TouchableNativeFeedback = _interopRequireDefault(__webpack_require__(4376));
var _TouchableWithoutFeedback = _interopRequireDefault(__webpack_require__(80356));
var _TouchableOpacity = _interopRequireDefault(__webpack_require__(44777));
var _TouchableHighlight = _interopRequireDefault(__webpack_require__(81849));
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
} //# sourceMappingURL=index.js.map


/***/ }),

/***/ 1699:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.getShadowNodeFromRef = getShadowNodeFromRef;
// Used by GestureDetector (unsupported on web at the moment) to check whether the
// attached view may get flattened on Fabric. Original implementation causes errors
// on web due to the static resolution of `require` statements by webpack breaking
// the conditional importing.
function getShadowNodeFromRef(_ref) {
    return null;
} //# sourceMappingURL=getShadowNodeFromRef.web.js.map


/***/ }),

/***/ 46709:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.FlingGestureHandler = exports.flingHandlerName = exports.flingGestureHandlerProps = void 0;
var _createHandler = _interopRequireDefault(__webpack_require__(83344));
var _gestureHandlerCommon = __webpack_require__(92730);
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
const flingGestureHandlerProps = [
    "numberOfPointers",
    "direction"
];
exports.flingGestureHandlerProps = flingGestureHandlerProps;
const flingHandlerName = "FlingGestureHandler";
exports.flingHandlerName = flingHandlerName;
// eslint-disable-next-line @typescript-eslint/no-redeclare -- backward compatibility; see description on the top of gestureHandlerCommon.ts file
const FlingGestureHandler = (0, _createHandler.default)({
    name: flingHandlerName,
    allowedProps: [
        ..._gestureHandlerCommon.baseGestureHandlerProps,
        ...flingGestureHandlerProps
    ],
    config: {}
});
exports.FlingGestureHandler = FlingGestureHandler; //# sourceMappingURL=FlingGestureHandler.js.map


/***/ }),

/***/ 69374:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.ForceTouchGestureHandler = exports.forceTouchHandlerName = exports.forceTouchGestureHandlerProps = void 0;
var _react = _interopRequireDefault(__webpack_require__(16689));
var _utils = __webpack_require__(50693);
var _PlatformConstants = _interopRequireDefault(__webpack_require__(14858));
var _createHandler = _interopRequireDefault(__webpack_require__(83344));
var _gestureHandlerCommon = __webpack_require__(92730);
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function _defineProperty(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
const forceTouchGestureHandlerProps = [
    "minForce",
    "maxForce",
    "feedbackOnActivation"
]; // implicit `children` prop has been removed in @types/react^18.0.0
exports.forceTouchGestureHandlerProps = forceTouchGestureHandlerProps;
class ForceTouchFallback extends _react.default.Component {
    componentDidMount() {
        console.warn((0, _utils.tagMessage)("ForceTouchGestureHandler is not available on this platform. Please use ForceTouchGestureHandler.forceTouchAvailable to conditionally render other components that would provide a fallback behavior specific to your usecase"));
    }
    render() {
        return this.props.children;
    }
}
_defineProperty(ForceTouchFallback, "forceTouchAvailable", false);
const forceTouchHandlerName = "ForceTouchGestureHandler"; // eslint-disable-next-line @typescript-eslint/no-redeclare -- backward compatibility; see description on the top of gestureHandlerCommon.ts file
exports.forceTouchHandlerName = forceTouchHandlerName;
const ForceTouchGestureHandler = _PlatformConstants.default !== null && _PlatformConstants.default !== void 0 && _PlatformConstants.default.forceTouchAvailable ? (0, _createHandler.default)({
    name: forceTouchHandlerName,
    allowedProps: [
        ..._gestureHandlerCommon.baseGestureHandlerProps,
        ...forceTouchGestureHandlerProps
    ],
    config: {}
}) : ForceTouchFallback;
exports.ForceTouchGestureHandler = ForceTouchGestureHandler;
ForceTouchGestureHandler.forceTouchAvailable = (_PlatformConstants.default === null || _PlatformConstants.default === void 0 ? void 0 : _PlatformConstants.default.forceTouchAvailable) || false; //# sourceMappingURL=ForceTouchGestureHandler.js.map


/***/ }),

/***/ 99901:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.LongPressGestureHandler = exports.longPressHandlerName = exports.longPressGestureHandlerProps = void 0;
var _createHandler = _interopRequireDefault(__webpack_require__(83344));
var _gestureHandlerCommon = __webpack_require__(92730);
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
const longPressGestureHandlerProps = [
    "minDurationMs",
    "maxDist"
];
exports.longPressGestureHandlerProps = longPressGestureHandlerProps;
const longPressHandlerName = "LongPressGestureHandler";
exports.longPressHandlerName = longPressHandlerName;
// eslint-disable-next-line @typescript-eslint/no-redeclare -- backward compatibility; see description on the top of gestureHandlerCommon.ts file
const LongPressGestureHandler = (0, _createHandler.default)({
    name: longPressHandlerName,
    allowedProps: [
        ..._gestureHandlerCommon.baseGestureHandlerProps,
        ...longPressGestureHandlerProps
    ],
    config: {
        shouldCancelWhenOutside: true
    }
});
exports.LongPressGestureHandler = LongPressGestureHandler; //# sourceMappingURL=LongPressGestureHandler.js.map


/***/ }),

/***/ 92922:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.NativeViewGestureHandler = exports.nativeViewHandlerName = exports.nativeViewProps = exports.nativeViewGestureHandlerProps = void 0;
var _createHandler = _interopRequireDefault(__webpack_require__(83344));
var _gestureHandlerCommon = __webpack_require__(92730);
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
const nativeViewGestureHandlerProps = [
    "shouldActivateOnStart",
    "disallowInterruption"
];
exports.nativeViewGestureHandlerProps = nativeViewGestureHandlerProps;
const nativeViewProps = [
    ..._gestureHandlerCommon.baseGestureHandlerProps,
    ...nativeViewGestureHandlerProps
];
exports.nativeViewProps = nativeViewProps;
const nativeViewHandlerName = "NativeViewGestureHandler";
exports.nativeViewHandlerName = nativeViewHandlerName;
// eslint-disable-next-line @typescript-eslint/no-redeclare -- backward compatibility; see description on the top of gestureHandlerCommon.ts file
const NativeViewGestureHandler = (0, _createHandler.default)({
    name: nativeViewHandlerName,
    allowedProps: nativeViewProps,
    config: {}
});
exports.NativeViewGestureHandler = NativeViewGestureHandler; //# sourceMappingURL=NativeViewGestureHandler.js.map


/***/ }),

/***/ 78673:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.managePanProps = managePanProps;
exports.PanGestureHandler = exports.panHandlerName = exports.panGestureHandlerCustomNativeProps = exports.panGestureHandlerProps = void 0;
var _createHandler = _interopRequireDefault(__webpack_require__(83344));
var _gestureHandlerCommon = __webpack_require__(92730);
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
const panGestureHandlerProps = [
    "activeOffsetY",
    "activeOffsetX",
    "failOffsetY",
    "failOffsetX",
    "minDist",
    "minVelocity",
    "minVelocityX",
    "minVelocityY",
    "minPointers",
    "maxPointers",
    "avgTouches",
    "enableTrackpadTwoFingerGesture",
    "activateAfterLongPress"
];
exports.panGestureHandlerProps = panGestureHandlerProps;
const panGestureHandlerCustomNativeProps = [
    "activeOffsetYStart",
    "activeOffsetYEnd",
    "activeOffsetXStart",
    "activeOffsetXEnd",
    "failOffsetYStart",
    "failOffsetYEnd",
    "failOffsetXStart",
    "failOffsetXEnd"
];
exports.panGestureHandlerCustomNativeProps = panGestureHandlerCustomNativeProps;
const panHandlerName = "PanGestureHandler";
exports.panHandlerName = panHandlerName;
// eslint-disable-next-line @typescript-eslint/no-redeclare -- backward compatibility; see description on the top of gestureHandlerCommon.ts file
const PanGestureHandler = (0, _createHandler.default)({
    name: panHandlerName,
    allowedProps: [
        ..._gestureHandlerCommon.baseGestureHandlerProps,
        ...panGestureHandlerProps
    ],
    config: {},
    transformProps: managePanProps,
    customNativeProps: panGestureHandlerCustomNativeProps
});
exports.PanGestureHandler = PanGestureHandler;
function validatePanGestureHandlerProps(props) {
    if (Array.isArray(props.activeOffsetX) && (props.activeOffsetX[0] > 0 || props.activeOffsetX[1] < 0)) {
        throw new Error(`First element of activeOffsetX should be negative, a the second one should be positive`);
    }
    if (Array.isArray(props.activeOffsetY) && (props.activeOffsetY[0] > 0 || props.activeOffsetY[1] < 0)) {
        throw new Error(`First element of activeOffsetY should be negative, a the second one should be positive`);
    }
    if (Array.isArray(props.failOffsetX) && (props.failOffsetX[0] > 0 || props.failOffsetX[1] < 0)) {
        throw new Error(`First element of failOffsetX should be negative, a the second one should be positive`);
    }
    if (Array.isArray(props.failOffsetY) && (props.failOffsetY[0] > 0 || props.failOffsetY[1] < 0)) {
        throw new Error(`First element of failOffsetY should be negative, a the second one should be positive`);
    }
    if (props.minDist && (props.failOffsetX || props.failOffsetY)) {
        throw new Error(`It is not supported to use minDist with failOffsetX or failOffsetY, use activeOffsetX and activeOffsetY instead`);
    }
    if (props.minDist && (props.activeOffsetX || props.activeOffsetY)) {
        throw new Error(`It is not supported to use minDist with activeOffsetX or activeOffsetY`);
    }
}
function transformPanGestureHandlerProps(props) {
    const res = {
        ...props
    };
    if (props.activeOffsetX !== undefined) {
        delete res.activeOffsetX;
        if (Array.isArray(props.activeOffsetX)) {
            res.activeOffsetXStart = props.activeOffsetX[0];
            res.activeOffsetXEnd = props.activeOffsetX[1];
        } else if (props.activeOffsetX < 0) {
            res.activeOffsetXStart = props.activeOffsetX;
        } else {
            res.activeOffsetXEnd = props.activeOffsetX;
        }
    }
    if (props.activeOffsetY !== undefined) {
        delete res.activeOffsetY;
        if (Array.isArray(props.activeOffsetY)) {
            res.activeOffsetYStart = props.activeOffsetY[0];
            res.activeOffsetYEnd = props.activeOffsetY[1];
        } else if (props.activeOffsetY < 0) {
            res.activeOffsetYStart = props.activeOffsetY;
        } else {
            res.activeOffsetYEnd = props.activeOffsetY;
        }
    }
    if (props.failOffsetX !== undefined) {
        delete res.failOffsetX;
        if (Array.isArray(props.failOffsetX)) {
            res.failOffsetXStart = props.failOffsetX[0];
            res.failOffsetXEnd = props.failOffsetX[1];
        } else if (props.failOffsetX < 0) {
            res.failOffsetXStart = props.failOffsetX;
        } else {
            res.failOffsetXEnd = props.failOffsetX;
        }
    }
    if (props.failOffsetY !== undefined) {
        delete res.failOffsetY;
        if (Array.isArray(props.failOffsetY)) {
            res.failOffsetYStart = props.failOffsetY[0];
            res.failOffsetYEnd = props.failOffsetY[1];
        } else if (props.failOffsetY < 0) {
            res.failOffsetYStart = props.failOffsetY;
        } else {
            res.failOffsetYEnd = props.failOffsetY;
        }
    }
    return res;
}
function managePanProps(props) {
    if (false) {}
    return transformPanGestureHandlerProps(props);
} //# sourceMappingURL=PanGestureHandler.js.map


/***/ }),

/***/ 81155:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.PinchGestureHandler = exports.pinchHandlerName = void 0;
var _createHandler = _interopRequireDefault(__webpack_require__(83344));
var _gestureHandlerCommon = __webpack_require__(92730);
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
const pinchHandlerName = "PinchGestureHandler";
exports.pinchHandlerName = pinchHandlerName;
// eslint-disable-next-line @typescript-eslint/no-redeclare -- backward compatibility; see description on the top of gestureHandlerCommon.ts file
const PinchGestureHandler = (0, _createHandler.default)({
    name: pinchHandlerName,
    allowedProps: _gestureHandlerCommon.baseGestureHandlerProps,
    config: {}
});
exports.PinchGestureHandler = PinchGestureHandler; //# sourceMappingURL=PinchGestureHandler.js.map


/***/ }),

/***/ 45834:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.PressabilityDebugView = PressabilityDebugView;
// PressabilityDebugView is not implemented in react-native-web
function PressabilityDebugView() {
    return null;
} //# sourceMappingURL=PressabilityDebugView.web.js.map


/***/ }),

/***/ 63153:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.RotationGestureHandler = exports.rotationHandlerName = void 0;
var _createHandler = _interopRequireDefault(__webpack_require__(83344));
var _gestureHandlerCommon = __webpack_require__(92730);
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
const rotationHandlerName = "RotationGestureHandler";
exports.rotationHandlerName = rotationHandlerName;
// eslint-disable-next-line @typescript-eslint/no-redeclare -- backward compatibility; see description on the top of gestureHandlerCommon.ts file
const RotationGestureHandler = (0, _createHandler.default)({
    name: rotationHandlerName,
    allowedProps: _gestureHandlerCommon.baseGestureHandlerProps,
    config: {}
});
exports.RotationGestureHandler = RotationGestureHandler; //# sourceMappingURL=RotationGestureHandler.js.map


/***/ }),

/***/ 91418:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.TapGestureHandler = exports.tapHandlerName = exports.tapGestureHandlerProps = void 0;
var _createHandler = _interopRequireDefault(__webpack_require__(83344));
var _gestureHandlerCommon = __webpack_require__(92730);
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
const tapGestureHandlerProps = [
    "maxDurationMs",
    "maxDelayMs",
    "numberOfTaps",
    "maxDeltaX",
    "maxDeltaY",
    "maxDist",
    "minPointers"
];
exports.tapGestureHandlerProps = tapGestureHandlerProps;
const tapHandlerName = "TapGestureHandler";
exports.tapHandlerName = tapHandlerName;
// eslint-disable-next-line @typescript-eslint/no-redeclare -- backward compatibility; see description on the top of gestureHandlerCommon.ts file
const TapGestureHandler = (0, _createHandler.default)({
    name: tapHandlerName,
    allowedProps: [
        ..._gestureHandlerCommon.baseGestureHandlerProps,
        ...tapGestureHandlerProps
    ],
    config: {
        shouldCancelWhenOutside: true
    }
});
exports.TapGestureHandler = TapGestureHandler; //# sourceMappingURL=TapGestureHandler.js.map


/***/ }),

/***/ 83344:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports["default"] = createHandler;
var React = _interopRequireWildcard(__webpack_require__(16689));
var _reactNative = __webpack_require__(83849);
var _isEqual = _interopRequireDefault(__webpack_require__(40113));
var _RNGestureHandlerModule = _interopRequireDefault(__webpack_require__(43121));
var _State = __webpack_require__(10125);
var _handlersRegistry = __webpack_require__(83406);
var _gestureHandlerCommon = __webpack_require__(92730);
var _utils = __webpack_require__(50693);
var _ActionType = __webpack_require__(10739);
var _PressabilityDebugView = __webpack_require__(45834);
var _GestureHandlerRootViewContext = _interopRequireDefault(__webpack_require__(49704));
var _UIManagerAny$getView, _UIManagerAny$getView2, _UIManagerAny$getCons;
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function _getRequireWildcardCache() {
    if (typeof WeakMap !== "function") return null;
    var cache = new WeakMap();
    _getRequireWildcardCache = function() {
        return cache;
    };
    return cache;
}
function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache();
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {};
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
function _defineProperty(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
const UIManagerAny = _reactNative.UIManager;
const customGHEventsConfigFabricAndroid = {
    topOnGestureHandlerEvent: {
        registrationName: "onGestureHandlerEvent"
    },
    topOnGestureHandlerStateChange: {
        registrationName: "onGestureHandlerStateChange"
    }
};
const customGHEventsConfig = {
    onGestureHandlerEvent: {
        registrationName: "onGestureHandlerEvent"
    },
    onGestureHandlerStateChange: {
        registrationName: "onGestureHandlerStateChange"
    },
    // When using React Native Gesture Handler for Animated.event with useNativeDriver: true
    // on Android with Fabric enabled, the native part still sends the native events to JS
    // but prefixed with "top". We cannot simply rename the events above so they are prefixed
    // with "top" instead of "on" because in such case Animated.events would not be registered.
    // That's why we need to register another pair of event names.
    // The incoming events will be queued but never handled.
    // Without this piece of code below, you'll get the following JS error:
    // Unsupported top level event type "topOnGestureHandlerEvent" dispatched
    ...(0, _utils.isFabric)() && _reactNative.Platform.OS === "android" && customGHEventsConfigFabricAndroid
}; // Add gesture specific events to genericDirectEventTypes object exported from UIManager
// native module.
// Once new event types are registered with react it is possible to dispatch these
// events to all kind of native views.
UIManagerAny.genericDirectEventTypes = {
    ...UIManagerAny.genericDirectEventTypes,
    ...customGHEventsConfig
}; // In newer versions of RN the `genericDirectEventTypes` is located in the object
// returned by UIManager.getViewManagerConfig('getConstants') or in older RN UIManager.getConstants(), we need to add it there as well to make
// it compatible with RN 61+
const UIManagerConstants = (_UIManagerAny$getView = (_UIManagerAny$getView2 = UIManagerAny.getViewManagerConfig) === null || _UIManagerAny$getView2 === void 0 ? void 0 : _UIManagerAny$getView2.call(UIManagerAny, "getConstants")) !== null && _UIManagerAny$getView !== void 0 ? _UIManagerAny$getView : (_UIManagerAny$getCons = UIManagerAny.getConstants) === null || _UIManagerAny$getCons === void 0 ? void 0 : _UIManagerAny$getCons.call(UIManagerAny);
if (UIManagerConstants) {
    UIManagerConstants.genericDirectEventTypes = {
        ...UIManagerConstants.genericDirectEventTypes,
        ...customGHEventsConfig
    };
} // Wrap JS responder calls and notify gesture handler manager
const { setJSResponder: oldSetJSResponder = ()=>{}, clearJSResponder: oldClearJSResponder = ()=>{} } = UIManagerAny;
UIManagerAny.setJSResponder = (tag, blockNativeResponder)=>{
    _RNGestureHandlerModule.default.handleSetJSResponder(tag, blockNativeResponder);
    oldSetJSResponder(tag, blockNativeResponder);
};
UIManagerAny.clearJSResponder = ()=>{
    _RNGestureHandlerModule.default.handleClearJSResponder();
    oldClearJSResponder();
};
let allowTouches = true;
const DEV_ON_ANDROID =  false && 0; // Toggled inspector blocks touch events in order to allow inspecting on Android
// This needs to be a global variable in order to set initial state for `allowTouches` property in Handler component
if (DEV_ON_ANDROID) {
    _reactNative.DeviceEventEmitter.addListener("toggleElementInspector", ()=>{
        allowTouches = !allowTouches;
    });
}
function hasUnresolvedRefs(props) {
    // TODO(TS) - add type for extract arg
    const extract = (refs)=>{
        if (!Array.isArray(refs)) {
            return refs && refs.current === null;
        }
        return refs.some((r)=>r && r.current === null);
    };
    return extract(props["simultaneousHandlers"]) || extract(props["waitFor"]);
}
const stateToPropMappings = {
    [_State.State.UNDETERMINED]: undefined,
    [_State.State.BEGAN]: "onBegan",
    [_State.State.FAILED]: "onFailed",
    [_State.State.CANCELLED]: "onCancelled",
    [_State.State.ACTIVE]: "onActivated",
    [_State.State.END]: "onEnded"
};
const UNRESOLVED_REFS_RETRY_LIMIT = 1; // TODO(TS) - make sure that BaseGestureHandlerProps doesn't need other generic parameter to work with custom properties.
function createHandler({ name, allowedProps = [], config = {}, transformProps, customNativeProps = [] }) {
    class Handler extends React.Component {
        constructor(props){
            super(props);
            _defineProperty(this, "handlerTag", void 0);
            _defineProperty(this, "config", void 0);
            _defineProperty(this, "propsRef", void 0);
            _defineProperty(this, "isMountedRef", void 0);
            _defineProperty(this, "viewNode", void 0);
            _defineProperty(this, "viewTag", void 0);
            _defineProperty(this, "inspectorToggleListener", void 0);
            _defineProperty(this, "onGestureHandlerEvent", (event)=>{
                if (event.nativeEvent.handlerTag === this.handlerTag) {
                    if (typeof this.props.onGestureEvent === "function") {
                        var _this$props$onGesture, _this$props;
                        (_this$props$onGesture = (_this$props = this.props).onGestureEvent) === null || _this$props$onGesture === void 0 ? void 0 : _this$props$onGesture.call(_this$props, event);
                    }
                } else {
                    var _this$props$onGesture2, _this$props2;
                    (_this$props$onGesture2 = (_this$props2 = this.props).onGestureHandlerEvent) === null || _this$props$onGesture2 === void 0 ? void 0 : _this$props$onGesture2.call(_this$props2, event);
                }
            });
            _defineProperty(this, "onGestureHandlerStateChange", (event)=>{
                if (event.nativeEvent.handlerTag === this.handlerTag) {
                    if (typeof this.props.onHandlerStateChange === "function") {
                        var _this$props$onHandler, _this$props3;
                        (_this$props$onHandler = (_this$props3 = this.props).onHandlerStateChange) === null || _this$props$onHandler === void 0 ? void 0 : _this$props$onHandler.call(_this$props3, event);
                    }
                    const state = event.nativeEvent.state;
                    const stateEventName = stateToPropMappings[state];
                    const eventHandler = stateEventName && this.props[stateEventName];
                    if (eventHandler && typeof eventHandler === "function") {
                        eventHandler(event);
                    }
                } else {
                    var _this$props$onGesture3, _this$props4;
                    (_this$props$onGesture3 = (_this$props4 = this.props).onGestureHandlerStateChange) === null || _this$props$onGesture3 === void 0 ? void 0 : _this$props$onGesture3.call(_this$props4, event);
                }
            });
            _defineProperty(this, "refHandler", (node)=>{
                this.viewNode = node;
                const child = React.Children.only(this.props.children); // TODO(TS) fix ref type
                const { ref } = child;
                if (ref !== null) {
                    if (typeof ref === "function") {
                        ref(node);
                    } else {
                        ref.current = node;
                    }
                }
            });
            _defineProperty(this, "createGestureHandler", (newConfig)=>{
                this.config = newConfig;
                _RNGestureHandlerModule.default.createGestureHandler(name, this.handlerTag, newConfig);
            });
            _defineProperty(this, "attachGestureHandler", (newViewTag)=>{
                this.viewTag = newViewTag;
                if (_reactNative.Platform.OS === "web") {
                    // typecast due to dynamic resolution, attachGestureHandler should have web version signature in this branch
                    _RNGestureHandlerModule.default.attachGestureHandler(this.handlerTag, newViewTag, _ActionType.ActionType.JS_FUNCTION_OLD_API, this.propsRef);
                } else {
                    (0, _handlersRegistry.registerOldGestureHandler)(this.handlerTag, {
                        onGestureEvent: this.onGestureHandlerEvent,
                        onGestureStateChange: this.onGestureHandlerStateChange
                    });
                    const actionType = (()=>{
                        var _this$props5, _this$props6;
                        if ((_this$props5 = this.props) !== null && _this$props5 !== void 0 && _this$props5.onGestureEvent && "current" in this.props.onGestureEvent) {
                            // Reanimated worklet
                            return _ActionType.ActionType.REANIMATED_WORKLET;
                        } else if ((_this$props6 = this.props) !== null && _this$props6 !== void 0 && _this$props6.onGestureEvent && "__isNative" in this.props.onGestureEvent) {
                            // Animated.event with useNativeDriver: true
                            return _ActionType.ActionType.NATIVE_ANIMATED_EVENT;
                        } else {
                            // JS callback or Animated.event with useNativeDriver: false
                            return _ActionType.ActionType.JS_FUNCTION_OLD_API;
                        }
                    })();
                    _RNGestureHandlerModule.default.attachGestureHandler(this.handlerTag, newViewTag, actionType);
                }
                (0, _gestureHandlerCommon.scheduleFlushOperations)();
            });
            _defineProperty(this, "updateGestureHandler", (newConfig)=>{
                this.config = newConfig;
                _RNGestureHandlerModule.default.updateGestureHandler(this.handlerTag, newConfig);
                (0, _gestureHandlerCommon.scheduleFlushOperations)();
            });
            this.handlerTag = (0, _handlersRegistry.getNextHandlerTag)();
            this.config = {};
            this.propsRef = /*#__PURE__*/ React.createRef();
            this.isMountedRef = /*#__PURE__*/ React.createRef();
            this.state = {
                allowTouches
            };
            if (props.id) {
                if (_handlersRegistry.handlerIDToTag[props.id] !== undefined) {
                    throw new Error(`Handler with ID "${props.id}" already registered`);
                }
                _handlersRegistry.handlerIDToTag[props.id] = this.handlerTag;
            }
        }
        componentDidMount() {
            const props = this.props;
            this.isMountedRef.current = true;
            if (DEV_ON_ANDROID) {
                this.inspectorToggleListener = _reactNative.DeviceEventEmitter.addListener("toggleElementInspector", ()=>{
                    this.setState((_)=>({
                            allowTouches
                        }));
                    this.update(UNRESOLVED_REFS_RETRY_LIMIT);
                });
            }
            if (hasUnresolvedRefs(props)) {
                // If there are unresolved refs (e.g. ".current" has not yet been set)
                // passed as `simultaneousHandlers` or `waitFor`, we enqueue a call to
                // _update method that will try to update native handler props using
                // queueMicrotask. This makes it so update() function gets called after all
                // react components are mounted and we expect the missing ref object to
                // be resolved by then.
                queueMicrotask(()=>{
                    this.update(UNRESOLVED_REFS_RETRY_LIMIT);
                });
            }
            this.createGestureHandler((0, _gestureHandlerCommon.filterConfig)(transformProps ? transformProps(this.props) : this.props, [
                ...allowedProps,
                ...customNativeProps
            ], config));
            this.attachGestureHandler((0, _gestureHandlerCommon.findNodeHandle)(this.viewNode)); // TODO(TS) - check if this can be null
        }
        componentDidUpdate() {
            const viewTag = (0, _gestureHandlerCommon.findNodeHandle)(this.viewNode);
            if (this.viewTag !== viewTag) {
                this.attachGestureHandler(viewTag); // TODO(TS) - check interaction between _viewTag & findNodeHandle
            }
            this.update(UNRESOLVED_REFS_RETRY_LIMIT);
        }
        componentWillUnmount() {
            var _this$inspectorToggle;
            (_this$inspectorToggle = this.inspectorToggleListener) === null || _this$inspectorToggle === void 0 ? void 0 : _this$inspectorToggle.remove();
            this.isMountedRef.current = false;
            _RNGestureHandlerModule.default.dropGestureHandler(this.handlerTag);
            (0, _gestureHandlerCommon.scheduleFlushOperations)(); // We can't use this.props.id directly due to TS generic type narrowing bug, see https://github.com/microsoft/TypeScript/issues/13995 for more context
            const handlerID = this.props.id;
            if (handlerID) {
                // eslint-disable-next-line @typescript-eslint/no-dynamic-delete
                delete _handlersRegistry.handlerIDToTag[handlerID];
            }
        }
        update(remainingTries) {
            if (!this.isMountedRef.current) {
                return;
            }
            const props = this.props; // When ref is set via a function i.e. `ref={(r) => refObject.current = r}` instead of
            // `ref={refObject}` it's possible that it won't be resolved in time. Seems like trying
            // again is easy enough fix.
            if (hasUnresolvedRefs(props) && remainingTries > 0) {
                queueMicrotask(()=>{
                    this.update(remainingTries - 1);
                });
            } else {
                const newConfig = (0, _gestureHandlerCommon.filterConfig)(transformProps ? transformProps(this.props) : this.props, [
                    ...allowedProps,
                    ...customNativeProps
                ], config);
                if (!(0, _isEqual.default)(this.config, newConfig)) {
                    this.updateGestureHandler(newConfig);
                }
            }
        }
        setNativeProps(updates) {
            const mergedProps = {
                ...this.props,
                ...updates
            };
            const newConfig = (0, _gestureHandlerCommon.filterConfig)(transformProps ? transformProps(mergedProps) : mergedProps, [
                ...allowedProps,
                ...customNativeProps
            ], config);
            this.updateGestureHandler(newConfig);
        }
        render() {
            var _this$props$testID;
            if (false) {}
            let gestureEventHandler = this.onGestureHandlerEvent; // Another instance of https://github.com/microsoft/TypeScript/issues/13995
            const { onGestureEvent, onGestureHandlerEvent } = this.props;
            if (onGestureEvent && typeof onGestureEvent !== "function") {
                // If it's not a method it should be an native Animated.event
                // object. We set it directly as the handler for the view
                // In this case nested handlers are not going to be supported
                if (onGestureHandlerEvent) {
                    throw new Error("Nesting touch handlers with native animated driver is not supported yet");
                }
                gestureEventHandler = onGestureEvent;
            } else {
                if (onGestureHandlerEvent && typeof onGestureHandlerEvent !== "function") {
                    throw new Error("Nesting touch handlers with native animated driver is not supported yet");
                }
            }
            let gestureStateEventHandler = this.onGestureHandlerStateChange; // Another instance of https://github.com/microsoft/TypeScript/issues/13995
            const { onHandlerStateChange, onGestureHandlerStateChange } = this.props;
            if (onHandlerStateChange && typeof onHandlerStateChange !== "function") {
                // If it's not a method it should be an native Animated.event
                // object. We set it directly as the handler for the view
                // In this case nested handlers are not going to be supported
                if (onGestureHandlerStateChange) {
                    throw new Error("Nesting touch handlers with native animated driver is not supported yet");
                }
                gestureStateEventHandler = onHandlerStateChange;
            } else {
                if (onGestureHandlerStateChange && typeof onGestureHandlerStateChange !== "function") {
                    throw new Error("Nesting touch handlers with native animated driver is not supported yet");
                }
            }
            const events = {
                onGestureHandlerEvent: this.state.allowTouches ? gestureEventHandler : undefined,
                onGestureHandlerStateChange: this.state.allowTouches ? gestureStateEventHandler : undefined
            };
            this.propsRef.current = events;
            let child = null;
            try {
                child = React.Children.only(this.props.children);
            } catch (e) {
                throw new Error((0, _utils.tagMessage)(`${name} got more than one view as a child. If you want the gesture to work on multiple views, wrap them with a common parent and attach the gesture to that view.`));
            }
            let grandChildren = child.props.children;
            if (false) {}
            return /*#__PURE__*/ React.cloneElement(child, {
                ref: this.refHandler,
                collapsable: false,
                ...(0, _utils.isJestEnv)() ? {
                    handlerType: name,
                    handlerTag: this.handlerTag
                } : {},
                testID: (_this$props$testID = this.props.testID) !== null && _this$props$testID !== void 0 ? _this$props$testID : child.props.testID,
                ...events
            }, grandChildren);
        }
    }
    _defineProperty(Handler, "displayName", name);
    _defineProperty(Handler, "contextType", _GestureHandlerRootViewContext.default);
    return Handler;
} //# sourceMappingURL=createHandler.js.map


/***/ }),

/***/ 54625:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports["default"] = createNativeWrapper;
var React = _interopRequireWildcard(__webpack_require__(16689));
var _NativeViewGestureHandler = __webpack_require__(92922);
function _getRequireWildcardCache() {
    if (typeof WeakMap !== "function") return null;
    var cache = new WeakMap();
    _getRequireWildcardCache = function() {
        return cache;
    };
    return cache;
}
function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache();
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {};
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
function _extends() {
    _extends = Object.assign || function(target) {
        for(var i = 1; i < arguments.length; i++){
            var source = arguments[i];
            for(var key in source){
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                }
            }
        }
        return target;
    };
    return _extends.apply(this, arguments);
}
/*
 * This array should consist of:
 *   - All keys in propTypes from NativeGestureHandler
 *     (and all keys in GestureHandlerPropTypes)
 *   - 'onGestureHandlerEvent'
 *   - 'onGestureHandlerStateChange'
 */ const NATIVE_WRAPPER_PROPS_FILTER = [
    ..._NativeViewGestureHandler.nativeViewProps,
    "onGestureHandlerEvent",
    "onGestureHandlerStateChange"
];
function createNativeWrapper(Component, config = {}) {
    var _Component$render;
    const ComponentWrapper = /*#__PURE__*/ React.forwardRef((props, ref)=>{
        // filter out props that should be passed to gesture handler wrapper
        const gestureHandlerProps = Object.keys(props).reduce((res, key)=>{
            // TS being overly protective with it's types, see https://github.com/microsoft/TypeScript/issues/26255#issuecomment-458013731 for more info
            const allowedKeys = NATIVE_WRAPPER_PROPS_FILTER;
            if (allowedKeys.includes(key)) {
                // @ts-ignore FIXME(TS)
                res[key] = props[key];
            }
            return res;
        }, {
            ...config
        } // watch out not to modify config
        );
        const _ref = (0, React.useRef)();
        const _gestureHandlerRef = (0, React.useRef)();
        (0, React.useImperativeHandle)(ref, ()=>{
            const node = _gestureHandlerRef.current; // add handlerTag for relations config
            if (_ref.current && node) {
                // @ts-ignore FIXME(TS) think about createHandler return type
                _ref.current.handlerTag = node.handlerTag;
                return _ref.current;
            }
            return null;
        }, [
            _ref,
            _gestureHandlerRef
        ]);
        return /*#__PURE__*/ React.createElement(_NativeViewGestureHandler.NativeViewGestureHandler, _extends({}, gestureHandlerProps, {
            // @ts-ignore TODO(TS)
            ref: _gestureHandlerRef
        }), /*#__PURE__*/ React.createElement(Component, _extends({}, props, {
            ref: _ref
        })));
    }); // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
    ComponentWrapper.displayName = (Component === null || Component === void 0 ? void 0 : Component.displayName) || (Component === null || Component === void 0 ? void 0 : (_Component$render = Component.render) === null || _Component$render === void 0 ? void 0 : _Component$render.name) || typeof Component === "string" && Component || "ComponentWrapper";
    return ComponentWrapper;
} //# sourceMappingURL=createNativeWrapper.js.map


/***/ }),

/***/ 92730:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.filterConfig = filterConfig;
exports.findNodeHandle = findNodeHandle;
exports.scheduleFlushOperations = scheduleFlushOperations;
exports.baseGestureHandlerWithMonitorProps = exports.baseGestureHandlerProps = void 0;
var _reactNative = __webpack_require__(83849);
var _handlersRegistry = __webpack_require__(83406);
var _utils = __webpack_require__(50693);
var _RNGestureHandlerModule = _interopRequireDefault(__webpack_require__(43121));
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
// Previous types exported gesture handlers as classes which creates an interface and variable, both named the same as class.
// Without those types, we'd introduce breaking change, forcing users to prefix every handler type specification with typeof
// e.g. React.createRef<TapGestureHandler> -> React.createRef<typeof TapGestureHandler>.
// See https://www.typescriptlang.org/docs/handbook/classes.html#constructor-functions for reference.
const commonProps = [
    "id",
    "enabled",
    "shouldCancelWhenOutside",
    "hitSlop",
    "cancelsTouchesInView",
    "userSelect"
];
const componentInteractionProps = [
    "waitFor",
    "simultaneousHandlers"
];
const baseGestureHandlerProps = [
    ...commonProps,
    ...componentInteractionProps,
    "onBegan",
    "onFailed",
    "onCancelled",
    "onActivated",
    "onEnded",
    "onGestureEvent",
    "onHandlerStateChange"
];
exports.baseGestureHandlerProps = baseGestureHandlerProps;
const baseGestureHandlerWithMonitorProps = [
    ...commonProps,
    "needsPointerData",
    "manualActivation"
];
exports.baseGestureHandlerWithMonitorProps = baseGestureHandlerWithMonitorProps;
function isConfigParam(param, name) {
    // param !== Object(param) returns false if `param` is a function
    // or an object and returns true if `param` is null
    return param !== undefined && (param !== Object(param) || !("__isNative" in param)) && name !== "onHandlerStateChange" && name !== "onGestureEvent";
}
function filterConfig(props, validProps, defaults = {}) {
    const filteredConfig = {
        ...defaults
    };
    for (const key of validProps){
        let value = props[key];
        if (isConfigParam(value, key)) {
            if (key === "simultaneousHandlers" || key === "waitFor") {
                value = transformIntoHandlerTags(props[key]);
            } else if (key === "hitSlop" && typeof value !== "object") {
                value = {
                    top: value,
                    left: value,
                    bottom: value,
                    right: value
                };
            }
            filteredConfig[key] = value;
        }
    }
    return filteredConfig;
}
function transformIntoHandlerTags(handlerIDs) {
    handlerIDs = (0, _utils.toArray)(handlerIDs);
    if (_reactNative.Platform.OS === "web") {
        return handlerIDs.map(({ current })=>current).filter((handle)=>handle);
    } // converts handler string IDs into their numeric tags
    return handlerIDs.map((handlerID)=>{
        var _handlerID$current;
        return _handlersRegistry.handlerIDToTag[handlerID] || ((_handlerID$current = handlerID.current) === null || _handlerID$current === void 0 ? void 0 : _handlerID$current.handlerTag) || -1;
    }).filter((handlerTag)=>handlerTag > 0);
}
function findNodeHandle(node) {
    if (_reactNative.Platform.OS === "web") {
        return node;
    }
    return (0, _reactNative.findNodeHandle)(node);
}
let flushOperationsScheduled = false;
function scheduleFlushOperations() {
    if (!flushOperationsScheduled) {
        flushOperationsScheduled = true;
        queueMicrotask(()=>{
            _RNGestureHandlerModule.default.flushOperations();
            flushOperationsScheduled = false;
        });
    }
} //# sourceMappingURL=gestureHandlerCommon.js.map


/***/ }),

/***/ 33668:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.GestureDetector = void 0;
var _react = _interopRequireWildcard(__webpack_require__(16689));
var _gesture = __webpack_require__(90159);
var _reanimatedWrapper = __webpack_require__(59836);
var _handlersRegistry = __webpack_require__(83406);
var _RNGestureHandlerModule = _interopRequireDefault(__webpack_require__(43121));
var _gestureHandlerCommon = __webpack_require__(92730);
var _gestureStateManager = __webpack_require__(8865);
var _FlingGestureHandler = __webpack_require__(46709);
var _ForceTouchGestureHandler = __webpack_require__(69374);
var _LongPressGestureHandler = __webpack_require__(99901);
var _PanGestureHandler = __webpack_require__(78673);
var _TapGestureHandler = __webpack_require__(91418);
var _State = __webpack_require__(10125);
var _TouchEventType = __webpack_require__(5887);
var _ActionType = __webpack_require__(10739);
var _utils = __webpack_require__(50693);
var _getShadowNodeFromRef = __webpack_require__(1699);
var _reactNative = __webpack_require__(83849);
var _eventReceiver = __webpack_require__(69323);
var _RNRenderer = __webpack_require__(79713);
var _EnableNewWebImplementation = __webpack_require__(29551);
var _NativeViewGestureHandler = __webpack_require__(92922);
var _GestureHandlerRootViewContext = _interopRequireDefault(__webpack_require__(49704));
var _Reanimated$default$c, _Reanimated$default;
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function _getRequireWildcardCache() {
    if (typeof WeakMap !== "function") return null;
    var cache = new WeakMap();
    _getRequireWildcardCache = function() {
        return cache;
    };
    return cache;
}
function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache();
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {};
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
const ALLOWED_PROPS = [
    ..._gestureHandlerCommon.baseGestureHandlerWithMonitorProps,
    ..._TapGestureHandler.tapGestureHandlerProps,
    ..._PanGestureHandler.panGestureHandlerProps,
    ..._PanGestureHandler.panGestureHandlerCustomNativeProps,
    ..._LongPressGestureHandler.longPressGestureHandlerProps,
    ..._ForceTouchGestureHandler.forceTouchGestureHandlerProps,
    ..._FlingGestureHandler.flingGestureHandlerProps,
    ..._NativeViewGestureHandler.nativeViewGestureHandlerProps
];
function convertToHandlerTag(ref) {
    if (typeof ref === "number") {
        return ref;
    } else if (ref instanceof _gesture.BaseGesture) {
        return ref.handlerTag;
    } else {
        var _ref$current$handlerT, _ref$current;
        // @ts-ignore in this case it should be a ref either to gesture object or
        // a gesture handler component, in both cases handlerTag property exists
        return (_ref$current$handlerT = (_ref$current = ref.current) === null || _ref$current === void 0 ? void 0 : _ref$current.handlerTag) !== null && _ref$current$handlerT !== void 0 ? _ref$current$handlerT : -1;
    }
}
function extractValidHandlerTags(interactionGroup) {
    var _interactionGroup$map, _interactionGroup$map2;
    return (_interactionGroup$map = interactionGroup === null || interactionGroup === void 0 ? void 0 : (_interactionGroup$map2 = interactionGroup.map(convertToHandlerTag)) === null || _interactionGroup$map2 === void 0 ? void 0 : _interactionGroup$map2.filter((tag)=>tag > 0)) !== null && _interactionGroup$map !== void 0 ? _interactionGroup$map : [];
}
function dropHandlers(preparedGesture) {
    for (const handler of preparedGesture.config){
        _RNGestureHandlerModule.default.dropGestureHandler(handler.handlerTag);
        (0, _handlersRegistry.unregisterHandler)(handler.handlerTag, handler.config.testId);
    }
    (0, _gestureHandlerCommon.scheduleFlushOperations)();
}
function checkGestureCallbacksForWorklets(gesture) {
    // if a gesture is explicitly marked to run on the JS thread there is no need to check
    // if callbacks are worklets as the user is aware they will be ran on the JS thread
    if (gesture.config.runOnJS) {
        return;
    }
    const areSomeNotWorklets = gesture.handlers.isWorklet.includes(false);
    const areSomeWorklets = gesture.handlers.isWorklet.includes(true); // if some of the callbacks are worklets and some are not, and the gesture is not
    // explicitly marked with `.runOnJS(true)` show an error
    if (areSomeNotWorklets && areSomeWorklets) {
        console.error((0, _utils.tagMessage)(`Some of the callbacks in the gesture are worklets and some are not. Either make sure that all calbacks are marked as 'worklet' if you wish to run them on the UI thread or use '.runOnJS(true)' modifier on the gesture explicitly to run all callbacks on the JS thread.`));
    }
}
function attachHandlers({ preparedGesture, gestureConfig, gesture, viewTag, webEventHandlersRef, mountedRef }) {
    if (!preparedGesture.firstExecution) {
        gestureConfig.initialize();
    } else {
        preparedGesture.firstExecution = false;
    } // use queueMicrotask to extract handlerTags, because all refs should be initialized
    // when it's ran
    queueMicrotask(()=>{
        if (!mountedRef.current) {
            return;
        }
        gestureConfig.prepare();
    });
    for (const handler of gesture){
        checkGestureCallbacksForWorklets(handler);
        _RNGestureHandlerModule.default.createGestureHandler(handler.handlerName, handler.handlerTag, (0, _gestureHandlerCommon.filterConfig)(handler.config, ALLOWED_PROPS));
        (0, _handlersRegistry.registerHandler)(handler.handlerTag, handler, handler.config.testId);
    } // use queueMicrotask to extract handlerTags, because all refs should be initialized
    // when it's ran
    queueMicrotask(()=>{
        if (!mountedRef.current) {
            return;
        }
        for (const handler of gesture){
            let requireToFail = [];
            if (handler.config.requireToFail) {
                requireToFail = extractValidHandlerTags(handler.config.requireToFail);
            }
            let simultaneousWith = [];
            if (handler.config.simultaneousWith) {
                simultaneousWith = extractValidHandlerTags(handler.config.simultaneousWith);
            }
            _RNGestureHandlerModule.default.updateGestureHandler(handler.handlerTag, (0, _gestureHandlerCommon.filterConfig)(handler.config, ALLOWED_PROPS, {
                simultaneousHandlers: simultaneousWith,
                waitFor: requireToFail
            }));
        }
        (0, _gestureHandlerCommon.scheduleFlushOperations)();
    });
    preparedGesture.config = gesture;
    for (const gesture of preparedGesture.config){
        const actionType = gesture.shouldUseReanimated ? _ActionType.ActionType.REANIMATED_WORKLET : _ActionType.ActionType.JS_FUNCTION_NEW_API;
        if (_reactNative.Platform.OS === "web") {
            _RNGestureHandlerModule.default.attachGestureHandler(gesture.handlerTag, viewTag, _ActionType.ActionType.JS_FUNCTION_OLD_API, webEventHandlersRef);
        } else {
            _RNGestureHandlerModule.default.attachGestureHandler(gesture.handlerTag, viewTag, actionType);
        }
    }
    if (preparedGesture.animatedHandlers) {
        const isAnimatedGesture = (g)=>g.shouldUseReanimated;
        preparedGesture.animatedHandlers.value = gesture.filter(isAnimatedGesture).map((g)=>g.handlers);
    }
}
function updateHandlers(preparedGesture, gestureConfig, gesture, mountedRef) {
    gestureConfig.prepare();
    for(let i = 0; i < gesture.length; i++){
        const handler = preparedGesture.config[i];
        checkGestureCallbacksForWorklets(handler); // only update handlerTag when it's actually different, it may be the same
        // if gesture config object is wrapped with useMemo
        if (gesture[i].handlerTag !== handler.handlerTag) {
            gesture[i].handlerTag = handler.handlerTag;
            gesture[i].handlers.handlerTag = handler.handlerTag;
        }
    } // use queueMicrotask to extract handlerTags, because when it's ran, all refs should be updated
    // and handlerTags in BaseGesture references should be updated in the loop above (we need to wait
    // in case of external relations)
    queueMicrotask(()=>{
        if (!mountedRef.current) {
            return;
        }
        for(let i = 0; i < gesture.length; i++){
            const handler = preparedGesture.config[i];
            handler.config = gesture[i].config;
            handler.handlers = gesture[i].handlers;
            const requireToFail = extractValidHandlerTags(handler.config.requireToFail);
            const simultaneousWith = extractValidHandlerTags(handler.config.simultaneousWith);
            _RNGestureHandlerModule.default.updateGestureHandler(handler.handlerTag, (0, _gestureHandlerCommon.filterConfig)(handler.config, ALLOWED_PROPS, {
                simultaneousHandlers: simultaneousWith,
                waitFor: requireToFail
            }));
            (0, _handlersRegistry.registerHandler)(handler.handlerTag, handler, handler.config.testId);
        }
        if (preparedGesture.animatedHandlers) {
            var _preparedGesture$anim;
            const previousHandlersValue = (_preparedGesture$anim = preparedGesture.animatedHandlers.value) !== null && _preparedGesture$anim !== void 0 ? _preparedGesture$anim : [];
            const newHandlersValue = preparedGesture.config.filter((g)=>g.shouldUseReanimated) // ignore gestures that shouldn't run on UI
            .map((g)=>g.handlers); // if amount of gesture configs changes, we need to update the callbacks in shared value
            let shouldUpdateSharedValue = previousHandlersValue.length !== newHandlersValue.length;
            if (!shouldUpdateSharedValue) {
                // if the amount is the same, we need to check if any of the configs inside has changed
                for(let i = 0; i < newHandlersValue.length; i++){
                    if (newHandlersValue[i].gestureId !== previousHandlersValue[i].gestureId) {
                        shouldUpdateSharedValue = true;
                        break;
                    }
                }
            }
            if (shouldUpdateSharedValue) {
                preparedGesture.animatedHandlers.value = newHandlersValue;
            }
        }
        (0, _gestureHandlerCommon.scheduleFlushOperations)();
    });
}
function needsToReattach(preparedGesture, gesture) {
    if (gesture.length !== preparedGesture.config.length) {
        return true;
    }
    for(let i = 0; i < gesture.length; i++){
        if (gesture[i].handlerName !== preparedGesture.config[i].handlerName || gesture[i].shouldUseReanimated !== preparedGesture.config[i].shouldUseReanimated) {
            return true;
        }
    }
    return false;
}
function isStateChangeEvent(event) {
    "worklet"; // @ts-ignore Yes, the oldState prop is missing on GestureTouchEvent, that's the point
    return event.oldState != null;
}
function isTouchEvent(event) {
    "worklet";
    return event.eventType != null;
}
function getHandler(type, gesture) {
    "worklet";
    switch(type){
        case _gesture.CALLBACK_TYPE.BEGAN:
            return gesture.onBegin;
        case _gesture.CALLBACK_TYPE.START:
            return gesture.onStart;
        case _gesture.CALLBACK_TYPE.UPDATE:
            return gesture.onUpdate;
        case _gesture.CALLBACK_TYPE.CHANGE:
            return gesture.onChange;
        case _gesture.CALLBACK_TYPE.END:
            return gesture.onEnd;
        case _gesture.CALLBACK_TYPE.FINALIZE:
            return gesture.onFinalize;
        case _gesture.CALLBACK_TYPE.TOUCHES_DOWN:
            return gesture.onTouchesDown;
        case _gesture.CALLBACK_TYPE.TOUCHES_MOVE:
            return gesture.onTouchesMove;
        case _gesture.CALLBACK_TYPE.TOUCHES_UP:
            return gesture.onTouchesUp;
        case _gesture.CALLBACK_TYPE.TOUCHES_CANCELLED:
            return gesture.onTouchesCancelled;
    }
}
function touchEventTypeToCallbackType(eventType) {
    "worklet";
    switch(eventType){
        case _TouchEventType.TouchEventType.TOUCHES_DOWN:
            return _gesture.CALLBACK_TYPE.TOUCHES_DOWN;
        case _TouchEventType.TouchEventType.TOUCHES_MOVE:
            return _gesture.CALLBACK_TYPE.TOUCHES_MOVE;
        case _TouchEventType.TouchEventType.TOUCHES_UP:
            return _gesture.CALLBACK_TYPE.TOUCHES_UP;
        case _TouchEventType.TouchEventType.TOUCHES_CANCELLED:
            return _gesture.CALLBACK_TYPE.TOUCHES_CANCELLED;
    }
    return _gesture.CALLBACK_TYPE.UNDEFINED;
}
function runWorklet(type, gesture, event, ...args) {
    "worklet";
    const handler = getHandler(type, gesture);
    if (gesture.isWorklet[type]) {
        // @ts-ignore Logic below makes sure the correct event is send to the
        // correct handler.
        handler === null || handler === void 0 ? void 0 : handler(event, ...args);
    } else if (handler) {
        console.warn((0, _utils.tagMessage)("Animated gesture callback must be a worklet"));
    }
}
function useAnimatedGesture(preparedGesture, needsRebuild) {
    if (!_reanimatedWrapper.Reanimated) {
        return;
    } // Hooks are called conditionally, but the condition is whether the
    // react-native-reanimated is installed, which shouldn't change while running
    // eslint-disable-next-line react-hooks/rules-of-hooks
    const sharedHandlersCallbacks = _reanimatedWrapper.Reanimated.useSharedValue(null); // eslint-disable-next-line react-hooks/rules-of-hooks
    const lastUpdateEvent = _reanimatedWrapper.Reanimated.useSharedValue([]); // not every gesture needs a state controller, init them lazily
    const stateControllers = [];
    const callback = (event)=>{
        "worklet";
        const currentCallback = sharedHandlersCallbacks.value;
        if (!currentCallback) {
            return;
        }
        for(let i = 0; i < currentCallback.length; i++){
            const gesture = currentCallback[i];
            if (event.handlerTag === gesture.handlerTag) {
                if (isStateChangeEvent(event)) {
                    if (event.oldState === _State.State.UNDETERMINED && event.state === _State.State.BEGAN) {
                        runWorklet(_gesture.CALLBACK_TYPE.BEGAN, gesture, event);
                    } else if ((event.oldState === _State.State.BEGAN || event.oldState === _State.State.UNDETERMINED) && event.state === _State.State.ACTIVE) {
                        runWorklet(_gesture.CALLBACK_TYPE.START, gesture, event);
                        lastUpdateEvent.value[gesture.handlerTag] = undefined;
                    } else if (event.oldState !== event.state && event.state === _State.State.END) {
                        if (event.oldState === _State.State.ACTIVE) {
                            runWorklet(_gesture.CALLBACK_TYPE.END, gesture, event, true);
                        }
                        runWorklet(_gesture.CALLBACK_TYPE.FINALIZE, gesture, event, true);
                    } else if ((event.state === _State.State.FAILED || event.state === _State.State.CANCELLED) && event.state !== event.oldState) {
                        if (event.oldState === _State.State.ACTIVE) {
                            runWorklet(_gesture.CALLBACK_TYPE.END, gesture, event, false);
                        }
                        runWorklet(_gesture.CALLBACK_TYPE.FINALIZE, gesture, event, false);
                    }
                } else if (isTouchEvent(event)) {
                    if (!stateControllers[i]) {
                        stateControllers[i] = _gestureStateManager.GestureStateManager.create(event.handlerTag);
                    }
                    if (event.eventType !== _TouchEventType.TouchEventType.UNDETERMINED) {
                        runWorklet(touchEventTypeToCallbackType(event.eventType), gesture, event, stateControllers[i]);
                    }
                } else {
                    runWorklet(_gesture.CALLBACK_TYPE.UPDATE, gesture, event);
                    if (gesture.onChange && gesture.changeEventCalculator) {
                        var _gesture$changeEventC;
                        runWorklet(_gesture.CALLBACK_TYPE.CHANGE, gesture, (_gesture$changeEventC = gesture.changeEventCalculator) === null || _gesture$changeEventC === void 0 ? void 0 : _gesture$changeEventC.call(gesture, event, lastUpdateEvent.value[gesture.handlerTag]));
                        lastUpdateEvent.value[gesture.handlerTag] = event;
                    }
                }
            }
        }
    }; // eslint-disable-next-line react-hooks/rules-of-hooks
    const event = _reanimatedWrapper.Reanimated.useEvent(callback, [
        "onGestureHandlerStateChange",
        "onGestureHandlerEvent"
    ], needsRebuild);
    preparedGesture.animatedEventHandler = event;
    preparedGesture.animatedHandlers = sharedHandlersCallbacks;
} // eslint-disable-next-line @typescript-eslint/no-explicit-any
function validateDetectorChildren(ref) {
    // finds the first native view under the Wrap component and traverses the fiber tree upwards
    // to check whether there is more than one native view as a pseudo-direct child of GestureDetector
    // i.e. this is not ok:
    //            Wrap
    //             |
    //            / \
    //           /   \
    //          /     \
    //         /       \
    //   NativeView  NativeView
    //
    // but this is fine:
    //            Wrap
    //             |
    //         NativeView
    //             |
    //            / \
    //           /   \
    //          /     \
    //         /       \
    //   NativeView  NativeView
    if (false) {}
}
const applyUserSelectProp = (userSelect, gesture)=>{
    for (const g of gesture.toGestureArray()){
        g.config.userSelect = userSelect;
    }
};
const GestureDetector = (props)=>{
    const rootViewContext = (0, _react.useContext)(_GestureHandlerRootViewContext.default);
    if (false) {}
    const gestureConfig = props.gesture;
    if (props.userSelect) {
        applyUserSelectProp(props.userSelect, gestureConfig);
    }
    const gesture = gestureConfig.toGestureArray();
    const useReanimatedHook = gesture.some((g)=>g.shouldUseReanimated); // store state in ref to prevent unnecessary renders
    const state = (0, _react.useRef)({
        firstRender: true,
        viewRef: null,
        previousViewTag: -1,
        forceReattach: false
    }).current;
    const mountedRef = (0, _react.useRef)(false);
    const webEventHandlersRef = (0, _react.useRef)({
        onGestureHandlerEvent: (e)=>{
            (0, _eventReceiver.onGestureHandlerEvent)(e.nativeEvent);
        },
        onGestureHandlerStateChange: (0, _EnableNewWebImplementation.isNewWebImplementationEnabled)() ? (e)=>{
            (0, _eventReceiver.onGestureHandlerEvent)(e.nativeEvent);
        } : undefined
    });
    const [renderState, setRenderState] = (0, _react.useState)(false);
    function forceRender() {
        setRenderState(!renderState);
    }
    const preparedGesture = _react.default.useRef({
        config: gesture,
        animatedEventHandler: null,
        animatedHandlers: null,
        firstExecution: true,
        useReanimatedHook: useReanimatedHook
    }).current;
    if (useReanimatedHook !== preparedGesture.useReanimatedHook) {
        throw new Error((0, _utils.tagMessage)("You cannot change the thread the callbacks are ran on while the app is running"));
    }
    function onHandlersUpdate(skipConfigUpdate) {
        // if the underlying view has changed we need to reattach handlers to the new view
        const viewTag = (0, _gestureHandlerCommon.findNodeHandle)(state.viewRef);
        const forceReattach = viewTag !== state.previousViewTag;
        if (forceReattach || needsToReattach(preparedGesture, gesture)) {
            validateDetectorChildren(state.viewRef);
            dropHandlers(preparedGesture);
            attachHandlers({
                preparedGesture,
                gestureConfig,
                gesture,
                webEventHandlersRef,
                viewTag,
                mountedRef
            });
            state.previousViewTag = viewTag;
            state.forceReattach = forceReattach;
            if (forceReattach) {
                forceRender();
            }
        } else if (!skipConfigUpdate) {
            updateHandlers(preparedGesture, gestureConfig, gesture, mountedRef);
        }
    } // Reanimated event should be rebuilt only when gestures are reattached, otherwise
    // config update will be enough as all necessary items are stored in shared values anyway
    const needsToRebuildReanimatedEvent = preparedGesture.firstExecution || needsToReattach(preparedGesture, gesture) || state.forceReattach;
    state.forceReattach = false;
    if (preparedGesture.firstExecution) {
        gestureConfig.initialize();
    }
    if (useReanimatedHook) {
        // Whether animatedGesture or gesture is used shouldn't change while the app is running
        // eslint-disable-next-line react-hooks/rules-of-hooks
        useAnimatedGesture(preparedGesture, needsToRebuildReanimatedEvent);
    }
    (0, _react.useEffect)(()=>{
        const viewTag = (0, _gestureHandlerCommon.findNodeHandle)(state.viewRef);
        state.firstRender = true;
        mountedRef.current = true;
        validateDetectorChildren(state.viewRef);
        attachHandlers({
            preparedGesture,
            gestureConfig,
            gesture,
            webEventHandlersRef,
            viewTag,
            mountedRef
        });
        return ()=>{
            mountedRef.current = false;
            dropHandlers(preparedGesture);
        };
    }, []);
    (0, _react.useEffect)(()=>{
        if (!state.firstRender) {
            onHandlersUpdate();
        } else {
            state.firstRender = false;
        }
    }, [
        props
    ]);
    const refFunction = (ref)=>{
        if (ref !== null) {
            // @ts-ignore Just setting the view ref
            state.viewRef = ref; // if it's the first render, also set the previousViewTag to prevent reattaching gestures when not needed
            if (state.previousViewTag === -1) {
                state.previousViewTag = (0, _gestureHandlerCommon.findNodeHandle)(state.viewRef);
            } // pass true as `skipConfigUpdate`, here we only want to trigger the eventual reattaching of handlers
            // in case the view has changed, while config update would be handled be the `useEffect` above
            onHandlersUpdate(true);
            if ((0, _utils.isFabric)()) {
                const node = (0, _getShadowNodeFromRef.getShadowNodeFromRef)(ref);
                if (global.isFormsStackingContext(node) === false) {
                    console.error((0, _utils.tagMessage)("GestureDetector has received a child that may get view-flattened. " + "\nTo prevent it from misbehaving you need to wrap the child with a `<View collapsable={false}>`."));
                }
            }
        }
    };
    if (useReanimatedHook) {
        return /*#__PURE__*/ _react.default.createElement(AnimatedWrap, {
            ref: refFunction,
            onGestureHandlerEvent: preparedGesture.animatedEventHandler
        }, props.children);
    } else {
        return /*#__PURE__*/ _react.default.createElement(Wrap, {
            ref: refFunction
        }, props.children);
    }
};
exports.GestureDetector = GestureDetector;
class Wrap extends _react.default.Component {
    render() {
        try {
            // I don't think that fighting with types over such a simple function is worth it
            // The only thing it does is add 'collapsable: false' to the child component
            // to make sure it is in the native view hierarchy so the detector can find
            // correct viewTag to attach to.
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            const child = _react.default.Children.only(this.props.children);
            return /*#__PURE__*/ _react.default.cloneElement(child, {
                collapsable: false
            }, child.props.children);
        } catch (e) {
            throw new Error((0, _utils.tagMessage)(`GestureDetector got more than one view as a child. If you want the gesture to work on multiple views, wrap them with a common parent and attach the gesture to that view.`));
        }
    }
}
const AnimatedWrap = (_Reanimated$default$c = _reanimatedWrapper.Reanimated === null || _reanimatedWrapper.Reanimated === void 0 ? void 0 : (_Reanimated$default = _reanimatedWrapper.Reanimated.default) === null || _Reanimated$default === void 0 ? void 0 : _Reanimated$default.createAnimatedComponent(Wrap)) !== null && _Reanimated$default$c !== void 0 ? _Reanimated$default$c : Wrap; //# sourceMappingURL=GestureDetector.js.map


/***/ }),

/***/ 69323:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.onGestureHandlerEvent = onGestureHandlerEvent;
exports.startListening = startListening;
exports.stopListening = stopListening;
var _reactNative = __webpack_require__(83849);
var _State = __webpack_require__(10125);
var _TouchEventType = __webpack_require__(5887);
var _handlersRegistry = __webpack_require__(83406);
var _gestureStateManager = __webpack_require__(8865);
let gestureHandlerEventSubscription = null;
let gestureHandlerStateChangeEventSubscription = null;
const gestureStateManagers = new Map();
const lastUpdateEvent = [];
function isStateChangeEvent(event) {
    // @ts-ignore oldState doesn't exist on GestureTouchEvent and that's the point
    return event.oldState != null;
}
function isTouchEvent(event) {
    return event.eventType != null;
}
function onGestureHandlerEvent(event) {
    var _handler$handlers7, _handler$handlers7$on, _handler$handlers8, _handler$handlers8$on, _handler$handlers9, _handler$handlers9$on, _handler$handlers10, _handler$handlers10$o;
    const handler = (0, _handlersRegistry.findHandler)(event.handlerTag);
    if (handler) {
        if (isStateChangeEvent(event)) {
            if (event.oldState === _State.State.UNDETERMINED && event.state === _State.State.BEGAN) {
                var _handler$handlers$onB, _handler$handlers;
                (_handler$handlers$onB = (_handler$handlers = handler.handlers).onBegin) === null || _handler$handlers$onB === void 0 ? void 0 : _handler$handlers$onB.call(_handler$handlers, event);
            } else if ((event.oldState === _State.State.BEGAN || event.oldState === _State.State.UNDETERMINED) && event.state === _State.State.ACTIVE) {
                var _handler$handlers$onS, _handler$handlers2;
                (_handler$handlers$onS = (_handler$handlers2 = handler.handlers).onStart) === null || _handler$handlers$onS === void 0 ? void 0 : _handler$handlers$onS.call(_handler$handlers2, event);
                lastUpdateEvent[handler.handlers.handlerTag] = event;
            } else if (event.oldState !== event.state && event.state === _State.State.END) {
                var _handler$handlers$onF, _handler$handlers4;
                if (event.oldState === _State.State.ACTIVE) {
                    var _handler$handlers$onE, _handler$handlers3;
                    (_handler$handlers$onE = (_handler$handlers3 = handler.handlers).onEnd) === null || _handler$handlers$onE === void 0 ? void 0 : _handler$handlers$onE.call(_handler$handlers3, event, true);
                }
                (_handler$handlers$onF = (_handler$handlers4 = handler.handlers).onFinalize) === null || _handler$handlers$onF === void 0 ? void 0 : _handler$handlers$onF.call(_handler$handlers4, event, true);
                lastUpdateEvent[handler.handlers.handlerTag] = undefined;
            } else if ((event.state === _State.State.FAILED || event.state === _State.State.CANCELLED) && event.oldState !== event.state) {
                var _handler$handlers$onF2, _handler$handlers6;
                if (event.oldState === _State.State.ACTIVE) {
                    var _handler$handlers$onE2, _handler$handlers5;
                    (_handler$handlers$onE2 = (_handler$handlers5 = handler.handlers).onEnd) === null || _handler$handlers$onE2 === void 0 ? void 0 : _handler$handlers$onE2.call(_handler$handlers5, event, false);
                }
                (_handler$handlers$onF2 = (_handler$handlers6 = handler.handlers).onFinalize) === null || _handler$handlers$onF2 === void 0 ? void 0 : _handler$handlers$onF2.call(_handler$handlers6, event, false);
                gestureStateManagers.delete(event.handlerTag);
                lastUpdateEvent[handler.handlers.handlerTag] = undefined;
            }
        } else if (isTouchEvent(event)) {
            if (!gestureStateManagers.has(event.handlerTag)) {
                gestureStateManagers.set(event.handlerTag, _gestureStateManager.GestureStateManager.create(event.handlerTag));
            } // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            const manager = gestureStateManagers.get(event.handlerTag);
            switch(event.eventType){
                case _TouchEventType.TouchEventType.TOUCHES_DOWN:
                    (_handler$handlers7 = handler.handlers) === null || _handler$handlers7 === void 0 ? void 0 : (_handler$handlers7$on = _handler$handlers7.onTouchesDown) === null || _handler$handlers7$on === void 0 ? void 0 : _handler$handlers7$on.call(_handler$handlers7, event, manager);
                    break;
                case _TouchEventType.TouchEventType.TOUCHES_MOVE:
                    (_handler$handlers8 = handler.handlers) === null || _handler$handlers8 === void 0 ? void 0 : (_handler$handlers8$on = _handler$handlers8.onTouchesMove) === null || _handler$handlers8$on === void 0 ? void 0 : _handler$handlers8$on.call(_handler$handlers8, event, manager);
                    break;
                case _TouchEventType.TouchEventType.TOUCHES_UP:
                    (_handler$handlers9 = handler.handlers) === null || _handler$handlers9 === void 0 ? void 0 : (_handler$handlers9$on = _handler$handlers9.onTouchesUp) === null || _handler$handlers9$on === void 0 ? void 0 : _handler$handlers9$on.call(_handler$handlers9, event, manager);
                    break;
                case _TouchEventType.TouchEventType.TOUCHES_CANCELLED:
                    (_handler$handlers10 = handler.handlers) === null || _handler$handlers10 === void 0 ? void 0 : (_handler$handlers10$o = _handler$handlers10.onTouchesCancelled) === null || _handler$handlers10$o === void 0 ? void 0 : _handler$handlers10$o.call(_handler$handlers10, event, manager);
                    break;
            }
        } else {
            var _handler$handlers$onU, _handler$handlers11;
            (_handler$handlers$onU = (_handler$handlers11 = handler.handlers).onUpdate) === null || _handler$handlers$onU === void 0 ? void 0 : _handler$handlers$onU.call(_handler$handlers11, event);
            if (handler.handlers.onChange && handler.handlers.changeEventCalculator) {
                var _handler$handlers$onC, _handler$handlers12, _handler$handlers$cha, _handler$handlers13;
                (_handler$handlers$onC = (_handler$handlers12 = handler.handlers).onChange) === null || _handler$handlers$onC === void 0 ? void 0 : _handler$handlers$onC.call(_handler$handlers12, (_handler$handlers$cha = (_handler$handlers13 = handler.handlers).changeEventCalculator) === null || _handler$handlers$cha === void 0 ? void 0 : _handler$handlers$cha.call(_handler$handlers13, event, lastUpdateEvent[handler.handlers.handlerTag]));
                lastUpdateEvent[handler.handlers.handlerTag] = event;
            }
        }
    } else {
        const oldHandler = (0, _handlersRegistry.findOldGestureHandler)(event.handlerTag);
        if (oldHandler) {
            const nativeEvent = {
                nativeEvent: event
            };
            if (isStateChangeEvent(event)) {
                oldHandler.onGestureStateChange(nativeEvent);
            } else {
                oldHandler.onGestureEvent(nativeEvent);
            }
            return;
        }
    }
}
function startListening() {
    stopListening();
    gestureHandlerEventSubscription = _reactNative.DeviceEventEmitter.addListener("onGestureHandlerEvent", onGestureHandlerEvent);
    gestureHandlerStateChangeEventSubscription = _reactNative.DeviceEventEmitter.addListener("onGestureHandlerStateChange", onGestureHandlerEvent);
}
function stopListening() {
    if (gestureHandlerEventSubscription) {
        gestureHandlerEventSubscription.remove();
        gestureHandlerEventSubscription = null;
    }
    if (gestureHandlerStateChangeEventSubscription) {
        gestureHandlerStateChangeEventSubscription.remove();
        gestureHandlerStateChangeEventSubscription = null;
    }
} //# sourceMappingURL=eventReceiver.js.map


/***/ }),

/***/ 5975:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.FlingGesture = void 0;
var _gesture = __webpack_require__(90159);
function _defineProperty(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
class FlingGesture extends _gesture.BaseGesture {
    constructor(){
        super();
        _defineProperty(this, "config", {});
        this.handlerName = "FlingGestureHandler";
    }
    numberOfPointers(pointers) {
        this.config.numberOfPointers = pointers;
        return this;
    }
    direction(direction) {
        this.config.direction = direction;
        return this;
    }
}
exports.FlingGesture = FlingGesture; //# sourceMappingURL=flingGesture.js.map


/***/ }),

/***/ 20273:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.ForceTouchGesture = void 0;
var _gesture = __webpack_require__(90159);
function _defineProperty(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
function changeEventCalculator(current, previous) {
    "worklet";
    let changePayload;
    if (previous === undefined) {
        changePayload = {
            forceChange: current.force
        };
    } else {
        changePayload = {
            forceChange: current.force - previous.force
        };
    }
    return {
        ...current,
        ...changePayload
    };
}
class ForceTouchGesture extends _gesture.ContinousBaseGesture {
    constructor(){
        super();
        _defineProperty(this, "config", {});
        this.handlerName = "ForceTouchGestureHandler";
    }
    minForce(force) {
        this.config.minForce = force;
        return this;
    }
    maxForce(force) {
        this.config.maxForce = force;
        return this;
    }
    feedbackOnActivation(value) {
        this.config.feedbackOnActivation = value;
        return this;
    }
    onChange(callback) {
        // @ts-ignore TS being overprotective, ForceTouchGestureHandlerEventPayload is Record
        this.handlers.changeEventCalculator = changeEventCalculator;
        return super.onChange(callback);
    }
}
exports.ForceTouchGesture = ForceTouchGesture; //# sourceMappingURL=forceTouchGesture.js.map


/***/ }),

/***/ 90159:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.ContinousBaseGesture = exports.BaseGesture = exports.Gesture = exports.CALLBACK_TYPE = void 0;
var _handlersRegistry = __webpack_require__(83406);
var _utils = __webpack_require__(50693);
function _defineProperty(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
const CALLBACK_TYPE = {
    UNDEFINED: 0,
    BEGAN: 1,
    START: 2,
    UPDATE: 3,
    CHANGE: 4,
    END: 5,
    FINALIZE: 6,
    TOUCHES_DOWN: 7,
    TOUCHES_MOVE: 8,
    TOUCHES_UP: 9,
    TOUCHES_CANCELLED: 10
}; // Allow using CALLBACK_TYPE as object and type
// eslint-disable-next-line @typescript-eslint/no-redeclare
exports.CALLBACK_TYPE = CALLBACK_TYPE;
class Gesture {
}
exports.Gesture = Gesture;
let nextGestureId = 0;
class BaseGesture extends Gesture {
    constructor(){
        super(); // Used to check whether the gesture config has been updated when wrapping it
        // with `useMemo`. Since every config will have a unique id, when the dependencies
        // don't change, the config won't be recreated and the id will stay the same.
        // If the id is different, it means that the config has changed and the gesture
        // needs to be updated.
        _defineProperty(this, "gestureId", -1);
        _defineProperty(this, "handlerTag", -1);
        _defineProperty(this, "handlerName", "");
        _defineProperty(this, "config", {});
        _defineProperty(this, "handlers", {
            gestureId: -1,
            handlerTag: -1,
            isWorklet: []
        });
        this.gestureId = nextGestureId++;
        this.handlers.gestureId = this.gestureId;
    }
    addDependency(key, gesture) {
        const value = this.config[key];
        this.config[key] = value ? Array().concat(value, gesture) : [
            gesture
        ];
    }
    withRef(ref) {
        this.config.ref = ref;
        return this;
    }
    isWorklet(callback) {
        //@ts-ignore if callback is a worklet, the property will be available, if not then the check will return false
        return callback.__workletHash !== undefined;
    }
    onBegin(callback) {
        this.handlers.onBegin = callback;
        this.handlers.isWorklet[CALLBACK_TYPE.BEGAN] = this.isWorklet(callback);
        return this;
    }
    onStart(callback) {
        this.handlers.onStart = callback;
        this.handlers.isWorklet[CALLBACK_TYPE.START] = this.isWorklet(callback);
        return this;
    }
    onEnd(callback) {
        this.handlers.onEnd = callback; //@ts-ignore if callback is a worklet, the property will be available, if not then the check will return false
        this.handlers.isWorklet[CALLBACK_TYPE.END] = this.isWorklet(callback);
        return this;
    }
    onFinalize(callback) {
        this.handlers.onFinalize = callback; //@ts-ignore if callback is a worklet, the property will be available, if not then the check will return false
        this.handlers.isWorklet[CALLBACK_TYPE.FINALIZE] = this.isWorklet(callback);
        return this;
    }
    onTouchesDown(callback) {
        this.config.needsPointerData = true;
        this.handlers.onTouchesDown = callback;
        this.handlers.isWorklet[CALLBACK_TYPE.TOUCHES_DOWN] = this.isWorklet(callback);
        return this;
    }
    onTouchesMove(callback) {
        this.config.needsPointerData = true;
        this.handlers.onTouchesMove = callback;
        this.handlers.isWorklet[CALLBACK_TYPE.TOUCHES_MOVE] = this.isWorklet(callback);
        return this;
    }
    onTouchesUp(callback) {
        this.config.needsPointerData = true;
        this.handlers.onTouchesUp = callback;
        this.handlers.isWorklet[CALLBACK_TYPE.TOUCHES_UP] = this.isWorklet(callback);
        return this;
    }
    onTouchesCancelled(callback) {
        this.config.needsPointerData = true;
        this.handlers.onTouchesCancelled = callback;
        this.handlers.isWorklet[CALLBACK_TYPE.TOUCHES_CANCELLED] = this.isWorklet(callback);
        return this;
    }
    enabled(enabled) {
        this.config.enabled = enabled;
        return this;
    }
    shouldCancelWhenOutside(value) {
        this.config.shouldCancelWhenOutside = value;
        return this;
    }
    hitSlop(hitSlop) {
        this.config.hitSlop = hitSlop;
        return this;
    }
    runOnJS(runOnJS) {
        this.config.runOnJS = runOnJS;
        return this;
    }
    simultaneousWithExternalGesture(...gestures) {
        for (const gesture of gestures){
            this.addDependency("simultaneousWith", gesture);
        }
        return this;
    }
    requireExternalGestureToFail(...gestures) {
        for (const gesture of gestures){
            this.addDependency("requireToFail", gesture);
        }
        return this;
    }
    withTestId(id) {
        this.config.testId = id;
        return this;
    }
    cancelsTouchesInView(value) {
        this.config.cancelsTouchesInView = value;
        return this;
    }
    initialize() {
        this.handlerTag = (0, _handlersRegistry.getNextHandlerTag)();
        this.handlers = {
            ...this.handlers,
            handlerTag: this.handlerTag
        };
        if (this.config.ref) {
            this.config.ref.current = this;
        }
    }
    toGestureArray() {
        return [
            this
        ];
    }
    prepare() {}
    get shouldUseReanimated() {
        // use Reanimated when runOnJS isn't set explicitly,
        // and all defined callbacks are worklets,
        // and remote debugging is disabled
        return this.config.runOnJS !== true && !this.handlers.isWorklet.includes(false) && !(0, _utils.isRemoteDebuggingEnabled)();
    }
}
exports.BaseGesture = BaseGesture;
class ContinousBaseGesture extends BaseGesture {
    onUpdate(callback) {
        this.handlers.onUpdate = callback;
        this.handlers.isWorklet[CALLBACK_TYPE.UPDATE] = this.isWorklet(callback);
        return this;
    }
    onChange(callback) {
        this.handlers.onChange = callback;
        this.handlers.isWorklet[CALLBACK_TYPE.CHANGE] = this.isWorklet(callback);
        return this;
    }
    manualActivation(manualActivation) {
        this.config.manualActivation = manualActivation;
        return this;
    }
}
exports.ContinousBaseGesture = ContinousBaseGesture; //# sourceMappingURL=gesture.js.map


/***/ }),

/***/ 33546:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.ExclusiveGesture = exports.SimultaneousGesture = exports.ComposedGesture = void 0;
var _gesture = __webpack_require__(90159);
function _defineProperty(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
function extendRelation(currentRelation, extendWith) {
    if (currentRelation === undefined) {
        return [
            ...extendWith
        ];
    } else {
        return [
            ...currentRelation,
            ...extendWith
        ];
    }
}
class ComposedGesture extends _gesture.Gesture {
    constructor(...gestures){
        super();
        _defineProperty(this, "gestures", []);
        _defineProperty(this, "simultaneousGestures", []);
        _defineProperty(this, "requireGesturesToFail", []);
        this.gestures = gestures;
    }
    prepareSingleGesture(gesture, simultaneousGestures, requireGesturesToFail) {
        if (gesture instanceof _gesture.BaseGesture) {
            const newConfig = {
                ...gesture.config
            };
            newConfig.simultaneousWith = extendRelation(newConfig.simultaneousWith, simultaneousGestures);
            newConfig.requireToFail = extendRelation(newConfig.requireToFail, requireGesturesToFail);
            gesture.config = newConfig;
        } else if (gesture instanceof ComposedGesture) {
            gesture.simultaneousGestures = simultaneousGestures;
            gesture.requireGesturesToFail = requireGesturesToFail;
            gesture.prepare();
        }
    }
    prepare() {
        for (const gesture of this.gestures){
            this.prepareSingleGesture(gesture, this.simultaneousGestures, this.requireGesturesToFail);
        }
    }
    initialize() {
        for (const gesture of this.gestures){
            gesture.initialize();
        }
    }
    toGestureArray() {
        return this.gestures.flatMap((gesture)=>gesture.toGestureArray());
    }
}
exports.ComposedGesture = ComposedGesture;
class SimultaneousGesture extends ComposedGesture {
    prepare() {
        // this piece of magic works something like this:
        // for every gesture in the array
        const simultaneousArrays = this.gestures.map((gesture)=>this.gestures // and make a copy without it
            .filter((x)=>x !== gesture) // then we flatmap the result to get list of raw (not composed) gestures
            // this way we don't make the gestures simultaneous with themselves, which is
            // important when the gesture is `ExclusiveGesture` - we don't want to make
            // exclusive gestures simultaneous
            .flatMap((x)=>x.toGestureArray()));
        for(let i = 0; i < this.gestures.length; i++){
            this.prepareSingleGesture(this.gestures[i], simultaneousArrays[i], this.requireGesturesToFail);
        }
    }
}
exports.SimultaneousGesture = SimultaneousGesture;
class ExclusiveGesture extends ComposedGesture {
    prepare() {
        // transforms the array of gestures into array of grouped raw (not composed) gestures
        // i.e. [gesture1, gesture2, ComposedGesture(gesture3, gesture4)] -> [[gesture1], [gesture2], [gesture3, gesture4]]
        const gestureArrays = this.gestures.map((gesture)=>gesture.toGestureArray());
        let requireToFail = [];
        for(let i = 0; i < this.gestures.length; i++){
            this.prepareSingleGesture(this.gestures[i], this.simultaneousGestures, this.requireGesturesToFail.concat(requireToFail)); // every group gets to wait for all groups before it
            requireToFail = requireToFail.concat(gestureArrays[i]);
        }
    }
}
exports.ExclusiveGesture = ExclusiveGesture; //# sourceMappingURL=gestureComposition.js.map


/***/ }),

/***/ 79559:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.GestureObjects = void 0;
var _flingGesture = __webpack_require__(5975);
var _forceTouchGesture = __webpack_require__(20273);
var _gestureComposition = __webpack_require__(33546);
var _longPressGesture = __webpack_require__(77846);
var _panGesture = __webpack_require__(58310);
var _pinchGesture = __webpack_require__(44427);
var _rotationGesture = __webpack_require__(13223);
var _tapGesture = __webpack_require__(37558);
var _nativeGesture = __webpack_require__(96913);
var _manualGesture = __webpack_require__(1610);
const GestureObjects = {
    Tap: ()=>{
        return new _tapGesture.TapGesture();
    },
    Pan: ()=>{
        return new _panGesture.PanGesture();
    },
    Pinch: ()=>{
        return new _pinchGesture.PinchGesture();
    },
    Rotation: ()=>{
        return new _rotationGesture.RotationGesture();
    },
    Fling: ()=>{
        return new _flingGesture.FlingGesture();
    },
    LongPress: ()=>{
        return new _longPressGesture.LongPressGesture();
    },
    ForceTouch: ()=>{
        return new _forceTouchGesture.ForceTouchGesture();
    },
    Native: ()=>{
        return new _nativeGesture.NativeGesture();
    },
    Manual: ()=>{
        return new _manualGesture.ManualGesture();
    },
    /**
   * Builds a composed gesture consisting of gestures provided as parameters.
   * The first one that becomes active cancels the rest of gestures.
   */ Race: (...gestures)=>{
        return new _gestureComposition.ComposedGesture(...gestures);
    },
    /**
   * Builds a composed gesture that allows all base gestures to run simultaneously.
   */ Simultaneous (...gestures) {
        return new _gestureComposition.SimultaneousGesture(...gestures);
    },
    /**
   * Builds a composed gesture where only one of the provided gestures can become active.
   * Priority is decided through the order of gestures: the first one has higher priority
   * than the second one, second one has higher priority than the third one, and so on.
   * For example, to make a gesture that recognizes both single and double tap you need
   * to call Exclusive(doubleTap, singleTap).
   */ Exclusive (...gestures) {
        return new _gestureComposition.ExclusiveGesture(...gestures);
    }
};
exports.GestureObjects = GestureObjects; //# sourceMappingURL=gestureObjects.js.map


/***/ }),

/***/ 8865:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.GestureStateManager = void 0;
var _NodeManager = _interopRequireDefault(__webpack_require__(60596));
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
const GestureStateManager = {
    create (handlerTag) {
        return {
            begin: ()=>{
                _NodeManager.default.getHandler(handlerTag).begin();
            },
            activate: ()=>{
                _NodeManager.default.getHandler(handlerTag).activate();
            },
            fail: ()=>{
                _NodeManager.default.getHandler(handlerTag).fail();
            },
            end: ()=>{
                _NodeManager.default.getHandler(handlerTag).end();
            }
        };
    }
};
exports.GestureStateManager = GestureStateManager; //# sourceMappingURL=gestureStateManager.web.js.map


/***/ }),

/***/ 77846:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.LongPressGesture = void 0;
var _gesture = __webpack_require__(90159);
function _defineProperty(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
class LongPressGesture extends _gesture.BaseGesture {
    constructor(){
        super();
        _defineProperty(this, "config", {});
        this.handlerName = "LongPressGestureHandler";
        this.shouldCancelWhenOutside(true);
    }
    minDuration(duration) {
        this.config.minDurationMs = duration;
        return this;
    }
    maxDistance(distance) {
        this.config.maxDist = distance;
        return this;
    }
}
exports.LongPressGesture = LongPressGesture; //# sourceMappingURL=longPressGesture.js.map


/***/ }),

/***/ 1610:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.ManualGesture = void 0;
var _gesture = __webpack_require__(90159);
function changeEventCalculator(current, _previous) {
    "worklet";
    return current;
}
class ManualGesture extends _gesture.ContinousBaseGesture {
    constructor(){
        super();
        this.handlerName = "ManualGestureHandler";
    }
    onChange(callback) {
        // @ts-ignore TS being overprotective, Record<string, never> is Record
        this.handlers.changeEventCalculator = changeEventCalculator;
        return super.onChange(callback);
    }
}
exports.ManualGesture = ManualGesture; //# sourceMappingURL=manualGesture.js.map


/***/ }),

/***/ 96913:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.NativeGesture = void 0;
var _gesture = __webpack_require__(90159);
function _defineProperty(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
class NativeGesture extends _gesture.BaseGesture {
    constructor(){
        super();
        _defineProperty(this, "config", {});
        this.handlerName = "NativeViewGestureHandler";
    }
    shouldActivateOnStart(value) {
        this.config.shouldActivateOnStart = value;
        return this;
    }
    disallowInterruption(value) {
        this.config.disallowInterruption = value;
        return this;
    }
}
exports.NativeGesture = NativeGesture; //# sourceMappingURL=nativeGesture.js.map


/***/ }),

/***/ 58310:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.PanGesture = void 0;
var _gesture = __webpack_require__(90159);
function _defineProperty(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
function changeEventCalculator(current, previous) {
    "worklet";
    let changePayload;
    if (previous === undefined) {
        changePayload = {
            changeX: current.translationX,
            changeY: current.translationY
        };
    } else {
        changePayload = {
            changeX: current.translationX - previous.translationX,
            changeY: current.translationY - previous.translationY
        };
    }
    return {
        ...current,
        ...changePayload
    };
}
class PanGesture extends _gesture.ContinousBaseGesture {
    constructor(){
        super();
        _defineProperty(this, "config", {});
        this.handlerName = "PanGestureHandler";
    }
    activeOffsetY(offset) {
        if (Array.isArray(offset)) {
            this.config.activeOffsetYStart = offset[0];
            this.config.activeOffsetYEnd = offset[1];
        } else if (offset < 0) {
            this.config.activeOffsetYStart = offset;
        } else {
            this.config.activeOffsetYEnd = offset;
        }
        return this;
    }
    activeOffsetX(offset) {
        if (Array.isArray(offset)) {
            this.config.activeOffsetXStart = offset[0];
            this.config.activeOffsetXEnd = offset[1];
        } else if (offset < 0) {
            this.config.activeOffsetXStart = offset;
        } else {
            this.config.activeOffsetXEnd = offset;
        }
        return this;
    }
    failOffsetY(offset) {
        if (Array.isArray(offset)) {
            this.config.failOffsetYStart = offset[0];
            this.config.failOffsetYEnd = offset[1];
        } else if (offset < 0) {
            this.config.failOffsetYStart = offset;
        } else {
            this.config.failOffsetYEnd = offset;
        }
        return this;
    }
    failOffsetX(offset) {
        if (Array.isArray(offset)) {
            this.config.failOffsetXStart = offset[0];
            this.config.failOffsetXEnd = offset[1];
        } else if (offset < 0) {
            this.config.failOffsetXStart = offset;
        } else {
            this.config.failOffsetXEnd = offset;
        }
        return this;
    }
    minPointers(minPointers) {
        this.config.minPointers = minPointers;
        return this;
    }
    maxPointers(maxPointers) {
        this.config.maxPointers = maxPointers;
        return this;
    }
    minDistance(distance) {
        this.config.minDist = distance;
        return this;
    }
    minVelocity(velocity) {
        this.config.minVelocity = velocity;
        return this;
    }
    minVelocityX(velocity) {
        this.config.minVelocityX = velocity;
        return this;
    }
    minVelocityY(velocity) {
        this.config.minVelocityY = velocity;
        return this;
    }
    averageTouches(value) {
        this.config.avgTouches = value;
        return this;
    }
    enableTrackpadTwoFingerGesture(value) {
        this.config.enableTrackpadTwoFingerGesture = value;
        return this;
    }
    activateAfterLongPress(duration) {
        this.config.activateAfterLongPress = duration;
        return this;
    }
    onChange(callback) {
        // @ts-ignore TS being overprotective, PanGestureHandlerEventPayload is Record
        this.handlers.changeEventCalculator = changeEventCalculator;
        return super.onChange(callback);
    }
}
exports.PanGesture = PanGesture; //# sourceMappingURL=panGesture.js.map


/***/ }),

/***/ 44427:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.PinchGesture = void 0;
var _gesture = __webpack_require__(90159);
function changeEventCalculator(current, previous) {
    "worklet";
    let changePayload;
    if (previous === undefined) {
        changePayload = {
            scaleChange: current.scale
        };
    } else {
        changePayload = {
            scaleChange: current.scale / previous.scale
        };
    }
    return {
        ...current,
        ...changePayload
    };
}
class PinchGesture extends _gesture.ContinousBaseGesture {
    constructor(){
        super();
        this.handlerName = "PinchGestureHandler";
    }
    onChange(callback) {
        // @ts-ignore TS being overprotective, PinchGestureHandlerEventPayload is Record
        this.handlers.changeEventCalculator = changeEventCalculator;
        return super.onChange(callback);
    }
}
exports.PinchGesture = PinchGesture; //# sourceMappingURL=pinchGesture.js.map


/***/ }),

/***/ 59836:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.Reanimated = void 0;
var _utils = __webpack_require__(50693);
var _Reanimated;
let Reanimated;
exports.Reanimated = Reanimated;
try {
    exports.Reanimated = Reanimated = __webpack_require__(82735);
} catch (e) {
    // When 'react-native-reanimated' is not available we want to quietly continue
    // @ts-ignore TS demands the variable to be initialized
    exports.Reanimated = Reanimated = undefined;
}
if (!((_Reanimated = Reanimated) !== null && _Reanimated !== void 0 && _Reanimated.useSharedValue)) {
    // @ts-ignore Make sure the loaded module is actually Reanimated, if it's not
    // reset the module to undefined so we can fallback to the default implementation
    exports.Reanimated = Reanimated = undefined;
}
if (Reanimated !== undefined && !Reanimated.setGestureState) {
    // The loaded module is Reanimated but it doesn't have the setGestureState defined
    Reanimated.setGestureState = ()=>{
        "worklet";
        console.warn((0, _utils.tagMessage)("Please use newer version of react-native-reanimated in order to control state of the gestures."));
    };
} //# sourceMappingURL=reanimatedWrapper.js.map


/***/ }),

/***/ 13223:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.RotationGesture = void 0;
var _gesture = __webpack_require__(90159);
function changeEventCalculator(current, previous) {
    "worklet";
    let changePayload;
    if (previous === undefined) {
        changePayload = {
            rotationChange: current.rotation
        };
    } else {
        changePayload = {
            rotationChange: current.rotation - previous.rotation
        };
    }
    return {
        ...current,
        ...changePayload
    };
}
class RotationGesture extends _gesture.ContinousBaseGesture {
    constructor(){
        super();
        this.handlerName = "RotationGestureHandler";
    }
    onChange(callback) {
        // @ts-ignore TS being overprotective, RotationGestureHandlerEventPayload is Record
        this.handlers.changeEventCalculator = changeEventCalculator;
        return super.onChange(callback);
    }
}
exports.RotationGesture = RotationGesture; //# sourceMappingURL=rotationGesture.js.map


/***/ }),

/***/ 37558:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.TapGesture = void 0;
var _gesture = __webpack_require__(90159);
function _defineProperty(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
class TapGesture extends _gesture.BaseGesture {
    constructor(){
        super();
        _defineProperty(this, "config", {});
        this.handlerName = "TapGestureHandler";
        this.shouldCancelWhenOutside(true);
    }
    minPointers(minPointers) {
        this.config.minPointers = minPointers;
        return this;
    }
    numberOfTaps(count) {
        this.config.numberOfTaps = count;
        return this;
    }
    maxDistance(maxDist) {
        this.config.maxDist = maxDist;
        return this;
    }
    maxDuration(duration) {
        this.config.maxDurationMs = duration;
        return this;
    }
    maxDelay(delay) {
        this.config.maxDelayMs = delay;
        return this;
    }
    maxDeltaX(delta) {
        this.config.maxDeltaX = delta;
        return this;
    }
    maxDeltaY(delta) {
        this.config.maxDeltaY = delta;
        return this;
    }
}
exports.TapGesture = TapGesture; //# sourceMappingURL=tapGesture.js.map


/***/ }),

/***/ 83406:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.getNextHandlerTag = getNextHandlerTag;
exports.registerHandler = registerHandler;
exports.registerOldGestureHandler = registerOldGestureHandler;
exports.unregisterHandler = unregisterHandler;
exports.findHandler = findHandler;
exports.findOldGestureHandler = findOldGestureHandler;
exports.findHandlerByTestID = findHandlerByTestID;
exports.handlerIDToTag = void 0;
var _utils = __webpack_require__(50693);
const handlerIDToTag = {};
exports.handlerIDToTag = handlerIDToTag;
const gestures = new Map();
const oldHandlers = new Map();
const testIDs = new Map();
let handlerTag = 1;
function getNextHandlerTag() {
    return handlerTag++;
}
function registerHandler(handlerTag, handler, testID) {
    gestures.set(handlerTag, handler);
    if ((0, _utils.isJestEnv)() && testID) {
        testIDs.set(testID, handlerTag);
    }
}
function registerOldGestureHandler(handlerTag, handler) {
    oldHandlers.set(handlerTag, handler);
}
function unregisterHandler(handlerTag, testID) {
    gestures.delete(handlerTag);
    if ((0, _utils.isJestEnv)() && testID) {
        testIDs.delete(testID);
    }
}
function findHandler(handlerTag) {
    return gestures.get(handlerTag);
}
function findOldGestureHandler(handlerTag) {
    return oldHandlers.get(handlerTag);
}
function findHandlerByTestID(testID) {
    const handlerTag = testIDs.get(testID);
    if (handlerTag !== undefined) {
        var _findHandler;
        return (_findHandler = findHandler(handlerTag)) !== null && _findHandler !== void 0 ? _findHandler : null;
    }
    return null;
} //# sourceMappingURL=handlersRegistry.js.map


/***/ }),

/***/ 20349:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
var __webpack_unused_export__;

__webpack_unused_export__ = ({
    value: true
});
__webpack_unused_export__ = ({
    enumerable: true,
    get: function() {
        return _Directions.Directions;
    }
});
__webpack_unused_export__ = ({
    enumerable: true,
    get: function() {
        return _State.State;
    }
});
__webpack_unused_export__ = ({
    enumerable: true,
    get: function() {
        return _gestureHandlerRootHOC.default;
    }
});
Object.defineProperty(exports, "cS", ({
    enumerable: true,
    get: function() {
        return _GestureHandlerRootView.default;
    }
}));
__webpack_unused_export__ = ({
    enumerable: true,
    get: function() {
        return _TapGestureHandler.TapGestureHandler;
    }
});
__webpack_unused_export__ = ({
    enumerable: true,
    get: function() {
        return _ForceTouchGestureHandler.ForceTouchGestureHandler;
    }
});
__webpack_unused_export__ = ({
    enumerable: true,
    get: function() {
        return _LongPressGestureHandler.LongPressGestureHandler;
    }
});
__webpack_unused_export__ = ({
    enumerable: true,
    get: function() {
        return _PanGestureHandler.PanGestureHandler;
    }
});
__webpack_unused_export__ = ({
    enumerable: true,
    get: function() {
        return _PinchGestureHandler.PinchGestureHandler;
    }
});
__webpack_unused_export__ = ({
    enumerable: true,
    get: function() {
        return _RotationGestureHandler.RotationGestureHandler;
    }
});
__webpack_unused_export__ = ({
    enumerable: true,
    get: function() {
        return _FlingGestureHandler.FlingGestureHandler;
    }
});
__webpack_unused_export__ = ({
    enumerable: true,
    get: function() {
        return _createNativeWrapper.default;
    }
});
__webpack_unused_export__ = ({
    enumerable: true,
    get: function() {
        return _GestureDetector.GestureDetector;
    }
});
__webpack_unused_export__ = ({
    enumerable: true,
    get: function() {
        return _gestureObjects.GestureObjects;
    }
});
__webpack_unused_export__ = ({
    enumerable: true,
    get: function() {
        return _NativeViewGestureHandler.NativeViewGestureHandler;
    }
});
__webpack_unused_export__ = ({
    enumerable: true,
    get: function() {
        return _GestureButtons.RawButton;
    }
});
__webpack_unused_export__ = ({
    enumerable: true,
    get: function() {
        return _GestureButtons.BaseButton;
    }
});
__webpack_unused_export__ = ({
    enumerable: true,
    get: function() {
        return _GestureButtons.RectButton;
    }
});
__webpack_unused_export__ = ({
    enumerable: true,
    get: function() {
        return _GestureButtons.BorderlessButton;
    }
});
__webpack_unused_export__ = ({
    enumerable: true,
    get: function() {
        return _GestureButtons.PureNativeButton;
    }
});
__webpack_unused_export__ = ({
    enumerable: true,
    get: function() {
        return _touchables.TouchableHighlight;
    }
});
__webpack_unused_export__ = ({
    enumerable: true,
    get: function() {
        return _touchables.TouchableNativeFeedback;
    }
});
__webpack_unused_export__ = ({
    enumerable: true,
    get: function() {
        return _touchables.TouchableOpacity;
    }
});
__webpack_unused_export__ = ({
    enumerable: true,
    get: function() {
        return _touchables.TouchableWithoutFeedback;
    }
});
__webpack_unused_export__ = ({
    enumerable: true,
    get: function() {
        return _GestureComponents.ScrollView;
    }
});
__webpack_unused_export__ = ({
    enumerable: true,
    get: function() {
        return _GestureComponents.Switch;
    }
});
__webpack_unused_export__ = ({
    enumerable: true,
    get: function() {
        return _GestureComponents.TextInput;
    }
});
__webpack_unused_export__ = ({
    enumerable: true,
    get: function() {
        return _GestureComponents.DrawerLayoutAndroid;
    }
});
__webpack_unused_export__ = ({
    enumerable: true,
    get: function() {
        return _GestureComponents.FlatList;
    }
});
__webpack_unused_export__ = ({
    enumerable: true,
    get: function() {
        return _GestureComponents.RefreshControl;
    }
});
__webpack_unused_export__ = ({
    enumerable: true,
    get: function() {
        return _Swipeable.default;
    }
});
__webpack_unused_export__ = ({
    enumerable: true,
    get: function() {
        return _DrawerLayout.default;
    }
});
__webpack_unused_export__ = ({
    enumerable: true,
    get: function() {
        return _EnableNewWebImplementation.enableExperimentalWebImplementation;
    }
});
__webpack_unused_export__ = ({
    enumerable: true,
    get: function() {
        return _EnableNewWebImplementation.enableLegacyWebImplementation;
    }
});
var _init = __webpack_require__(63619);
var _Directions = __webpack_require__(1166);
var _State = __webpack_require__(10125);
var _gestureHandlerRootHOC = _interopRequireDefault(__webpack_require__(57017));
var _GestureHandlerRootView = _interopRequireDefault(__webpack_require__(40946));
var _TapGestureHandler = __webpack_require__(91418);
var _ForceTouchGestureHandler = __webpack_require__(69374);
var _LongPressGestureHandler = __webpack_require__(99901);
var _PanGestureHandler = __webpack_require__(78673);
var _PinchGestureHandler = __webpack_require__(81155);
var _RotationGestureHandler = __webpack_require__(63153);
var _FlingGestureHandler = __webpack_require__(46709);
var _createNativeWrapper = _interopRequireDefault(__webpack_require__(54625));
var _GestureDetector = __webpack_require__(33668);
var _gestureObjects = __webpack_require__(79559);
var _NativeViewGestureHandler = __webpack_require__(92922);
var _GestureButtons = __webpack_require__(91142);
var _touchables = __webpack_require__(68046);
var _GestureComponents = __webpack_require__(28226);
var _Swipeable = _interopRequireDefault(__webpack_require__(14407));
var _DrawerLayout = _interopRequireDefault(__webpack_require__(57334));
var _EnableNewWebImplementation = __webpack_require__(29551);
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
(0, _init.initialize)(); //# sourceMappingURL=index.js.map


/***/ }),

/***/ 63619:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.initialize = initialize;
exports.maybeInitializeFabric = maybeInitializeFabric;
var _eventReceiver = __webpack_require__(69323);
var _RNGestureHandlerModule = _interopRequireDefault(__webpack_require__(43121));
var _utils = __webpack_require__(50693);
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
let fabricInitialized = false;
function initialize() {
    (0, _eventReceiver.startListening)();
} // since isFabric() may give wrong results before the first render, we call this
// method during render of GestureHandlerRootView
function maybeInitializeFabric() {
    if ((0, _utils.isFabric)() && !fabricInitialized) {
        _RNGestureHandlerModule.default.install();
        fabricInitialized = true;
    }
} //# sourceMappingURL=init.js.map


/***/ }),

/***/ 50693:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.toArray = toArray;
exports.withPrevAndCurrent = withPrevAndCurrent;
exports.hasProperty = hasProperty;
exports.isJestEnv = isJestEnv;
exports.tagMessage = tagMessage;
exports.isFabric = isFabric;
exports.isRemoteDebuggingEnabled = isRemoteDebuggingEnabled;
exports.REACT_NATIVE_VERSION = void 0;
var _package = _interopRequireDefault(__webpack_require__(32834));
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
const [majorStr, minorStr] = _package.default.version.split(".");
const REACT_NATIVE_VERSION = {
    major: parseInt(majorStr, 10),
    minor: parseInt(minorStr, 10)
};
exports.REACT_NATIVE_VERSION = REACT_NATIVE_VERSION;
function toArray(object) {
    if (!Array.isArray(object)) {
        return [
            object
        ];
    }
    return object;
}
function withPrevAndCurrent(array, mapFn) {
    const previousArr = [
        null
    ];
    const currentArr = [
        ...array
    ];
    const transformedArr = [];
    currentArr.forEach((current, i)=>{
        const previous = previousArr[i];
        const transformed = mapFn(previous, current);
        previousArr.push(transformed);
        transformedArr.push(transformed);
    });
    return transformedArr;
} // eslint-disable-next-line @typescript-eslint/ban-types
function hasProperty(object, key) {
    return Object.prototype.hasOwnProperty.call(object, key);
}
function isJestEnv() {
    // @ts-ignore Do not use `@types/node` because it will prioritise Node types over RN types which breaks the types (ex. setTimeout) in React Native projects.
    return hasProperty(global, "process") && !!process.env.JEST_WORKER_ID;
}
function tagMessage(msg) {
    return `[react-native-gesture-handler] ${msg}`;
} // helper method to check whether Fabric is enabled, however global.nativeFabricUIManager
// may not be initialized before the first render
function isFabric() {
    var _global;
    // @ts-expect-error nativeFabricUIManager is not yet included in the RN types
    return !!((_global = global) !== null && _global !== void 0 && _global.nativeFabricUIManager);
}
function isRemoteDebuggingEnabled() {
    // react-native-reanimated checks if in remote debugging in the same way
    // @ts-ignore global is available but node types are not included
    return !global.nativeCallSyncHook || global.__REMOTEDEV__;
} //# sourceMappingURL=utils.js.map


/***/ }),

/***/ 98179:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.Direction = exports.DEFAULT_TOUCH_SLOP = void 0;
const DEFAULT_TOUCH_SLOP = 15;
exports.DEFAULT_TOUCH_SLOP = DEFAULT_TOUCH_SLOP;
const Direction = {
    RIGHT: 1,
    LEFT: 2,
    UP: 4,
    DOWN: 8
};
exports.Direction = Direction; //# sourceMappingURL=constants.js.map


/***/ }),

/***/ 58371:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports["default"] = void 0;
var _interfaces = __webpack_require__(68814);
function _defineProperty(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
class RotationGestureDetector {
    constructor(callbacks){
        _defineProperty(this, "onRotationBegin", void 0);
        _defineProperty(this, "onRotation", void 0);
        _defineProperty(this, "onRotationEnd", void 0);
        _defineProperty(this, "currentTime", 0);
        _defineProperty(this, "previousTime", 0);
        _defineProperty(this, "previousAngle", 0);
        _defineProperty(this, "rotation", 0);
        _defineProperty(this, "anchorX", 0);
        _defineProperty(this, "anchorY", 0);
        _defineProperty(this, "isInProgress", false);
        _defineProperty(this, "keyPointers", [
            NaN,
            NaN
        ]);
        this.onRotationBegin = callbacks.onRotationBegin;
        this.onRotation = callbacks.onRotation;
        this.onRotationEnd = callbacks.onRotationEnd;
    }
    updateCurrent(event, tracker) {
        this.previousTime = this.currentTime;
        this.currentTime = event.time;
        const [firstPointerID, secondPointerID] = this.keyPointers;
        const firstPointerX = tracker.getLastX(firstPointerID);
        const firstPointerY = tracker.getLastY(firstPointerID);
        const secondPointerX = tracker.getLastX(secondPointerID);
        const secondPointerY = tracker.getLastY(secondPointerID);
        const vectorX = secondPointerX - firstPointerX;
        const vectorY = secondPointerY - firstPointerY;
        this.anchorX = (firstPointerX + secondPointerX) / 2;
        this.anchorY = (firstPointerY + secondPointerY) / 2; //Angle diff should be positive when rotating in clockwise direction
        const angle = -Math.atan2(vectorY, vectorX);
        this.rotation = Number.isNaN(this.previousAngle) ? 0 : this.previousAngle - angle;
        this.previousAngle = angle;
        if (this.rotation > Math.PI) {
            this.rotation -= Math.PI;
        } else if (this.rotation < -Math.PI) {
            this.rotation += Math.PI;
        }
        if (this.rotation > Math.PI / 2) {
            this.rotation -= Math.PI;
        } else if (this.rotation < -Math.PI / 2) {
            this.rotation += Math.PI;
        }
    }
    finish() {
        if (!this.isInProgress) {
            return;
        }
        this.isInProgress = false;
        this.keyPointers = [
            NaN,
            NaN
        ];
        this.onRotationEnd(this);
    }
    setKeyPointers(tracker) {
        if (this.keyPointers[0] && this.keyPointers[1]) {
            return;
        }
        const pointerIDs = tracker.getData().keys();
        this.keyPointers[0] = pointerIDs.next().value;
        this.keyPointers[1] = pointerIDs.next().value;
    }
    onTouchEvent(event, tracker) {
        switch(event.eventType){
            case _interfaces.EventTypes.DOWN:
                this.isInProgress = false;
                break;
            case _interfaces.EventTypes.ADDITIONAL_POINTER_DOWN:
                if (this.isInProgress) {
                    break;
                }
                this.isInProgress = true;
                this.previousTime = event.time;
                this.previousAngle = NaN;
                this.setKeyPointers(tracker);
                this.updateCurrent(event, tracker);
                this.onRotationBegin(this);
                break;
            case _interfaces.EventTypes.MOVE:
                if (!this.isInProgress) {
                    break;
                }
                this.updateCurrent(event, tracker);
                this.onRotation(this);
                break;
            case _interfaces.EventTypes.ADDITIONAL_POINTER_UP:
                if (!this.isInProgress) {
                    break;
                }
                if (this.keyPointers.indexOf(event.pointerId) >= 0) {
                    this.finish();
                }
                break;
            case _interfaces.EventTypes.UP:
                if (this.isInProgress) {
                    this.finish();
                }
                break;
        }
        return true;
    }
    getTimeDelta() {
        return this.currentTime + this.previousTime;
    }
    getAnchorX() {
        return this.anchorX;
    }
    getAnchorY() {
        return this.anchorY;
    }
    getRotation() {
        return this.rotation;
    }
    reset() {
        this.keyPointers = [
            NaN,
            NaN
        ];
        this.isInProgress = false;
    }
}
exports["default"] = RotationGestureDetector; //# sourceMappingURL=RotationGestureDetector.js.map


/***/ }),

/***/ 5516:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports["default"] = void 0;
var _constants = __webpack_require__(98179);
var _interfaces = __webpack_require__(68814);
function _defineProperty(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
class ScaleGestureDetector {
    constructor(callbacks){
        _defineProperty(this, "onScaleBegin", void 0);
        _defineProperty(this, "onScale", void 0);
        _defineProperty(this, "onScaleEnd", void 0);
        _defineProperty(this, "focusX", void 0);
        _defineProperty(this, "focusY", void 0);
        _defineProperty(this, "currentSpan", void 0);
        _defineProperty(this, "prevSpan", void 0);
        _defineProperty(this, "initialSpan", void 0);
        _defineProperty(this, "currentTime", void 0);
        _defineProperty(this, "prevTime", void 0);
        _defineProperty(this, "inProgress", false);
        _defineProperty(this, "spanSlop", void 0);
        _defineProperty(this, "minSpan", void 0);
        this.onScaleBegin = callbacks.onScaleBegin;
        this.onScale = callbacks.onScale;
        this.onScaleEnd = callbacks.onScaleEnd;
        this.spanSlop = _constants.DEFAULT_TOUCH_SLOP * 2;
        this.minSpan = 0;
    }
    onTouchEvent(event, tracker) {
        this.currentTime = event.time;
        const action = event.eventType;
        const numOfPointers = tracker.getTrackedPointersCount();
        const streamComplete = action === _interfaces.EventTypes.UP || action === _interfaces.EventTypes.ADDITIONAL_POINTER_UP || action === _interfaces.EventTypes.CANCEL;
        if (action === _interfaces.EventTypes.DOWN || streamComplete) {
            if (this.inProgress) {
                this.onScaleEnd(this);
                this.inProgress = false;
                this.initialSpan = 0;
            }
            if (streamComplete) {
                return true;
            }
        }
        const configChanged = action === _interfaces.EventTypes.DOWN || action === _interfaces.EventTypes.ADDITIONAL_POINTER_UP || action === _interfaces.EventTypes.ADDITIONAL_POINTER_DOWN;
        const pointerUp = action === _interfaces.EventTypes.ADDITIONAL_POINTER_UP;
        const ignoredPointer = pointerUp ? event.pointerId : undefined; //Determine focal point
        const div = pointerUp ? numOfPointers - 1 : numOfPointers;
        const sumX = tracker.getSumX(ignoredPointer);
        const sumY = tracker.getSumY(ignoredPointer);
        const focusX = sumX / div;
        const focusY = sumY / div; //Determine average deviation from focal point
        let devSumX = 0;
        let devSumY = 0;
        tracker.getData().forEach((value, key)=>{
            if (key === ignoredPointer) {
                return;
            }
            devSumX += Math.abs(value.lastX - focusX);
            devSumY += Math.abs(value.lastY - focusY);
        });
        const devX = devSumX / div;
        const devY = devSumY / div;
        const spanX = devX * 2;
        const spanY = devY * 2;
        const span = Math.hypot(spanX, spanY); //Begin/end events
        const wasInProgress = this.inProgress;
        this.focusX = focusX;
        this.focusY = focusY;
        if (this.inProgress && (span < this.minSpan || configChanged)) {
            this.onScaleEnd(this);
            this.inProgress = false;
            this.initialSpan = span;
        }
        if (configChanged) {
            this.initialSpan = this.prevSpan = this.currentSpan = span;
        }
        if (!this.inProgress && span >= this.minSpan && (wasInProgress || Math.abs(span - this.initialSpan) > this.spanSlop)) {
            this.prevSpan = this.currentSpan = span;
            this.prevTime = this.currentTime;
            this.inProgress = this.onScaleBegin(this);
        } //Handle motion
        if (action !== _interfaces.EventTypes.MOVE) {
            return true;
        }
        this.currentSpan = span;
        if (this.inProgress && !this.onScale(this)) {
            return true;
        }
        this.prevSpan = this.currentSpan;
        this.prevTime = this.currentTime;
        return true;
    }
    getCurrentSpan() {
        return this.currentSpan;
    }
    getFocusX() {
        return this.focusX;
    }
    getFocusY() {
        return this.focusY;
    }
    getTimeDelta() {
        return this.currentTime - this.prevTime;
    }
    getScaleFactor(numOfPointers) {
        if (numOfPointers < 2) {
            return 1;
        }
        return this.prevSpan > 0 ? this.currentSpan / this.prevSpan : 1;
    }
}
exports["default"] = ScaleGestureDetector; //# sourceMappingURL=ScaleGestureDetector.js.map


/***/ }),

/***/ 59932:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports["default"] = void 0;
var _State = __webpack_require__(10125);
var _constants = __webpack_require__(98179);
var _GestureHandler = _interopRequireDefault(__webpack_require__(84886));
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function _defineProperty(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
const DEFAULT_MAX_DURATION_MS = 800;
const DEFAULT_MIN_ACCEPTABLE_DELTA = 160;
const DEFAULT_DIRECTION = _constants.Direction.RIGHT;
const DEFAULT_NUMBER_OF_TOUCHES_REQUIRED = 1;
class FlingGestureHandler extends _GestureHandler.default {
    constructor(...args){
        super(...args);
        _defineProperty(this, "numberOfPointersRequired", DEFAULT_NUMBER_OF_TOUCHES_REQUIRED);
        _defineProperty(this, "direction", DEFAULT_DIRECTION);
        _defineProperty(this, "maxDurationMs", DEFAULT_MAX_DURATION_MS);
        _defineProperty(this, "minAcceptableDelta", DEFAULT_MIN_ACCEPTABLE_DELTA);
        _defineProperty(this, "delayTimeout", void 0);
        _defineProperty(this, "startX", 0);
        _defineProperty(this, "startY", 0);
        _defineProperty(this, "maxNumberOfPointersSimultaneously", 0);
        _defineProperty(this, "keyPointer", NaN);
    }
    init(ref, propsRef) {
        super.init(ref, propsRef);
    }
    updateGestureConfig({ enabled = true, ...props }) {
        super.updateGestureConfig({
            enabled: enabled,
            ...props
        });
        if (this.config.direction) {
            this.direction = this.config.direction;
        }
        if (this.config.numberOfPointers) {
            this.numberOfPointersRequired = this.config.numberOfPointers;
        }
    }
    transformNativeEvent() {
        const rect = this.view.getBoundingClientRect();
        return {
            x: this.tracker.getLastAvgX() - rect.left,
            y: this.tracker.getLastAvgY() - rect.top,
            absoluteX: this.tracker.getLastAvgX(),
            absoluteY: this.tracker.getLastAvgY()
        };
    }
    startFling() {
        this.startX = this.tracker.getLastX(this.keyPointer);
        this.startY = this.tracker.getLastY(this.keyPointer);
        this.begin();
        this.maxNumberOfPointersSimultaneously = 1;
        this.delayTimeout = setTimeout(()=>this.fail(), this.maxDurationMs);
    }
    tryEndFling() {
        if (this.maxNumberOfPointersSimultaneously === this.numberOfPointersRequired && (this.direction & _constants.Direction.RIGHT && this.tracker.getLastX(this.keyPointer) - this.startX > this.minAcceptableDelta || this.direction & _constants.Direction.LEFT && this.startX - this.tracker.getLastX(this.keyPointer) > this.minAcceptableDelta || this.direction & _constants.Direction.UP && this.startY - this.tracker.getLastY(this.keyPointer) > this.minAcceptableDelta || this.direction & _constants.Direction.DOWN && this.tracker.getLastY(this.keyPointer) - this.startY > this.minAcceptableDelta)) {
            clearTimeout(this.delayTimeout);
            this.activate();
            return true;
        }
        return false;
    }
    endFling() {
        if (!this.tryEndFling()) {
            this.fail();
        }
    }
    onPointerDown(event) {
        this.tracker.addToTracker(event);
        this.keyPointer = event.pointerId;
        super.onPointerDown(event);
        this.newPointerAction();
    }
    onPointerAdd(event) {
        this.tracker.addToTracker(event);
        super.onPointerAdd(event);
        this.newPointerAction();
    }
    newPointerAction() {
        if (this.currentState === _State.State.UNDETERMINED) {
            this.startFling();
        }
        if (this.currentState !== _State.State.BEGAN) {
            return;
        }
        this.tryEndFling();
        if (this.tracker.getTrackedPointersCount() > this.maxNumberOfPointersSimultaneously) {
            this.maxNumberOfPointersSimultaneously = this.tracker.getTrackedPointersCount();
        }
    }
    onPointerMove(event) {
        this.tracker.track(event);
        if (this.currentState !== _State.State.BEGAN) {
            return;
        }
        this.tryEndFling();
        super.onPointerMove(event);
    }
    onPointerUp(event) {
        super.onPointerUp(event);
        this.onUp(event);
        this.keyPointer = NaN;
    }
    onPointerRemove(event) {
        super.onPointerRemove(event);
        this.onUp(event);
    }
    onUp(event) {
        this.tracker.removeFromTracker(event.pointerId);
        if (this.currentState !== _State.State.BEGAN) {
            return;
        }
        this.endFling();
    }
    activate(force) {
        super.activate(force);
        this.end();
    }
    resetConfig() {
        super.resetConfig();
        this.numberOfPointersRequired = DEFAULT_NUMBER_OF_TOUCHES_REQUIRED;
        this.direction = DEFAULT_DIRECTION;
    }
}
exports["default"] = FlingGestureHandler; //# sourceMappingURL=FlingGestureHandler.js.map


/***/ }),

/***/ 84886:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports["default"] = void 0;
var _reactNative = __webpack_require__(83849);
var _State = __webpack_require__(10125);
var _interfaces = __webpack_require__(68814);
var _GestureHandlerOrchestrator = _interopRequireDefault(__webpack_require__(13213));
var _InteractionManager = _interopRequireDefault(__webpack_require__(77125));
var _PointerEventManager = _interopRequireDefault(__webpack_require__(97171));
var _PointerTracker = _interopRequireDefault(__webpack_require__(18125));
var _TouchEventManager = _interopRequireDefault(__webpack_require__(26813));
var _utils = __webpack_require__(8200);
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function _defineProperty(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
class GestureHandler {
    // Orchestrator properties
    constructor(){
        _defineProperty(this, "lastSentState", null);
        _defineProperty(this, "currentState", _State.State.UNDETERMINED);
        _defineProperty(this, "shouldCancellWhenOutside", false);
        _defineProperty(this, "hasCustomActivationCriteria", void 0);
        _defineProperty(this, "enabled", false);
        _defineProperty(this, "ref", void 0);
        _defineProperty(this, "propsRef", void 0);
        _defineProperty(this, "handlerTag", void 0);
        _defineProperty(this, "config", {
            enabled: false
        });
        _defineProperty(this, "view", void 0);
        _defineProperty(this, "eventManagers", []);
        _defineProperty(this, "tracker", new _PointerTracker.default());
        _defineProperty(this, "activationIndex", 0);
        _defineProperty(this, "awaiting", false);
        _defineProperty(this, "active", false);
        _defineProperty(this, "shouldResetProgress", false);
        _defineProperty(this, "pointerType", _interfaces.PointerType.NONE);
        _defineProperty(this, "sendEvent", (newState, oldState)=>{
            const { onGestureHandlerEvent, onGestureHandlerStateChange } = this.propsRef.current;
            const resultEvent = this.transformEventData(newState, oldState); // In the new API oldState field has to be undefined, unless we send event state changed
            // Here the order is flipped to avoid workarounds such as making backup of the state and setting it to undefined first, then changing it back
            // Flipping order with setting oldState to undefined solves issue, when events were being sent twice instead of once
            // However, this may cause trouble in the future (but for now we don't know that)
            if (this.lastSentState !== newState) {
                this.lastSentState = newState;
                invokeNullableMethod(onGestureHandlerStateChange, resultEvent);
            }
            if (this.currentState === _State.State.ACTIVE) {
                resultEvent.nativeEvent.oldState = undefined;
                invokeNullableMethod(onGestureHandlerEvent, resultEvent);
            }
        });
        this.hasCustomActivationCriteria = false;
    }
    // Initializing handler
    //
    init(ref, propsRef) {
        this.propsRef = propsRef;
        this.ref = ref;
        this.currentState = _State.State.UNDETERMINED;
        this.setView();
        this.addEventManager(new _PointerEventManager.default(this.view));
        this.addEventManager(new _TouchEventManager.default(this.view));
    }
    setView() {
        if (!this.ref) {
            throw new Error(`Cannot find HTML Element for handler ${this.handlerTag}`);
        }
        this.view = (0, _reactNative.findNodeHandle)(this.ref);
        this.view.style["touchAction"] = "none"; //@ts-ignore This one disables default events on Safari
        this.view.style["WebkitTouchCallout"] = "none";
        if (!this.config.userSelect) {
            this.view.style["webkitUserSelect"] = "none";
            this.view.style["userSelect"] = "none";
        } else {
            this.view.style["webkitUserSelect"] = this.config.userSelect;
            this.view.style["userSelect"] = this.config.userSelect;
        }
    }
    addEventManager(manager) {
        manager.setOnPointerDown(this.onPointerDown.bind(this));
        manager.setOnPointerAdd(this.onPointerAdd.bind(this));
        manager.setOnPointerUp(this.onPointerUp.bind(this));
        manager.setOnPointerRemove(this.onPointerRemove.bind(this));
        manager.setOnPointerMove(this.onPointerMove.bind(this));
        manager.setOnPointerEnter(this.onPointerEnter.bind(this));
        manager.setOnPointerOut(this.onPointerOut.bind(this));
        manager.setOnPointerCancel(this.onPointerCancel.bind(this));
        manager.setOnPointerOutOfBounds(this.onPointerOutOfBounds.bind(this));
        manager.setListeners();
        this.eventManagers.push(manager);
    }
    // Resetting handler
    //
    onCancel() {}
    onReset() {}
    resetProgress() {}
    reset() {
        this.tracker.resetTracker();
        this.onReset();
        this.resetProgress();
        this.eventManagers.forEach((manager)=>manager.resetManager());
        this.currentState = _State.State.UNDETERMINED;
    }
    // State logic
    //
    moveToState(newState, sendIfDisabled) {
        if (this.currentState === newState) {
            return;
        }
        const oldState = this.currentState;
        this.currentState = newState;
        if (this.tracker.getTrackedPointersCount() > 0 && this.config.needsPointerData && this.isFinished()) {
            this.cancelTouches();
        }
        _GestureHandlerOrchestrator.default.getInstance().onHandlerStateChange(this, newState, oldState, sendIfDisabled);
        this.onStateChange(newState, oldState);
    }
    onStateChange(_newState, _oldState) {}
    begin() {
        if (!this.checkHitSlop()) {
            return;
        }
        if (this.currentState === _State.State.UNDETERMINED) {
            this.moveToState(_State.State.BEGAN);
        }
    }
    /**
   * @param {boolean} sendIfDisabled - Used when handler becomes disabled. With this flag orchestrator will be forced to send fail event
   */ fail(sendIfDisabled) {
        if (this.currentState === _State.State.ACTIVE || this.currentState === _State.State.BEGAN) {
            this.moveToState(_State.State.FAILED, sendIfDisabled);
            this.view.style.cursor = "auto";
        }
        this.resetProgress();
    }
    /**
   * @param {boolean} sendIfDisabled - Used when handler becomes disabled. With this flag orchestrator will be forced to send cancel event
   */ cancel(sendIfDisabled) {
        if (this.currentState === _State.State.ACTIVE || this.currentState === _State.State.UNDETERMINED || this.currentState === _State.State.BEGAN) {
            this.onCancel();
            this.moveToState(_State.State.CANCELLED, sendIfDisabled);
            this.view.style.cursor = "auto";
        }
    }
    activate(_force = false) {
        if (this.currentState === _State.State.UNDETERMINED || this.currentState === _State.State.BEGAN) {
            this.moveToState(_State.State.ACTIVE);
            this.view.style.cursor = "grab";
        }
    }
    end() {
        if (this.currentState === _State.State.BEGAN || this.currentState === _State.State.ACTIVE) {
            this.moveToState(_State.State.END);
            this.view.style.cursor = "auto";
        }
        this.resetProgress();
    }
    // Methods for orchestrator
    //
    isAwaiting() {
        return this.awaiting;
    }
    setAwaiting(value) {
        this.awaiting = value;
    }
    isActive() {
        return this.active;
    }
    setActive(value) {
        this.active = value;
    }
    getShouldResetProgress() {
        return this.shouldResetProgress;
    }
    setShouldResetProgress(value) {
        this.shouldResetProgress = value;
    }
    getActivationIndex() {
        return this.activationIndex;
    }
    setActivationIndex(value) {
        this.activationIndex = value;
    }
    shouldWaitForHandlerFailure(handler) {
        if (handler === this) {
            return false;
        }
        return _InteractionManager.default.getInstance().shouldWaitForHandlerFailure(this, handler);
    }
    shouldRequireToWaitForFailure(handler) {
        if (handler === this) {
            return false;
        }
        return _InteractionManager.default.getInstance().shouldRequireHandlerToWaitForFailure(this, handler);
    }
    shouldRecognizeSimultaneously(handler) {
        if (handler === this) {
            return true;
        }
        return _InteractionManager.default.getInstance().shouldRecognizeSimultaneously(this, handler);
    }
    shouldBeCancelledByOther(handler) {
        if (handler === this) {
            return false;
        }
        return _InteractionManager.default.getInstance().shouldHandlerBeCancelledBy(this, handler);
    }
    // Event actions
    //
    onPointerDown(event) {
        _GestureHandlerOrchestrator.default.getInstance().recordHandlerIfNotPresent(this);
        this.pointerType = event.pointerType;
        if (this.pointerType === _interfaces.PointerType.TOUCH) {
            _GestureHandlerOrchestrator.default.getInstance().cancelMouseAndPenGestures(this);
        }
        if (this.config.needsPointerData) {
            this.sendTouchEvent(event);
        }
    }
    onPointerAdd(event) {
        if (this.config.needsPointerData) {
            this.sendTouchEvent(event);
        }
    }
    onPointerUp(event) {
        if (this.config.needsPointerData) {
            this.sendTouchEvent(event);
        }
    }
    onPointerRemove(event) {
        if (this.config.needsPointerData) {
            this.sendTouchEvent(event);
        }
    }
    onPointerMove(event) {
        this.tryToSendMoveEvent(false);
        if (this.config.needsPointerData) {
            this.sendTouchEvent(event);
        }
    }
    onPointerOut(event) {
        if (this.shouldCancellWhenOutside) {
            switch(this.currentState){
                case _State.State.ACTIVE:
                    this.cancel();
                    break;
                case _State.State.BEGAN:
                    this.fail();
                    break;
            }
            return;
        }
        if (this.config.needsPointerData) {
            this.sendTouchEvent(event);
        }
    }
    onPointerEnter(event) {
        if (this.config.needsPointerData) {
            this.sendTouchEvent(event);
        }
    }
    onPointerCancel(event) {
        if (this.config.needsPointerData) {
            this.sendTouchEvent(event);
        }
        this.cancel();
        this.reset();
    }
    onPointerOutOfBounds(event) {
        this.tryToSendMoveEvent(true);
        if (this.config.needsPointerData) {
            this.sendTouchEvent(event);
        }
    }
    tryToSendMoveEvent(out) {
        if (this.enabled && this.active && (!out || out && !this.shouldCancellWhenOutside)) {
            this.sendEvent(this.currentState, this.currentState);
        }
    }
    sendTouchEvent(event) {
        if (!this.enabled) {
            return;
        }
        const { onGestureHandlerEvent } = this.propsRef.current;
        const touchEvent = this.transformTouchEvent(event);
        if (touchEvent) {
            invokeNullableMethod(onGestureHandlerEvent, touchEvent);
        }
    }
    // Events Sending
    //
    transformEventData(newState, oldState) {
        return {
            nativeEvent: {
                numberOfPointers: this.tracker.getTrackedPointersCount(),
                state: newState,
                pointerInside: (0, _utils.isPointerInBounds)(this.view, {
                    x: this.tracker.getLastAvgX(),
                    y: this.tracker.getLastAvgY()
                }),
                ...this.transformNativeEvent(),
                handlerTag: this.handlerTag,
                target: this.ref,
                oldState: newState !== oldState ? oldState : undefined
            },
            timeStamp: Date.now()
        };
    }
    transformTouchEvent(event) {
        var _event$touchEventType;
        const rect = this.view.getBoundingClientRect();
        const all = [];
        const changed = [];
        const trackerData = this.tracker.getData(); // This if handles edge case where all pointers have been cancelled
        // When pointercancel is triggered, reset method is called. This means that tracker will be reset after first pointer being cancelled
        // The problem is, that handler will receive another pointercancel event from the rest of the pointers
        // To avoid crashing, we don't send event if tracker tracks no pointers, i.e. has been reset
        if (trackerData.size === 0 || !trackerData.has(event.pointerId)) {
            return;
        }
        trackerData.forEach((element, key)=>{
            const id = this.tracker.getMappedTouchEventId(key);
            all.push({
                id: id,
                x: element.lastX - rect.left,
                y: element.lastY - rect.top,
                absoluteX: element.lastX,
                absoluteY: element.lastY
            });
        }); // Each pointer sends its own event, so we want changed touches to contain only the pointer that has changed.
        // However, if the event is cancel, we want to cancel all pointers to avoid crashes
        if (event.eventType !== _interfaces.EventTypes.CANCEL) {
            changed.push({
                id: this.tracker.getMappedTouchEventId(event.pointerId),
                x: event.x - rect.left,
                y: event.y - rect.top,
                absoluteX: event.x,
                absoluteY: event.y
            });
        } else {
            trackerData.forEach((element, key)=>{
                const id = this.tracker.getMappedTouchEventId(key);
                changed.push({
                    id: id,
                    x: element.lastX - rect.left,
                    y: element.lastY - rect.top,
                    absoluteX: element.lastX,
                    absoluteY: element.lastY
                });
            });
        }
        let eventType = _interfaces.TouchEventType.UNDETERMINED;
        switch(event.eventType){
            case _interfaces.EventTypes.DOWN:
            case _interfaces.EventTypes.ADDITIONAL_POINTER_DOWN:
                eventType = _interfaces.TouchEventType.DOWN;
                break;
            case _interfaces.EventTypes.UP:
            case _interfaces.EventTypes.ADDITIONAL_POINTER_UP:
                eventType = _interfaces.TouchEventType.UP;
                break;
            case _interfaces.EventTypes.MOVE:
                eventType = _interfaces.TouchEventType.MOVE;
                break;
            case _interfaces.EventTypes.CANCEL:
                eventType = _interfaces.TouchEventType.CANCELLED;
                break;
        } // Here, when we receive up event, we want to decrease number of touches
        // That's because we want handler to send information that there's one pointer less
        // However, we still want this pointer to be present in allTouches array, so that its data can be accessed
        let numberOfTouches = all.length;
        if (event.eventType === _interfaces.EventTypes.UP || event.eventType === _interfaces.EventTypes.ADDITIONAL_POINTER_UP) {
            --numberOfTouches;
        }
        return {
            nativeEvent: {
                handlerTag: this.handlerTag,
                state: this.currentState,
                eventType: (_event$touchEventType = event.touchEventType) !== null && _event$touchEventType !== void 0 ? _event$touchEventType : eventType,
                changedTouches: changed,
                allTouches: all,
                numberOfTouches: numberOfTouches
            },
            timeStamp: Date.now()
        };
    }
    cancelTouches() {
        const rect = this.view.getBoundingClientRect();
        const all = [];
        const changed = [];
        const trackerData = this.tracker.getData();
        if (trackerData.size === 0) {
            return;
        }
        trackerData.forEach((element, key)=>{
            const id = this.tracker.getMappedTouchEventId(key);
            all.push({
                id: id,
                x: element.lastX - rect.left,
                y: element.lastY - rect.top,
                absoluteX: element.lastX,
                absoluteY: element.lastY
            });
            changed.push({
                id: id,
                x: element.lastX - rect.left,
                y: element.lastY - rect.top,
                absoluteX: element.lastX,
                absoluteY: element.lastY
            });
        });
        const cancelEvent = {
            nativeEvent: {
                handlerTag: this.handlerTag,
                state: this.currentState,
                eventType: _interfaces.TouchEventType.CANCELLED,
                changedTouches: changed,
                allTouches: all,
                numberOfTouches: all.length
            },
            timeStamp: Date.now()
        };
        const { onGestureHandlerEvent } = this.propsRef.current;
        invokeNullableMethod(onGestureHandlerEvent, cancelEvent);
    }
    transformNativeEvent() {
        return {};
    }
    // Handling config
    //
    updateGestureConfig({ enabled = true, ...props }) {
        this.config = {
            enabled: enabled,
            ...props
        };
        this.enabled = enabled;
        if (this.config.shouldCancelWhenOutside !== undefined) {
            this.setShouldCancelWhenOutside(this.config.shouldCancelWhenOutside);
        }
        this.validateHitSlops();
        if (this.enabled) {
            return;
        }
        switch(this.currentState){
            case _State.State.ACTIVE:
                this.fail(true);
                break;
            case _State.State.UNDETERMINED:
                _GestureHandlerOrchestrator.default.getInstance().removeHandlerFromOrchestrator(this);
                break;
            default:
                this.cancel(true);
                break;
        }
    }
    checkCustomActivationCriteria(criterias) {
        for(const key in this.config){
            if (criterias.indexOf(key) >= 0) {
                this.hasCustomActivationCriteria = true;
            }
        }
    }
    validateHitSlops() {
        if (!this.config.hitSlop) {
            return;
        }
        if (this.config.hitSlop.left !== undefined && this.config.hitSlop.right !== undefined && this.config.hitSlop.width !== undefined) {
            throw new Error("HitSlop Error: Cannot define left, right and width at the same time");
        }
        if (this.config.hitSlop.width !== undefined && this.config.hitSlop.left === undefined && this.config.hitSlop.right === undefined) {
            throw new Error("HitSlop Error: When width is defined, either left or right has to be defined");
        }
        if (this.config.hitSlop.height !== undefined && this.config.hitSlop.top !== undefined && this.config.hitSlop.bottom !== undefined) {
            throw new Error("HitSlop Error: Cannot define top, bottom and height at the same time");
        }
        if (this.config.hitSlop.height !== undefined && this.config.hitSlop.top === undefined && this.config.hitSlop.bottom === undefined) {
            throw new Error("HitSlop Error: When height is defined, either top or bottom has to be defined");
        }
    }
    checkHitSlop() {
        if (!this.config.hitSlop) {
            return true;
        }
        const width = this.view.getBoundingClientRect().width;
        const height = this.view.getBoundingClientRect().height;
        let left = 0;
        let top = 0;
        let right = width;
        let bottom = height;
        if (this.config.hitSlop.horizontal !== undefined) {
            left -= this.config.hitSlop.horizontal;
            right += this.config.hitSlop.horizontal;
        }
        if (this.config.hitSlop.vertical !== undefined) {
            top -= this.config.hitSlop.vertical;
            bottom += this.config.hitSlop.vertical;
        }
        if (this.config.hitSlop.left !== undefined) {
            left = -this.config.hitSlop.left;
        }
        if (this.config.hitSlop.right !== undefined) {
            right = width + this.config.hitSlop.right;
        }
        if (this.config.hitSlop.top !== undefined) {
            top = -this.config.hitSlop.top;
        }
        if (this.config.hitSlop.bottom !== undefined) {
            bottom = width + this.config.hitSlop.bottom;
        }
        if (this.config.hitSlop.width !== undefined) {
            if (this.config.hitSlop.left !== undefined) {
                right = left + this.config.hitSlop.width;
            } else if (this.config.hitSlop.right !== undefined) {
                left = right - this.config.hitSlop.width;
            }
        }
        if (this.config.hitSlop.height !== undefined) {
            if (this.config.hitSlop.top !== undefined) {
                bottom = top + this.config.hitSlop.height;
            } else if (this.config.hitSlop.bottom !== undefined) {
                top = bottom - this.config.hitSlop.height;
            }
        }
        const rect = this.view.getBoundingClientRect();
        const offsetX = this.tracker.getLastX() - rect.left;
        const offsetY = this.tracker.getLastY() - rect.top;
        if (offsetX >= left && offsetX <= right && offsetY >= top && offsetY <= bottom) {
            return true;
        }
        return false;
    }
    isPointerInBounds({ x, y }) {
        const rect = this.view.getBoundingClientRect();
        return x >= rect.left && x <= rect.right && y >= rect.top && y <= rect.bottom;
    }
    resetConfig() {}
    // Getters and setters
    //
    getTag() {
        return this.handlerTag;
    }
    setTag(tag) {
        this.handlerTag = tag;
    }
    getConfig() {
        return this.config;
    }
    getShouldEnableGestureOnSetup() {
        throw new Error("Must override GestureHandler.shouldEnableGestureOnSetup");
    }
    getView() {
        return this.view;
    }
    getEventManagers() {
        return this.eventManagers;
    }
    getTracker() {
        return this.tracker;
    }
    getTrackedPointersID() {
        return this.tracker.getTrackedPointersID();
    }
    getState() {
        return this.currentState;
    }
    isEnabled() {
        return this.enabled;
    }
    isFinished() {
        return this.currentState === _State.State.END || this.currentState === _State.State.FAILED || this.currentState === _State.State.CANCELLED;
    }
    setShouldCancelWhenOutside(shouldCancel) {
        this.shouldCancellWhenOutside = shouldCancel;
    }
    getShouldCancelWhenOutside() {
        return this.shouldCancellWhenOutside;
    }
    getPointerType() {
        return this.pointerType;
    }
}
exports["default"] = GestureHandler;
function invokeNullableMethod(method, event) {
    if (!method) {
        return;
    }
    if (typeof method === "function") {
        method(event);
        return;
    }
    if ("__getHandler" in method && typeof method.__getHandler === "function") {
        const handler = method.__getHandler();
        invokeNullableMethod(handler, event);
        return;
    }
    if (!("__nodeConfig" in method)) {
        return;
    }
    const { argMapping } = method.__nodeConfig;
    if (!Array.isArray(argMapping)) {
        return;
    }
    for (const [index, [key, value]] of argMapping.entries()){
        if (!(key in event.nativeEvent)) {
            continue;
        } // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
        const nativeValue = event.nativeEvent[key]; // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
        if (value !== null && value !== void 0 && value.setValue) {
            //Reanimated API
            // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-call
            value.setValue(nativeValue);
        } else {
            //RN Animated API
            method.__nodeConfig.argMapping[index] = [
                key,
                nativeValue
            ];
        }
    }
    return;
} //# sourceMappingURL=GestureHandler.js.map


/***/ }),

/***/ 54310:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports["default"] = void 0;
var _State = __webpack_require__(10125);
var _GestureHandler = _interopRequireDefault(__webpack_require__(84886));
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function _defineProperty(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
const DEFAULT_MIN_DURATION_MS = 500;
const DEFAULT_MAX_DIST_DP = 10;
const SCALING_FACTOR = 10;
class LongPressGestureHandler extends _GestureHandler.default {
    constructor(...args){
        super(...args);
        _defineProperty(this, "minDurationMs", DEFAULT_MIN_DURATION_MS);
        _defineProperty(this, "defaultMaxDistSq", DEFAULT_MAX_DIST_DP * SCALING_FACTOR);
        _defineProperty(this, "maxDistSq", this.defaultMaxDistSq);
        _defineProperty(this, "startX", 0);
        _defineProperty(this, "startY", 0);
        _defineProperty(this, "startTime", 0);
        _defineProperty(this, "previousTime", 0);
        _defineProperty(this, "activationTimeout", void 0);
    }
    init(ref, propsRef) {
        super.init(ref, propsRef);
        this.view.oncontextmenu = ()=>false;
    }
    transformNativeEvent() {
        const rect = this.view.getBoundingClientRect();
        return {
            x: this.tracker.getLastAvgX() - rect.left,
            y: this.tracker.getLastAvgY() - rect.top,
            absoluteX: this.tracker.getLastAvgX(),
            absoluteY: this.tracker.getLastAvgY(),
            duration: Date.now() - this.startTime
        };
    }
    updateGestureConfig({ enabled = true, ...props }) {
        super.updateGestureConfig({
            enabled: enabled,
            ...props
        });
        if (this.config.minDurationMs !== undefined) {
            this.minDurationMs = this.config.minDurationMs;
        }
        if (this.config.maxDist !== undefined) {
            this.maxDistSq = this.config.maxDist * this.config.maxDist;
        }
    }
    resetConfig() {
        super.resetConfig();
        this.minDurationMs = DEFAULT_MIN_DURATION_MS;
        this.maxDistSq = this.defaultMaxDistSq;
    }
    onStateChange(_newState, _oldState) {
        clearTimeout(this.activationTimeout);
    }
    onPointerDown(event) {
        this.tracker.addToTracker(event);
        super.onPointerDown(event);
        this.tryBegin(event);
        this.tryActivate();
        this.checkDistanceFail(event);
    }
    onPointerMove(event) {
        super.onPointerMove(event);
        this.tracker.track(event);
        this.checkDistanceFail(event);
    }
    onPointerUp(event) {
        super.onPointerUp(event);
        this.tracker.removeFromTracker(event.pointerId);
        if (this.currentState === _State.State.ACTIVE) {
            this.end();
        } else {
            this.fail();
        }
    }
    tryBegin(event) {
        if (this.currentState !== _State.State.UNDETERMINED) {
            return;
        }
        this.previousTime = Date.now();
        this.startTime = this.previousTime;
        this.begin();
        this.startX = event.x;
        this.startY = event.y;
    }
    tryActivate() {
        if (this.minDurationMs > 0) {
            this.activationTimeout = setTimeout(()=>{
                this.activate();
            }, this.minDurationMs);
        } else if (this.minDurationMs === 0) {
            this.activate();
        }
    }
    checkDistanceFail(event) {
        const dx = event.x - this.startX;
        const dy = event.y - this.startY;
        const distSq = dx * dx + dy * dy;
        if (distSq <= this.maxDistSq) {
            return;
        }
        if (this.currentState === _State.State.ACTIVE) {
            this.cancel();
        } else {
            this.fail();
        }
    }
}
exports["default"] = LongPressGestureHandler; //# sourceMappingURL=LongPressGestureHandler.js.map


/***/ }),

/***/ 47242:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports["default"] = void 0;
var _GestureHandler = _interopRequireDefault(__webpack_require__(84886));
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
class ManualGestureHandler extends _GestureHandler.default {
    init(ref, propsRef) {
        super.init(ref, propsRef);
    }
    updateGestureConfig({ enabled = true, ...props }) {
        super.updateGestureConfig({
            enabled: enabled,
            ...props
        });
    }
    onPointerDown(event) {
        this.tracker.addToTracker(event);
        super.onPointerDown(event);
        this.begin();
    }
    onPointerAdd(event) {
        this.tracker.addToTracker(event);
        super.onPointerAdd(event);
    }
    onPointerMove(event) {
        this.tracker.track(event);
        super.onPointerMove(event);
    }
    onPointerOutOfBounds(event) {
        this.tracker.track(event);
        super.onPointerOutOfBounds(event);
    }
    onPointerUp(event) {
        super.onPointerUp(event);
        this.tracker.removeFromTracker(event.pointerId);
    }
    onPointerRemove(event) {
        super.onPointerRemove(event);
        this.tracker.removeFromTracker(event.pointerId);
    }
}
exports["default"] = ManualGestureHandler; //# sourceMappingURL=ManualGestureHandler.js.map


/***/ }),

/***/ 88821:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports["default"] = void 0;
var _State = __webpack_require__(10125);
var _constants = __webpack_require__(98179);
var _GestureHandler = _interopRequireDefault(__webpack_require__(84886));
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function _defineProperty(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
class NativeViewGestureHandler extends _GestureHandler.default {
    constructor(...args){
        super(...args);
        _defineProperty(this, "buttonRole", void 0);
        _defineProperty(this, "shouldActivateOnStart", false);
        _defineProperty(this, "disallowInterruption", false);
        _defineProperty(this, "startX", 0);
        _defineProperty(this, "startY", 0);
        _defineProperty(this, "minDistSq", _constants.DEFAULT_TOUCH_SLOP * _constants.DEFAULT_TOUCH_SLOP);
    }
    init(ref, propsRef) {
        super.init(ref, propsRef);
        this.setShouldCancelWhenOutside(true);
        this.view.style["touchAction"] = "auto"; //@ts-ignore Turns on defualt touch behavior on Safari
        this.view.style["WebkitTouchCallout"] = "auto";
        if (this.view.hasAttribute("role")) {
            this.buttonRole = true;
        } else {
            this.buttonRole = false;
        }
    }
    updateGestureConfig({ enabled = true, ...props }) {
        super.updateGestureConfig({
            enabled: enabled,
            ...props
        });
        if (this.config.shouldActivateOnStart !== undefined) {
            this.shouldActivateOnStart = this.config.shouldActivateOnStart;
        }
        if (this.config.disallowInterruption !== undefined) {
            this.disallowInterruption = this.config.disallowInterruption;
        }
    }
    resetConfig() {
        super.resetConfig();
    }
    onPointerDown(event) {
        this.tracker.addToTracker(event);
        super.onPointerDown(event);
        this.newPointerAction();
    }
    onPointerAdd(event) {
        this.tracker.addToTracker(event);
        super.onPointerAdd(event);
        this.newPointerAction();
    }
    newPointerAction() {
        this.startX = this.tracker.getLastAvgX();
        this.startY = this.tracker.getLastAvgY();
        if (this.currentState !== _State.State.UNDETERMINED) {
            return;
        }
        this.begin();
        if (this.buttonRole) {
            this.activate();
        }
    }
    onPointerMove(event) {
        this.tracker.track(event);
        const dx = this.startX - this.tracker.getLastAvgX();
        const dy = this.startY - this.tracker.getLastAvgY();
        const distSq = dx * dx + dy * dy;
        if (distSq >= this.minDistSq) {
            if (this.buttonRole && this.currentState === _State.State.ACTIVE) {
                this.cancel();
            } else if (!this.buttonRole && this.currentState === _State.State.BEGAN) {
                this.activate();
            }
        }
    }
    onPointerOut() {
        if (this.currentState === _State.State.BEGAN || this.currentState === _State.State.ACTIVE) {
            this.cancel();
        }
    }
    onPointerUp(event) {
        super.onPointerUp(event);
        this.onUp(event);
    }
    onPointerRemove(event) {
        super.onPointerRemove(event);
        this.onUp(event);
    }
    onUp(event) {
        this.tracker.removeFromTracker(event.pointerId);
        if (this.tracker.getTrackedPointersCount() === 0) {
            if (this.currentState === _State.State.ACTIVE) {
                this.end();
            } else {
                this.fail();
            }
        }
    }
    shouldRecognizeSimultaneously(handler) {
        if (super.shouldRecognizeSimultaneously(handler)) {
            return true;
        }
        if (handler instanceof NativeViewGestureHandler && handler.getState() === _State.State.ACTIVE && handler.disallowsInterruption()) {
            return false;
        }
        const canBeInterrupted = !this.disallowInterruption;
        if (this.currentState === _State.State.ACTIVE && handler.getState() === _State.State.ACTIVE && canBeInterrupted) {
            return false;
        }
        return this.currentState === _State.State.ACTIVE && canBeInterrupted && handler.getTag() > 0;
    }
    shouldBeCancelledByOther(_handler) {
        return !this.disallowInterruption;
    }
    disallowsInterruption() {
        return this.disallowInterruption;
    }
}
exports["default"] = NativeViewGestureHandler; //# sourceMappingURL=NativeViewGestureHandler.js.map


/***/ }),

/***/ 3383:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports["default"] = void 0;
var _State = __webpack_require__(10125);
var _constants = __webpack_require__(98179);
var _GestureHandler = _interopRequireDefault(__webpack_require__(84886));
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function _defineProperty(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
const DEFAULT_MIN_POINTERS = 1;
const DEFAULT_MAX_POINTERS = 10;
const DEFAULT_MIN_DIST_SQ = _constants.DEFAULT_TOUCH_SLOP * _constants.DEFAULT_TOUCH_SLOP;
class PanGestureHandler extends _GestureHandler.default {
    constructor(...args){
        super(...args);
        _defineProperty(this, "customActivationProperties", [
            "activeOffsetXStart",
            "activeOffsetXEnd",
            "failOffsetXStart",
            "failOffsetXEnd",
            "activeOffsetYStart",
            "activeOffsetYEnd",
            "failOffsetYStart",
            "failOffsetYEnd",
            "minVelocityX",
            "minVelocityY"
        ]);
        _defineProperty(this, "velocityX", 0);
        _defineProperty(this, "velocityY", 0);
        _defineProperty(this, "minDistSq", DEFAULT_MIN_DIST_SQ);
        _defineProperty(this, "activeOffsetXStart", -Number.MAX_SAFE_INTEGER);
        _defineProperty(this, "activeOffsetXEnd", Number.MIN_SAFE_INTEGER);
        _defineProperty(this, "failOffsetXStart", Number.MIN_SAFE_INTEGER);
        _defineProperty(this, "failOffsetXEnd", Number.MAX_SAFE_INTEGER);
        _defineProperty(this, "activeOffsetYStart", Number.MAX_SAFE_INTEGER);
        _defineProperty(this, "activeOffsetYEnd", Number.MIN_SAFE_INTEGER);
        _defineProperty(this, "failOffsetYStart", Number.MIN_SAFE_INTEGER);
        _defineProperty(this, "failOffsetYEnd", Number.MAX_SAFE_INTEGER);
        _defineProperty(this, "minVelocityX", Number.MAX_SAFE_INTEGER);
        _defineProperty(this, "minVelocityY", Number.MAX_SAFE_INTEGER);
        _defineProperty(this, "minVelocitySq", Number.MAX_SAFE_INTEGER);
        _defineProperty(this, "minPointers", DEFAULT_MIN_POINTERS);
        _defineProperty(this, "maxPointers", DEFAULT_MAX_POINTERS);
        _defineProperty(this, "startX", 0);
        _defineProperty(this, "startY", 0);
        _defineProperty(this, "offsetX", 0);
        _defineProperty(this, "offsetY", 0);
        _defineProperty(this, "lastX", 0);
        _defineProperty(this, "lastY", 0);
        _defineProperty(this, "activateAfterLongPress", 0);
        _defineProperty(this, "activationTimeout", 0);
    }
    init(ref, propsRef) {
        super.init(ref, propsRef);
    }
    updateGestureConfig({ enabled = true, ...props }) {
        this.resetConfig();
        super.updateGestureConfig({
            enabled: enabled,
            ...props
        });
        this.checkCustomActivationCriteria(this.customActivationProperties);
        if (this.config.minDist !== undefined) {
            this.minDistSq = this.config.minDist * this.config.minDist;
        } else if (this.hasCustomActivationCriteria) {
            this.minDistSq = Number.MAX_SAFE_INTEGER;
        }
        if (this.config.minPointers !== undefined) {
            this.minPointers = this.config.minPointers;
        }
        if (this.config.maxPointers !== undefined) {
            this.maxPointers = this.config.maxPointers;
        }
        if (this.config.minVelocity !== undefined) {
            this.minVelocityX = this.config.minVelocity;
            this.minVelocityY = this.config.minVelocity;
        }
        if (this.config.minVelocityX !== undefined) {
            this.minVelocityX = this.config.minVelocityX;
        }
        if (this.config.minVelocityY !== undefined) {
            this.minVelocityY = this.config.minVelocityY;
        }
        if (this.config.activateAfterLongPress !== undefined) {
            this.activateAfterLongPress = this.config.activateAfterLongPress;
        }
        if (this.config.activeOffsetXStart !== undefined) {
            this.activeOffsetXStart = this.config.activeOffsetXStart;
            if (this.config.activeOffsetXEnd === undefined) {
                this.activeOffsetXEnd = Number.MAX_SAFE_INTEGER;
            }
        }
        if (this.config.activeOffsetXEnd !== undefined) {
            this.activeOffsetXEnd = this.config.activeOffsetXEnd;
            if (this.config.activeOffsetXStart === undefined) {
                this.activeOffsetXStart = Number.MIN_SAFE_INTEGER;
            }
        }
        if (this.config.failOffsetXStart !== undefined) {
            this.failOffsetXStart = this.config.failOffsetXStart;
            if (this.config.failOffsetXEnd === undefined) {
                this.failOffsetXEnd = Number.MAX_SAFE_INTEGER;
            }
        }
        if (this.config.failOffsetXEnd !== undefined) {
            this.failOffsetXEnd = this.config.failOffsetXEnd;
            if (this.config.failOffsetXStart === undefined) {
                this.failOffsetXStart = Number.MIN_SAFE_INTEGER;
            }
        }
        if (this.config.activeOffsetYStart !== undefined) {
            this.activeOffsetYStart = this.config.activeOffsetYStart;
            if (this.config.activeOffsetYEnd === undefined) {
                this.activeOffsetYEnd = Number.MAX_SAFE_INTEGER;
            }
        }
        if (this.config.activeOffsetYEnd !== undefined) {
            this.activeOffsetYEnd = this.config.activeOffsetYEnd;
            if (this.config.activeOffsetYStart === undefined) {
                this.activeOffsetYStart = Number.MIN_SAFE_INTEGER;
            }
        }
        if (this.config.failOffsetYStart !== undefined) {
            this.failOffsetYStart = this.config.failOffsetYStart;
            if (this.config.failOffsetYEnd === undefined) {
                this.failOffsetYEnd = Number.MAX_SAFE_INTEGER;
            }
        }
        if (this.config.failOffsetYEnd !== undefined) {
            this.failOffsetYEnd = this.config.failOffsetYEnd;
            if (this.config.failOffsetYStart === undefined) {
                this.failOffsetYStart = Number.MIN_SAFE_INTEGER;
            }
        }
    }
    resetConfig() {
        super.resetConfig();
        this.activeOffsetXStart = -Number.MAX_SAFE_INTEGER;
        this.activeOffsetXEnd = Number.MIN_SAFE_INTEGER;
        this.failOffsetXStart = Number.MIN_SAFE_INTEGER;
        this.failOffsetXEnd = Number.MAX_SAFE_INTEGER;
        this.activeOffsetYStart = Number.MAX_SAFE_INTEGER;
        this.activeOffsetYEnd = Number.MIN_SAFE_INTEGER;
        this.failOffsetYStart = Number.MIN_SAFE_INTEGER;
        this.failOffsetYEnd = Number.MAX_SAFE_INTEGER;
        this.minVelocityX = Number.MAX_SAFE_INTEGER;
        this.minVelocityY = Number.MAX_SAFE_INTEGER;
        this.minVelocitySq = Number.MAX_SAFE_INTEGER;
        this.minDistSq = DEFAULT_MIN_DIST_SQ;
        this.minPointers = DEFAULT_MIN_POINTERS;
        this.maxPointers = DEFAULT_MAX_POINTERS;
        this.activateAfterLongPress = 0;
    }
    transformNativeEvent() {
        const rect = this.view.getBoundingClientRect();
        const translationX = this.getTranslationX();
        const translationY = this.getTranslationY();
        return {
            translationX: isNaN(translationX) ? 0 : translationX,
            translationY: isNaN(translationY) ? 0 : translationY,
            absoluteX: this.tracker.getLastAvgX(),
            absoluteY: this.tracker.getLastAvgY(),
            velocityX: this.velocityX,
            velocityY: this.velocityY,
            x: this.tracker.getLastAvgX() - rect.left,
            y: this.tracker.getLastAvgY() - rect.top
        };
    }
    getTranslationX() {
        return this.lastX - this.startX + this.offsetX;
    }
    getTranslationY() {
        return this.lastY - this.startY + this.offsetY;
    }
    clearActivationTimeout() {
        clearTimeout(this.activationTimeout);
    }
    onPointerDown(event) {
        this.tracker.addToTracker(event);
        super.onPointerDown(event);
        this.lastX = this.tracker.getLastAvgX();
        this.lastY = this.tracker.getLastAvgY();
        this.tryBegin(event);
        this.checkBegan();
    }
    onPointerAdd(event) {
        this.tracker.addToTracker(event);
        super.onPointerAdd(event);
        this.tryBegin(event);
        this.offsetX += this.lastX - this.startX;
        this.offsetY += this.lastY - this.startY;
        this.lastX = this.tracker.getLastAvgX();
        this.lastY = this.tracker.getLastAvgY();
        this.startX = this.lastX;
        this.startY = this.lastY;
        if (this.tracker.getTrackedPointersCount() > this.maxPointers) {
            if (this.currentState === _State.State.ACTIVE) {
                this.cancel();
            } else {
                this.fail();
            }
        } else {
            this.checkBegan();
        }
    }
    onPointerUp(event) {
        super.onPointerUp(event);
        if (this.currentState === _State.State.ACTIVE) {
            this.lastX = this.tracker.getLastAvgX();
            this.lastY = this.tracker.getLastAvgY();
        }
        this.tracker.removeFromTracker(event.pointerId);
        if (this.currentState === _State.State.ACTIVE) {
            this.end();
        } else {
            this.resetProgress();
            this.fail();
        }
    }
    onPointerRemove(event) {
        super.onPointerRemove(event);
        this.tracker.removeFromTracker(event.pointerId);
        this.offsetX += this.lastX - this.startX;
        this.offsetY += this.lastY - this.startY;
        this.lastX = this.tracker.getLastAvgX();
        this.lastY = this.tracker.getLastAvgY();
        this.startX = this.lastX;
        this.startY = this.lastY;
        if (!(this.currentState === _State.State.ACTIVE && this.tracker.getTrackedPointersCount() < this.minPointers)) {
            this.checkBegan();
        }
    }
    onPointerMove(event) {
        this.tracker.track(event);
        this.lastX = this.tracker.getLastAvgX();
        this.lastY = this.tracker.getLastAvgY();
        this.velocityX = this.tracker.getVelocityX(event.pointerId);
        this.velocityY = this.tracker.getVelocityY(event.pointerId);
        this.checkBegan();
        super.onPointerMove(event);
    }
    onPointerOutOfBounds(event) {
        if (this.getShouldCancelWhenOutside()) {
            return;
        }
        this.tracker.track(event);
        this.lastX = this.tracker.getLastAvgX();
        this.lastY = this.tracker.getLastAvgY();
        this.velocityX = this.tracker.getVelocityX(event.pointerId);
        this.velocityY = this.tracker.getVelocityY(event.pointerId);
        this.checkBegan();
        if (this.currentState === _State.State.ACTIVE) {
            super.onPointerOutOfBounds(event);
        }
    }
    shouldActivate() {
        const dx = this.getTranslationX();
        if (this.activeOffsetXStart !== Number.MAX_SAFE_INTEGER && dx < this.activeOffsetXStart) {
            return true;
        }
        if (this.activeOffsetXEnd !== Number.MIN_SAFE_INTEGER && dx > this.activeOffsetXEnd) {
            return true;
        }
        const dy = this.getTranslationY();
        if (this.activeOffsetYStart !== Number.MAX_SAFE_INTEGER && dy < this.activeOffsetYStart) {
            return true;
        }
        if (this.activeOffsetYEnd !== Number.MIN_SAFE_INTEGER && dy > this.activeOffsetYEnd) {
            return true;
        }
        const distanceSq = dx * dx + dy * dy;
        if (this.minDistSq !== Number.MAX_SAFE_INTEGER && distanceSq >= this.minDistSq) {
            return true;
        }
        const vx = this.velocityX;
        if (this.minVelocityX !== Number.MAX_SAFE_INTEGER && (this.minVelocityX < 0 && vx <= this.minVelocityX || this.minVelocityX >= 0 && this.minVelocityX <= vx)) {
            return true;
        }
        const vy = this.velocityY;
        if (this.minVelocityY !== Number.MAX_SAFE_INTEGER && (this.minVelocityY < 0 && vy <= this.minVelocityY || this.minVelocityY >= 0 && this.minVelocityY <= vy)) {
            return true;
        }
        const velocitySq = vx * vx + vy * vy;
        return this.minVelocitySq !== Number.MAX_SAFE_INTEGER && velocitySq >= this.minVelocitySq;
    }
    shouldFail() {
        const dx = this.getTranslationX();
        const dy = this.getTranslationY();
        const distanceSq = dx * dx + dy * dy;
        if (this.activateAfterLongPress > 0 && distanceSq > DEFAULT_MIN_DIST_SQ) {
            this.clearActivationTimeout();
            return true;
        }
        if (this.failOffsetXStart !== Number.MIN_SAFE_INTEGER && dx < this.failOffsetXStart) {
            return true;
        }
        if (this.failOffsetXEnd !== Number.MAX_SAFE_INTEGER && dx > this.failOffsetXEnd) {
            return true;
        }
        if (this.failOffsetYStart !== Number.MIN_SAFE_INTEGER && dy < this.failOffsetYStart) {
            return true;
        }
        return this.failOffsetYEnd !== Number.MAX_SAFE_INTEGER && dy > this.failOffsetYEnd;
    }
    tryBegin(event) {
        if (this.currentState === _State.State.UNDETERMINED && this.tracker.getTrackedPointersCount() >= this.minPointers) {
            this.resetProgress();
            this.offsetX = 0;
            this.offsetY = 0;
            this.velocityX = 0;
            this.velocityY = 0;
            this.begin();
            if (this.activateAfterLongPress > 0) {
                this.activationTimeout = setTimeout(()=>{
                    this.activate();
                }, this.activateAfterLongPress);
            }
        } else {
            this.velocityX = this.tracker.getVelocityX(event.pointerId);
            this.velocityY = this.tracker.getVelocityY(event.pointerId);
        }
    }
    checkBegan() {
        if (this.currentState === _State.State.BEGAN) {
            if (this.shouldFail()) {
                this.fail();
            } else if (this.shouldActivate()) {
                this.activate();
            }
        }
    }
    activate(force = false) {
        if (this.currentState !== _State.State.ACTIVE) {
            this.resetProgress();
        }
        super.activate(force);
    }
    onCancel() {
        this.clearActivationTimeout();
    }
    onReset() {
        this.clearActivationTimeout();
    }
    resetProgress() {
        if (this.currentState === _State.State.ACTIVE) {
            return;
        }
        this.startX = this.lastX;
        this.startY = this.lastY;
    }
}
exports["default"] = PanGestureHandler; //# sourceMappingURL=PanGestureHandler.js.map


/***/ }),

/***/ 10074:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports["default"] = void 0;
var _State = __webpack_require__(10125);
var _constants = __webpack_require__(98179);
var _GestureHandler = _interopRequireDefault(__webpack_require__(84886));
var _ScaleGestureDetector = _interopRequireDefault(__webpack_require__(5516));
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function _defineProperty(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
class PinchGestureHandler extends _GestureHandler.default {
    constructor(...args){
        super(...args);
        _defineProperty(this, "scale", 1);
        _defineProperty(this, "velocity", 0);
        _defineProperty(this, "startingSpan", 0);
        _defineProperty(this, "spanSlop", _constants.DEFAULT_TOUCH_SLOP);
        _defineProperty(this, "scaleDetectorListener", {
            onScaleBegin: (detector)=>{
                this.startingSpan = detector.getCurrentSpan();
                return true;
            },
            onScale: (detector)=>{
                const prevScaleFactor = this.scale;
                this.scale *= detector.getScaleFactor(this.tracker.getTrackedPointersCount());
                const delta = detector.getTimeDelta();
                if (delta > 0) {
                    this.velocity = (this.scale - prevScaleFactor) / delta;
                }
                if (Math.abs(this.startingSpan - detector.getCurrentSpan()) >= this.spanSlop && this.currentState === _State.State.BEGAN) {
                    this.activate();
                }
                return true;
            },
            onScaleEnd: (_detector)=>{}
        });
        _defineProperty(this, "scaleGestureDetector", new _ScaleGestureDetector.default(this.scaleDetectorListener));
    }
    init(ref, propsRef) {
        super.init(ref, propsRef);
        this.setShouldCancelWhenOutside(false);
    }
    updateGestureConfig({ enabled = true, ...props }) {
        super.updateGestureConfig({
            enabled: enabled,
            ...props
        });
    }
    transformNativeEvent() {
        return {
            focalX: this.scaleGestureDetector.getFocusX(),
            focalY: this.scaleGestureDetector.getFocusY(),
            velocity: this.velocity,
            scale: this.scale
        };
    }
    onPointerDown(event) {
        this.tracker.addToTracker(event);
        super.onPointerDown(event);
    }
    onPointerAdd(event) {
        this.tracker.addToTracker(event);
        super.onPointerAdd(event);
        this.tryBegin();
        this.scaleGestureDetector.onTouchEvent(event, this.tracker);
    }
    onPointerUp(event) {
        super.onPointerUp(event);
        this.tracker.removeFromTracker(event.pointerId);
        if (this.currentState !== _State.State.ACTIVE) {
            return;
        }
        this.scaleGestureDetector.onTouchEvent(event, this.tracker);
        if (this.currentState === _State.State.ACTIVE) {
            this.end();
        } else {
            this.fail();
        }
    }
    onPointerRemove(event) {
        super.onPointerRemove(event);
        this.scaleGestureDetector.onTouchEvent(event, this.tracker);
        this.tracker.removeFromTracker(event.pointerId);
        if (this.currentState === _State.State.ACTIVE && this.tracker.getTrackedPointersCount() < 2) {
            this.end();
        }
    }
    onPointerMove(event) {
        if (this.tracker.getTrackedPointersCount() < 2) {
            return;
        }
        this.tracker.track(event);
        this.scaleGestureDetector.onTouchEvent(event, this.tracker);
        super.onPointerMove(event);
    }
    onPointerOutOfBounds(event) {
        if (this.tracker.getTrackedPointersCount() < 2) {
            return;
        }
        this.tracker.track(event);
        this.scaleGestureDetector.onTouchEvent(event, this.tracker);
        super.onPointerOutOfBounds(event);
    }
    tryBegin() {
        if (this.currentState !== _State.State.UNDETERMINED) {
            return;
        }
        this.resetProgress();
        this.begin();
    }
    activate(force) {
        if (this.currentState !== _State.State.ACTIVE) {
            this.resetProgress();
        }
        super.activate(force);
    }
    onReset() {
        this.resetProgress();
    }
    resetProgress() {
        if (this.currentState === _State.State.ACTIVE) {
            return;
        }
        this.velocity = 0;
        this.scale = 1;
    }
}
exports["default"] = PinchGestureHandler; //# sourceMappingURL=PinchGestureHandler.js.map


/***/ }),

/***/ 44751:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports["default"] = void 0;
var _State = __webpack_require__(10125);
var _GestureHandler = _interopRequireDefault(__webpack_require__(84886));
var _RotationGestureDetector = _interopRequireDefault(__webpack_require__(58371));
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function _defineProperty(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
const ROTATION_RECOGNITION_THRESHOLD = Math.PI / 36;
class RotationGestureHandler extends _GestureHandler.default {
    constructor(...args){
        super(...args);
        _defineProperty(this, "rotation", 0);
        _defineProperty(this, "velocity", 0);
        _defineProperty(this, "cachedAnchorX", 0);
        _defineProperty(this, "cachedAnchorY", 0);
        _defineProperty(this, "rotationGestureListener", {
            onRotationBegin: (_detector)=>true,
            onRotation: (detector)=>{
                const previousRotation = this.rotation;
                this.rotation += detector.getRotation();
                const delta = detector.getTimeDelta();
                if (delta > 0) {
                    this.velocity = (this.rotation - previousRotation) / delta;
                }
                if (Math.abs(this.rotation) >= ROTATION_RECOGNITION_THRESHOLD && this.currentState === _State.State.BEGAN) {
                    this.activate();
                }
                return true;
            },
            onRotationEnd: (_detector)=>{
                this.end();
            }
        });
        _defineProperty(this, "rotationGestureDetector", new _RotationGestureDetector.default(this.rotationGestureListener));
    }
    init(ref, propsRef) {
        super.init(ref, propsRef);
        this.setShouldCancelWhenOutside(false);
    }
    updateGestureConfig({ enabled = true, ...props }) {
        super.updateGestureConfig({
            enabled: enabled,
            ...props
        });
    }
    transformNativeEvent() {
        return {
            rotation: this.rotation ? this.rotation : 0,
            anchorX: this.getAnchorX(),
            anchorY: this.getAnchorY(),
            velocity: this.velocity ? this.velocity : 0
        };
    }
    getAnchorX() {
        const anchorX = this.rotationGestureDetector.getAnchorX();
        return anchorX ? anchorX : this.cachedAnchorX;
    }
    getAnchorY() {
        const anchorY = this.rotationGestureDetector.getAnchorY();
        return anchorY ? anchorY : this.cachedAnchorY;
    }
    onPointerDown(event) {
        this.tracker.addToTracker(event);
        super.onPointerDown(event);
    }
    onPointerAdd(event) {
        this.tracker.addToTracker(event);
        super.onPointerAdd(event);
        this.tryBegin();
        this.rotationGestureDetector.onTouchEvent(event, this.tracker);
    }
    onPointerMove(event) {
        if (this.tracker.getTrackedPointersCount() < 2) {
            return;
        }
        if (this.getAnchorX()) {
            this.cachedAnchorX = this.getAnchorX();
        }
        if (this.getAnchorY()) {
            this.cachedAnchorY = this.getAnchorY();
        }
        this.tracker.track(event);
        this.rotationGestureDetector.onTouchEvent(event, this.tracker);
        super.onPointerMove(event);
    }
    onPointerOutOfBounds(event) {
        if (this.tracker.getTrackedPointersCount() < 2) {
            return;
        }
        if (this.getAnchorX()) {
            this.cachedAnchorX = this.getAnchorX();
        }
        if (this.getAnchorY()) {
            this.cachedAnchorY = this.getAnchorY();
        }
        this.tracker.track(event);
        this.rotationGestureDetector.onTouchEvent(event, this.tracker);
        super.onPointerOutOfBounds(event);
    }
    onPointerUp(event) {
        super.onPointerUp(event);
        this.tracker.removeFromTracker(event.pointerId);
        this.rotationGestureDetector.onTouchEvent(event, this.tracker);
        if (this.currentState !== _State.State.ACTIVE) {
            return;
        }
        if (this.currentState === _State.State.ACTIVE) {
            this.end();
        } else {
            this.fail();
        }
    }
    onPointerRemove(event) {
        super.onPointerRemove(event);
        this.rotationGestureDetector.onTouchEvent(event, this.tracker);
        this.tracker.removeFromTracker(event.pointerId);
    }
    tryBegin() {
        if (this.currentState !== _State.State.UNDETERMINED) {
            return;
        }
        this.begin();
    }
    activate(_force) {
        super.activate();
    }
    onReset() {
        if (this.currentState === _State.State.ACTIVE) {
            return;
        }
        this.rotation = 0;
        this.velocity = 0;
        this.rotationGestureDetector.reset();
    }
}
exports["default"] = RotationGestureHandler; //# sourceMappingURL=RotationGestureHandler.js.map


/***/ }),

/***/ 52412:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports["default"] = void 0;
var _State = __webpack_require__(10125);
var _interfaces = __webpack_require__(68814);
var _GestureHandler = _interopRequireDefault(__webpack_require__(84886));
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function _defineProperty(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
const DEFAULT_MAX_DURATION_MS = 500;
const DEFAULT_MAX_DELAY_MS = 500;
const DEFAULT_NUMBER_OF_TAPS = 1;
const DEFAULT_MIN_NUMBER_OF_POINTERS = 1;
class TapGestureHandler extends _GestureHandler.default {
    constructor(...args){
        super(...args);
        _defineProperty(this, "maxDeltaX", Number.MIN_SAFE_INTEGER);
        _defineProperty(this, "maxDeltaY", Number.MIN_SAFE_INTEGER);
        _defineProperty(this, "maxDistSq", Number.MIN_SAFE_INTEGER);
        _defineProperty(this, "maxDurationMs", DEFAULT_MAX_DURATION_MS);
        _defineProperty(this, "maxDelayMs", DEFAULT_MAX_DELAY_MS);
        _defineProperty(this, "numberOfTaps", DEFAULT_NUMBER_OF_TAPS);
        _defineProperty(this, "minNumberOfPointers", DEFAULT_MIN_NUMBER_OF_POINTERS);
        _defineProperty(this, "currentMaxNumberOfPointers", 1);
        _defineProperty(this, "startX", 0);
        _defineProperty(this, "startY", 0);
        _defineProperty(this, "offsetX", 0);
        _defineProperty(this, "offsetY", 0);
        _defineProperty(this, "lastX", 0);
        _defineProperty(this, "lastY", 0);
        _defineProperty(this, "waitTimeout", void 0);
        _defineProperty(this, "delayTimeout", void 0);
        _defineProperty(this, "tapsSoFar", 0);
    }
    init(ref, propsRef) {
        super.init(ref, propsRef);
    }
    updateGestureConfig({ enabled = true, ...props }) {
        super.updateGestureConfig({
            enabled: enabled,
            ...props
        });
        if (this.config.numberOfTaps !== undefined) {
            this.numberOfTaps = this.config.numberOfTaps;
        }
        if (this.config.maxDurationMs !== undefined) {
            this.maxDurationMs = this.config.maxDurationMs;
        }
        if (this.config.maxDelayMs !== undefined) {
            this.maxDelayMs = this.config.maxDelayMs;
        }
        if (this.config.maxDeltaX !== undefined) {
            this.maxDeltaX = this.config.maxDeltaX;
        }
        if (this.config.maxDeltaY !== undefined) {
            this.maxDeltaY = this.config.maxDeltaY;
        }
        if (this.config.maxDist !== undefined) {
            this.maxDistSq = this.config.maxDist * this.config.maxDist;
        }
        if (this.config.minPointers !== undefined) {
            this.minNumberOfPointers = this.config.minPointers;
        }
    }
    resetConfig() {
        super.resetConfig();
        this.maxDeltaX = Number.MIN_SAFE_INTEGER;
        this.maxDeltaY = Number.MIN_SAFE_INTEGER;
        this.maxDistSq = Number.MIN_SAFE_INTEGER;
        this.maxDurationMs = DEFAULT_MAX_DURATION_MS;
        this.maxDelayMs = DEFAULT_MAX_DELAY_MS;
        this.numberOfTaps = DEFAULT_NUMBER_OF_TAPS;
        this.minNumberOfPointers = DEFAULT_MIN_NUMBER_OF_POINTERS;
    }
    transformNativeEvent() {
        const rect = this.view.getBoundingClientRect();
        return {
            x: this.tracker.getLastAvgX() - rect.left,
            y: this.tracker.getLastAvgY() - rect.top,
            absoluteX: this.tracker.getLastAvgX(),
            absoluteY: this.tracker.getLastAvgY()
        };
    }
    clearTimeouts() {
        clearTimeout(this.waitTimeout);
        clearTimeout(this.delayTimeout);
    }
    startTap() {
        this.clearTimeouts();
        this.waitTimeout = setTimeout(()=>this.fail(), this.maxDurationMs);
    }
    endTap() {
        this.clearTimeouts();
        if (++this.tapsSoFar === this.numberOfTaps && this.currentMaxNumberOfPointers >= this.minNumberOfPointers) {
            this.activate();
        } else {
            this.delayTimeout = setTimeout(()=>this.fail(), this.maxDelayMs);
        }
    }
    onPointerDown(event) {
        this.tracker.addToTracker(event);
        super.onPointerDown(event);
        this.trySettingPosition(event);
        this.startX = event.x;
        this.startY = event.y;
        this.lastX = event.x;
        this.lastY = event.y;
        this.updateState(event);
    }
    onPointerAdd(event) {
        super.onPointerAdd(event);
        this.tracker.addToTracker(event);
        this.trySettingPosition(event);
        this.offsetX += this.lastX - this.startX;
        this.offsetY += this.lastY - this.startY;
        this.lastX = this.tracker.getLastAvgX();
        this.lastY = this.tracker.getLastAvgY();
        this.startX = this.tracker.getLastAvgX();
        this.startY = this.tracker.getLastAvgY();
        this.updateState(event);
    }
    onPointerUp(event) {
        super.onPointerUp(event);
        this.lastX = this.tracker.getLastAvgX();
        this.lastY = this.tracker.getLastAvgY();
        this.tracker.removeFromTracker(event.pointerId);
        this.updateState(event);
    }
    onPointerRemove(event) {
        super.onPointerRemove(event);
        this.tracker.removeFromTracker(event.pointerId);
        this.offsetX += this.lastX - this.startX;
        this.offsetY += this.lastY = this.startY;
        this.lastX = this.tracker.getLastAvgX();
        this.lastY = this.tracker.getLastAvgY();
        this.startX = this.lastX;
        this.startY = this.lastY;
        this.updateState(event);
    }
    onPointerMove(event) {
        this.trySettingPosition(event);
        this.tracker.track(event);
        this.lastX = this.tracker.getLastAvgX();
        this.lastY = this.tracker.getLastAvgY();
        this.updateState(event);
        super.onPointerMove(event);
    }
    onPointerOutOfBounds(event) {
        this.trySettingPosition(event);
        this.tracker.track(event);
        this.lastX = this.tracker.getLastAvgX();
        this.lastY = this.tracker.getLastAvgY();
        this.updateState(event);
        super.onPointerOutOfBounds(event);
    }
    updateState(event) {
        if (this.currentMaxNumberOfPointers < this.tracker.getTrackedPointersCount()) {
            this.currentMaxNumberOfPointers = this.tracker.getTrackedPointersCount();
        }
        if (this.shouldFail()) {
            this.fail();
            return;
        }
        switch(this.currentState){
            case _State.State.UNDETERMINED:
                if (event.eventType === _interfaces.EventTypes.DOWN) {
                    this.begin();
                }
                this.startTap();
                break;
            case _State.State.BEGAN:
                if (event.eventType === _interfaces.EventTypes.UP) {
                    this.endTap();
                }
                if (event.eventType === _interfaces.EventTypes.DOWN) {
                    this.startTap();
                }
                break;
            default:
                break;
        }
    }
    trySettingPosition(event) {
        if (this.currentState !== _State.State.UNDETERMINED) {
            return;
        }
        this.offsetX = 0;
        this.offsetY = 0;
        this.startX = event.x;
        this.startY = event.y;
    }
    shouldFail() {
        const dx = this.lastX - this.startX + this.offsetX;
        if (this.maxDeltaX !== Number.MIN_SAFE_INTEGER && Math.abs(dx) > this.maxDeltaX) {
            return true;
        }
        const dy = this.lastY - this.startY + this.offsetY;
        if (this.maxDeltaY !== Number.MIN_SAFE_INTEGER && Math.abs(dy) > this.maxDeltaY) {
            return true;
        }
        const distSq = dy * dy + dx * dx;
        return this.maxDistSq !== Number.MIN_SAFE_INTEGER && distSq > this.maxDistSq;
    }
    activate() {
        super.activate();
        this.end();
    }
    onCancel() {
        this.resetProgress();
        this.clearTimeouts();
    }
    resetProgress() {
        this.clearTimeouts();
        this.tapsSoFar = 0;
        this.currentMaxNumberOfPointers = 0;
    }
}
exports["default"] = TapGestureHandler; //# sourceMappingURL=TapGestureHandler.js.map


/***/ }),

/***/ 68814:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.PointerType = exports.TouchEventType = exports.EventTypes = exports.MouseButtons = void 0;
let MouseButtons;
exports.MouseButtons = MouseButtons;
(function(MouseButtons) {
    MouseButtons[MouseButtons["NONE"] = 0] = "NONE";
    MouseButtons[MouseButtons["LEFT"] = 1] = "LEFT";
    MouseButtons[MouseButtons["RIGHT"] = 2] = "RIGHT";
    MouseButtons[MouseButtons["LEFT_RIGHT"] = 3] = "LEFT_RIGHT";
    MouseButtons[MouseButtons["SCROLL"] = 4] = "SCROLL";
    MouseButtons[MouseButtons["SCROLL_LEFT"] = 5] = "SCROLL_LEFT";
    MouseButtons[MouseButtons["SCROLL_RIGHT"] = 6] = "SCROLL_RIGHT";
    MouseButtons[MouseButtons["SCROLL_LEFT_RIGHT"] = 7] = "SCROLL_LEFT_RIGHT";
})(MouseButtons || (exports.MouseButtons = MouseButtons = {}));
let EventTypes;
exports.EventTypes = EventTypes;
(function(EventTypes) {
    EventTypes[EventTypes["DOWN"] = 0] = "DOWN";
    EventTypes[EventTypes["ADDITIONAL_POINTER_DOWN"] = 1] = "ADDITIONAL_POINTER_DOWN";
    EventTypes[EventTypes["UP"] = 2] = "UP";
    EventTypes[EventTypes["ADDITIONAL_POINTER_UP"] = 3] = "ADDITIONAL_POINTER_UP";
    EventTypes[EventTypes["MOVE"] = 4] = "MOVE";
    EventTypes[EventTypes["ENTER"] = 5] = "ENTER";
    EventTypes[EventTypes["OUT"] = 6] = "OUT";
    EventTypes[EventTypes["CANCEL"] = 7] = "CANCEL";
})(EventTypes || (exports.EventTypes = EventTypes = {}));
let TouchEventType;
exports.TouchEventType = TouchEventType;
(function(TouchEventType) {
    TouchEventType[TouchEventType["UNDETERMINED"] = 0] = "UNDETERMINED";
    TouchEventType[TouchEventType["DOWN"] = 1] = "DOWN";
    TouchEventType[TouchEventType["MOVE"] = 2] = "MOVE";
    TouchEventType[TouchEventType["UP"] = 3] = "UP";
    TouchEventType[TouchEventType["CANCELLED"] = 4] = "CANCELLED";
})(TouchEventType || (exports.TouchEventType = TouchEventType = {}));
let PointerType;
exports.PointerType = PointerType;
(function(PointerType) {
    PointerType["NONE"] = "none";
    PointerType["MOUSE"] = "mouse";
    PointerType["TOUCH"] = "touch";
    PointerType["PEN"] = "pen";
})(PointerType || (exports.PointerType = PointerType = {})); //# sourceMappingURL=interfaces.js.map


/***/ }),

/***/ 4306:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports["default"] = void 0;
function _defineProperty(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
class CircularBuffer {
    constructor(size){
        _defineProperty(this, "bufferSize", void 0);
        _defineProperty(this, "buffer", void 0);
        _defineProperty(this, "index", void 0);
        _defineProperty(this, "actualSize", void 0);
        this.bufferSize = size;
        this.buffer = new Array(size);
        this.index = 0;
        this.actualSize = 0;
    }
    get size() {
        return this.actualSize;
    }
    push(element) {
        this.buffer[this.index] = element;
        this.index = (this.index + 1) % this.bufferSize;
        this.actualSize = Math.min(this.actualSize + 1, this.bufferSize);
    }
    get(at) {
        if (this.actualSize === this.bufferSize) {
            let index = (this.index + at) % this.bufferSize;
            if (index < 0) {
                index += this.bufferSize;
            }
            return this.buffer[index];
        } else {
            return this.buffer[at];
        }
    }
    clear() {
        this.buffer = new Array(this.bufferSize);
        this.index = 0;
        this.actualSize = 0;
    }
}
exports["default"] = CircularBuffer; //# sourceMappingURL=CircularBuffer.js.map


/***/ }),

/***/ 61912:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports["default"] = void 0;
function _defineProperty(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
/* eslint-disable @typescript-eslint/no-empty-function */ class EventManager {
    constructor(view){
        _defineProperty(this, "view", void 0);
        _defineProperty(this, "pointersInBounds", []);
        _defineProperty(this, "activePointersCounter", void 0);
        this.view = view;
        this.activePointersCounter = 0;
    }
    onPointerDown(_event) {}
    onPointerAdd(_event) {}
    onPointerUp(_event) {}
    onPointerRemove(_event) {}
    onPointerMove(_event) {}
    onPointerOut(_event) {}
    onPointerEnter(_event) {}
    onPointerCancel(_event) {
    // Because we want all pointers to be cancelled by that event, we are doing it manually by reseting handler and changing activePointersCounter to 0
    // Events that correspond to removing the pointer (pointerup, touchend) have condition, that they don't perform any action when activePointersCounter
    // is equal to 0. This prevents counter from going to negative values, when pointers are removed from view after one of them has been cancelled
    }
    onPointerOutOfBounds(_event) {}
    setOnPointerDown(callback) {
        this.onPointerDown = callback;
    }
    setOnPointerAdd(callback) {
        this.onPointerAdd = callback;
    }
    setOnPointerUp(callback) {
        this.onPointerUp = callback;
    }
    setOnPointerRemove(callback) {
        this.onPointerRemove = callback;
    }
    setOnPointerMove(callback) {
        this.onPointerMove = callback;
    }
    setOnPointerOut(callback) {
        this.onPointerOut = callback;
    }
    setOnPointerEnter(callback) {
        this.onPointerEnter = callback;
    }
    setOnPointerCancel(callback) {
        this.onPointerCancel = callback;
    }
    setOnPointerOutOfBounds(callback) {
        this.onPointerOutOfBounds = callback;
    }
    markAsInBounds(pointerId) {
        if (this.pointersInBounds.indexOf(pointerId) >= 0) {
            return;
        }
        this.pointersInBounds.push(pointerId);
    }
    markAsOutOfBounds(pointerId) {
        const index = this.pointersInBounds.indexOf(pointerId);
        if (index < 0) {
            return;
        }
        this.pointersInBounds.splice(index, 1);
    }
    resetManager() {
        // Reseting activePointersCounter is necessary to make gestures such as pinch work properly
        // There are gestures that end when there is still one active pointer (like pinch/rotation)
        // When these gestures end, they are reset, but they still receive events from pointer that is active
        // This causes trouble, since only onPointerDown registers gesture in orchestrator, and while gestures receive
        // Events from active pointer after they finished, next pointerdown event will be registered as additional pointer, not the first one
        // This casues trouble like gestures getting stuck in END state, even though they should have gone to UNDETERMINED
        this.activePointersCounter = 0;
        this.pointersInBounds = [];
    }
}
exports["default"] = EventManager; //# sourceMappingURL=EventManager.js.map


/***/ }),

/***/ 13213:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports["default"] = void 0;
var _State = __webpack_require__(10125);
var _interfaces = __webpack_require__(68814);
var _PointerTracker = _interopRequireDefault(__webpack_require__(18125));
var _utils = __webpack_require__(8200);
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function _defineProperty(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
class GestureHandlerOrchestrator {
    // Private beacuse of Singleton
    // eslint-disable-next-line no-useless-constructor, @typescript-eslint/no-empty-function
    constructor(){
        _defineProperty(this, "gestureHandlers", []);
        _defineProperty(this, "awaitingHandlers", []);
        _defineProperty(this, "handlersToCancel", []);
        _defineProperty(this, "handlingChangeSemaphore", 0);
        _defineProperty(this, "activationIndex", 0);
    }
    scheduleFinishedHandlersCleanup() {
        if (this.handlingChangeSemaphore === 0) {
            this.cleanupFinishedHandlers();
        }
    }
    cleanHandler(handler) {
        handler.reset();
        handler.setActive(false);
        handler.setAwaiting(false);
        handler.setActivationIndex(Number.MAX_VALUE);
    }
    removeHandlerFromOrchestrator(handler) {
        this.gestureHandlers.splice(this.gestureHandlers.indexOf(handler), 1);
        this.awaitingHandlers.splice(this.awaitingHandlers.indexOf(handler), 1);
        this.handlersToCancel.splice(this.handlersToCancel.indexOf(handler), 1);
    }
    cleanupFinishedHandlers() {
        for(let i = this.gestureHandlers.length - 1; i >= 0; --i){
            const handler = this.gestureHandlers[i];
            if (!handler) {
                continue;
            }
            if (this.isFinished(handler.getState()) && !handler.isAwaiting()) {
                this.gestureHandlers.splice(i, 1);
                this.cleanHandler(handler);
            }
        }
    }
    hasOtherHandlerToWaitFor(handler) {
        let hasToWait = false;
        this.gestureHandlers.forEach((otherHandler)=>{
            if (otherHandler && !this.isFinished(otherHandler.getState()) && this.shouldHandlerWaitForOther(handler, otherHandler)) {
                hasToWait = true;
                return;
            }
        });
        return hasToWait;
    }
    tryActivate(handler) {
        if (this.hasOtherHandlerToWaitFor(handler)) {
            this.addAwaitingHandler(handler);
        } else if (handler.getState() !== _State.State.CANCELLED && handler.getState() !== _State.State.FAILED) {
            if (this.shouldActivate(handler)) {
                this.makeActive(handler);
            } else {
                switch(handler.getState()){
                    case _State.State.ACTIVE:
                        handler.fail();
                        break;
                    case _State.State.BEGAN:
                        handler.cancel();
                }
            }
        }
    }
    shouldActivate(handler) {
        for (const otherHandler of this.gestureHandlers){
            if (this.shouldHandlerBeCancelledBy(handler, otherHandler)) {
                return false;
            }
        }
        return true;
    }
    cleanupAwaitingHandlers(handler) {
        for(let i = 0; i < this.awaitingHandlers.length; ++i){
            if (!this.awaitingHandlers[i].isAwaiting() && this.shouldHandlerWaitForOther(this.awaitingHandlers[i], handler)) {
                this.cleanHandler(this.awaitingHandlers[i]);
                this.awaitingHandlers.splice(i, 1);
            }
        }
    }
    onHandlerStateChange(handler, newState, oldState, sendIfDisabled) {
        if (!handler.isEnabled() && !sendIfDisabled) {
            return;
        }
        this.handlingChangeSemaphore += 1;
        if (this.isFinished(newState)) {
            this.awaitingHandlers.forEach((otherHandler)=>{
                if (this.shouldHandlerWaitForOther(otherHandler, handler)) {
                    if (newState === _State.State.END) {
                        otherHandler === null || otherHandler === void 0 ? void 0 : otherHandler.cancel();
                        if (otherHandler.getState() === _State.State.END) {
                            // Handle edge case, where discrete gestures end immediately after activation thus
                            // their state is set to END and when the gesture they are waiting for activates they
                            // should be cancelled, however `cancel` was never sent as gestures were already in the END state.
                            // Send synthetic BEGAN -> CANCELLED to properly handle JS logic
                            otherHandler.sendEvent(_State.State.CANCELLED, _State.State.BEGAN);
                        }
                        otherHandler === null || otherHandler === void 0 ? void 0 : otherHandler.setAwaiting(false);
                    } else {
                        this.tryActivate(otherHandler);
                    }
                }
            });
        }
        if (newState === _State.State.ACTIVE) {
            this.tryActivate(handler);
        } else if (oldState === _State.State.ACTIVE || oldState === _State.State.END) {
            if (handler.isActive()) {
                handler.sendEvent(newState, oldState);
            } else if (oldState === _State.State.ACTIVE && (newState === _State.State.CANCELLED || newState === _State.State.FAILED)) {
                handler.sendEvent(newState, _State.State.BEGAN);
            }
        } else if (oldState !== _State.State.UNDETERMINED || newState !== _State.State.CANCELLED) {
            handler.sendEvent(newState, oldState);
        }
        this.handlingChangeSemaphore -= 1;
        this.scheduleFinishedHandlersCleanup();
        if (this.awaitingHandlers.indexOf(handler) < 0) {
            this.cleanupAwaitingHandlers(handler);
        }
    }
    makeActive(handler) {
        const currentState = handler.getState();
        handler.setActive(true);
        handler.setShouldResetProgress(true);
        handler.setActivationIndex(this.activationIndex++);
        this.gestureHandlers.forEach((otherHandler)=>{
            // Order of arguments is correct - we check whether current handler should cancel existing handlers
            if (this.shouldHandlerBeCancelledBy(otherHandler, handler)) {
                this.handlersToCancel.push(otherHandler);
            }
        });
        for(let i = this.handlersToCancel.length - 1; i >= 0; --i){
            var _this$handlersToCance;
            (_this$handlersToCance = this.handlersToCancel[i]) === null || _this$handlersToCance === void 0 ? void 0 : _this$handlersToCance.cancel();
        }
        this.awaitingHandlers.forEach((otherHandler)=>{
            if (this.shouldHandlerBeCancelledBy(otherHandler, handler)) {
                otherHandler === null || otherHandler === void 0 ? void 0 : otherHandler.cancel();
                otherHandler === null || otherHandler === void 0 ? void 0 : otherHandler.setAwaiting(true);
            }
        });
        handler.sendEvent(_State.State.ACTIVE, _State.State.BEGAN);
        if (currentState !== _State.State.ACTIVE) {
            handler.sendEvent(_State.State.END, _State.State.ACTIVE);
            if (currentState !== _State.State.END) {
                handler.sendEvent(_State.State.UNDETERMINED, _State.State.END);
            }
        }
        if (handler.isAwaiting()) {
            handler.setAwaiting(false);
            for(let i = 0; i < this.awaitingHandlers.length; ++i){
                if (this.awaitingHandlers[i] === handler) {
                    this.awaitingHandlers.splice(i, 1);
                }
            }
        }
        this.handlersToCancel = [];
    }
    addAwaitingHandler(handler) {
        let alreadyExists = false;
        this.awaitingHandlers.forEach((otherHandler)=>{
            if (otherHandler === handler) {
                alreadyExists = true;
                return;
            }
        });
        if (alreadyExists) {
            return;
        }
        this.awaitingHandlers.push(handler);
        handler.setAwaiting(true);
        handler.setActivationIndex(this.activationIndex++);
    }
    recordHandlerIfNotPresent(handler) {
        let alreadyExists = false;
        this.gestureHandlers.forEach((otherHandler)=>{
            if (otherHandler === handler) {
                alreadyExists = true;
                return;
            }
        });
        if (alreadyExists) {
            return;
        }
        this.gestureHandlers.push(handler);
        handler.setActive(false);
        handler.setAwaiting(false);
        handler.setActivationIndex(Number.MAX_SAFE_INTEGER);
    }
    shouldHandlerWaitForOther(handler, otherHandler) {
        return handler !== otherHandler && (handler.shouldWaitForHandlerFailure(otherHandler) || otherHandler.shouldRequireToWaitForFailure(handler));
    }
    canRunSimultaneously(gh1, gh2) {
        return gh1 === gh2 || gh1.shouldRecognizeSimultaneously(gh2) || gh2.shouldRecognizeSimultaneously(gh1);
    }
    shouldHandlerBeCancelledBy(handler, otherHandler) {
        if (this.canRunSimultaneously(handler, otherHandler)) {
            return false;
        }
        if (handler !== otherHandler && (handler.isAwaiting() || handler.getState() === _State.State.ACTIVE)) {
            // For now it always returns false
            return handler.shouldBeCancelledByOther(otherHandler);
        }
        const handlerPointers = handler.getTrackedPointersID();
        const otherPointers = otherHandler.getTrackedPointersID();
        if (!_PointerTracker.default.shareCommonPointers(handlerPointers, otherPointers) && handler.getView() !== otherHandler.getView()) {
            return this.checkOverlap(handler, otherHandler);
        }
        return true;
    }
    checkOverlap(handler, otherHandler) {
        // If handlers don't have common pointers, default return value is false.
        // However, if at least on pointer overlaps with both handlers, we return true
        // This solves issue in overlapping parents example
        // TODO: Find better way to handle that issue, for example by activation order and handler cancelling
        const handlerPointers = handler.getTrackedPointersID();
        const otherPointers = otherHandler.getTrackedPointersID();
        let overlap = false;
        handlerPointers.forEach((pointer)=>{
            const handlerX = handler.getTracker().getLastX(pointer);
            const handlerY = handler.getTracker().getLastY(pointer);
            if ((0, _utils.isPointerInBounds)(handler.getView(), {
                x: handlerX,
                y: handlerY
            }) && (0, _utils.isPointerInBounds)(otherHandler.getView(), {
                x: handlerX,
                y: handlerY
            })) {
                overlap = true;
            }
        });
        otherPointers.forEach((pointer)=>{
            const otherX = otherHandler.getTracker().getLastX(pointer);
            const otherY = otherHandler.getTracker().getLastY(pointer);
            if ((0, _utils.isPointerInBounds)(handler.getView(), {
                x: otherX,
                y: otherY
            }) && (0, _utils.isPointerInBounds)(otherHandler.getView(), {
                x: otherX,
                y: otherY
            })) {
                overlap = true;
            }
        });
        return overlap;
    }
    isFinished(state) {
        return state === _State.State.END || state === _State.State.FAILED || state === _State.State.CANCELLED;
    }
    // If handler is using mouse or pen as a pointer and any handler receives touch event,
    // mouse/pen event dissappears - it doesn't send onPointerCancel nor onPointerUp (and others)
    // This became a problem because handler was left at active state without any signal to end or fail
    // To handle this, when new touch event is received, we loop through active handlers and check which type of
    // pointer they're using. If there are any handler with mouse/pen as a pointer, we cancel them
    cancelMouseAndPenGestures(currentHandler) {
        this.gestureHandlers.forEach((handler)=>{
            if (handler.getPointerType() !== _interfaces.PointerType.MOUSE && handler.getPointerType() !== _interfaces.PointerType.PEN) {
                return;
            }
            if (handler !== currentHandler) {
                handler.cancel();
            } else {
                // Handler that received touch event should have its pointer tracker reset
                // This allows handler to smoothly change from mouse/pen to touch
                // The drawback is, that when we try to use mouse/pen one more time, it doesn't send onPointerDown at the first time
                // so it is required to click two times to get handler to work
                //
                // However, handler will receive manually created onPointerEnter that is triggered in EventManager in onPointerMove method.
                // There may be possibility to use that fact to make handler respond properly to first mouse click
                handler.getTracker().resetTracker();
            }
        });
    }
    static getInstance() {
        if (!GestureHandlerOrchestrator.instance) {
            GestureHandlerOrchestrator.instance = new GestureHandlerOrchestrator();
        }
        return GestureHandlerOrchestrator.instance;
    }
}
exports["default"] = GestureHandlerOrchestrator;
_defineProperty(GestureHandlerOrchestrator, "instance", void 0); //# sourceMappingURL=GestureHandlerOrchestrator.js.map


/***/ }),

/***/ 77125:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports["default"] = void 0;
function _defineProperty(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
class InteractionManager {
    // Private becaues of singleton
    // eslint-disable-next-line no-useless-constructor, @typescript-eslint/no-empty-function
    constructor(){
        _defineProperty(this, "waitForRelations", new Map());
        _defineProperty(this, "simultaneousRelations", new Map());
    }
    configureInteractions(handler, config) {
        this.dropRelationsForHandlerWithTag(handler.getTag());
        if (config.waitFor) {
            const waitFor = [];
            config.waitFor.forEach((otherHandler)=>{
                // New API reference
                if (typeof otherHandler === "number") {
                    waitFor.push(otherHandler);
                } else {
                    // Old API reference
                    waitFor.push(otherHandler.handlerTag);
                }
            });
            this.waitForRelations.set(handler.getTag(), waitFor);
        }
        if (config.simultaneousHandlers) {
            const simultaneousHandlers = [];
            config.simultaneousHandlers.forEach((otherHandler)=>{
                if (typeof otherHandler === "number") {
                    simultaneousHandlers.push(otherHandler);
                } else {
                    simultaneousHandlers.push(otherHandler.handlerTag);
                }
            });
            this.simultaneousRelations.set(handler.getTag(), simultaneousHandlers);
        }
    }
    shouldWaitForHandlerFailure(handler, otherHandler) {
        const waitFor = this.waitForRelations.get(handler.getTag());
        if (!waitFor) {
            return false;
        }
        let shouldWait = false;
        waitFor.forEach((tag)=>{
            if (tag === otherHandler.getTag()) {
                shouldWait = true;
                return; //Returns from callback
            }
        });
        return shouldWait;
    }
    shouldRecognizeSimultaneously(handler, otherHandler) {
        const simultaneousHandlers = this.simultaneousRelations.get(handler.getTag());
        if (!simultaneousHandlers) {
            return false;
        }
        let shouldRecognizeSimultaneously = false;
        simultaneousHandlers.forEach((tag)=>{
            if (tag === otherHandler.getTag()) {
                shouldRecognizeSimultaneously = true;
                return;
            }
        });
        return shouldRecognizeSimultaneously;
    }
    shouldRequireHandlerToWaitForFailure(_handler, _otherHandler) {
        //TODO: Implement logic
        return false;
    }
    shouldHandlerBeCancelledBy(_handler, _otherHandler) {
        //TODO: Implement logic
        return false;
    }
    dropRelationsForHandlerWithTag(handlerTag) {
        this.waitForRelations.delete(handlerTag);
        this.simultaneousRelations.delete(handlerTag);
    }
    reset() {
        this.waitForRelations.clear();
        this.simultaneousRelations.clear();
    }
    static getInstance() {
        if (!this.instance) {
            this.instance = new InteractionManager();
        }
        return this.instance;
    }
}
exports["default"] = InteractionManager;
_defineProperty(InteractionManager, "instance", void 0); //# sourceMappingURL=InteractionManager.js.map


/***/ }),

/***/ 92511:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports["default"] = void 0;
function _defineProperty(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
// Implementation taken from Flutter's LeastSquareSolver
// https://github.com/flutter/flutter/blob/master/packages/flutter/lib/src/gestures/lsq_solver.dart
class Vector {
    constructor(length){
        _defineProperty(this, "offset", void 0);
        _defineProperty(this, "length", void 0);
        _defineProperty(this, "elements", void 0);
        this.offset = 0;
        this.length = length;
        this.elements = new Array(length);
    }
    static fromVOL(values, offset, length) {
        const result = new Vector(0);
        result.offset = offset;
        result.length = length;
        result.elements = values;
        return result;
    }
    get(index) {
        return this.elements[this.offset + index];
    }
    set(index, value) {
        this.elements[this.offset + index] = value;
    }
    dot(other) {
        let result = 0;
        for(let i = 0; i < this.length; i++){
            result += this.get(i) * other.get(i);
        }
        return result;
    }
    norm() {
        return Math.sqrt(this.dot(this));
    }
}
class Matrix {
    constructor(rows, columns){
        _defineProperty(this, "columns", void 0);
        _defineProperty(this, "elements", void 0);
        this.columns = columns;
        this.elements = new Array(rows * columns);
    }
    get(row, column) {
        return this.elements[row * this.columns + column];
    }
    set(row, column, value) {
        this.elements[row * this.columns + column] = value;
    }
    getRow(row) {
        return Vector.fromVOL(this.elements, row * this.columns, this.columns);
    }
} /// An nth degree polynomial fit to a dataset.
class PolynomialFit {
    /// The polynomial coefficients of the fit.
    ///
    /// For each `i`, the element `coefficients[i]` is the coefficient of
    /// the `i`-th power of the variable.
    /// Creates a polynomial fit of the given degree.
    ///
    /// There are n + 1 coefficients in a fit of degree n.
    constructor(degree){
        _defineProperty(this, "coefficients", void 0);
        this.coefficients = new Array(degree + 1);
    }
}
const precisionErrorTolerance = 1e-10; /// Uses the least-squares algorithm to fit a polynomial to a set of data.
class LeastSquareSolver {
    /// The x-coordinates of each data point.
    /// The y-coordinates of each data point.
    /// The weight to use for each data point.
    /// Creates a least-squares solver.
    ///
    /// The [x], [y], and [w] arguments must not be null.
    constructor(x, y, w){
        _defineProperty(this, "x", void 0);
        _defineProperty(this, "y", void 0);
        _defineProperty(this, "w", void 0);
        this.x = x;
        this.y = y;
        this.w = w;
    }
    ///
    /// When there is not enough data to fit a curve null is returned.
    solve(degree) {
        if (degree > this.x.length) {
            // Not enough data to fit a curve.
            return null;
        }
        const result = new PolynomialFit(degree); // Shorthands for the purpose of notation equivalence to original C++ code.
        const m = this.x.length;
        const n = degree + 1; // Expand the X vector to a matrix A, pre-multiplied by the weights.
        const a = new Matrix(n, m);
        for(let h = 0; h < m; h++){
            a.set(0, h, this.w[h]);
            for(let i = 1; i < n; i++){
                a.set(i, h, a.get(i - 1, h) * this.x[h]);
            }
        } // Apply the Gram-Schmidt process to A to obtain its QR decomposition.
        // Orthonormal basis, column-major ordVectorer.
        const q = new Matrix(n, m); // Upper triangular matrix, row-major order.
        const r = new Matrix(n, m);
        for(let j = 0; j < n; j += 1){
            for(let h = 0; h < m; h += 1){
                q.set(j, h, a.get(j, h));
            }
            for(let i = 0; i < j; i += 1){
                const dot = q.getRow(j).dot(q.getRow(i));
                for(let h = 0; h < m; h += 1){
                    q.set(j, h, q.get(j, h) - dot * q.get(i, h));
                }
            }
            const norm = q.getRow(j).norm();
            if (norm < precisionErrorTolerance) {
                // Vectors are linearly dependent or zero so no solution.
                return null;
            }
            const inverseNorm = 1.0 / norm;
            for(let h = 0; h < m; h += 1){
                q.set(j, h, q.get(j, h) * inverseNorm);
            }
            for(let i = 0; i < n; i += 1){
                r.set(j, i, i < j ? 0.0 : q.getRow(j).dot(a.getRow(i)));
            }
        } // Solve R B = Qt W Y to find B. This is easy because R is upper triangular.
        // We just work from bottom-right to top-left calculating B's coefficients.
        const wy = new Vector(m);
        for(let h = 0; h < m; h += 1){
            wy.set(h, this.y[h] * this.w[h]);
        }
        for(let i = n - 1; i >= 0; i -= 1){
            result.coefficients[i] = q.getRow(i).dot(wy);
            for(let j = n - 1; j > i; j -= 1){
                result.coefficients[i] -= r.get(i, j) * result.coefficients[j];
            }
            result.coefficients[i] /= r.get(i, i);
        }
        return result;
    }
}
exports["default"] = LeastSquareSolver; //# sourceMappingURL=LeastSquareSolver.js.map


/***/ }),

/***/ 60596:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports["default"] = void 0;
function _defineProperty(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
// eslint-disable-next-line @typescript-eslint/no-extraneous-class
class NodeManager {
    static getHandler(tag) {
        if (tag in this.gestures) {
            return this.gestures[tag];
        }
        throw new Error(`No handler for tag ${tag}`);
    }
    static createGestureHandler(handlerTag, handler) {
        if (handlerTag in this.gestures) {
            throw new Error(`Handler with tag ${handlerTag} already exists`);
        }
        this.gestures[handlerTag] = handler;
        this.gestures[handlerTag].setTag(handlerTag);
    }
    static dropGestureHandler(handlerTag) {
        if (!(handlerTag in this.gestures)) {
            return;
        } // eslint-disable-next-line @typescript-eslint/no-dynamic-delete
        delete this.gestures[handlerTag];
    }
    static getNodes() {
        return {
            ...this.gestures
        };
    }
}
exports["default"] = NodeManager;
_defineProperty(NodeManager, "gestures", {}); //# sourceMappingURL=NodeManager.js.map


/***/ }),

/***/ 97171:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports["default"] = void 0;
var _interfaces = __webpack_require__(68814);
var _EventManager = _interopRequireDefault(__webpack_require__(61912));
var _utils = __webpack_require__(8200);
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function _defineProperty(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
class PointerEventManager extends _EventManager.default {
    constructor(...args){
        super(...args);
        _defineProperty(this, "trackedPointers", new Set());
    }
    setListeners() {
        this.view.addEventListener("pointerdown", (event)=>{
            if (event.pointerType === _interfaces.PointerType.TOUCH) {
                return;
            }
            if (!(0, _utils.isPointerInBounds)(this.view, {
                x: event.clientX,
                y: event.clientY
            })) {
                return;
            }
            const adaptedEvent = this.mapEvent(event, _interfaces.EventTypes.DOWN);
            const target = event.target;
            target.setPointerCapture(adaptedEvent.pointerId);
            this.markAsInBounds(adaptedEvent.pointerId);
            this.trackedPointers.add(adaptedEvent.pointerId);
            if (++this.activePointersCounter > 1) {
                adaptedEvent.eventType = _interfaces.EventTypes.ADDITIONAL_POINTER_DOWN;
                this.onPointerAdd(adaptedEvent);
            } else {
                this.onPointerDown(adaptedEvent);
            }
        });
        this.view.addEventListener("pointerup", (event)=>{
            if (event.pointerType === _interfaces.PointerType.TOUCH) {
                return;
            } // When we call reset on gesture handlers, it also resets their event managers
            // In some handlers (like RotationGestureHandler) reset is called before all pointers leave view
            // This means, that activePointersCounter will be set to 0, while there are still remaining pointers on view
            // Removing them will end in activePointersCounter going below 0, therefore handlers won't behave properly
            if (this.activePointersCounter === 0) {
                return;
            }
            const adaptedEvent = this.mapEvent(event, _interfaces.EventTypes.UP);
            const target = event.target;
            target.releasePointerCapture(adaptedEvent.pointerId);
            this.markAsOutOfBounds(adaptedEvent.pointerId);
            this.trackedPointers.delete(adaptedEvent.pointerId);
            if (--this.activePointersCounter > 0) {
                adaptedEvent.eventType = _interfaces.EventTypes.ADDITIONAL_POINTER_UP;
                this.onPointerRemove(adaptedEvent);
            } else {
                this.onPointerUp(adaptedEvent);
            }
        });
        this.view.addEventListener("pointermove", (event)=>{
            if (event.pointerType === _interfaces.PointerType.TOUCH) {
                return;
            }
            if (event.pointerType === _interfaces.PointerType.MOUSE && event.buttons !== _interfaces.MouseButtons.LEFT) {
                return;
            }
            const adaptedEvent = this.mapEvent(event, _interfaces.EventTypes.MOVE);
            const inBounds = (0, _utils.isPointerInBounds)(this.view, {
                x: adaptedEvent.x,
                y: adaptedEvent.y
            });
            const pointerIndex = this.pointersInBounds.indexOf(adaptedEvent.pointerId);
            if (inBounds) {
                if (pointerIndex < 0) {
                    adaptedEvent.eventType = _interfaces.EventTypes.ENTER;
                    this.onPointerEnter(adaptedEvent);
                    this.markAsInBounds(adaptedEvent.pointerId);
                } else {
                    this.onPointerMove(adaptedEvent);
                }
            } else {
                if (pointerIndex >= 0) {
                    adaptedEvent.eventType = _interfaces.EventTypes.OUT;
                    this.onPointerOut(adaptedEvent);
                    this.markAsOutOfBounds(adaptedEvent.pointerId);
                } else {
                    this.onPointerOutOfBounds(adaptedEvent);
                }
            }
        });
        this.view.addEventListener("pointercancel", (event)=>{
            if (event.pointerType === _interfaces.PointerType.TOUCH) {
                return;
            }
            const adaptedEvent = this.mapEvent(event, _interfaces.EventTypes.CANCEL);
            this.onPointerCancel(adaptedEvent);
            this.markAsOutOfBounds(adaptedEvent.pointerId);
            this.activePointersCounter = 0;
            this.trackedPointers.clear();
        });
        this.view.addEventListener("lostpointercapture", (event)=>{
            const adaptedEvent = this.mapEvent(event, _interfaces.EventTypes.CANCEL);
            if (this.trackedPointers.has(adaptedEvent.pointerId)) {
                // in some cases the `pointerup` event is not fired, but `lostpointercapture` is
                // we simulate the `pointercancel` event here to make sure the gesture handler stops tracking it
                this.onPointerCancel(adaptedEvent);
                this.activePointersCounter = 0;
                this.trackedPointers.clear();
            }
        });
    }
    mapEvent(event, eventType) {
        return {
            x: event.clientX,
            y: event.clientY,
            offsetX: event.offsetX,
            offsetY: event.offsetY,
            pointerId: event.pointerId,
            eventType: eventType,
            pointerType: event.pointerType,
            buttons: event.buttons,
            time: event.timeStamp
        };
    }
    resetManager() {
        super.resetManager();
        this.trackedPointers.clear();
    }
}
exports["default"] = PointerEventManager; //# sourceMappingURL=PointerEventManager.js.map


/***/ }),

/***/ 18125:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports["default"] = void 0;
var _VelocityTracker = _interopRequireDefault(__webpack_require__(59442));
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function _defineProperty(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
const MAX_POINTERS = 20;
class PointerTracker {
    constructor(){
        _defineProperty(this, "velocityTracker", new _VelocityTracker.default());
        _defineProperty(this, "trackedPointers", new Map());
        _defineProperty(this, "touchEventsIds", new Map());
        _defineProperty(this, "lastMovedPointerId", void 0);
        _defineProperty(this, "cachedAverages", {
            x: 0,
            y: 0
        });
        this.lastMovedPointerId = NaN;
        for(let i = 0; i < MAX_POINTERS; ++i){
            this.touchEventsIds.set(i, NaN);
        }
    }
    addToTracker(event) {
        if (this.trackedPointers.has(event.pointerId)) {
            return;
        }
        this.lastMovedPointerId = event.pointerId;
        const newElement = {
            lastX: event.x,
            lastY: event.y,
            timeStamp: event.time,
            velocityX: 0,
            velocityY: 0
        };
        this.trackedPointers.set(event.pointerId, newElement);
        this.mapTouchEventId(event.pointerId);
        this.cachedAverages = {
            x: this.getLastAvgX(),
            y: this.getLastAvgY()
        };
    }
    removeFromTracker(pointerId) {
        this.trackedPointers.delete(pointerId);
        this.removeMappedTouchId(pointerId);
    }
    track(event) {
        const element = this.trackedPointers.get(event.pointerId);
        if (!element) {
            return;
        }
        this.lastMovedPointerId = event.pointerId;
        this.velocityTracker.add(event);
        const [velocityX, velocityY] = this.velocityTracker.getVelocity();
        element.velocityX = velocityX;
        element.velocityY = velocityY;
        element.lastX = event.x;
        element.lastY = event.y;
        this.trackedPointers.set(event.pointerId, element);
        const avgX = this.getLastAvgX();
        const avgY = this.getLastAvgY();
        this.cachedAverages = {
            x: avgX,
            y: avgY
        };
    }
    mapTouchEventId(id) {
        for (const [mappedId, touchId] of this.touchEventsIds){
            if (isNaN(touchId)) {
                this.touchEventsIds.set(mappedId, id);
                break;
            }
        }
    }
    removeMappedTouchId(id) {
        const mappedId = this.getMappedTouchEventId(id);
        if (!isNaN(mappedId)) {
            this.touchEventsIds.set(mappedId, NaN);
        }
    }
    getMappedTouchEventId(touchEventId) {
        for (const [key, value] of this.touchEventsIds.entries()){
            if (value === touchEventId) {
                return key;
            }
        }
        return NaN;
    }
    getVelocityX(pointerId) {
        var _this$trackedPointers;
        return (_this$trackedPointers = this.trackedPointers.get(pointerId)) === null || _this$trackedPointers === void 0 ? void 0 : _this$trackedPointers.velocityX;
    }
    getVelocityY(pointerId) {
        var _this$trackedPointers2;
        return (_this$trackedPointers2 = this.trackedPointers.get(pointerId)) === null || _this$trackedPointers2 === void 0 ? void 0 : _this$trackedPointers2.velocityY;
    }
    /**
   * Returns X coordinate of last moved pointer
   */ getLastX(pointerId) {
        if (pointerId !== undefined) {
            var _this$trackedPointers3;
            return (_this$trackedPointers3 = this.trackedPointers.get(pointerId)) === null || _this$trackedPointers3 === void 0 ? void 0 : _this$trackedPointers3.lastX;
        } else {
            var _this$trackedPointers4;
            return (_this$trackedPointers4 = this.trackedPointers.get(this.lastMovedPointerId)) === null || _this$trackedPointers4 === void 0 ? void 0 : _this$trackedPointers4.lastX;
        }
    }
    /**
   * Returns Y coordinate of last moved pointer
   */ getLastY(pointerId) {
        if (pointerId !== undefined) {
            var _this$trackedPointers5;
            return (_this$trackedPointers5 = this.trackedPointers.get(pointerId)) === null || _this$trackedPointers5 === void 0 ? void 0 : _this$trackedPointers5.lastY;
        } else {
            var _this$trackedPointers6;
            return (_this$trackedPointers6 = this.trackedPointers.get(this.lastMovedPointerId)) === null || _this$trackedPointers6 === void 0 ? void 0 : _this$trackedPointers6.lastY;
        }
    }
    // This may happen when pointers have already been removed from tracker (i.e. pointerup event).
    // In situation when NaN would be sent as a response, we return cached value.
    // That prevents handlers from crashing
    getLastAvgX() {
        const avgX = this.getSumX() / this.trackedPointers.size;
        return isNaN(avgX) ? this.cachedAverages.x : avgX;
    }
    getLastAvgY() {
        const avgY = this.getSumY() / this.trackedPointers.size;
        return isNaN(avgY) ? this.cachedAverages.y : avgY;
    }
    getSumX(ignoredPointer) {
        let sumX = 0;
        this.trackedPointers.forEach((value, key)=>{
            if (key !== ignoredPointer) {
                sumX += value.lastX;
            }
        });
        return sumX;
    }
    getSumY(ignoredPointer) {
        let sumY = 0;
        this.trackedPointers.forEach((value, key)=>{
            if (key !== ignoredPointer) {
                sumY += value.lastY;
            }
        });
        return sumY;
    }
    getTrackedPointersCount() {
        return this.trackedPointers.size;
    }
    getTrackedPointersID() {
        const keys = [];
        this.trackedPointers.forEach((_value, key)=>{
            keys.push(key);
        });
        return keys;
    }
    getData() {
        return this.trackedPointers;
    }
    resetTracker() {
        this.velocityTracker.reset();
        this.trackedPointers.clear();
        this.lastMovedPointerId = NaN;
        for(let i = 0; i < MAX_POINTERS; ++i){
            this.touchEventsIds.set(i, NaN);
        }
    }
    static shareCommonPointers(stPointers, ndPointers) {
        return stPointers.some((pointerId)=>ndPointers.includes(pointerId));
    }
}
exports["default"] = PointerTracker; //# sourceMappingURL=PointerTracker.js.map


/***/ }),

/***/ 26813:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports["default"] = void 0;
var _interfaces = __webpack_require__(68814);
var _EventManager = _interopRequireDefault(__webpack_require__(61912));
var _utils = __webpack_require__(8200);
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
class TouchEventManager extends _EventManager.default {
    setListeners() {
        this.view.addEventListener("touchstart", (event)=>{
            for(let i = 0; i < event.changedTouches.length; ++i){
                const adaptedEvent = this.mapEvent(event, _interfaces.EventTypes.DOWN, i, _interfaces.TouchEventType.DOWN); // Here we skip stylus, because in case of anything different than touch we want to handle it by using PointerEvents
                // If we leave stylus to send touch events, handlers will receive every action twice
                if (!(0, _utils.isPointerInBounds)(this.view, {
                    x: adaptedEvent.x,
                    y: adaptedEvent.y
                }) || //@ts-ignore touchType field does exist
                event.changedTouches[i].touchType === "stylus") {
                    continue;
                }
                this.markAsInBounds(adaptedEvent.pointerId);
                if (++this.activePointersCounter > 1) {
                    adaptedEvent.eventType = _interfaces.EventTypes.ADDITIONAL_POINTER_DOWN;
                    this.onPointerAdd(adaptedEvent);
                } else {
                    this.onPointerDown(adaptedEvent);
                }
            }
        });
        this.view.addEventListener("touchmove", (event)=>{
            for(let i = 0; i < event.changedTouches.length; ++i){
                const adaptedEvent = this.mapEvent(event, _interfaces.EventTypes.MOVE, i, _interfaces.TouchEventType.MOVE); //@ts-ignore touchType field does exist
                if (event.changedTouches[i].touchType === "stylus") {
                    continue;
                }
                const inBounds = (0, _utils.isPointerInBounds)(this.view, {
                    x: adaptedEvent.x,
                    y: adaptedEvent.y
                });
                const pointerIndex = this.pointersInBounds.indexOf(adaptedEvent.pointerId);
                if (inBounds) {
                    if (pointerIndex < 0) {
                        adaptedEvent.eventType = _interfaces.EventTypes.ENTER;
                        this.onPointerEnter(adaptedEvent);
                        this.markAsInBounds(adaptedEvent.pointerId);
                    } else {
                        this.onPointerMove(adaptedEvent);
                    }
                } else {
                    if (pointerIndex >= 0) {
                        adaptedEvent.eventType = _interfaces.EventTypes.OUT;
                        this.onPointerOut(adaptedEvent);
                        this.markAsOutOfBounds(adaptedEvent.pointerId);
                    } else {
                        this.onPointerOutOfBounds(adaptedEvent);
                    }
                }
            }
        });
        this.view.addEventListener("touchend", (event)=>{
            for(let i = 0; i < event.changedTouches.length; ++i){
                // When we call reset on gesture handlers, it also resets their event managers
                // In some handlers (like RotationGestureHandler) reset is called before all pointers leave view
                // This means, that activePointersCounter will be set to 0, while there are still remaining pointers on view
                // Removing them will end in activePointersCounter going below 0, therefore handlers won't behave properly
                if (this.activePointersCounter === 0) {
                    break;
                } //@ts-ignore touchType field does exist
                if (event.changedTouches[i].touchType === "stylus") {
                    continue;
                }
                const adaptedEvent = this.mapEvent(event, _interfaces.EventTypes.UP, i, _interfaces.TouchEventType.UP);
                this.markAsOutOfBounds(adaptedEvent.pointerId);
                if (--this.activePointersCounter > 0) {
                    adaptedEvent.eventType = _interfaces.EventTypes.ADDITIONAL_POINTER_UP;
                    this.onPointerRemove(adaptedEvent);
                } else {
                    this.onPointerUp(adaptedEvent);
                }
            }
        });
        this.view.addEventListener("touchcancel", (event)=>{
            for(let i = 0; i < event.changedTouches.length; ++i){
                const adaptedEvent = this.mapEvent(event, _interfaces.EventTypes.CANCEL, i, _interfaces.TouchEventType.CANCELLED); //@ts-ignore touchType field does exist
                if (event.changedTouches[i].touchType === "stylus") {
                    continue;
                }
                this.onPointerCancel(adaptedEvent);
                this.markAsOutOfBounds(adaptedEvent.pointerId);
                this.activePointersCounter = 0;
            }
        });
    }
    mapEvent(event, eventType, index, touchEventType) {
        const rect = this.view.getBoundingClientRect();
        const clientX = event.changedTouches[index].clientX;
        const clientY = event.changedTouches[index].clientY;
        return {
            x: clientX,
            y: clientY,
            offsetX: clientX - rect.left,
            offsetY: clientY - rect.top,
            pointerId: event.changedTouches[index].identifier,
            eventType: eventType,
            pointerType: _interfaces.PointerType.TOUCH,
            buttons: _interfaces.MouseButtons.NONE,
            time: event.timeStamp,
            allTouches: event.touches,
            changedTouches: event.changedTouches,
            touchEventType: touchEventType
        };
    }
}
exports["default"] = TouchEventManager; //# sourceMappingURL=TouchEventManager.js.map


/***/ }),

/***/ 59442:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports["default"] = void 0;
var _CircularBuffer = _interopRequireDefault(__webpack_require__(4306));
var _LeastSquareSolver = _interopRequireDefault(__webpack_require__(92511));
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function _defineProperty(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
class VelocityTracker {
    constructor(){
        _defineProperty(this, "assumePointerMoveStoppedMilliseconds", 40);
        _defineProperty(this, "historySize", 20);
        _defineProperty(this, "horizonMilliseconds", 300);
        _defineProperty(this, "minSampleSize", 3);
        _defineProperty(this, "samples", void 0);
        this.samples = new _CircularBuffer.default(this.historySize);
    }
    add(event) {
        this.samples.push(event);
    }
    /// tracker given the current information available to the tracker.
    ///
    /// Information is added using [addPosition].
    ///
    /// Returns null if there is no data on which to base an estimate.
    getVelocityEstimate() {
        const x = [];
        const y = [];
        const w = [];
        const time = [];
        let sampleCount = 0;
        let index = this.samples.size - 1;
        const newestSample = this.samples.get(index);
        if (!newestSample) {
            return null;
        }
        let previousSample = newestSample; // Starting with the most recent PointAtTime sample, iterate backwards while
        // the samples represent continuous motion.
        while(sampleCount < this.samples.size){
            const sample = this.samples.get(index);
            const age = newestSample.time - sample.time;
            const delta = Math.abs(sample.time - previousSample.time);
            previousSample = sample;
            if (age > this.horizonMilliseconds || delta > this.assumePointerMoveStoppedMilliseconds) {
                break;
            }
            x.push(sample.x);
            y.push(sample.y);
            w.push(1);
            time.push(-age);
            sampleCount++;
            index--;
        }
        if (sampleCount >= this.minSampleSize) {
            const xSolver = new _LeastSquareSolver.default(time, x, w);
            const xFit = xSolver.solve(2);
            if (xFit !== null) {
                const ySolver = new _LeastSquareSolver.default(time, y, w);
                const yFit = ySolver.solve(2);
                if (yFit !== null) {
                    const xVelocity = xFit.coefficients[1] * 1000;
                    const yVelocity = yFit.coefficients[1] * 1000;
                    return [
                        xVelocity,
                        yVelocity
                    ];
                }
            }
        }
        return null;
    }
    getVelocity() {
        const estimate = this.getVelocityEstimate();
        if (estimate !== null) {
            return estimate;
        }
        return [
            0,
            0
        ];
    }
    reset() {
        this.samples.clear();
    }
}
exports["default"] = VelocityTracker; //# sourceMappingURL=VelocityTracker.js.map


/***/ }),

/***/ 8200:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.isPointerInBounds = isPointerInBounds;
function isPointerInBounds(view, { x, y }) {
    const rect = view.getBoundingClientRect();
    return x >= rect.left && x <= rect.right && y >= rect.top && y <= rect.bottom;
} //# sourceMappingURL=utils.js.map


/***/ }),

/***/ 38434:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports["default"] = void 0;
var _GestureHandler = _interopRequireDefault(__webpack_require__(22833));
var _utils = __webpack_require__(4354);
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
/* eslint-disable eslint-comments/no-unlimited-disable */ /* eslint-disable */ class DiscreteGestureHandler extends _GestureHandler.default {
    get isDiscrete() {
        return true;
    }
    get shouldEnableGestureOnSetup() {
        return true;
    }
    shouldFailUnderCustomCriteria({ x, y, deltaX, deltaY }, { maxDeltaX, maxDeltaY, maxDistSq, shouldCancelWhenOutside }) {
        if (shouldCancelWhenOutside) {
            if (!this.isPointInView({
                x,
                y
            })) {
                return true;
            }
        }
        return (0, _utils.TEST_MAX_IF_NOT_NAN)(Math.abs(deltaX), maxDeltaX) || (0, _utils.TEST_MAX_IF_NOT_NAN)(Math.abs(deltaY), maxDeltaY) || (0, _utils.TEST_MAX_IF_NOT_NAN)(Math.abs(deltaY * deltaY + deltaX * deltaX), maxDistSq);
    }
    transformNativeEvent({ center: { x, y } }) {
        // @ts-ignore FIXME(TS)
        const rect = this.view.getBoundingClientRect();
        return {
            absoluteX: x,
            absoluteY: y,
            x: x - rect.left,
            y: y - rect.top
        };
    }
    isGestureEnabledForEvent({ minPointers, maxPointers, maxDeltaX, maxDeltaY, maxDistSq, shouldCancelWhenOutside }, _recognizer, { maxPointers: pointerLength, center, deltaX, deltaY }) {
        const validPointerCount = pointerLength >= minPointers && pointerLength <= maxPointers;
        if (this.shouldFailUnderCustomCriteria({
            ...center,
            deltaX,
            deltaY
        }, {
            maxDeltaX,
            maxDeltaY,
            maxDistSq,
            shouldCancelWhenOutside
        }) || // A user probably won't land a multi-pointer tap on the first tick (so we cannot just cancel each time)
        // but if the gesture is running and the user adds or subtracts another pointer then it should fail.
        !validPointerCount && this.isGestureRunning) {
            return {
                failed: true
            };
        }
        return {
            success: validPointerCount
        };
    }
}
var _default = DiscreteGestureHandler;
exports["default"] = _default; //# sourceMappingURL=DiscreteGestureHandler.js.map


/***/ }),

/***/ 5557:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports["default"] = void 0;
var _GestureHandler = _interopRequireDefault(__webpack_require__(22833));
var _reactNative = __webpack_require__(83849);
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
/* eslint-disable eslint-comments/no-unlimited-disable */ /* eslint-disable */ class DraggingGestureHandler extends _GestureHandler.default {
    get shouldEnableGestureOnSetup() {
        return true;
    }
    transformNativeEvent({ deltaX, deltaY, velocityX, velocityY, center: { x, y } }) {
        // @ts-ignore FIXME(TS)
        const rect = this.view.getBoundingClientRect();
        const ratio = _reactNative.PixelRatio.get();
        return {
            translationX: deltaX - (this.__initialX || 0),
            translationY: deltaY - (this.__initialY || 0),
            absoluteX: x,
            absoluteY: y,
            velocityX: velocityX * ratio,
            velocityY: velocityY * ratio,
            x: x - rect.left,
            y: y - rect.top
        };
    }
}
var _default = DraggingGestureHandler;
exports["default"] = _default; //# sourceMappingURL=DraggingGestureHandler.js.map


/***/ }),

/***/ 32275:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.GesturePropError = void 0;
class GesturePropError extends Error {
    constructor(name, value, expectedType){
        super(`Invalid property \`${name}: ${value}\` expected \`${expectedType}\``);
    }
}
exports.GesturePropError = GesturePropError; //# sourceMappingURL=Errors.js.map


/***/ }),

/***/ 49929:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports["default"] = void 0;
var _hammerjs = _interopRequireDefault(__webpack_require__(28722));
var _constants = __webpack_require__(49000);
var _Errors = __webpack_require__(32275);
var _DraggingGestureHandler = _interopRequireDefault(__webpack_require__(5557));
var _utils = __webpack_require__(4354);
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
/* eslint-disable eslint-comments/no-unlimited-disable */ /* eslint-disable */ class FlingGestureHandler extends _DraggingGestureHandler.default {
    get name() {
        return "swipe";
    }
    get NativeGestureClass() {
        return _hammerjs.default.Swipe;
    }
    onGestureActivated(event) {
        this.sendEvent({
            ...event,
            eventType: _hammerjs.default.INPUT_MOVE,
            isFinal: false,
            isFirst: true
        });
        this.isGestureRunning = false;
        this.hasGestureFailed = false;
        this.sendEvent({
            ...event,
            eventType: _hammerjs.default.INPUT_END,
            isFinal: true
        });
    }
    onRawEvent(ev) {
        super.onRawEvent(ev);
        if (this.hasGestureFailed) {
            return;
        } // Hammer doesn't send a `cancel` event for taps.
        // Manually fail the event.
        if (ev.isFinal) {
            setTimeout(()=>{
                if (this.isGestureRunning) {
                    this.cancelEvent(ev);
                }
            });
        } else if (!this.hasGestureFailed && !this.isGestureRunning) {
            // Tap Gesture start event
            const gesture = this.hammer.get(this.name); // @ts-ignore FIXME(TS)
            if (gesture.options.enable(gesture, ev)) {
                this.onStart(ev);
                this.sendEvent(ev);
            }
        }
    }
    getHammerConfig() {
        return {
            // @ts-ignore FIXME(TS)
            pointers: this.config.numberOfPointers,
            direction: this.getDirection()
        };
    }
    getTargetDirections(direction) {
        const directions = [];
        if (direction & _constants.Direction.RIGHT) {
            directions.push(_hammerjs.default.DIRECTION_RIGHT);
        }
        if (direction & _constants.Direction.LEFT) {
            directions.push(_hammerjs.default.DIRECTION_LEFT);
        }
        if (direction & _constants.Direction.UP) {
            directions.push(_hammerjs.default.DIRECTION_UP);
        }
        if (direction & _constants.Direction.DOWN) {
            directions.push(_hammerjs.default.DIRECTION_DOWN);
        } // const hammerDirection = directions.reduce((a, b) => a | b, 0);
        return directions;
    }
    getDirection() {
        // @ts-ignore FIXME(TS)
        const { direction } = this.getConfig();
        let directions = [];
        if (direction & _constants.Direction.RIGHT) {
            directions.push(_hammerjs.default.DIRECTION_HORIZONTAL);
        }
        if (direction & _constants.Direction.LEFT) {
            directions.push(_hammerjs.default.DIRECTION_HORIZONTAL);
        }
        if (direction & _constants.Direction.UP) {
            directions.push(_hammerjs.default.DIRECTION_VERTICAL);
        }
        if (direction & _constants.Direction.DOWN) {
            directions.push(_hammerjs.default.DIRECTION_VERTICAL);
        }
        directions = [
            ...new Set(directions)
        ];
        if (directions.length === 0) return _hammerjs.default.DIRECTION_NONE;
        if (directions.length === 1) return directions[0];
        return _hammerjs.default.DIRECTION_ALL;
    }
    isGestureEnabledForEvent({ numberOfPointers }, _recognizer, { maxPointers: pointerLength }) {
        const validPointerCount = pointerLength === numberOfPointers;
        if (!validPointerCount && this.isGestureRunning) {
            return {
                failed: true
            };
        }
        return {
            success: validPointerCount
        };
    }
    updateGestureConfig({ numberOfPointers = 1, direction, ...props }) {
        if ((0, _utils.isnan)(direction) || typeof direction !== "number") {
            throw new _Errors.GesturePropError("direction", direction, "number");
        }
        return super.updateGestureConfig({
            numberOfPointers,
            direction,
            ...props
        });
    }
}
var _default = FlingGestureHandler;
exports["default"] = _default; //# sourceMappingURL=FlingGestureHandler.js.map


/***/ }),

/***/ 22833:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports["default"] = void 0;
var _hammerjs = _interopRequireDefault(__webpack_require__(28722));
var _reactNative = __webpack_require__(83849);
var _State = __webpack_require__(10125);
var _constants = __webpack_require__(49000);
var NodeManager = _interopRequireWildcard(__webpack_require__(24359));
function _getRequireWildcardCache() {
    if (typeof WeakMap !== "function") return null;
    var cache = new WeakMap();
    _getRequireWildcardCache = function() {
        return cache;
    };
    return cache;
}
function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache();
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {};
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function _defineProperty(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
let gestureInstances = 0;
class GestureHandler {
    get id() {
        return `${this.name}${this.gestureInstance}`;
    }
    // here to use instanceof would cause import cycle
    get isNative() {
        return false;
    }
    get isDiscrete() {
        return false;
    }
    get shouldEnableGestureOnSetup() {
        throw new Error("Must override GestureHandler.shouldEnableGestureOnSetup");
    }
    constructor(){
        _defineProperty(this, "handlerTag", void 0);
        _defineProperty(this, "isGestureRunning", false);
        _defineProperty(this, "view", null);
        _defineProperty(this, "hasCustomActivationCriteria", void 0);
        _defineProperty(this, "hasGestureFailed", false);
        _defineProperty(this, "hammer", null);
        _defineProperty(this, "initialRotation", null);
        _defineProperty(this, "__initialX", void 0);
        _defineProperty(this, "__initialY", void 0);
        _defineProperty(this, "config", {});
        _defineProperty(this, "previousState", _State.State.UNDETERMINED);
        _defineProperty(this, "pendingGestures", {});
        _defineProperty(this, "oldState", _State.State.UNDETERMINED);
        _defineProperty(this, "lastSentState", null);
        _defineProperty(this, "gestureInstance", void 0);
        _defineProperty(this, "_stillWaiting", void 0);
        _defineProperty(this, "propsRef", void 0);
        _defineProperty(this, "ref", void 0);
        _defineProperty(this, "clearSelfAsPending", ()=>{
            if (Array.isArray(this.config.waitFor)) {
                for (const gesture of this.config.waitFor){
                    gesture.removePendingGesture(this.id);
                }
            }
        });
        _defineProperty(this, "destroy", ()=>{
            this.clearSelfAsPending();
            if (this.hammer) {
                this.hammer.stop(false);
                this.hammer.destroy();
            }
            this.hammer = null;
        });
        _defineProperty(this, "isPointInView", ({ x, y })=>{
            // @ts-ignore FIXME(TS)
            const rect = this.view.getBoundingClientRect();
            const pointerInside = x >= rect.left && x <= rect.right && y >= rect.top && y <= rect.bottom;
            return pointerInside;
        });
        _defineProperty(this, "sendEvent", (nativeEvent)=>{
            const { onGestureHandlerEvent, onGestureHandlerStateChange } = this.propsRef.current;
            const event = this.transformEventData(nativeEvent);
            invokeNullableMethod(onGestureHandlerEvent, event);
            if (this.lastSentState !== event.nativeEvent.state) {
                this.lastSentState = event.nativeEvent.state;
                invokeNullableMethod(onGestureHandlerStateChange, event);
            }
        });
        _defineProperty(this, "sync", ()=>{
            const gesture = this.hammer.get(this.name);
            if (!gesture) return;
            const enable = (recognizer, inputData)=>{
                if (!this.config.enabled) {
                    this.isGestureRunning = false;
                    this.hasGestureFailed = false;
                    return false;
                } // Prevent events before the system is ready.
                if (!inputData || !recognizer.options || typeof inputData.maxPointers === "undefined") {
                    return this.shouldEnableGestureOnSetup;
                }
                if (this.hasGestureFailed) {
                    return false;
                }
                if (!this.isDiscrete) {
                    if (this.isGestureRunning) {
                        return true;
                    } // The built-in hammer.js "waitFor" doesn't work across multiple views.
                    // Only process if there are views to wait for.
                    this._stillWaiting = this._getPendingGestures(); // This gesture should continue waiting.
                    if (this._stillWaiting.length) {
                        // Check to see if one of the gestures you're waiting for has started.
                        // If it has then the gesture should fail.
                        for (const gesture of this._stillWaiting){
                            // When the target gesture has started, this gesture must force fail.
                            if (!gesture.isDiscrete && gesture.isGestureRunning) {
                                this.hasGestureFailed = true;
                                this.isGestureRunning = false;
                                return false;
                            }
                        } // This gesture shouldn't start until the others have finished.
                        return false;
                    }
                } // Use default behaviour
                if (!this.hasCustomActivationCriteria) {
                    return true;
                }
                const deltaRotation = this.initialRotation == null ? 0 : inputData.rotation - this.initialRotation; // @ts-ignore FIXME(TS)
                const { success, failed } = this.isGestureEnabledForEvent(this.getConfig(), recognizer, {
                    ...inputData,
                    deltaRotation
                });
                if (failed) {
                    this.simulateCancelEvent(inputData);
                    this.hasGestureFailed = true;
                }
                return success;
            };
            const params = this.getHammerConfig(); // @ts-ignore FIXME(TS)
            gesture.set({
                ...params,
                enable
            });
        });
        this.gestureInstance = gestureInstances++;
        this.hasCustomActivationCriteria = false;
    }
    getConfig() {
        return this.config;
    }
    onWaitingEnded(_gesture) {}
    removePendingGesture(id) {
        delete this.pendingGestures[id];
    }
    addPendingGesture(gesture) {
        this.pendingGestures[gesture.id] = gesture;
    }
    isGestureEnabledForEvent(_config, _recognizer, _event) {
        return {
            success: true
        };
    }
    get NativeGestureClass() {
        throw new Error("Must override GestureHandler.NativeGestureClass");
    }
    updateHasCustomActivationCriteria(_config) {
        return true;
    }
    updateGestureConfig({ enabled = true, ...props }) {
        this.clearSelfAsPending();
        this.config = this.ensureConfig({
            enabled,
            ...props
        });
        this.hasCustomActivationCriteria = this.updateHasCustomActivationCriteria(this.config);
        if (Array.isArray(this.config.waitFor)) {
            for (const gesture of this.config.waitFor){
                gesture.addPendingGesture(this);
            }
        }
        if (this.hammer) {
            this.sync();
        }
        return this.config;
    }
    getState(type) {
        // @ts-ignore TODO(TS) check if this is needed
        if (type == 0) {
            return 0;
        }
        return _constants.EventMap[type];
    }
    transformEventData(event) {
        const { eventType, maxPointers: numberOfPointers } = event; // const direction = DirectionMap[ev.direction];
        const changedTouch = event.changedPointers[0];
        const pointerInside = this.isPointInView({
            x: changedTouch.clientX,
            y: changedTouch.clientY
        }); // TODO(TS) Remove cast after https://github.com/DefinitelyTyped/DefinitelyTyped/pull/50966 is merged.
        const state = this.getState(eventType);
        if (state !== this.previousState) {
            this.oldState = this.previousState;
            this.previousState = state;
        }
        return {
            nativeEvent: {
                numberOfPointers,
                state,
                pointerInside,
                ...this.transformNativeEvent(event),
                // onHandlerStateChange only
                handlerTag: this.handlerTag,
                target: this.ref,
                // send oldState only when the state was changed, or is different than ACTIVE
                // GestureDetector relies on the presence of `oldState` to differentiate between
                // update events and state change events
                oldState: state !== this.previousState || state != 4 ? this.oldState : undefined
            },
            timeStamp: Date.now()
        };
    }
    transformNativeEvent(_event) {
        return {};
    }
    cancelPendingGestures(event) {
        for (const gesture of Object.values(this.pendingGestures)){
            if (gesture && gesture.isGestureRunning) {
                gesture.hasGestureFailed = true;
                gesture.cancelEvent(event);
            }
        }
    }
    notifyPendingGestures() {
        for (const gesture of Object.values(this.pendingGestures)){
            if (gesture) {
                gesture.onWaitingEnded(this);
            }
        }
    }
    onGestureEnded(event) {
        this.isGestureRunning = false;
        this.cancelPendingGestures(event);
    }
    forceInvalidate(event) {
        if (this.isGestureRunning) {
            this.hasGestureFailed = true;
            this.cancelEvent(event);
        }
    }
    cancelEvent(event) {
        this.notifyPendingGestures();
        this.sendEvent({
            ...event,
            eventType: _hammerjs.default.INPUT_CANCEL,
            isFinal: true
        });
        this.onGestureEnded(event);
    }
    onRawEvent({ isFirst }) {
        if (isFirst) {
            this.hasGestureFailed = false;
        }
    }
    shouldUseTouchEvents(config) {
        var _config$simultaneousH, _config$simultaneousH2;
        return (_config$simultaneousH = (_config$simultaneousH2 = config.simultaneousHandlers) === null || _config$simultaneousH2 === void 0 ? void 0 : _config$simultaneousH2.some((handler)=>handler.isNative)) !== null && _config$simultaneousH !== void 0 ? _config$simultaneousH : false;
    }
    setView(ref, propsRef) {
        if (ref == null) {
            this.destroy();
            this.view = null;
            return;
        } // @ts-ignore window doesn't exist on global type as we don't want to use Node types
        const SUPPORTS_TOUCH = "ontouchstart" in window;
        this.propsRef = propsRef;
        this.ref = ref;
        this.view = (0, _reactNative.findNodeHandle)(ref); // When the browser starts handling the gesture (e.g. scrolling), it sends a pointercancel event and stops
        // sending additional pointer events. This is not the case with touch events, so if the gesture is simultaneous
        // with a NativeGestureHandler, we need to check if touch events are supported and use them if possible.
        this.hammer = SUPPORTS_TOUCH && this.shouldUseTouchEvents(this.config) ? new _hammerjs.default.Manager(this.view, {
            inputClass: _hammerjs.default.TouchInput
        }) : new _hammerjs.default.Manager(this.view);
        this.oldState = _State.State.UNDETERMINED;
        this.previousState = _State.State.UNDETERMINED;
        this.lastSentState = null;
        const { NativeGestureClass } = this; // @ts-ignore TODO(TS)
        const gesture = new NativeGestureClass(this.getHammerConfig());
        this.hammer.add(gesture);
        this.hammer.on("hammer.input", (ev)=>{
            if (!this.config.enabled) {
                this.hasGestureFailed = false;
                this.isGestureRunning = false;
                return;
            }
            this.onRawEvent(ev); // TODO: Bacon: Check against something other than null
            // The isFirst value is not called when the first rotation is calculated.
            if (this.initialRotation === null && ev.rotation !== 0) {
                this.initialRotation = ev.rotation;
            }
            if (ev.isFinal) {
                // in favor of a willFail otherwise the last frame of the gesture will be captured.
                setTimeout(()=>{
                    this.initialRotation = null;
                    this.hasGestureFailed = false;
                });
            }
        });
        this.setupEvents();
        this.sync();
    }
    setupEvents() {
        // TODO(TS) Hammer types aren't exactly that what we get in runtime
        if (!this.isDiscrete) {
            this.hammer.on(`${this.name}start`, (event)=>this.onStart(event));
            this.hammer.on(`${this.name}end ${this.name}cancel`, (event)=>{
                this.onGestureEnded(event);
            });
        }
        this.hammer.on(this.name, (ev)=>this.onGestureActivated(ev)); // TODO(TS) remove cast after https://github.com/DefinitelyTyped/DefinitelyTyped/pull/50438 is merged
    }
    onStart({ deltaX, deltaY, rotation }) {
        // Reset the state for the next gesture
        this.oldState = _State.State.UNDETERMINED;
        this.previousState = _State.State.UNDETERMINED;
        this.lastSentState = null;
        this.isGestureRunning = true;
        this.__initialX = deltaX;
        this.__initialY = deltaY;
        this.initialRotation = rotation;
    }
    onGestureActivated(ev) {
        this.sendEvent(ev);
    }
    onSuccess() {}
    _getPendingGestures() {
        if (Array.isArray(this.config.waitFor) && this.config.waitFor.length) {
            // Get the list of gestures that this gesture is still waiting for.
            // Use `=== false` in case a ref that isn't a gesture handler is used.
            const stillWaiting = this.config.waitFor.filter(({ hasGestureFailed })=>hasGestureFailed === false);
            return stillWaiting;
        }
        return [];
    }
    getHammerConfig() {
        const pointers = this.config.minPointers === this.config.maxPointers ? this.config.minPointers : 0;
        return {
            pointers
        };
    }
    simulateCancelEvent(_inputData) {}
    ensureConfig(config) {
        const props = {
            ...config
        }; // TODO(TS) We use ! to assert that if property is present then value is not empty (null, undefined)
        if ("minDist" in config) {
            props.minDist = config.minDist;
            props.minDistSq = props.minDist * props.minDist;
        }
        if ("minVelocity" in config) {
            props.minVelocity = config.minVelocity;
            props.minVelocitySq = props.minVelocity * props.minVelocity;
        }
        if ("maxDist" in config) {
            props.maxDist = config.maxDist;
            props.maxDistSq = config.maxDist * config.maxDist;
        }
        if ("waitFor" in config) {
            props.waitFor = asArray(config.waitFor).map(({ handlerTag })=>NodeManager.getHandler(handlerTag)).filter((v)=>v);
        } else {
            props.waitFor = null;
        }
        if ("simultaneousHandlers" in config) {
            const shouldUseTouchEvents = this.shouldUseTouchEvents(this.config);
            props.simultaneousHandlers = asArray(config.simultaneousHandlers).map((handler)=>{
                if (typeof handler === "number") {
                    return NodeManager.getHandler(handler);
                } else {
                    return NodeManager.getHandler(handler.handlerTag);
                }
            }).filter((v)=>v);
            if (shouldUseTouchEvents !== this.shouldUseTouchEvents(props)) {
                queueMicrotask(()=>{
                    // if the undelying event API needs to be changed, we need to unmount and mount
                    // the hammer instance again.
                    this.destroy();
                    this.setView(this.ref, this.propsRef);
                });
            }
        } else {
            props.simultaneousHandlers = null;
        }
        const configProps = [
            "minPointers",
            "maxPointers",
            "minDist",
            "maxDist",
            "maxDistSq",
            "minVelocitySq",
            "minDistSq",
            "minVelocity",
            "failOffsetXStart",
            "failOffsetYStart",
            "failOffsetXEnd",
            "failOffsetYEnd",
            "activeOffsetXStart",
            "activeOffsetXEnd",
            "activeOffsetYStart",
            "activeOffsetYEnd"
        ];
        configProps.forEach((prop)=>{
            if (typeof props[prop] === "undefined") {
                props[prop] = Number.NaN;
            }
        });
        return props; // TODO(TS) how to convince TS that props are filled?
    }
} // TODO(TS) investigate this method
// Used for sending data to a callback or AnimatedEvent
function invokeNullableMethod(method, event) {
    if (method) {
        if (typeof method === "function") {
            method(event);
        } else {
            // For use with reanimated's AnimatedEvent
            if ("__getHandler" in method && typeof method.__getHandler === "function") {
                const handler = method.__getHandler();
                invokeNullableMethod(handler, event);
            } else {
                if ("__nodeConfig" in method) {
                    const { argMapping } = method.__nodeConfig;
                    if (Array.isArray(argMapping)) {
                        for (const [index, [key, value]] of argMapping.entries()){
                            if (key in event.nativeEvent) {
                                // @ts-ignore fix method type
                                const nativeValue = event.nativeEvent[key];
                                if (value && value.setValue) {
                                    // Reanimated API
                                    value.setValue(nativeValue);
                                } else {
                                    // RN Animated API
                                    method.__nodeConfig.argMapping[index] = [
                                        key,
                                        nativeValue
                                    ];
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}
function asArray(value) {
    // TODO(TS) use config.waitFor type
    return value == null ? [] : Array.isArray(value) ? value : [
        value
    ];
}
var _default = GestureHandler;
exports["default"] = _default; //# sourceMappingURL=GestureHandler.js.map


/***/ }),

/***/ 84403:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports["default"] = void 0;
var _GestureHandler = _interopRequireDefault(__webpack_require__(22833));
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
/**
 * The base class for **Rotation** and **Pinch** gesture handlers.
 */ class IndiscreteGestureHandler extends _GestureHandler.default {
    get shouldEnableGestureOnSetup() {
        return false;
    }
    updateGestureConfig({ minPointers = 2, maxPointers = 2, ...props }) {
        return super.updateGestureConfig({
            minPointers,
            maxPointers,
            ...props
        });
    }
    isGestureEnabledForEvent({ minPointers, maxPointers }, _recognizer, { maxPointers: pointerLength }) {
        if (pointerLength > maxPointers) {
            return {
                failed: true
            };
        }
        const validPointerCount = pointerLength >= minPointers;
        return {
            success: validPointerCount
        };
    }
}
var _default = IndiscreteGestureHandler;
exports["default"] = _default; //# sourceMappingURL=IndiscreteGestureHandler.js.map


/***/ }),

/***/ 46438:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports["default"] = void 0;
var _hammerjs = _interopRequireDefault(__webpack_require__(28722));
var _State = __webpack_require__(10125);
var _PressGestureHandler = _interopRequireDefault(__webpack_require__(17132));
var _utils = __webpack_require__(4354);
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
/* eslint-disable eslint-comments/no-unlimited-disable */ /* eslint-disable */ class LongPressGestureHandler extends _PressGestureHandler.default {
    get minDurationMs() {
        // @ts-ignore FIXNE(TS)
        return (0, _utils.isnan)(this.config.minDurationMs) ? 251 : this.config.minDurationMs;
    }
    get maxDist() {
        // @ts-ignore FIXNE(TS)
        return (0, _utils.isnan)(this.config.maxDist) ? 9 : this.config.maxDist;
    }
    updateHasCustomActivationCriteria({ maxDistSq }) {
        return !(0, _utils.isValidNumber)(maxDistSq);
    }
    getConfig() {
        if (!this.hasCustomActivationCriteria) {
            // Default config
            // If no params have been defined then this config should emulate the native gesture as closely as possible.
            return {
                shouldCancelWhenOutside: true,
                maxDistSq: 10
            };
        }
        return this.config;
    }
    getHammerConfig() {
        return {
            ...super.getHammerConfig(),
            // threshold: this.maxDist,
            time: this.minDurationMs
        };
    }
    getState(type) {
        return ({
            [_hammerjs.default.INPUT_START]: _State.State.ACTIVE,
            [_hammerjs.default.INPUT_MOVE]: _State.State.ACTIVE,
            [_hammerjs.default.INPUT_END]: _State.State.END,
            [_hammerjs.default.INPUT_CANCEL]: _State.State.FAILED
        })[type];
    }
}
var _default = LongPressGestureHandler;
exports["default"] = _default; //# sourceMappingURL=LongPressGestureHandler.js.map


/***/ }),

/***/ 30027:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports["default"] = void 0;
var _DiscreteGestureHandler = _interopRequireDefault(__webpack_require__(38434));
var NodeManager = _interopRequireWildcard(__webpack_require__(24359));
var _PressGestureHandler = _interopRequireDefault(__webpack_require__(17132));
var _utils = __webpack_require__(4354);
function _getRequireWildcardCache() {
    if (typeof WeakMap !== "function") return null;
    var cache = new WeakMap();
    _getRequireWildcardCache = function() {
        return cache;
    };
    return cache;
}
function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache();
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {};
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
class NativeViewGestureHandler extends _PressGestureHandler.default {
    get isNative() {
        return true;
    }
    onRawEvent(ev) {
        super.onRawEvent(ev);
        if (!ev.isFinal) {
            // if (this.ref instanceof ScrollView) {
            if ((0, _utils.TEST_MIN_IF_NOT_NAN)((0, _utils.VEC_LEN_SQ)({
                x: ev.deltaX,
                y: ev.deltaY
            }), 10)) {
                // @ts-ignore FIXME(TS) config type
                if (this.config.disallowInterruption) {
                    const gestures = Object.values(NodeManager.getNodes()).filter((gesture)=>{
                        const { handlerTag, view, isGestureRunning } = gesture;
                        return handlerTag !== this.handlerTag && // Ensure the gesture needs to be cancelled
                        isGestureRunning && // ScrollView can cancel discrete gestures like taps and presses
                        gesture instanceof _DiscreteGestureHandler.default && // Ensure a view exists and is a child of the current view
                        view && // @ts-ignore FIXME(TS) view type
                        this.view.contains(view);
                    }); // Cancel all of the gestures that passed the filter
                    for (const gesture of gestures){
                        // TODO: Bacon: Send some cached event.
                        gesture.forceInvalidate(ev);
                    }
                }
            }
        }
    }
}
var _default = NativeViewGestureHandler;
exports["default"] = _default; //# sourceMappingURL=NativeViewGestureHandler.js.map


/***/ }),

/***/ 24359:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.getHandler = getHandler;
exports.createGestureHandler = createGestureHandler;
exports.dropGestureHandler = dropGestureHandler;
exports.getNodes = getNodes;
const gestures = {};
function getHandler(tag) {
    if (tag in gestures) {
        return gestures[tag];
    }
    throw new Error(`No handler for tag ${tag}`);
}
function createGestureHandler(handlerTag, handler) {
    if (handlerTag in gestures) {
        throw new Error(`Handler with tag ${handlerTag} already exists`);
    }
    gestures[handlerTag] = handler; // @ts-ignore no types for web handlers yet
    gestures[handlerTag].handlerTag = handlerTag;
}
function dropGestureHandler(handlerTag) {
    // Since React 18, there are cases where componentWillUnmount gets called twice in a row
    // so skip this if the tag was already removed.
    if (!(handlerTag in gestures)) {
        return;
    }
    getHandler(handlerTag).destroy(); // eslint-disable-next-line @typescript-eslint/no-dynamic-delete
    delete gestures[handlerTag];
}
function getNodes() {
    return {
        ...gestures
    };
} //# sourceMappingURL=NodeManager.js.map


/***/ }),

/***/ 54255:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports["default"] = void 0;
var _hammerjs = _interopRequireDefault(__webpack_require__(28722));
var _constants = __webpack_require__(49000);
var _DraggingGestureHandler = _interopRequireDefault(__webpack_require__(5557));
var _utils = __webpack_require__(4354);
var _State = __webpack_require__(10125);
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
class PanGestureHandler extends _DraggingGestureHandler.default {
    get name() {
        return "pan";
    }
    get NativeGestureClass() {
        return _hammerjs.default.Pan;
    }
    getHammerConfig() {
        return {
            ...super.getHammerConfig(),
            direction: this.getDirection()
        };
    }
    getState(type) {
        const nextState = super.getState(type); // Ensure that the first state sent is `BEGAN` and not `ACTIVE`
        if (this.previousState === _State.State.UNDETERMINED && nextState === _State.State.ACTIVE) {
            return _State.State.BEGAN;
        }
        return nextState;
    }
    getDirection() {
        const config = this.getConfig();
        const { activeOffsetXStart, activeOffsetXEnd, activeOffsetYStart, activeOffsetYEnd, minDist } = config;
        let directions = [];
        let horizontalDirections = [];
        if (!(0, _utils.isnan)(minDist)) {
            return _hammerjs.default.DIRECTION_ALL;
        }
        if (!(0, _utils.isnan)(activeOffsetXStart)) {
            horizontalDirections.push(_hammerjs.default.DIRECTION_LEFT);
        }
        if (!(0, _utils.isnan)(activeOffsetXEnd)) {
            horizontalDirections.push(_hammerjs.default.DIRECTION_RIGHT);
        }
        if (horizontalDirections.length === 2) {
            horizontalDirections = [
                _hammerjs.default.DIRECTION_HORIZONTAL
            ];
        }
        directions = directions.concat(horizontalDirections);
        let verticalDirections = [];
        if (!(0, _utils.isnan)(activeOffsetYStart)) {
            verticalDirections.push(_hammerjs.default.DIRECTION_UP);
        }
        if (!(0, _utils.isnan)(activeOffsetYEnd)) {
            verticalDirections.push(_hammerjs.default.DIRECTION_DOWN);
        }
        if (verticalDirections.length === 2) {
            verticalDirections = [
                _hammerjs.default.DIRECTION_VERTICAL
            ];
        }
        directions = directions.concat(verticalDirections);
        if (!directions.length) {
            return _hammerjs.default.DIRECTION_NONE;
        }
        if (directions[0] === _hammerjs.default.DIRECTION_HORIZONTAL && directions[1] === _hammerjs.default.DIRECTION_VERTICAL) {
            return _hammerjs.default.DIRECTION_ALL;
        }
        if (horizontalDirections.length && verticalDirections.length) {
            return _hammerjs.default.DIRECTION_ALL;
        }
        return directions[0];
    }
    getConfig() {
        if (!this.hasCustomActivationCriteria) {
            // Default config
            // If no params have been defined then this config should emulate the native gesture as closely as possible.
            return {
                minDistSq: 10
            };
        }
        return this.config;
    }
    shouldFailUnderCustomCriteria({ deltaX, deltaY }, criteria) {
        return !(0, _utils.isnan)(criteria.failOffsetXStart) && deltaX < criteria.failOffsetXStart || !(0, _utils.isnan)(criteria.failOffsetXEnd) && deltaX > criteria.failOffsetXEnd || !(0, _utils.isnan)(criteria.failOffsetYStart) && deltaY < criteria.failOffsetYStart || !(0, _utils.isnan)(criteria.failOffsetYEnd) && deltaY > criteria.failOffsetYEnd;
    }
    shouldActivateUnderCustomCriteria({ deltaX, deltaY, velocity }, criteria) {
        return !(0, _utils.isnan)(criteria.activeOffsetXStart) && deltaX < criteria.activeOffsetXStart || !(0, _utils.isnan)(criteria.activeOffsetXEnd) && deltaX > criteria.activeOffsetXEnd || !(0, _utils.isnan)(criteria.activeOffsetYStart) && deltaY < criteria.activeOffsetYStart || !(0, _utils.isnan)(criteria.activeOffsetYEnd) && deltaY > criteria.activeOffsetYEnd || (0, _utils.TEST_MIN_IF_NOT_NAN)((0, _utils.VEC_LEN_SQ)({
            x: deltaX,
            y: deltaY
        }), criteria.minDistSq) || (0, _utils.TEST_MIN_IF_NOT_NAN)(velocity.x, criteria.minVelocityX) || (0, _utils.TEST_MIN_IF_NOT_NAN)(velocity.y, criteria.minVelocityY) || (0, _utils.TEST_MIN_IF_NOT_NAN)((0, _utils.VEC_LEN_SQ)(velocity), criteria.minVelocitySq);
    }
    shouldMultiFingerPanFail({ pointerLength, scale, deltaRotation }) {
        if (pointerLength <= 1) {
            return false;
        } // Test if the pan had too much pinching or rotating.
        const deltaScale = Math.abs(scale - 1);
        const absDeltaRotation = Math.abs(deltaRotation);
        if (deltaScale > _constants.MULTI_FINGER_PAN_MAX_PINCH_THRESHOLD) {
            // > If the threshold doesn't seem right.
            // You can log the value which it failed at here:
            return true;
        }
        if (absDeltaRotation > _constants.MULTI_FINGER_PAN_MAX_ROTATION_THRESHOLD) {
            // > If the threshold doesn't seem right.
            // You can log the value which it failed at here:
            return true;
        }
        return false;
    }
    updateHasCustomActivationCriteria(criteria) {
        return (0, _utils.isValidNumber)(criteria.minDistSq) || (0, _utils.isValidNumber)(criteria.minVelocityX) || (0, _utils.isValidNumber)(criteria.minVelocityY) || (0, _utils.isValidNumber)(criteria.minVelocitySq) || (0, _utils.isValidNumber)(criteria.activeOffsetXStart) || (0, _utils.isValidNumber)(criteria.activeOffsetXEnd) || (0, _utils.isValidNumber)(criteria.activeOffsetYStart) || (0, _utils.isValidNumber)(criteria.activeOffsetYEnd);
    }
    isGestureEnabledForEvent(props, _recognizer, inputData) {
        if (this.shouldFailUnderCustomCriteria(inputData, props)) {
            return {
                failed: true
            };
        }
        const velocity = {
            x: inputData.velocityX,
            y: inputData.velocityY
        };
        if (this.hasCustomActivationCriteria && this.shouldActivateUnderCustomCriteria({
            deltaX: inputData.deltaX,
            deltaY: inputData.deltaY,
            velocity
        }, props)) {
            if (this.shouldMultiFingerPanFail({
                pointerLength: inputData.maxPointers,
                scale: inputData.scale,
                deltaRotation: inputData.deltaRotation
            })) {
                return {
                    failed: true
                };
            }
            return {
                success: true
            };
        }
        return {
            success: false
        };
    }
}
var _default = PanGestureHandler;
exports["default"] = _default; //# sourceMappingURL=PanGestureHandler.js.map


/***/ }),

/***/ 88164:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports["default"] = void 0;
var _hammerjs = _interopRequireDefault(__webpack_require__(28722));
var _IndiscreteGestureHandler = _interopRequireDefault(__webpack_require__(84403));
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
class PinchGestureHandler extends _IndiscreteGestureHandler.default {
    get name() {
        return "pinch";
    }
    get NativeGestureClass() {
        return _hammerjs.default.Pinch;
    }
    transformNativeEvent({ scale, velocity, center }) {
        return {
            focalX: center.x,
            focalY: center.y,
            velocity,
            scale
        };
    }
}
var _default = PinchGestureHandler;
exports["default"] = _default; //# sourceMappingURL=PinchGestureHandler.js.map


/***/ }),

/***/ 17132:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports["default"] = void 0;
var _hammerjs = _interopRequireDefault(__webpack_require__(28722));
var _State = __webpack_require__(10125);
var _constants = __webpack_require__(49000);
var _DiscreteGestureHandler = _interopRequireDefault(__webpack_require__(38434));
var _utils = __webpack_require__(4354);
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function _defineProperty(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
class PressGestureHandler extends _DiscreteGestureHandler.default {
    constructor(...args){
        super(...args);
        _defineProperty(this, "visualFeedbackTimer", void 0);
        _defineProperty(this, "initialEvent", null);
        _defineProperty(this, "shouldDelayTouches", true);
    }
    get name() {
        return "press";
    }
    get minDurationMs() {
        // @ts-ignore FIXME(TS)
        return (0, _utils.isnan)(this.config.minDurationMs) ? 5 : this.config.minDurationMs;
    }
    get maxDist() {
        return (0, _utils.isnan)(this.config.maxDist) ? 9 : this.config.maxDist;
    }
    get NativeGestureClass() {
        return _hammerjs.default.Press;
    }
    simulateCancelEvent(inputData) {
        // Long press never starts so we can't rely on the running event boolean.
        this.hasGestureFailed = true;
        this.cancelEvent(inputData);
    }
    updateHasCustomActivationCriteria({ shouldCancelWhenOutside, maxDistSq }) {
        return shouldCancelWhenOutside || !(0, _utils.isValidNumber)(maxDistSq);
    }
    getState(type) {
        return ({
            [_hammerjs.default.INPUT_START]: _State.State.BEGAN,
            [_hammerjs.default.INPUT_MOVE]: _State.State.ACTIVE,
            [_hammerjs.default.INPUT_END]: _State.State.END,
            [_hammerjs.default.INPUT_CANCEL]: _State.State.CANCELLED
        })[type];
    }
    getConfig() {
        if (!this.hasCustomActivationCriteria) {
            // Default config
            // If no params have been defined then this config should emulate the native gesture as closely as possible.
            return {
                shouldCancelWhenOutside: true,
                maxDistSq: 10
            };
        }
        return this.config;
    }
    getHammerConfig() {
        return {
            ...super.getHammerConfig(),
            // threshold: this.maxDist,
            time: this.minDurationMs
        };
    }
    onGestureActivated(ev) {
        this.onGestureStart(ev);
    }
    shouldDelayTouchForEvent({ pointerType }) {
        // Don't disable event for mouse input
        return this.shouldDelayTouches && pointerType === "touch";
    }
    onGestureStart(ev) {
        this.isGestureRunning = true;
        clearTimeout(this.visualFeedbackTimer);
        this.initialEvent = ev;
        this.visualFeedbackTimer = (0, _utils.fireAfterInterval)(()=>{
            this.sendGestureStartedEvent(this.initialEvent);
            this.initialEvent = null;
        }, this.shouldDelayTouchForEvent(ev) && _constants.CONTENT_TOUCHES_DELAY);
    }
    sendGestureStartedEvent(ev) {
        clearTimeout(this.visualFeedbackTimer);
        this.visualFeedbackTimer = null;
        this.sendEvent({
            ...ev,
            eventType: _hammerjs.default.INPUT_MOVE,
            isFirst: true
        });
    }
    forceInvalidate(event) {
        super.forceInvalidate(event);
        clearTimeout(this.visualFeedbackTimer);
        this.visualFeedbackTimer = null;
        this.initialEvent = null;
    }
    onRawEvent(ev) {
        super.onRawEvent(ev);
        if (this.isGestureRunning) {
            if (ev.isFinal) {
                let timeout;
                if (this.visualFeedbackTimer) {
                    // Aesthetic timing for a quick tap.
                    // We haven't activated the tap right away to emulate iOS `delaysContentTouches`
                    // Now we must send the initial activation event and wait a set amount of time before firing the end event.
                    timeout = _constants.CONTENT_TOUCHES_QUICK_TAP_END_DELAY;
                    this.sendGestureStartedEvent(this.initialEvent);
                    this.initialEvent = null;
                }
                (0, _utils.fireAfterInterval)(()=>{
                    this.sendEvent({
                        ...ev,
                        eventType: _hammerjs.default.INPUT_END,
                        isFinal: true
                    }); // @ts-ignore -- this should explicitly support undefined
                    this.onGestureEnded();
                }, timeout);
            } else {
                this.sendEvent({
                    ...ev,
                    eventType: _hammerjs.default.INPUT_MOVE,
                    isFinal: false
                });
            }
        }
    }
    updateGestureConfig({ shouldActivateOnStart = false, disallowInterruption = false, shouldCancelWhenOutside = true, minDurationMs = Number.NaN, maxDist = Number.NaN, minPointers = 1, maxPointers = 1, ...props }) {
        return super.updateGestureConfig({
            shouldActivateOnStart,
            disallowInterruption,
            shouldCancelWhenOutside,
            minDurationMs,
            maxDist,
            minPointers,
            maxPointers,
            ...props
        });
    }
}
var _default = PressGestureHandler;
exports["default"] = _default; //# sourceMappingURL=PressGestureHandler.js.map


/***/ }),

/***/ 61236:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports["default"] = void 0;
var _hammerjs = _interopRequireDefault(__webpack_require__(28722));
var _constants = __webpack_require__(49000);
var _IndiscreteGestureHandler = _interopRequireDefault(__webpack_require__(84403));
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
class RotationGestureHandler extends _IndiscreteGestureHandler.default {
    get name() {
        return "rotate";
    }
    get NativeGestureClass() {
        return _hammerjs.default.Rotate;
    }
    transformNativeEvent({ rotation, velocity, center }) {
        var _this$initialRotation;
        return {
            rotation: (rotation - ((_this$initialRotation = this.initialRotation) !== null && _this$initialRotation !== void 0 ? _this$initialRotation : 0)) * _constants.DEG_RAD,
            anchorX: center.x,
            anchorY: center.y,
            velocity
        };
    }
}
var _default = RotationGestureHandler;
exports["default"] = _default; //# sourceMappingURL=RotationGestureHandler.js.map


/***/ }),

/***/ 97833:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports["default"] = void 0;
var _hammerjs = _interopRequireDefault(__webpack_require__(28722));
var _DiscreteGestureHandler = _interopRequireDefault(__webpack_require__(38434));
var _utils = __webpack_require__(4354);
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function _defineProperty(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
class TapGestureHandler extends _DiscreteGestureHandler.default {
    constructor(...args){
        super(...args);
        _defineProperty(this, "_shouldFireEndEvent", null);
        _defineProperty(this, "_timer", void 0);
        _defineProperty(this, "_multiTapTimer", void 0);
        _defineProperty(this, "onSuccessfulTap", (ev)=>{
            if (this._getPendingGestures().length) {
                this._shouldFireEndEvent = ev;
                return;
            }
            if (ev.eventType === _hammerjs.default.INPUT_END) {
                this.sendEvent({
                    ...ev,
                    eventType: _hammerjs.default.INPUT_MOVE
                });
            } // When handler gets activated it will turn into State.END immediately.
            this.sendEvent({
                ...ev,
                isFinal: true
            });
            this.onGestureEnded(ev);
        });
    }
    // TODO unused?
    get name() {
        return "tap";
    }
    get NativeGestureClass() {
        return _hammerjs.default.Tap;
    }
    get maxDelayMs() {
        // @ts-ignore TODO(TS) trace down config
        return (0, _utils.isnan)(this.config.maxDelayMs) ? 300 : this.config.maxDelayMs;
    }
    simulateCancelEvent(inputData) {
        if (this.isGestureRunning) {
            this.cancelEvent(inputData);
        }
    }
    onGestureActivated(ev) {
        if (this.isGestureRunning) {
            this.onSuccessfulTap(ev);
        }
    }
    onRawEvent(ev) {
        super.onRawEvent(ev); // Attempt to create a touch-down event by checking if a valid tap hasn't started yet, then validating the input.
        if (!this.hasGestureFailed && !this.isGestureRunning && // Prevent multi-pointer events from misfiring.
        !ev.isFinal) {
            // Tap Gesture start event
            const gesture = this.hammer.get(this.name); // @ts-ignore TODO(TS) trace down config
            if (gesture.options.enable(gesture, ev)) {
                clearTimeout(this._multiTapTimer);
                this.onStart(ev);
                this.sendEvent(ev);
            }
        }
        if (ev.isFinal && ev.maxPointers > 1) {
            setTimeout(()=>{
                // Handle case where one finger presses slightly
                // after the first finger on a multi-tap event
                if (this.isGestureRunning) {
                    this.cancelEvent(ev);
                }
            });
        }
        if (this.hasGestureFailed) {
            return;
        } // Hammer doesn't send a `cancel` event for taps.
        // Manually fail the event.
        if (ev.isFinal) {
            // Handle case where one finger presses slightly
            // after the first finger on a multi-tap event
            if (ev.maxPointers > 1) {
                setTimeout(()=>{
                    if (this.isGestureRunning) {
                        this.cancelEvent(ev);
                    }
                });
            } // Clear last timer
            clearTimeout(this._timer); // Create time out for multi-taps.
            this._timer = setTimeout(()=>{
                this.hasGestureFailed = true;
                this.cancelEvent(ev);
            }, this.maxDelayMs);
        } else if (!this.hasGestureFailed && !this.isGestureRunning) {
            // Tap Gesture start event
            const gesture = this.hammer.get(this.name); // @ts-ignore TODO(TS) trace down config
            if (gesture.options.enable(gesture, ev)) {
                clearTimeout(this._multiTapTimer);
                this.onStart(ev);
                this.sendEvent(ev);
            }
        }
    }
    getHammerConfig() {
        return {
            ...super.getHammerConfig(),
            event: this.name,
            // @ts-ignore TODO(TS) trace down config
            taps: (0, _utils.isnan)(this.config.numberOfTaps) ? 1 : this.config.numberOfTaps,
            interval: this.maxDelayMs,
            time: (0, _utils.isnan)(this.config.maxDurationMs) || this.config.maxDurationMs == null ? 250 : this.config.maxDurationMs
        };
    }
    updateGestureConfig({ shouldCancelWhenOutside = true, maxDeltaX = Number.NaN, maxDeltaY = Number.NaN, numberOfTaps = 1, minDurationMs = 525, maxDelayMs = Number.NaN, // eslint-disable-next-line @typescript-eslint/no-unused-vars -- TODO possibly forgotten to use in updateGestureConfig?
    maxDurationMs = Number.NaN, maxDist = 2, minPointers = 1, maxPointers = 1, ...props }) {
        return super.updateGestureConfig({
            shouldCancelWhenOutside,
            numberOfTaps,
            maxDeltaX,
            maxDeltaY,
            minDurationMs,
            maxDelayMs,
            maxDist,
            minPointers,
            maxPointers,
            ...props
        });
    }
    onGestureEnded(...props) {
        clearTimeout(this._timer); // @ts-ignore TODO(TS) check how onGestureEnded works
        super.onGestureEnded(...props);
    }
    onWaitingEnded(_gesture) {
        if (this._shouldFireEndEvent) {
            this.onSuccessfulTap(this._shouldFireEndEvent);
            this._shouldFireEndEvent = null;
        }
    }
}
var _default = TapGestureHandler;
exports["default"] = _default; //# sourceMappingURL=TapGestureHandler.js.map


/***/ }),

/***/ 49000:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.HammerDirectionNames = exports.HammerInputNames = exports.DirectionMap = exports.Direction = exports.EventMap = exports.DEG_RAD = exports.MULTI_FINGER_PAN_MAX_ROTATION_THRESHOLD = exports.MULTI_FINGER_PAN_MAX_PINCH_THRESHOLD = exports.CONTENT_TOUCHES_QUICK_TAP_END_DELAY = exports.CONTENT_TOUCHES_DELAY = void 0;
var _hammerjs = _interopRequireDefault(__webpack_require__(28722));
var _State = __webpack_require__(10125);
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
const CONTENT_TOUCHES_DELAY = 240;
exports.CONTENT_TOUCHES_DELAY = CONTENT_TOUCHES_DELAY;
const CONTENT_TOUCHES_QUICK_TAP_END_DELAY = 50;
exports.CONTENT_TOUCHES_QUICK_TAP_END_DELAY = CONTENT_TOUCHES_QUICK_TAP_END_DELAY;
const MULTI_FINGER_PAN_MAX_PINCH_THRESHOLD = 0.1;
exports.MULTI_FINGER_PAN_MAX_PINCH_THRESHOLD = MULTI_FINGER_PAN_MAX_PINCH_THRESHOLD;
const MULTI_FINGER_PAN_MAX_ROTATION_THRESHOLD = 7;
exports.MULTI_FINGER_PAN_MAX_ROTATION_THRESHOLD = MULTI_FINGER_PAN_MAX_ROTATION_THRESHOLD;
const DEG_RAD = Math.PI / 180; // Map Hammer values to RNGH
exports.DEG_RAD = DEG_RAD;
const EventMap = {
    [_hammerjs.default.INPUT_START]: _State.State.BEGAN,
    [_hammerjs.default.INPUT_MOVE]: _State.State.ACTIVE,
    [_hammerjs.default.INPUT_END]: _State.State.END,
    [_hammerjs.default.INPUT_CANCEL]: _State.State.FAILED
};
exports.EventMap = EventMap;
const Direction = {
    RIGHT: 1,
    LEFT: 2,
    UP: 4,
    DOWN: 8
};
exports.Direction = Direction;
const DirectionMap = {
    [_hammerjs.default.DIRECTION_RIGHT]: Direction.RIGHT,
    [_hammerjs.default.DIRECTION_LEFT]: Direction.LEFT,
    [_hammerjs.default.DIRECTION_UP]: Direction.UP,
    [_hammerjs.default.DIRECTION_DOWN]: Direction.DOWN
};
exports.DirectionMap = DirectionMap;
const HammerInputNames = {
    [_hammerjs.default.INPUT_START]: "START",
    [_hammerjs.default.INPUT_MOVE]: "MOVE",
    [_hammerjs.default.INPUT_END]: "END",
    [_hammerjs.default.INPUT_CANCEL]: "CANCEL"
};
exports.HammerInputNames = HammerInputNames;
const HammerDirectionNames = {
    [_hammerjs.default.DIRECTION_HORIZONTAL]: "HORIZONTAL",
    [_hammerjs.default.DIRECTION_UP]: "UP",
    [_hammerjs.default.DIRECTION_DOWN]: "DOWN",
    [_hammerjs.default.DIRECTION_VERTICAL]: "VERTICAL",
    [_hammerjs.default.DIRECTION_NONE]: "NONE",
    [_hammerjs.default.DIRECTION_ALL]: "ALL",
    [_hammerjs.default.DIRECTION_RIGHT]: "RIGHT",
    [_hammerjs.default.DIRECTION_LEFT]: "LEFT"
};
exports.HammerDirectionNames = HammerDirectionNames; //# sourceMappingURL=constants.js.map


/***/ }),

/***/ 4354:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.fireAfterInterval = fireAfterInterval;
exports.TEST_MAX_IF_NOT_NAN = exports.VEC_LEN_SQ = exports.TEST_MIN_IF_NOT_NAN = exports.isValidNumber = exports.isnan = void 0;
// TODO(TS) remove if not necessary after rewrite
const isnan = (v)=>Number.isNaN(v); // TODO(TS) remove if not necessary after rewrite
exports.isnan = isnan;
const isValidNumber = (v)=>typeof v === "number" && !Number.isNaN(v);
exports.isValidNumber = isValidNumber;
const TEST_MIN_IF_NOT_NAN = (value, limit)=>!isnan(limit) && (limit < 0 && value <= limit || limit >= 0 && value >= limit);
exports.TEST_MIN_IF_NOT_NAN = TEST_MIN_IF_NOT_NAN;
const VEC_LEN_SQ = ({ x = 0, y = 0 } = {})=>x * x + y * y;
exports.VEC_LEN_SQ = VEC_LEN_SQ;
const TEST_MAX_IF_NOT_NAN = (value, max)=>!isnan(max) && (max < 0 && value < max || max >= 0 && value > max);
exports.TEST_MAX_IF_NOT_NAN = TEST_MAX_IF_NOT_NAN;
function fireAfterInterval(method, interval) {
    if (!interval) {
        method();
        return null;
    }
    return setTimeout(()=>method(), interval);
} //# sourceMappingURL=utils.js.map


/***/ }),

/***/ 30665:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  Z: () => (/* binding */ ReanimatedModule)
});

;// CONCATENATED MODULE: ./node_modules/react-native-reanimated/lib/ReanimatedModuleCompat.js
var __awaiter = undefined && undefined.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
/* harmony default export */ const ReanimatedModuleCompat = ({
    disconnectNodeFromView () {
        return __awaiter(this, void 0, void 0, function*() {
        // noop
        });
    },
    attachEvent (_viewTag, _eventName, _nodeID) {
        return __awaiter(this, void 0, void 0, function*() {
        // noop
        });
    },
    detachEvent (_viewTag, _eventName, _nodeID) {
        return __awaiter(this, void 0, void 0, function*() {
        // noop
        });
    },
    createNode (_nodeID, _config) {
        return __awaiter(this, void 0, void 0, function*() {
        // noop
        });
    },
    dropNode (_nodeID) {
        return __awaiter(this, void 0, void 0, function*() {
        // noop
        });
    },
    configureProps (_nativeProps, _uiProps) {
        return __awaiter(this, void 0, void 0, function*() {
        // noop
        });
    },
    disconnectNodes () {
        return __awaiter(this, void 0, void 0, function*() {
        // noop
        });
    },
    addListener () {
        return __awaiter(this, void 0, void 0, function*() {
        // noop
        });
    },
    removeListeners () {
        return __awaiter(this, void 0, void 0, function*() {
        // noop
        });
    },
    removeAllListeners () {
        return __awaiter(this, void 0, void 0, function*() {
        // noop
        });
    },
    animateNextTransition () {
        return __awaiter(this, void 0, void 0, function*() {
            console.warn("Reanimated: animateNextTransition is unimplemented on current platform");
        });
    }
});

;// CONCATENATED MODULE: ./node_modules/react-native-reanimated/lib/ReanimatedModule.js

/* harmony default export */ const ReanimatedModule = (ReanimatedModuleCompat);


/***/ }),

/***/ 82735:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  BaseAnimationBuilder: () => (/* reexport */ BaseAnimationBuilder),
  BounceIn: () => (/* reexport */ BounceIn),
  BounceInDown: () => (/* reexport */ BounceInDown),
  BounceInLeft: () => (/* reexport */ BounceInLeft),
  BounceInRight: () => (/* reexport */ BounceInRight),
  BounceInUp: () => (/* reexport */ BounceInUp),
  BounceOut: () => (/* reexport */ BounceOut),
  BounceOutDown: () => (/* reexport */ BounceOutDown),
  BounceOutLeft: () => (/* reexport */ BounceOutLeft),
  BounceOutRight: () => (/* reexport */ BounceOutRight),
  BounceOutUp: () => (/* reexport */ BounceOutUp),
  Clock: () => (/* reexport */ AnimatedClock),
  Code: () => (/* reexport */ AnimatedCode),
  ColorSpace: () => (/* reexport */ ColorSpace),
  ComplexAnimationBuilder: () => (/* reexport */ ComplexAnimationBuilder),
  CurvedTransition: () => (/* reexport */ CurvedTransition),
  Easing: () => (/* reexport */ reanimated2_Easing/* Easing */.o),
  EasingNode: () => (/* reexport */ Easing/* default */.Z),
  EntryExitTransition: () => (/* reexport */ EntryExitTransition),
  Extrapolate: () => (/* reexport */ Extrapolate),
  Extrapolation: () => (/* reexport */ Extrapolation),
  FadeIn: () => (/* reexport */ FadeIn),
  FadeInDown: () => (/* reexport */ FadeInDown),
  FadeInLeft: () => (/* reexport */ FadeInLeft),
  FadeInRight: () => (/* reexport */ FadeInRight),
  FadeInUp: () => (/* reexport */ FadeInUp),
  FadeOut: () => (/* reexport */ FadeOut),
  FadeOutDown: () => (/* reexport */ FadeOutDown),
  FadeOutLeft: () => (/* reexport */ FadeOutLeft),
  FadeOutRight: () => (/* reexport */ FadeOutRight),
  FadeOutUp: () => (/* reexport */ FadeOutUp),
  FadingTransition: () => (/* reexport */ FadingTransition),
  FlipInEasyX: () => (/* reexport */ FlipInEasyX),
  FlipInEasyY: () => (/* reexport */ FlipInEasyY),
  FlipInXDown: () => (/* reexport */ FlipInXDown),
  FlipInXUp: () => (/* reexport */ FlipInXUp),
  FlipInYLeft: () => (/* reexport */ FlipInYLeft),
  FlipInYRight: () => (/* reexport */ FlipInYRight),
  FlipOutEasyX: () => (/* reexport */ FlipOutEasyX),
  FlipOutEasyY: () => (/* reexport */ FlipOutEasyY),
  FlipOutXDown: () => (/* reexport */ FlipOutXDown),
  FlipOutXUp: () => (/* reexport */ FlipOutXUp),
  FlipOutYLeft: () => (/* reexport */ FlipOutYLeft),
  FlipOutYRight: () => (/* reexport */ FlipOutYRight),
  JumpingTransition: () => (/* reexport */ JumpingTransition),
  KeyboardState: () => (/* reexport */ KeyboardState),
  Keyframe: () => (/* reexport */ Keyframe),
  Layout: () => (/* reexport */ Layout),
  LightSpeedInLeft: () => (/* reexport */ LightSpeedInLeft),
  LightSpeedInRight: () => (/* reexport */ LightSpeedInRight),
  LightSpeedOutLeft: () => (/* reexport */ LightSpeedOutLeft),
  LightSpeedOutRight: () => (/* reexport */ LightSpeedOutRight),
  LinearTransition: () => (/* reexport */ LinearTransition),
  Node: () => (/* reexport */ core_AnimatedNode/* default */.ZP),
  PinwheelIn: () => (/* reexport */ PinwheelIn),
  PinwheelOut: () => (/* reexport */ PinwheelOut),
  RGBtoHSV: () => (/* reexport */ Colors/* RGBtoHSV */.Ls),
  RollInLeft: () => (/* reexport */ RollInLeft),
  RollInRight: () => (/* reexport */ RollInRight),
  RollOutLeft: () => (/* reexport */ RollOutLeft),
  RollOutRight: () => (/* reexport */ RollOutRight),
  RotateInDownLeft: () => (/* reexport */ RotateInDownLeft),
  RotateInDownRight: () => (/* reexport */ RotateInDownRight),
  RotateInUpLeft: () => (/* reexport */ RotateInUpLeft),
  RotateInUpRight: () => (/* reexport */ RotateInUpRight),
  RotateOutDownLeft: () => (/* reexport */ RotateOutDownLeft),
  RotateOutDownRight: () => (/* reexport */ RotateOutDownRight),
  RotateOutUpLeft: () => (/* reexport */ RotateOutUpLeft),
  RotateOutUpRight: () => (/* reexport */ RotateOutUpRight),
  SVGAdapter: () => (/* reexport */ SVGAdapter),
  SensorType: () => (/* reexport */ SensorType),
  SequencedTransition: () => (/* reexport */ SequencedTransition),
  SlideInDown: () => (/* reexport */ SlideInDown),
  SlideInLeft: () => (/* reexport */ SlideInLeft),
  SlideInRight: () => (/* reexport */ SlideInRight),
  SlideInUp: () => (/* reexport */ SlideInUp),
  SlideOutDown: () => (/* reexport */ SlideOutDown),
  SlideOutLeft: () => (/* reexport */ SlideOutLeft),
  SlideOutRight: () => (/* reexport */ SlideOutRight),
  SlideOutUp: () => (/* reexport */ SlideOutUp),
  SpringUtils: () => (/* reexport */ SpringUtils),
  StretchInX: () => (/* reexport */ StretchInX),
  StretchInY: () => (/* reexport */ StretchInY),
  StretchOutX: () => (/* reexport */ StretchOutX),
  StretchOutY: () => (/* reexport */ StretchOutY),
  TextInputAdapter: () => (/* reexport */ TextInputAdapter),
  Transition: () => (/* reexport */ Transition),
  Transitioning: () => (/* reexport */ Transitioning),
  Value: () => (/* reexport */ AnimatedValue),
  ZoomIn: () => (/* reexport */ ZoomIn),
  ZoomInDown: () => (/* reexport */ ZoomInDown),
  ZoomInEasyDown: () => (/* reexport */ ZoomInEasyDown),
  ZoomInEasyUp: () => (/* reexport */ ZoomInEasyUp),
  ZoomInLeft: () => (/* reexport */ ZoomInLeft),
  ZoomInRight: () => (/* reexport */ ZoomInRight),
  ZoomInRotate: () => (/* reexport */ ZoomInRotate),
  ZoomInUp: () => (/* reexport */ ZoomInUp),
  ZoomOut: () => (/* reexport */ ZoomOut),
  ZoomOutDown: () => (/* reexport */ ZoomOutDown),
  ZoomOutEasyDown: () => (/* reexport */ ZoomOutEasyDown),
  ZoomOutEasyUp: () => (/* reexport */ ZoomOutEasyUp),
  ZoomOutLeft: () => (/* reexport */ ZoomOutLeft),
  ZoomOutRight: () => (/* reexport */ ZoomOutRight),
  ZoomOutRotate: () => (/* reexport */ ZoomOutRotate),
  ZoomOutUp: () => (/* reexport */ ZoomOutUp),
  abs: () => (/* reexport */ operators/* abs */.Wn),
  acc: () => (/* reexport */ acc),
  acos: () => (/* reexport */ operators/* acos */.Kh),
  adapt: () => (/* reexport */ AnimatedBlock/* adapt */.p),
  add: () => (/* reexport */ operators/* add */.IH),
  always: () => (/* reexport */ createAnimatedAlways),
  and: () => (/* reexport */ operators/* and */.xD),
  asin: () => (/* reexport */ operators/* asin */.ZR),
  atan: () => (/* reexport */ operators/* atan */.z4),
  block: () => (/* reexport */ AnimatedBlock/* createAnimatedBlock */.F),
  blue: () => (/* reexport */ Colors/* blue */.iN),
  call: () => (/* reexport */ createAnimatedCall),
  cancelAnimation: () => (/* reexport */ util/* cancelAnimation */.RE),
  ceil: () => (/* reexport */ operators/* ceil */.mD),
  checkPluginState: () => (/* reexport */ core/* checkPluginState */.rh),
  clockRunning: () => (/* reexport */ createAnimatedClockTest),
  color: () => (/* reexport */ color),
  combineTransition: () => (/* reexport */ combineTransition),
  concat: () => (/* reexport */ createAnimatedConcat),
  cond: () => (/* reexport */ AnimatedCond/* createAnimatedCond */.d),
  configureProps: () => (/* reexport */ core/* configureProps */.RR),
  convertToRGBA: () => (/* reexport */ Colors/* convertToRGBA */._k),
  cos: () => (/* reexport */ operators/* cos */.mC),
  createAnimatedPropAdapter: () => (/* reexport */ createAnimatedPropAdapter),
  createTransitioningComponent: () => (/* reexport */ createTransitioningComponent),
  debug: () => (/* reexport */ createAnimatedDebug),
  decay: () => (/* reexport */ decayWrapper),
  "default": () => (/* binding */ lib),
  defineAnimation: () => (/* reexport */ util/* defineAnimation */.oF),
  defined: () => (/* reexport */ operators/* defined */.ri),
  diff: () => (/* reexport */ diff),
  diffClamp: () => (/* reexport */ diffClamp),
  divide: () => (/* reexport */ operators/* divide */.cs),
  enableLayoutAnimations: () => (/* reexport */ core/* enableLayoutAnimations */.HD),
  eq: () => (/* reexport */ operators.eq),
  event: () => (/* reexport */ createAnimatedEvent),
  exp: () => (/* reexport */ operators/* exp */.Qq),
  floor: () => (/* reexport */ operators/* floor */.GW),
  getRelativeCoords: () => (/* reexport */ getRelativeCoords),
  getTag: () => (/* reexport */ getTag),
  getTimestamp: () => (/* reexport */ core/* getTimestamp */.u3),
  getViewProp: () => (/* reexport */ core/* getViewProp */.UE),
  greaterOrEq: () => (/* reexport */ operators/* greaterOrEq */.l7),
  greaterThan: () => (/* reexport */ operators/* greaterThan */.tS),
  green: () => (/* reexport */ Colors/* green */.ek),
  hsvToColor: () => (/* reexport */ Colors/* hsvToColor */.De),
  initialUpdaterRun: () => (/* reexport */ util/* initialUpdaterRun */.AX),
  interpolate: () => (/* reexport */ interpolation_interpolate),
  interpolateColor: () => (/* reexport */ interpolateColor),
  interpolateColors: () => (/* reexport */ interpolateColors),
  interpolateNode: () => (/* reexport */ interpolate),
  interpolateSharableColor: () => (/* reexport */ interpolateSharableColor),
  isColor: () => (/* reexport */ Colors/* isColor */.D5),
  isConfigured: () => (/* reexport */ core/* isConfigured */.lF),
  isConfiguredCheck: () => (/* reexport */ core/* isConfiguredCheck */.N5),
  jestResetJsReanimatedModule: () => (/* reexport */ core/* jestResetJsReanimatedModule */.z7),
  lessOrEq: () => (/* reexport */ operators/* lessOrEq */.w5),
  lessThan: () => (/* reexport */ operators/* lessThan */.Qj),
  log: () => (/* reexport */ operators/* log */.cM),
  makeMutable: () => (/* reexport */ core/* makeMutable */.vG),
  makeRemote: () => (/* reexport */ core/* makeRemote */.I1),
  makeShareable: () => (/* reexport */ core/* makeShareable */.Uv),
  max: () => (/* reexport */ operators/* max */.Fp),
  measure: () => (/* reexport */ measure),
  min: () => (/* reexport */ operators/* min */.VV),
  modulo: () => (/* reexport */ operators/* modulo */.$W),
  multiply: () => (/* reexport */ operators/* multiply */.Jp),
  neq: () => (/* reexport */ operators/* neq */.uH),
  not: () => (/* reexport */ operators/* not */.ff),
  onChange: () => (/* reexport */ onChange),
  opacity: () => (/* reexport */ Colors/* opacity */.Oh),
  or: () => (/* reexport */ operators.or),
  pow: () => (/* reexport */ operators/* pow */.sQ),
  proc: () => (/* reexport */ createAnimatedFunction),
  processColor: () => (/* reexport */ Colors/* processColor */.aL),
  processColorInitially: () => (/* reexport */ Colors/* processColorInitially */.gv),
  red: () => (/* reexport */ Colors/* red */.Q6),
  requestFrame: () => (/* reexport */ core/* requestFrame */.pT),
  rgbaArrayToRGBAColor: () => (/* reexport */ Colors/* rgbaArrayToRGBAColor */.GM),
  rgbaColor: () => (/* reexport */ Colors/* rgbaColor */.qX),
  round: () => (/* reexport */ operators/* round */.NM),
  runOnJS: () => (/* reexport */ core/* runOnJS */.tC),
  runOnUI: () => (/* reexport */ core/* runOnUI */.m_),
  scrollTo: () => (/* reexport */ scrollTo),
  set: () => (/* reexport */ createAnimatedSet),
  setGestureState: () => (/* reexport */ setGestureState),
  sin: () => (/* reexport */ operators/* sin */.O$),
  spring: () => (/* reexport */ springWrapper),
  sqrt: () => (/* reexport */ operators/* sqrt */._b),
  startClock: () => (/* reexport */ createAnimatedStartClock),
  startMapper: () => (/* reexport */ core/* startMapper */.Rn),
  stopClock: () => (/* reexport */ createAnimatedStopClock),
  stopMapper: () => (/* reexport */ core/* stopMapper */.BV),
  sub: () => (/* reexport */ operators/* sub */.lu),
  tan: () => (/* reexport */ operators/* tan */.OR),
  timing: () => (/* reexport */ timingWrapper),
  toGammaSpace: () => (/* reexport */ Colors/* toGammaSpace */.o7),
  toLinearSpace: () => (/* reexport */ Colors/* toLinearSpace */.YU),
  useAnimatedGestureHandler: () => (/* reexport */ useAnimatedGestureHandler),
  useAnimatedKeyboard: () => (/* reexport */ useAnimatedKeyboard),
  useAnimatedProps: () => (/* reexport */ useAnimatedProps),
  useAnimatedReaction: () => (/* reexport */ useAnimatedReaction),
  useAnimatedRef: () => (/* reexport */ useAnimatedRef),
  useAnimatedScrollHandler: () => (/* reexport */ useAnimatedScrollHandler),
  useAnimatedSensor: () => (/* reexport */ useAnimatedSensor),
  useAnimatedStyle: () => (/* reexport */ useAnimatedStyle/* useAnimatedStyle */.l),
  useCode: () => (/* reexport */ useCode),
  useDerivedValue: () => (/* reexport */ useDerivedValue),
  useEvent: () => (/* reexport */ utils/* useEvent */.zX),
  useFrameCallback: () => (/* reexport */ useFrameCallback),
  useHandler: () => (/* reexport */ utils/* useHandler */.Ak),
  useInterpolateConfig: () => (/* reexport */ useInterpolateConfig),
  useScrollViewOffset: () => (/* reexport */ useScrollViewOffset),
  useSharedValue: () => (/* reexport */ useSharedValue/* useSharedValue */.y),
  useValue: () => (/* reexport */ useValue),
  useWorkletCallback: () => (/* reexport */ useWorkletCallback),
  withDecay: () => (/* reexport */ withDecay),
  withDelay: () => (/* reexport */ withDelay),
  withRepeat: () => (/* reexport */ withRepeat),
  withSequence: () => (/* reexport */ withSequence),
  withSpring: () => (/* reexport */ withSpring),
  withStyleAnimation: () => (/* reexport */ withStyleAnimation),
  withTiming: () => (/* reexport */ animation_timing/* withTiming */.j)
});

// NAMESPACE OBJECT: ./node_modules/react-native-reanimated/lib/Animated.js
var Animated_namespaceObject = {};
__webpack_require__.r(Animated_namespaceObject);
__webpack_require__.d(Animated_namespaceObject, {
  Clock: () => (AnimatedClock),
  Code: () => (AnimatedCode),
  EasingNode: () => (Easing/* default */.Z),
  Extrapolate: () => (Extrapolate),
  FlatList: () => (FlatList),
  Image: () => (Image),
  Node: () => (core_AnimatedNode/* default */.ZP),
  ScrollView: () => (ScrollView),
  SpringUtils: () => (SpringUtils),
  Text: () => (Text),
  Transition: () => (Transition),
  Transitioning: () => (Transitioning),
  Value: () => (AnimatedValue),
  View: () => (View),
  abs: () => (operators/* abs */.Wn),
  acc: () => (acc),
  acos: () => (operators/* acos */.Kh),
  adapt: () => (AnimatedBlock/* adapt */.p),
  add: () => (operators/* add */.IH),
  addWhitelistedNativeProps: () => (addWhitelistedNativeProps),
  addWhitelistedUIProps: () => (addWhitelistedUIProps),
  always: () => (createAnimatedAlways),
  and: () => (operators/* and */.xD),
  asin: () => (operators/* asin */.ZR),
  atan: () => (operators/* atan */.z4),
  block: () => (AnimatedBlock/* createAnimatedBlock */.F),
  call: () => (createAnimatedCall),
  ceil: () => (operators/* ceil */.mD),
  clockRunning: () => (createAnimatedClockTest),
  color: () => (color),
  concat: () => (createAnimatedConcat),
  cond: () => (AnimatedCond/* createAnimatedCond */.d),
  cos: () => (operators/* cos */.mC),
  createAnimatedComponent: () => (createAnimatedComponent),
  createTransitioningComponent: () => (createTransitioningComponent),
  debug: () => (createAnimatedDebug),
  decay: () => (decayWrapper),
  defined: () => (operators/* defined */.ri),
  diff: () => (diff),
  diffClamp: () => (diffClamp),
  divide: () => (operators/* divide */.cs),
  eq: () => (operators.eq),
  event: () => (createAnimatedEvent),
  exp: () => (operators/* exp */.Qq),
  floor: () => (operators/* floor */.GW),
  greaterOrEq: () => (operators/* greaterOrEq */.l7),
  greaterThan: () => (operators/* greaterThan */.tS),
  interpolateColors: () => (interpolateColors),
  interpolateNode: () => (interpolate),
  lessOrEq: () => (operators/* lessOrEq */.w5),
  lessThan: () => (operators/* lessThan */.Qj),
  log: () => (operators/* log */.cM),
  max: () => (operators/* max */.Fp),
  min: () => (operators/* min */.VV),
  modulo: () => (operators/* modulo */.$W),
  multiply: () => (operators/* multiply */.Jp),
  neq: () => (operators/* neq */.uH),
  not: () => (operators/* not */.ff),
  onChange: () => (onChange),
  or: () => (operators.or),
  pow: () => (operators/* pow */.sQ),
  proc: () => (createAnimatedFunction),
  round: () => (operators/* round */.NM),
  set: () => (createAnimatedSet),
  sin: () => (operators/* sin */.O$),
  spring: () => (springWrapper),
  sqrt: () => (operators/* sqrt */._b),
  startClock: () => (createAnimatedStartClock),
  stopClock: () => (createAnimatedStopClock),
  sub: () => (operators/* sub */.lu),
  tan: () => (operators/* tan */.OR),
  timing: () => (timingWrapper),
  useCode: () => (useCode),
  useValue: () => (useValue)
});

// EXTERNAL MODULE: ./node_modules/react/jsx-runtime.js
var jsx_runtime = __webpack_require__(85893);
// EXTERNAL MODULE: external "react"
var external_react_ = __webpack_require__(16689);
var external_react_default = /*#__PURE__*/__webpack_require__.n(external_react_);
// EXTERNAL MODULE: ./node_modules/react-native-web/dist/cjs/index.js
var cjs = __webpack_require__(83849);
// EXTERNAL MODULE: ./node_modules/react-native-reanimated/lib/ReanimatedModule.js + 1 modules
var ReanimatedModule = __webpack_require__(30665);
;// CONCATENATED MODULE: ./node_modules/react-native-reanimated/lib/ReanimatedEventEmitter.js


/* harmony default export */ const ReanimatedEventEmitter = (new cjs.NativeEventEmitter(ReanimatedModule/* default */.Z));

// EXTERNAL MODULE: ./node_modules/react-native-reanimated/lib/reanimated1/core/AnimatedNode.js
var core_AnimatedNode = __webpack_require__(70009);
// EXTERNAL MODULE: external "invariant"
var external_invariant_ = __webpack_require__(67644);
var external_invariant_default = /*#__PURE__*/__webpack_require__.n(external_invariant_);
// EXTERNAL MODULE: ./node_modules/react-native-reanimated/lib/reanimated1/val.js
var reanimated1_val = __webpack_require__(47599);
// EXTERNAL MODULE: ./node_modules/react-native-reanimated/lib/reanimated1/core/AnimatedBlock.js
var AnimatedBlock = __webpack_require__(48282);
;// CONCATENATED MODULE: ./node_modules/react-native-reanimated/lib/reanimated1/core/AnimatedSet.js




class AnimatedSet extends core_AnimatedNode/* default */.ZP {
    constructor(what, value){
        external_invariant_default()(what instanceof core_AnimatedNode/* default */.ZP, `Reanimated: Animated.set first argument should be of type AnimatedNode but got ${what}`);
        external_invariant_default()(value instanceof core_AnimatedNode/* default */.ZP, `Reanimated: Animated.set second argument should be of type AnimatedNode, String or Number but got ${value}`);
        super({
            type: "set",
            what,
            value
        }, [
            value
        ]);
        external_invariant_default()(!what._constant, "Value to be set cannot be constant");
        this._what = what;
        this._value = value;
    }
    toString() {
        return `AnimatedSet, id: ${this.__nodeID}`;
    }
    __onEvaluate() {
        const newValue = (0,reanimated1_val/* val */.P)(this._value);
        this._what.setValue(newValue);
        return newValue;
    }
}
function createAnimatedSet(what, value) {
    return new AnimatedSet(what, (0,AnimatedBlock/* adapt */.p)(value));
}

// EXTERNAL MODULE: ./node_modules/react-native-reanimated/lib/reanimated1/operators.js + 1 modules
var operators = __webpack_require__(66889);
// EXTERNAL MODULE: ./node_modules/react-native-reanimated/lib/reanimated1/core/AnimatedCond.js
var AnimatedCond = __webpack_require__(14584);
;// CONCATENATED MODULE: ./node_modules/react-native-reanimated/lib/reanimated1/core/AnimatedCallFunc.js




class AnimatedCallFunc extends core_AnimatedNode/* default */.ZP {
    constructor(what, args, params){
        external_invariant_default()(what instanceof core_AnimatedNode/* default */.ZP, `Reanimated: AnimatedCallFunc 'what' argument should be of type AnimatedNode but got ${what}`);
        external_invariant_default()(args.every((el)=>el instanceof core_AnimatedNode/* default */.ZP), `Reanimated: every AnimatedCallFunc 'args' argument should be of type AnimatedNode but got ${args}`);
        external_invariant_default()(params.every((el)=>el instanceof core_AnimatedNode/* default */.ZP), `Reanimated: every AnimatedCallFunc 'params' argument should be of type AnimatedNode but got ${params}`);
        super({
            type: "callfunc",
            what,
            args,
            params
        }, [
            ...args
        ]);
        this._what = what;
        this._args = args;
        this._params = params;
    }
    toString() {
        return `AnimatedCallFunc, id: ${this.__nodeID}`;
    }
    beginContext() {
        this._previousCallID = (0,core_AnimatedNode/* getCallID */.I)();
        (0,core_AnimatedNode/* setCallID */.$I)((0,core_AnimatedNode/* getCallID */.I)() + "/" + this.__nodeID);
        this._params.forEach((param, index)=>{
            param.beginContext(this._args[index], this._previousCallID);
        });
    }
    endContext() {
        this._params.forEach((param)=>{
            param.endContext();
        });
        (0,core_AnimatedNode/* setCallID */.$I)(this._previousCallID);
    }
    __onEvaluate() {
        this.beginContext();
        const value = (0,reanimated1_val/* val */.P)(this._what);
        this.endContext();
        return value;
    }
}
function createAnimatedCallFunc(proc, args, params) {
    return new AnimatedCallFunc(proc, args.map((p)=>(0,AnimatedBlock/* adapt */.p)(p)), params);
}

// EXTERNAL MODULE: ./node_modules/react-native-reanimated/lib/reanimated1/core/InternalAnimatedValue.js
var InternalAnimatedValue = __webpack_require__(93513);
;// CONCATENATED MODULE: ./node_modules/react-native-reanimated/lib/reanimated1/core/AnimatedClock.js



class AnimatedMainClock extends InternalAnimatedValue/* default */.Z {
    constructor(){
        super({
            type: "MAIN_CLOCK"
        });
        this._runFrame = ()=>{
            this._updateValue(0);
            if (this.__children.length > 0) {
                this._frameCallback = requestAnimationFrame(this._runFrame);
            }
        };
    }
    __onEvaluate() {
        return +new Date();
    }
    __attach() {
        super.__attach();
        if (!this._frameCallback) {
            this._frameCallback = requestAnimationFrame(this._runFrame);
        }
    }
    __detach() {
        if (this._frameCallback) {
            cancelAnimationFrame(this._frameCallback);
            this._frameCallback = null;
        }
        super.__detach();
    }
}
const mainClock = new AnimatedMainClock();
class AnimatedClock extends core_AnimatedNode/* default */.ZP {
    constructor(){
        super({
            type: "clock"
        });
    }
    toString() {
        return `AnimatedClock, id: ${this.__nodeID}`;
    }
    __onEvaluate() {
        return (0,reanimated1_val/* val */.P)(mainClock);
    }
    __attach() {
        super.__attach();
        if (this._started && !this._attached) {
            mainClock.__addChild(this);
        }
        this._attached = true;
    }
    __detach() {
        if (this._started && this._attached) {
            mainClock.__removeChild(this);
        }
        this._attached = false;
        super.__detach();
    }
    start() {
        if (!this._started && this._attached) {
            mainClock.__addChild(this);
        }
        this._started = true;
    }
    stop() {
        if (this._started && this._attached) {
            mainClock.__removeChild(this);
        }
        this._started = false;
    }
    isStarted() {
        return this._started;
    }
}

;// CONCATENATED MODULE: ./node_modules/react-native-reanimated/lib/reanimated1/core/AnimatedParam.js




class AnimatedParam extends core_AnimatedNode/* default */.ZP {
    constructor(){
        super({
            type: "param"
        }, []);
        this.argsStack = [];
        this.__attach();
    }
    beginContext(ref, prevCallID) {
        this._prevCallID = prevCallID;
        this.argsStack.push(ref);
    }
    endContext() {
        this.argsStack.pop();
    }
    _getTopNode() {
        if (this.argsStack.length === 0) throw new Error(`param: Invocation failed because argsStack is empty`);
        const top = this.argsStack[this.argsStack.length - 1];
        return top;
    }
    setValue(value) {
        const top = this._getTopNode();
        if (top.setValue) {
            const callID = (0,core_AnimatedNode/* getCallID */.I)();
            (0,core_AnimatedNode/* setCallID */.$I)(this._prevCallID);
            top.setValue(value);
            (0,core_AnimatedNode/* setCallID */.$I)(callID);
        } else {
            throw new Error(`param: setValue(${value}) failed because the top element has no known method for updating it's current value.`);
        }
    }
    __onEvaluate() {
        const callID = (0,core_AnimatedNode/* getCallID */.I)();
        (0,core_AnimatedNode/* setCallID */.$I)(this._prevCallID);
        const top = this._getTopNode();
        const value = (0,reanimated1_val/* val */.P)(top);
        (0,core_AnimatedNode/* setCallID */.$I)(callID);
        return value;
    }
    start() {
        const node = this._getTopNode();
        external_invariant_default()(node instanceof AnimatedClock || node instanceof AnimatedParam, `param: top node should be of type AnimatedClock but got ${node}`);
        node.start();
    }
    stop() {
        const node = this._getTopNode();
        external_invariant_default()(node instanceof AnimatedClock || node instanceof AnimatedParam, `param: top node should be of type AnimatedClock but got ${node}`);
        node.stop();
    }
    isRunning() {
        const node = this._getTopNode();
        if (node instanceof AnimatedParam) {
            return node.isRunning();
        }
        external_invariant_default()(node instanceof AnimatedClock, `param: top node should be of type AnimatedClock but got ${node}`);
        return node.isStarted();
    }
}
function createAnimatedParam() {
    return new AnimatedParam();
}

;// CONCATENATED MODULE: ./node_modules/react-native-reanimated/lib/reanimated1/core/AnimatedFunction.js





class AnimatedFunction extends core_AnimatedNode/* default */.ZP {
    constructor(what, ...params){
        external_invariant_default()(what instanceof core_AnimatedNode/* default */.ZP, `Reanimated: AnimatedCallFunc 'what' argument should be of type AnimatedNode but got ${what}`);
        super({
            type: "func",
            what
        }, [
            what,
            ...params
        ]);
        this._what = what;
        this.__attach();
    }
    __onEvaluate() {
        return (0,reanimated1_val/* val */.P)(this._what);
    }
    toString() {
        return `AnimatedFunction, id: ${this.__nodeID}`;
    }
}
function createAnimatedFunction(cb) {
    const params = new Array(cb.length);
    for(let i = 0; i < params.length; i++){
        params[i] = createAnimatedParam();
    }
    // eslint-disable-next-line node/no-callback-literal
    const what = cb(...params);
    const func = new AnimatedFunction(what, ...params);
    return (...args)=>{
        if (args.length !== params.length) {
            throw new Error("Parameter mismatch when calling reanimated function. Expected " + params.length + " parameters, got " + args.length + ".");
        }
        return createAnimatedCallFunc(func, args, params);
    };
}

;// CONCATENATED MODULE: ./node_modules/react-native-reanimated/lib/reanimated1/derived/interpolate.js





const interpolateInternalSingleProc = createAnimatedFunction(function(value, inS, inE, outS, outE) {
    const progress = (0,operators/* divide */.cs)((0,operators/* sub */.lu)(value, inS), (0,operators/* sub */.lu)(inE, inS));
    // logic below was made in order to provide a compatibility witn an Animated API
    const resultForNonZeroRange = (0,operators/* add */.IH)(outS, (0,operators/* multiply */.Jp)(progress, (0,operators/* sub */.lu)(outE, outS)));
    const result = (0,AnimatedCond/* createAnimatedCond */.d)((0,operators.eq)(inS, inE), (0,AnimatedCond/* createAnimatedCond */.d)((0,operators/* lessOrEq */.w5)(value, inS), outS, outE), resultForNonZeroRange);
    return result;
});
function interpolateInternalSingle(value, inputRange, outputRange, offset) {
    const inS = inputRange[offset];
    const inE = inputRange[offset + 1];
    const outS = outputRange[offset];
    const outE = outputRange[offset + 1];
    return interpolateInternalSingleProc(value, inS, inE, outS, outE);
}
function interpolateInternal(value, inputRange, outputRange, offset = 0) {
    if (inputRange.length - offset === 2) {
        return interpolateInternalSingle(value, inputRange, outputRange, offset);
    }
    return (0,AnimatedCond/* createAnimatedCond */.d)((0,operators/* lessThan */.Qj)(value, inputRange[offset + 1]), interpolateInternalSingle(value, inputRange, outputRange, offset), interpolateInternal(value, inputRange, outputRange, offset + 1));
}
const Extrapolate = {
    EXTEND: "extend",
    CLAMP: "clamp",
    IDENTITY: "identity"
};
function checkNonDecreasing(name, arr) {
    for(let i = 1; i < arr.length; ++i){
        // We can't validate animated nodes in JS.
        if (arr[i] instanceof core_AnimatedNode/* default */.ZP || arr[i - 1] instanceof core_AnimatedNode/* default */.ZP) continue;
        external_invariant_default()(arr[i] >= arr[i - 1], "%s must be monotonically non-decreasing. (%s)", name, arr);
    }
}
function checkMinElements(name, arr) {
    external_invariant_default()(arr.length >= 2, "%s must have at least 2 elements. (%s)", name, arr);
}
function checkValidNumbers(name, arr) {
    for(let i = 0; i < arr.length; i++){
        // We can't validate animated nodes in JS.
        if (arr[i] instanceof core_AnimatedNode/* default */.ZP || typeof arr[i] !== "number") continue;
        external_invariant_default()(Number.isFinite(arr[i]), "%s cannot include %s. (%s)", name, arr[i], arr);
    }
}
function convertToRadians(outputRange) {
    for (const [i, value] of outputRange.entries()){
        if (typeof value === "string" && value.endsWith("deg")) {
            outputRange[i] = parseFloat(value) * (Math.PI / 180);
        } else if (typeof value === "string" && value.endsWith("rad")) {
            outputRange[i] = parseFloat(value);
        }
    }
}
function interpolate(value, config) {
    const { inputRange, outputRange, extrapolate = Extrapolate.EXTEND, extrapolateLeft, extrapolateRight } = config;
    checkMinElements("inputRange", inputRange);
    checkValidNumbers("inputRange", inputRange);
    checkMinElements("outputRange", outputRange);
    checkValidNumbers("outputRange", outputRange);
    checkNonDecreasing("inputRange", inputRange);
    external_invariant_default()(inputRange.length === outputRange.length, "inputRange and outputRange must be the same length.");
    convertToRadians(outputRange);
    const left = extrapolateLeft || extrapolate;
    const right = extrapolateRight || extrapolate;
    let output = interpolateInternal(value, inputRange, outputRange);
    if (left === Extrapolate.CLAMP) {
        output = (0,AnimatedCond/* createAnimatedCond */.d)((0,operators/* lessThan */.Qj)(value, inputRange[0]), outputRange[0], output);
    } else if (left === Extrapolate.IDENTITY) {
        output = (0,AnimatedCond/* createAnimatedCond */.d)((0,operators/* lessThan */.Qj)(value, inputRange[0]), value, output);
    }
    if (right === Extrapolate.CLAMP) {
        output = (0,AnimatedCond/* createAnimatedCond */.d)((0,operators/* greaterThan */.tS)(value, inputRange[inputRange.length - 1]), outputRange[outputRange.length - 1], output);
    } else if (right === Extrapolate.IDENTITY) {
        output = (0,AnimatedCond/* createAnimatedCond */.d)((0,operators/* greaterThan */.tS)(value, inputRange[inputRange.length - 1]), value, output);
    }
    return output;
}

;// CONCATENATED MODULE: ./node_modules/react-native-reanimated/lib/reanimated1/core/AnimatedCall.js




const NODE_MAPPING = new Map();
function listener(data) {
    const node = NODE_MAPPING.get(data.id);
    node && node._callback(data.args);
}
class AnimatedCall extends core_AnimatedNode/* default */.ZP {
    constructor(args, jsFunction){
        external_invariant_default()(args.every((el)=>el instanceof core_AnimatedNode/* default */.ZP), `Reanimated: Animated.call node args should be an array with elements of type AnimatedNode. One or more of them are not AnimatedNodes`);
        super({
            type: "call",
            input: args
        }, args);
        this._callback = jsFunction;
        this._args = args;
    }
    toString() {
        return `AnimatedCall, id: ${this.__nodeID}`;
    }
    __attach() {
        super.__attach();
        NODE_MAPPING.set(this.__nodeID, this);
        if (NODE_MAPPING.size === 1) {
            ReanimatedEventEmitter.addListener("onReanimatedCall", listener);
        }
    }
    __detach() {
        NODE_MAPPING.delete(this.__nodeID);
        if (NODE_MAPPING.size === 0) {
            ReanimatedEventEmitter.removeAllListeners("onReanimatedCall");
        }
        super.__detach();
    }
    __onEvaluate() {
        this._callback(this._args.map(reanimated1_val/* val */.P));
        return 0;
    }
}
function createAnimatedCall(args, func) {
    return new AnimatedCall(args, func);
}

;// CONCATENATED MODULE: ./node_modules/react-native-reanimated/lib/reanimated1/core/AnimatedAlways.js



class AnimatedAlways extends core_AnimatedNode/* default */.ZP {
    constructor(what){
        external_invariant_default()(what instanceof core_AnimatedNode/* default */.ZP, `Reanimated: Animated.always node argument should be of type AnimatedNode but got ${what}`);
        super({
            type: "always",
            what
        }, [
            what
        ]);
        this._what = what;
    }
    toString() {
        return `AnimatedAlways, id: ${this.__nodeID}`;
    }
    update() {
        this.__getValue();
    }
    __onEvaluate() {
        (0,reanimated1_val/* val */.P)(this._what);
        return 0;
    }
}
function createAnimatedAlways(item) {
    return new AnimatedAlways(item);
}

;// CONCATENATED MODULE: ./node_modules/react-native-reanimated/lib/reanimated1/derived/evaluateOnce.js





/**
 * evaluate given node and notify children
 * @param node - node to be evaluated
 * @param input - nodes (or one node) representing values which states input for node.
 * @param callback - after callback
 */ function evaluateOnce(node, input = [], callback) {
    if (!Array.isArray(input)) {
        input = [
            input
        ];
    }
    const done = new InternalAnimatedValue/* default */.Z(0);
    const evalNode = (0,AnimatedCond/* createAnimatedCond */.d)(done, 0, createAnimatedCall([
        node,
        createAnimatedSet(done, 1)
    ], ()=>{
        callback && callback();
        for(let i = 0; i < input.length; i++){
            input[i].__removeChild(alwaysNode);
            alwaysNode.__detach();
        }
    }));
    const alwaysNode = createAnimatedAlways(evalNode);
    for(let i = 0; i < input.length; i++){
        input[i].__addChild(alwaysNode);
        alwaysNode.__attach();
    }
}

;// CONCATENATED MODULE: ./node_modules/react-native-reanimated/lib/reanimated1/core/AnimatedValue.js







// Animated value wrapped with extra methods for omit cycle of dependencies
class AnimatedValue extends InternalAnimatedValue/* default */.Z {
    setValue(value) {
        this.__detachAnimation(this._animation);
        if (cjs.Platform.OS === "web" || cjs.Platform.OS === "windows" || cjs.Platform.OS === "macos") {
            this._updateValue((0,reanimated1_val/* val */.P)(value));
        } else {
            if (ReanimatedModule/* default */.Z.setValue && typeof value === "number") {
                // FIXME Remove it after some time
                // For OTA-safety
                // FIXME handle setting value with a node
                ReanimatedModule/* default */.Z.setValue(this.__nodeID, value);
            } else {
                evaluateOnce(createAnimatedSet(this, value), this);
            }
        }
    }
    toString() {
        return `AnimatedValue, id: ${this.__nodeID}`;
    }
    interpolate(config) {
        return interpolate(this, config);
    }
}

;// CONCATENATED MODULE: ./node_modules/react-native-reanimated/lib/reanimated1/core/createEventObjectProxyPolyfill.js
// JSC on Android and iOS 8 & 9 does not support proxies.
// The below workaround provides a proxy-like functionality for event data by
// creating an object which contains predefined fields for the most commonly
// used event attributes. If your app uses even attribute which is not listed
// here please submit a PR to add that and we will merge it right away
function createEventObjectProxyPolyfill() {
    const nodesMap = {
        // Gesture handlers-related event
        translationX: {},
        translationY: {},
        state: {},
        oldState: {},
        absoluteX: {},
        absoluteY: {},
        x: {},
        y: {},
        velocityX: {},
        velocityY: {},
        scale: {},
        focalX: {},
        focalY: {},
        rotation: {},
        anchorX: {},
        anchorY: {},
        velocity: {},
        numberOfPointers: {},
        // onLayour-related event
        layout: {
            x: {},
            y: {},
            width: {},
            height: {}
        },
        // ScrollView event
        contentOffset: {
            y: {},
            x: {}
        },
        layoutMeasurement: {
            width: {},
            height: {}
        },
        contentSize: {
            width: {},
            height: {}
        },
        zoomScale: {},
        contentInset: {
            right: {},
            top: {},
            left: {},
            bottom: {}
        }
    };
    const traverse = (obj)=>{
        for(const key in obj){
            traverse(obj[key]);
            Object.assign(obj[key], {
                __isProxy: true
            });
        }
    };
    traverse(nodesMap);
    return nodesMap;
}

;// CONCATENATED MODULE: ./node_modules/react-native-reanimated/lib/reanimated1/core/AnimatedEvent.js







function sanitizeArgMapping(argMapping) {
    // Find animated values in `argMapping` and create an array representing their
    // key path inside the `nativeEvent` object. Ex.: ['contentOffset', 'x'].
    const eventMappings = [];
    const alwaysNodes = [];
    const getNode = (node)=>{
        if (cjs.Platform.OS === "web" || cjs.Platform.OS === "windows" || cjs.Platform.OS === "macos") {
            return node;
        }
        return node.__nodeID;
    };
    const traverse = (value, path)=>{
        if (value instanceof AnimatedValue) {
            eventMappings.push(path.concat(getNode(value)));
        } else if (typeof value === "object" && value.__val) {
            eventMappings.push(path.concat(getNode(value.__val)));
        } else if (typeof value === "function") {
            const node = new AnimatedValue(0);
            alwaysNodes.push(createAnimatedAlways(value(node)));
            eventMappings.push(path.concat(getNode(node)));
        } else if (typeof value === "object") {
            for(const key in value){
                traverse(value[key], path.concat(key));
            }
        }
    };
    external_invariant_default()(argMapping[0] && argMapping[0].nativeEvent, "Native driven events only support animated values contained inside `nativeEvent`.");
    // Assume that the event containing `nativeEvent` is always the first argument.
    const ev = argMapping[0].nativeEvent;
    if (typeof ev === "object") {
        traverse(ev, []);
    } else if (typeof ev === "function") {
        const proxyHandler = {
            get: function(target, name) {
                if (name === "__isProxy") {
                    return true;
                }
                if (!target[name] && name !== "__val") {
                    target[name] = new Proxy({}, proxyHandler);
                }
                return target[name];
            },
            set: function(target, prop, value) {
                if (prop === "__val") {
                    target[prop] = value;
                    return true;
                }
                return false;
            }
        };
        const proxy = typeof Proxy === "function" ? new Proxy({}, proxyHandler) : createEventObjectProxyPolyfill();
        alwaysNodes.push(createAnimatedAlways(ev(proxy)));
        traverse(proxy, []);
    }
    return {
        eventMappings,
        alwaysNodes
    };
}
class AnimatedEvent extends core_AnimatedNode/* default */.ZP {
    constructor(argMapping, _config = {}){
        const { eventMappings, alwaysNodes } = sanitizeArgMapping(argMapping);
        super({
            type: "event",
            argMapping: eventMappings
        });
        // The below field is a temporary workaround to make AnimatedEvent object be recognized
        // as Animated.event event callback and therefore filtered out from being send over the
        // bridge which was causing the object to be frozen in JS.
        this.__isNative = true;
        this._alwaysNodes = alwaysNodes;
    }
    toString() {
        return `AnimatedEvent, id: ${this.__nodeID}`;
    }
    attachEvent(viewRef, eventName) {
        for(let i = 0; i < this._alwaysNodes.length; i++){
            this._alwaysNodes[i].__attach();
        }
        this.__attach();
        const viewTag = (0,cjs.findNodeHandle)(viewRef);
        ReanimatedModule/* default */.Z.attachEvent(viewTag, eventName, this.__nodeID);
    }
    __onEvaluate() {
        return 0;
    }
    detachEvent(viewRef, eventName) {
        for(let i = 0; i < this._alwaysNodes.length; i++){
            this._alwaysNodes[i].isNativelyInitialized() && this._alwaysNodes[i].__detach();
        }
        const viewTag = (0,cjs.findNodeHandle)(viewRef);
        ReanimatedModule/* default */.Z.detachEvent(viewTag, eventName, this.__nodeID);
        this.__detach();
    }
}
function createAnimatedEvent(argMapping, config) {
    return new AnimatedEvent(argMapping, config);
}

// EXTERNAL MODULE: external "lodash.isequal"
var external_lodash_isequal_ = __webpack_require__(23676);
var external_lodash_isequal_default = /*#__PURE__*/__webpack_require__.n(external_lodash_isequal_);
;// CONCATENATED MODULE: ./node_modules/react-native-reanimated/lib/reanimated1/core/AnimatedTransform.js


function sanitizeTransform(inputTransform) {
    const outputTransform = [];
    let hasAnimatedTransform = false;
    inputTransform.forEach((transform)=>{
        for(const key in transform){
            const value = transform[key];
            if (value instanceof core_AnimatedNode/* default */.ZP) {
                hasAnimatedTransform = true;
                outputTransform.push({
                    property: key,
                    nodeID: value.__nodeID
                });
            } else {
                outputTransform.push({
                    property: key,
                    value
                });
            }
        }
    });
    return hasAnimatedTransform ? outputTransform : undefined;
}
function extractAnimatedParentNodes(transform) {
    const parents = [];
    transform.forEach((transform)=>{
        for(const key in transform){
            const value = transform[key];
            if (value instanceof core_AnimatedNode/* default */.ZP) {
                parents.push(value);
            }
        }
    });
    return parents;
}
function createOrReuseTransformNode(transform, oldNode) {
    const config = sanitizeTransform(transform);
    if (config === undefined) {
        return undefined;
    }
    if (oldNode && external_lodash_isequal_default()(config, oldNode._config)) {
        return oldNode;
    }
    return new AnimatedTransform(transform, config);
}
class AnimatedTransform extends core_AnimatedNode/* default */.ZP {
    constructor(transform, config){
        super({
            type: "transform",
            transform: config
        }, extractAnimatedParentNodes(transform));
        this._config = config;
        this._transform = transform;
    }
    toString() {
        return `AnimatedTransform, id: ${this.__nodeID}`;
    }
    __onEvaluate() {
        return this._transform.map((transform)=>{
            const result = {};
            for(const key in transform){
                const value = transform[key];
                if (value instanceof core_AnimatedNode/* default */.ZP) {
                    result[key] = value.__getValue();
                }
            }
            return result;
        });
    }
}

;// CONCATENATED MODULE: ./node_modules/react-native-reanimated/lib/reanimated1/core/AnimatedStyle.js




function sanitizeStyle(inputStyle) {
    let style;
    for(const key in inputStyle){
        const value = inputStyle[key];
        if (value instanceof core_AnimatedNode/* default */.ZP) {
            if (style === undefined) {
                style = {};
            }
            style[key] = value.__nodeID;
        }
    }
    return style;
}
function createOrReuseStyleNode(style, oldNode) {
    style = cjs.StyleSheet.flatten(style) || {};
    if (style.transform) {
        const transform = createOrReuseTransformNode(style.transform, oldNode && oldNode._style.transform);
        if (transform) {
            style = {
                ...style,
                transform
            };
        }
    }
    const config = sanitizeStyle(style);
    if (config === undefined) {
        return undefined;
    }
    if (oldNode && external_lodash_isequal_default()(config, oldNode._config)) {
        return oldNode;
    }
    return new AnimatedStyle(style, config);
}
/**
 * AnimatedStyle should never be directly instantiated, use createOrReuseStyleNode
 * in order to make a new instance of this node.
 */ class AnimatedStyle extends core_AnimatedNode/* default */.ZP {
    constructor(style, config){
        super({
            type: "style",
            style: config
        }, Object.values(style));
        this._config = config;
        this._style = style;
    }
    toString() {
        return `AnimatedStyle, id: ${this.__nodeID}`;
    }
    _walkStyleAndGetAnimatedValues(style) {
        const updatedStyle = {};
        for(const key in style){
            const value = style[key];
            if (value instanceof core_AnimatedNode/* default */.ZP) {
                updatedStyle[key] = value.__getValue();
            } else if (value && !Array.isArray(value) && typeof value === "object") {
                // Support animating nested values (for example: shadowOffset.height)
                updatedStyle[key] = this._walkStyleAndGetAnimatedValues(value);
            }
        }
        return updatedStyle;
    }
    __onEvaluate() {
        return this._walkStyleAndGetAnimatedValues(this._style);
    }
}

;// CONCATENATED MODULE: ./node_modules/react-native-reanimated/lib/reanimated1/core/AnimatedProps.js







function sanitizeProps(inputProps) {
    let props;
    for(const key in inputProps){
        const value = inputProps[key];
        if (value instanceof core_AnimatedNode/* default */.ZP && !(value instanceof AnimatedEvent)) {
            if (props === undefined) {
                props = {};
            }
            props[key] = value.__nodeID;
        }
    }
    return props;
}
function createOrReusePropsNode(props, callback, oldNode) {
    if (props.style) {
        const style = createOrReuseStyleNode(props.style, oldNode && oldNode._props.style);
        if (style) {
            props = {
                ...props,
                style
            };
        }
    }
    const config = sanitizeProps(props);
    if (config === undefined) {
        return undefined;
    }
    if (oldNode && external_lodash_isequal_default()(config, oldNode._config)) {
        return oldNode;
    }
    return new AnimatedProps(props, config, callback);
}
class AnimatedProps extends core_AnimatedNode/* default */.ZP {
    constructor(props, config, callback){
        super({
            type: "props",
            props: config
        }, Object.values(props).filter((n)=>!(n instanceof AnimatedEvent)));
        this._config = config;
        this._props = props;
        this._callback = callback;
        this.__attach();
    }
    toString() {
        return `AnimatedProps, id: ${this.__nodeID}`;
    }
    __onEvaluate() {
        const props = {};
        for(const key in this._props){
            const value = this._props[key];
            if (value instanceof core_AnimatedNode/* default */.ZP) {
                props[key] = value.__getValue();
            }
        }
        return props;
    }
    __detach() {
        const nativeViewTag = (0,cjs.findNodeHandle)(this._animatedView);
        external_invariant_default()(nativeViewTag != null, "Unable to locate attached view in the native tree");
        this._disconnectAnimatedView(nativeViewTag);
        super.__detach();
    }
    update() {
        this._callback();
        if (!this._animatedView) {
            return;
        }
        (0,reanimated1_val/* val */.P)(this);
    }
    setNativeView(animatedView) {
        if (this._animatedView === animatedView) {
            return;
        }
        this._animatedView = animatedView;
        const nativeViewTag = (0,cjs.findNodeHandle)(this._animatedView);
        external_invariant_default()(nativeViewTag != null, "Unable to locate attached view in the native tree");
        this._connectAnimatedView(nativeViewTag);
    }
}

// EXTERNAL MODULE: ./node_modules/react-native-reanimated/lib/reanimated2/WorkletEventHandler.js
var WorkletEventHandler = __webpack_require__(95654);
;// CONCATENATED MODULE: ./node_modules/react-native-reanimated/lib/setAndForwardRef.js
/**
 * imported from react-native
 */ function setAndForwardRef({ getForwardedRef, setLocalRef }) {
    return function forwardRef(ref) {
        const forwardedRef = getForwardedRef();
        setLocalRef(ref);
        // Forward to user ref prop (if one has been specified)
        if (typeof forwardedRef === "function") {
            // Handle function-based refs. String-based refs are handled as functions.
            forwardedRef(ref);
        } else if (typeof forwardedRef === "object" && forwardedRef != null) {
            // Handle createRef-based refs
            forwardedRef.current = ref;
        }
    };
}
/* harmony default export */ const lib_setAndForwardRef = (setAndForwardRef);

// EXTERNAL MODULE: ./node_modules/react-native-reanimated/lib/reanimated2/core.js
var core = __webpack_require__(86095);
;// CONCATENATED MODULE: ./node_modules/react-native-reanimated/lib/ConfigHelper.js

/**
 * Styles allowed to be direcly updated in UI thread
 */ let UI_THREAD_PROPS_WHITELIST = {
    opacity: true,
    transform: true,
    /* colors */ backgroundColor: true,
    borderRightColor: true,
    borderBottomColor: true,
    borderColor: true,
    borderEndColor: true,
    borderLeftColor: true,
    borderStartColor: true,
    borderTopColor: true,
    /* ios styles */ shadowOpacity: true,
    shadowRadius: true,
    /* legacy android transform properties */ scaleX: true,
    scaleY: true,
    translateX: true,
    translateY: true
};
/**
 * Whitelist of view props that can be updated in native thread via UIManagerModule
 */ let NATIVE_THREAD_PROPS_WHITELIST = {
    borderBottomWidth: true,
    borderEndWidth: true,
    borderLeftWidth: true,
    borderRightWidth: true,
    borderStartWidth: true,
    borderTopWidth: true,
    borderWidth: true,
    bottom: true,
    flex: true,
    flexGrow: true,
    flexShrink: true,
    height: true,
    left: true,
    margin: true,
    marginBottom: true,
    marginEnd: true,
    marginHorizontal: true,
    marginLeft: true,
    marginRight: true,
    marginStart: true,
    marginTop: true,
    marginVertical: true,
    maxHeight: true,
    maxWidth: true,
    minHeight: true,
    minWidth: true,
    padding: true,
    paddingBottom: true,
    paddingEnd: true,
    paddingHorizontal: true,
    paddingLeft: true,
    paddingRight: true,
    paddingStart: true,
    paddingTop: true,
    paddingVertical: true,
    right: true,
    start: true,
    top: true,
    width: true,
    zIndex: true,
    borderBottomEndRadius: true,
    borderBottomLeftRadius: true,
    borderBottomRightRadius: true,
    borderBottomStartRadius: true,
    borderRadius: true,
    borderTopEndRadius: true,
    borderTopLeftRadius: true,
    borderTopRightRadius: true,
    borderTopStartRadius: true,
    elevation: true,
    fontSize: true,
    lineHeight: true,
    textShadowRadius: true,
    letterSpacing: true,
    /* strings */ display: true,
    backfaceVisibility: true,
    overflow: true,
    resizeMode: true,
    fontStyle: true,
    fontWeight: true,
    textAlign: true,
    textDecorationLine: true,
    fontFamily: true,
    textAlignVertical: true,
    fontVariant: true,
    textDecorationStyle: true,
    textTransform: true,
    writingDirection: true,
    /* text color */ color: true,
    tintColor: true,
    shadowColor: true,
    placeholderTextColor: true
};
function configureProps() {
    (0,core/* configureProps */.RR)(Object.keys(UI_THREAD_PROPS_WHITELIST), Object.keys(NATIVE_THREAD_PROPS_WHITELIST));
}
function addWhitelistedNativeProps(props) {
    const oldSize = Object.keys(NATIVE_THREAD_PROPS_WHITELIST).length;
    NATIVE_THREAD_PROPS_WHITELIST = Object.assign(Object.assign({}, NATIVE_THREAD_PROPS_WHITELIST), props);
    if (oldSize !== Object.keys(NATIVE_THREAD_PROPS_WHITELIST).length) {
        configureProps();
    }
}
function addWhitelistedUIProps(props) {
    const oldSize = Object.keys(UI_THREAD_PROPS_WHITELIST).length;
    UI_THREAD_PROPS_WHITELIST = Object.assign(Object.assign({}, UI_THREAD_PROPS_WHITELIST), props);
    if (oldSize !== Object.keys(UI_THREAD_PROPS_WHITELIST).length) {
        configureProps();
    }
}
const PROCESSED_VIEW_NAMES = new Set();
/**
 * updates UI props whitelist for given view host instance
 * this will work just once for every view name
 */ function adaptViewConfig(viewConfig) {
    const viewName = viewConfig.uiViewClassName;
    const props = viewConfig.validAttributes;
    // update whitelist of UI props for this view name only once
    if (!PROCESSED_VIEW_NAMES.has(viewName)) {
        const propsToAdd = {};
        Object.keys(props).forEach((key)=>{
            // we don't want to add native props as they affect layout
            // we also skip props which repeat here
            if (!(key in NATIVE_THREAD_PROPS_WHITELIST) && !(key in UI_THREAD_PROPS_WHITELIST)) {
                propsToAdd[key] = true;
            }
        });
        addWhitelistedUIProps(propsToAdd);
        PROCESSED_VIEW_NAMES.add(viewName);
    }
}
configureProps();

// EXTERNAL MODULE: ./node_modules/react-native-reanimated/lib/reanimated2/platform-specific/RNRenderer.web.js
var RNRenderer_web = __webpack_require__(32157);
;// CONCATENATED MODULE: ./node_modules/react-native-reanimated/lib/reanimated2/layoutReanimation/defaultAnimations/Default.js
const DefaultLayout = (values)=>{
    "worklet";
    return {
        initialValues: {
            originX: values.targetOriginX,
            originY: values.targetOriginY,
            width: values.targetWidth,
            height: values.targetHeight
        },
        animations: {}
    };
};
const DefaultEntering = (values)=>{
    "worklet";
    return {
        initialValues: {
            originX: values.targetOriginX,
            originY: values.targetOriginY,
            width: values.targetWidth,
            height: values.targetHeight
        },
        animations: {}
    };
};
const DefaultExiting = (values)=>{
    "worklet";
    return {
        initialValues: {
            originX: values.currentOriginX,
            originY: values.currentOriginY,
            width: values.currentWidth,
            height: values.currentHeight
        },
        animations: {}
    };
};

// EXTERNAL MODULE: ./node_modules/react-native-reanimated/lib/reanimated2/PlatformChecker.js
var PlatformChecker = __webpack_require__(39335);
// EXTERNAL MODULE: ./node_modules/react-native-reanimated/lib/reanimated2/animation/util.js
var util = __webpack_require__(3138);
;// CONCATENATED MODULE: ./node_modules/react-native-reanimated/lib/createAnimatedComponent.js




// @ts-ignore JS file

// @ts-ignore JS file

// @ts-ignore JS file

// @ts-ignore JS file











const createAnimatedComponent_NODE_MAPPING = new Map();
function createAnimatedComponent_listener(data) {
    const component = createAnimatedComponent_NODE_MAPPING.get(data.viewTag);
    component && component._updateFromNative(data.props);
}
function dummyListener() {
// empty listener we use to assign to listener properties for which animated
// event is used.
}
function hasAnimatedNodes(value) {
    if (value instanceof core_AnimatedNode/* default */.ZP) {
        return true;
    }
    if (Array.isArray(value)) {
        return value.some((item)=>hasAnimatedNodes(item));
    }
    if (value && typeof value === "object") {
        return Object.keys(value).some((key)=>hasAnimatedNodes(value[key]));
    }
    return false;
}
function flattenArray(array) {
    if (!Array.isArray(array)) {
        return [
            array
        ];
    }
    const resultArr = [];
    const _flattenArray = (arr)=>{
        arr.forEach((item)=>{
            if (Array.isArray(item)) {
                _flattenArray(item);
            } else {
                resultArr.push(item);
            }
        });
    };
    _flattenArray(array);
    return resultArr;
}
function onlyAnimatedStyles(styles) {
    return styles.filter((style)=>style === null || style === void 0 ? void 0 : style.viewDescriptors);
}
function isSameAnimatedStyle(style1, style2) {
    // We cannot use equality check to compare useAnimatedStyle outputs directly.
    // Instead, we can compare its viewsRefs.
    return (style1 === null || style1 === void 0 ? void 0 : style1.viewsRef) === (style2 === null || style2 === void 0 ? void 0 : style2.viewsRef);
}
const isSameAnimatedProps = isSameAnimatedStyle;
const has = (key, x)=>{
    if (typeof x === "function" || typeof x === "object") {
        if (x === null || x === undefined) {
            return false;
        } else {
            return key in x;
        }
    }
    return false;
};
function createAnimatedComponent(Component, options) {
    external_invariant_default()(typeof Component !== "function" || Component.prototype && Component.prototype.isReactComponent, "`createAnimatedComponent` does not support stateless functional components; " + "use a class component instead.");
    class AnimatedComponent extends (external_react_default()).Component {
        constructor(props){
            super(props);
            this._invokeAnimatedPropsCallbackOnMount = false;
            this._styles = null;
            this._viewTag = -1;
            this._isFirstRender = true;
            this.animatedStyle = {
                value: {}
            };
            this.initialStyle = {};
            this._component = null;
            // The system is best designed when setNativeProps is implemented. It is
            // able to avoid re-rendering and directly set the attributes that changed.
            // However, setNativeProps can only be implemented on native components
            // If you want to animate a composite component, you need to re-render it.
            // In this case, we have a fallback that uses forceUpdate.
            this._animatedPropsCallback = ()=>{
                if (this._component == null) {
                    // AnimatedProps is created in will-mount because it's used in render.
                    // But this callback may be invoked before mount in async mode,
                    // In which case we should defer the setNativeProps() call.
                    // React may throw away uncommitted work in async mode,
                    // So a deferred call won't always be invoked.
                    this._invokeAnimatedPropsCallbackOnMount = true;
                } else if (typeof this._component.setNativeProps !== "function") {
                    this.forceUpdate();
                } else {
                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                    this._component.setNativeProps(this._propsAnimated.__getValue());
                }
            };
            this._setComponentRef = lib_setAndForwardRef({
                getForwardedRef: ()=>this.props.forwardedRef,
                setLocalRef: (ref)=>{
                    // TODO update config
                    const tag = (0,cjs.findNodeHandle)(ref);
                    if (!(0,PlatformChecker/* shouldBeUseWeb */.Wr)() && (this.props.layout || this.props.entering || this.props.exiting) && tag != null) {
                        (0,core/* enableLayoutAnimations */.HD)(true, false);
                        let layout = this.props.layout ? this.props.layout : DefaultLayout;
                        let entering = this.props.entering ? this.props.entering : DefaultEntering;
                        let exiting = this.props.exiting ? this.props.exiting : DefaultExiting;
                        if (has("build", layout)) {
                            layout = layout.build();
                        }
                        if (has("build", entering)) {
                            entering = entering.build();
                        }
                        if (has("build", exiting)) {
                            exiting = exiting.build();
                        }
                        const config = {
                            layout,
                            entering,
                            exiting,
                            sv: this.sv
                        };
                        (0,core/* runOnUI */.m_)(()=>{
                            "worklet";
                            global.LayoutAnimationRepository.registerConfig(tag, config);
                        })();
                    }
                    if (ref !== this._component) {
                        this._component = ref;
                    }
                }
            });
            this._attachProps(this.props);
            if ((0,PlatformChecker/* isJest */.V5)()) {
                this.animatedStyle = {
                    value: {}
                };
            }
            this.sv = (0,core/* makeMutable */.vG)({});
        }
        componentWillUnmount() {
            this._detachPropUpdater();
            this._propsAnimated && this._propsAnimated.__detach();
            this._detachNativeEvents();
            this._detachStyles();
            this.sv = null;
        }
        componentDidMount() {
            if (this._invokeAnimatedPropsCallbackOnMount) {
                this._invokeAnimatedPropsCallbackOnMount = false;
                this._animatedPropsCallback();
            }
            this._propsAnimated && // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            this._propsAnimated.setNativeView(this._component);
            this._attachNativeEvents();
            this._attachPropUpdater();
            this._attachAnimatedStyles();
        }
        _getEventViewRef() {
            var _a;
            // Make sure to get the scrollable node for components that implement
            // `ScrollResponder.Mixin`.
            return ((_a = this._component) === null || _a === void 0 ? void 0 : _a.getScrollableNode) ? this._component.getScrollableNode() : this._component;
        }
        _attachNativeEvents() {
            const node = this._getEventViewRef();
            let viewTag = (0,cjs.findNodeHandle)((options === null || options === void 0 ? void 0 : options.setNativeProps) ? this : node);
            const componentName = Component.displayName || Component.name;
            if ((componentName === null || componentName === void 0 ? void 0 : componentName.endsWith("FlashList")) && this._component) {
                // @ts-ignore it's FlashList specific: https://github.com/Shopify/flash-list/blob/218f314e63806b4fe926741ef73f8b9cd6ebc7eb/src/FlashList.tsx#L815
                viewTag = (0,cjs.findNodeHandle)(this._component.getScrollableNode());
            }
            for(const key in this.props){
                const prop = this.props[key];
                if (prop instanceof AnimatedEvent) {
                    prop.attachEvent(node, key);
                } else if (has("current", prop) && prop.current instanceof WorkletEventHandler/* default */.Z) {
                    prop.current.registerForEvents(viewTag, key);
                }
            }
        }
        _detachNativeEvents() {
            const node = this._getEventViewRef();
            for(const key in this.props){
                const prop = this.props[key];
                if (prop instanceof AnimatedEvent) {
                    prop.detachEvent(node, key);
                } else if (has("current", prop) && prop.current instanceof WorkletEventHandler/* default */.Z) {
                    prop.current.unregisterFromEvents();
                }
            }
        }
        _detachStyles() {
            var _a;
            if (cjs.Platform.OS === "web" && this._styles !== null) {
                for (const style of this._styles){
                    if (style === null || style === void 0 ? void 0 : style.viewsRef) {
                        style.viewsRef.remove(this);
                    }
                }
            } else if (this._viewTag !== -1 && this._styles !== null) {
                for (const style of this._styles){
                    style.viewDescriptors.remove(this._viewTag);
                }
                if ((_a = this.props.animatedProps) === null || _a === void 0 ? void 0 : _a.viewDescriptors) {
                    this.props.animatedProps.viewDescriptors.remove(this._viewTag);
                }
            }
        }
        _reattachNativeEvents(prevProps) {
            const node = this._getEventViewRef();
            const attached = new Set();
            const nextEvts = new Set();
            let viewTag;
            for(const key in this.props){
                const prop = this.props[key];
                if (prop instanceof AnimatedEvent) {
                    nextEvts.add(prop.__nodeID);
                } else if (has("current", prop) && prop.current instanceof WorkletEventHandler/* default */.Z) {
                    if (viewTag === undefined) {
                        viewTag = prop.current.viewTag;
                    }
                }
            }
            for(const key in prevProps){
                const prop = this.props[key];
                if (prop instanceof AnimatedEvent) {
                    if (!nextEvts.has(prop.__nodeID)) {
                        // event was in prev props but not in current props, we detach
                        prop.detachEvent(node, key);
                    } else {
                        // event was in prev and is still in current props
                        attached.add(prop.__nodeID);
                    }
                } else if (has("current", prop) && prop.current instanceof WorkletEventHandler/* default */.Z && prop.current.reattachNeeded) {
                    prop.current.unregisterFromEvents();
                }
            }
            for(const key in this.props){
                const prop = this.props[key];
                if (prop instanceof AnimatedEvent && !attached.has(prop.__nodeID)) {
                    // not yet attached
                    prop.attachEvent(node, key);
                } else if (has("current", prop) && prop.current instanceof WorkletEventHandler/* default */.Z && prop.current.reattachNeeded) {
                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                    prop.current.registerForEvents(viewTag, key);
                    prop.current.reattachNeeded = false;
                }
            }
        }
        _attachProps(nextProps) {
            const oldPropsAnimated = this._propsAnimated;
            this._propsAnimated = createOrReusePropsNode(nextProps, this._animatedPropsCallback, oldPropsAnimated);
            // If prop node has been reused we don't need to call into "__detach"
            if (oldPropsAnimated !== this._propsAnimated) {
                // When you call detach, it removes the element from the parent list
                // of children. If it goes to 0, then the parent also detaches itself
                // and so on.
                // An optimization is to attach the new elements and THEN detach the old
                // ones instead of detaching and THEN attaching.
                // This way the intermediate state isn't to go to 0 and trigger
                // this expensive recursive detaching to then re-attach everything on
                // the very next operation.
                oldPropsAnimated && oldPropsAnimated.__detach();
            }
        }
        _updateFromNative(props) {
            var _a, _b;
            if (options === null || options === void 0 ? void 0 : options.setNativeProps) {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                options.setNativeProps(this._component, props);
            } else {
                // eslint-disable-next-line no-unused-expressions
                (_b = (_a = this._component) === null || _a === void 0 ? void 0 : _a.setNativeProps) === null || _b === void 0 ? void 0 : _b.call(_a, props);
            }
        }
        _attachPropUpdater() {
            const viewTag = (0,cjs.findNodeHandle)(this);
            createAnimatedComponent_NODE_MAPPING.set(viewTag, this);
            if (createAnimatedComponent_NODE_MAPPING.size === 1) {
                ReanimatedEventEmitter.addListener("onReanimatedPropsChange", createAnimatedComponent_listener);
            }
        }
        _attachAnimatedStyles() {
            var _a, _b, _c;
            const styles = this.props.style ? onlyAnimatedStyles(flattenArray(this.props.style)) : [];
            const prevStyles = this._styles;
            this._styles = styles;
            const prevAnimatedProps = this._animatedProps;
            this._animatedProps = this.props.animatedProps;
            let viewTag;
            let viewName;
            if (cjs.Platform.OS === "web") {
                viewTag = (0,cjs.findNodeHandle)(this);
                viewName = null;
            } else {
                // hostInstance can be null for a component that doesn't render anything (render function returns null). Example: svg Stop: https://github.com/react-native-svg/react-native-svg/blob/develop/src/elements/Stop.tsx
                const hostInstance = RNRenderer_web.RNRenderer.findHostInstance_DEPRECATED(this);
                if (!hostInstance) {
                    throw new Error("Cannot find host instance for this component. Maybe it renders nothing?");
                }
                // we can access view tag in the same way it's accessed here https://github.com/facebook/react/blob/e3f4eb7272d4ca0ee49f27577156b57eeb07cf73/packages/react-native-renderer/src/ReactFabric.js#L146
                viewTag = hostInstance === null || hostInstance === void 0 ? void 0 : hostInstance._nativeTag;
                /**
                 * RN uses viewConfig for components for storing different properties of the component(example: https://github.com/facebook/react-native/blob/master/Libraries/Components/ScrollView/ScrollViewViewConfig.js#L16).
                 * The name we're looking for is in the field named uiViewClassName.
                 */ viewName = (_a = hostInstance === null || hostInstance === void 0 ? void 0 : hostInstance.viewConfig) === null || _a === void 0 ? void 0 : _a.uiViewClassName;
                // update UI props whitelist for this view
                const hasReanimated2Props = ((_b = this.props.animatedProps) === null || _b === void 0 ? void 0 : _b.viewDescriptors) || styles.length;
                if (hasReanimated2Props && (hostInstance === null || hostInstance === void 0 ? void 0 : hostInstance.viewConfig)) {
                    adaptViewConfig(hostInstance.viewConfig);
                }
            }
            this._viewTag = viewTag;
            // remove old styles
            if (prevStyles) {
                // in most of the cases, views have only a single animated style and it remains unchanged
                const hasOneSameStyle = styles.length === 1 && prevStyles.length === 1 && isSameAnimatedStyle(styles[0], prevStyles[0]);
                if (!hasOneSameStyle) {
                    // otherwise, remove each style that is not present in new styles
                    for (const prevStyle of prevStyles){
                        const isPresent = styles.some((style)=>isSameAnimatedStyle(style, prevStyle));
                        if (!isPresent) {
                            prevStyle.viewDescriptors.remove(viewTag);
                        }
                    }
                }
            }
            styles.forEach((style)=>{
                style.viewDescriptors.add({
                    tag: viewTag,
                    name: viewName
                });
                if ((0,PlatformChecker/* isJest */.V5)()) {
                    /**
                     * We need to connect Jest's TestObject instance whose contains just props object
                     * with the updateProps() function where we update the properties of the component.
                     * We can't update props object directly because TestObject contains a copy of props - look at render function:
                     * const props = this._filterNonAnimatedProps(this.props);
                     */ this.animatedStyle.value = Object.assign(Object.assign({}, this.animatedStyle.value), style.initial.value);
                    style.animatedStyle.current = this.animatedStyle;
                }
            });
            // detach old animatedProps
            if (prevAnimatedProps && !isSameAnimatedProps(prevAnimatedProps, this.props.animatedProps)) {
                prevAnimatedProps.viewDescriptors.remove(viewTag);
            }
            // attach animatedProps property
            if ((_c = this.props.animatedProps) === null || _c === void 0 ? void 0 : _c.viewDescriptors) {
                this.props.animatedProps.viewDescriptors.add({
                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                    tag: viewTag,
                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                    name: viewName
                });
            }
        }
        _detachPropUpdater() {
            const viewTag = (0,cjs.findNodeHandle)(this);
            createAnimatedComponent_NODE_MAPPING.delete(viewTag);
            if (createAnimatedComponent_NODE_MAPPING.size === 0) {
                ReanimatedEventEmitter.removeAllListeners("onReanimatedPropsChange");
            }
        }
        componentDidUpdate(prevProps) {
            this._attachProps(this.props);
            this._reattachNativeEvents(prevProps);
            this._propsAnimated && // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            this._propsAnimated.setNativeView(this._component);
            this._attachAnimatedStyles();
        }
        _filterNonAnimatedStyle(inputStyle) {
            const style = {};
            for(const key in inputStyle){
                const value = inputStyle[key];
                if (!hasAnimatedNodes(value)) {
                    style[key] = value;
                } else if (value instanceof AnimatedValue) {
                    // if any style in animated component is set directly to the `Value` we set those styles to the first value of `Value` node in order
                    // to avoid flash of default styles when `Value` is being asynchrounously sent via bridge and initialized in the native side.
                    style[key] = value._startingValue;
                }
            }
            return style;
        }
        _filterNonAnimatedProps(inputProps) {
            const props = {};
            for(const key in inputProps){
                const value = inputProps[key];
                if (key === "style") {
                    const styleProp = inputProps.style;
                    const styles = flattenArray(styleProp !== null && styleProp !== void 0 ? styleProp : []);
                    const processedStyle = styles.map((style)=>{
                        if (style && style.viewDescriptors) {
                            // this is how we recognize styles returned by useAnimatedStyle
                            style.viewsRef.add(this);
                            if (this._isFirstRender) {
                                this.initialStyle = Object.assign(Object.assign({}, style.initial.value), (0,util/* initialUpdaterRun */.AX)(style.initial.updater));
                            }
                            return this.initialStyle;
                        } else {
                            return style;
                        }
                    });
                    props[key] = this._filterNonAnimatedStyle(cjs.StyleSheet.flatten(processedStyle));
                } else if (key === "animatedProps") {
                    const animatedProp = inputProps.animatedProps;
                    if (animatedProp.initial !== undefined) {
                        Object.keys(animatedProp.initial.value).forEach((key)=>{
                            var _a, _b;
                            props[key] = (_a = animatedProp.initial) === null || _a === void 0 ? void 0 : _a.value[key];
                            (_b = animatedProp.viewsRef) === null || _b === void 0 ? void 0 : _b.add(this);
                        });
                    }
                } else if (value instanceof AnimatedEvent) {
                    // we cannot filter out event listeners completely as some components
                    // rely on having a callback registered in order to generate events
                    // alltogether. Therefore we provide a dummy callback here to allow
                    // native event dispatcher to hijack events.
                    props[key] = dummyListener;
                } else if (has("current", value) && value.current instanceof WorkletEventHandler/* default */.Z) {
                    if (value.current.eventNames.length > 0) {
                        value.current.eventNames.forEach((eventName)=>{
                            props[eventName] = has("listeners", value.current) ? value.current.listeners[eventName] : dummyListener;
                        });
                    } else {
                        props[key] = dummyListener;
                    }
                } else if (!(value instanceof core_AnimatedNode/* default */.ZP)) {
                    if (key !== "onGestureHandlerStateChange" || !(0,PlatformChecker/* isChromeDebugger */.f1)()) {
                        props[key] = value;
                    }
                } else if (value instanceof AnimatedValue) {
                    // if any prop in animated component is set directly to the `Value` we set those props to the first value of `Value` node in order
                    // to avoid default values for a short moment when `Value` is being asynchrounously sent via bridge and initialized in the native side.
                    props[key] = value._startingValue;
                }
            }
            return props;
        }
        render() {
            const props = this._filterNonAnimatedProps(this.props);
            if ((0,PlatformChecker/* isJest */.V5)()) {
                props.animatedStyle = this.animatedStyle;
            }
            if (this._isFirstRender) {
                this._isFirstRender = false;
            }
            const platformProps = cjs.Platform.select({
                web: {},
                default: {
                    collapsable: false
                }
            });
            return /*#__PURE__*/ (0,jsx_runtime.jsx)(Component, {
                ...props,
                ref: this._setComponentRef,
                ...platformProps
            });
        }
    }
    AnimatedComponent.displayName = `AnimatedComponent(${Component.displayName || Component.name || "Component"})`;
    return /*#__PURE__*/ external_react_default().forwardRef((props, ref)=>{
        return /*#__PURE__*/ (0,jsx_runtime.jsx)(AnimatedComponent, {
            ...props,
            ...ref === null ? null : {
                forwardedRef: ref
            }
        });
    });
}

;// CONCATENATED MODULE: ./node_modules/react-native-reanimated/lib/reanimated2/component/Text.js


const AnimatedText = createAnimatedComponent(cjs.Text);
/* harmony default export */ const Text = (AnimatedText);

;// CONCATENATED MODULE: ./node_modules/react-native-reanimated/lib/reanimated2/component/View.js


const AnimatedView = createAnimatedComponent(cjs.View);
/* harmony default export */ const View = (AnimatedView);

;// CONCATENATED MODULE: ./node_modules/react-native-reanimated/lib/reanimated2/component/ScrollView.js


const AnimatedScrollView = createAnimatedComponent(cjs.ScrollView);
/* harmony default export */ const ScrollView = (AnimatedScrollView);

;// CONCATENATED MODULE: ./node_modules/react-native-reanimated/lib/reanimated2/component/Image.js


const AnimatedImage = createAnimatedComponent(cjs.Image);
/* harmony default export */ const Image = (AnimatedImage);

;// CONCATENATED MODULE: ./node_modules/react-native-reanimated/lib/reanimated2/component/FlatList.js

var __rest = undefined && undefined.__rest || function(s, e) {
    var t = {};
    for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function") for(var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++){
        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
    }
    return t;
};




const AnimatedFlatList = createAnimatedComponent(cjs.FlatList);
const createCellRenderer = (itemLayoutAnimation)=>{
    const cellRenderer = (props)=>{
        return /*#__PURE__*/ (0,jsx_runtime.jsx)(View, {
            layout: itemLayoutAnimation,
            onLayout: props.onLayout,
            children: props.children
        });
    };
    return cellRenderer;
};
const ReanimatedFlatlist = /*#__PURE__*/ (0,external_react_.forwardRef)((props, ref)=>{
    const { itemLayoutAnimation } = props, restProps = __rest(props, [
        "itemLayoutAnimation"
    ]);
    const cellRenderer = external_react_default().useMemo(()=>createCellRenderer(itemLayoutAnimation), []);
    return /*#__PURE__*/ (0,jsx_runtime.jsx)(AnimatedFlatList, {
        ref: ref,
        ...restProps,
        CellRendererComponent: cellRenderer
    });
});
/* harmony default export */ const FlatList = (ReanimatedFlatlist);

// EXTERNAL MODULE: ./node_modules/react-native-reanimated/lib/reanimated1/Easing.js + 1 modules
var Easing = __webpack_require__(88593);
;// CONCATENATED MODULE: ./node_modules/react-native-reanimated/lib/reanimated1/derived/useCode.js


/**
 * @callback NodeFactory
 * Function to create a node or an array of nodes.
 * @returns {(Node[] | Node | null | undefined | Boolean)}
 */ /**
 * React hook to run a node.
 * @param {NodeFactory} nodeFactory Function to build the node to run.
 * @param dependencies Array of dependencies. Refresh the node on changes.
 */ function useCode(nodeFactory, dependencies) {
    if (!((external_react_default()).useEffect instanceof Function)) return;
    external_react_default().useEffect(()=>{
        // check and correct 1st parameter
        if (!(nodeFactory instanceof Function)) {
            console.warn("useCode() first argument should be a function that returns an animation node.");
            const node = nodeFactory;
            nodeFactory = ()=>node;
        }
        let node = nodeFactory();
        if (node) {
            // allow factory to return array
            if (node instanceof Array) node = (0,AnimatedBlock/* createAnimatedBlock */.F)(node);
            const animatedAlways = createAnimatedAlways(node);
            animatedAlways.__attach();
            // return undo function
            return ()=>animatedAlways.__detach();
        }
    }, dependencies);
}

;// CONCATENATED MODULE: ./node_modules/react-native-reanimated/lib/reanimated1/core/AnimatedCode.js


function assertNodesNotNull(code, children, exec) {
    if (!code) {
        const error = !children ? `Got "${typeof children}" type passed to children` : `Got "${typeof exec}" type passed to exec`;
        throw new Error(`<Animated.Code /> expects the 'exec' prop or children to be an animated node or a function returning an animated node. ${error}`);
    }
}
function Code({ exec, children, dependencies }) {
    const nodes = children || exec;
    let code = null;
    if (nodes instanceof core_AnimatedNode/* default */.ZP) {
        code = ()=>nodes;
    } else if (typeof nodes === "function") {
        code = nodes;
    }
    assertNodesNotNull(code, children, exec);
    useCode(code, dependencies);
    return null;
}
/* harmony default export */ const AnimatedCode = (Code);

;// CONCATENATED MODULE: ./node_modules/react-native-reanimated/lib/reanimated1/animations/decay.js

const VELOCITY_EPS = 5;
function decay(clock, state, config) {
    const lastTime = (0,AnimatedCond/* createAnimatedCond */.d)(state.time, state.time, clock);
    const deltaTime = (0,operators/* sub */.lu)(clock, lastTime);
    // v0 = v / 1000
    // v = v0 * powf(deceleration, dt);
    // v = v * 1000;
    // x0 = x;
    // x = x0 + v0 * deceleration * (1 - powf(deceleration, dt)) / (1 - deceleration)
    const kv = (0,operators/* pow */.sQ)(config.deceleration, deltaTime);
    const kx = (0,operators/* divide */.cs)((0,operators/* multiply */.Jp)(config.deceleration, (0,operators/* sub */.lu)(1, kv)), (0,operators/* sub */.lu)(1, config.deceleration));
    const v0 = (0,operators/* divide */.cs)(state.velocity, 1000);
    const v = (0,operators/* multiply */.Jp)(v0, kv, 1000);
    const x = (0,operators/* add */.IH)(state.position, (0,operators/* multiply */.Jp)(v0, kx));
    return (0,AnimatedBlock/* createAnimatedBlock */.F)([
        createAnimatedSet(state.position, x),
        createAnimatedSet(state.velocity, v),
        createAnimatedSet(state.time, clock),
        (0,AnimatedCond/* createAnimatedCond */.d)((0,operators/* lessThan */.Qj)((0,operators/* abs */.Wn)(v), VELOCITY_EPS), createAnimatedSet(state.finished, 1))
    ]);
}
const procDecay = createAnimatedFunction((clock, time, velocity, position, finished, deceleration)=>decay(clock, {
        time,
        velocity,
        position,
        finished
    }, {
        deceleration
    }));
function decayAnimation(clock, { time, velocity, position, finished }, { deceleration }) {
    return procDecay(clock, time, velocity, position, finished, deceleration);
}

;// CONCATENATED MODULE: ./node_modules/react-native-reanimated/lib/reanimated1/animations/timing.js

const internalTiming = createAnimatedFunction(function(clock, time, frameTime, position, finished, toValue, duration, nextProgress, progress, newFrameTime) {
    const state = {
        time,
        finished,
        frameTime,
        position
    };
    const config = {
        duration,
        toValue
    };
    const distanceLeft = (0,operators/* sub */.lu)(config.toValue, state.position);
    const fullDistance = (0,operators/* divide */.cs)(distanceLeft, (0,operators/* sub */.lu)(1, progress));
    const startPosition = (0,operators/* sub */.lu)(config.toValue, fullDistance);
    const nextPosition = (0,operators/* add */.IH)(startPosition, (0,operators/* multiply */.Jp)(fullDistance, nextProgress));
    return (0,AnimatedBlock/* createAnimatedBlock */.F)([
        (0,AnimatedCond/* createAnimatedCond */.d)((0,operators/* greaterOrEq */.l7)(newFrameTime, config.duration), [
            createAnimatedSet(state.position, config.toValue),
            createAnimatedSet(state.finished, 1)
        ], createAnimatedSet(state.position, nextPosition)),
        createAnimatedSet(state.frameTime, newFrameTime),
        createAnimatedSet(state.time, clock)
    ]);
});
function timing(clock, state, config) {
    if (config.duration === 0) {
        // when duration is zero we end the timing immediately
        return (0,AnimatedBlock/* createAnimatedBlock */.F)([
            createAnimatedSet(state.position, config.toValue),
            createAnimatedSet(state.finished, 1)
        ]);
    }
    const lastTime = (0,AnimatedCond/* createAnimatedCond */.d)(state.time, state.time, clock);
    const newFrameTime = (0,operators/* add */.IH)(state.frameTime, (0,operators/* sub */.lu)(clock, lastTime));
    const nextProgress = config.easing((0,operators/* divide */.cs)(newFrameTime, config.duration));
    const progress = config.easing((0,operators/* divide */.cs)(state.frameTime, config.duration));
    return internalTiming(clock, state.time, state.frameTime, state.position, state.finished, config.toValue, config.duration, nextProgress, progress, newFrameTime);
}

;// CONCATENATED MODULE: ./node_modules/react-native-reanimated/lib/reanimated1/animations/spring.js


const MAX_STEPS_MS = 64;
function spring(clock, state, config) {
    const lastTime = (0,AnimatedCond/* createAnimatedCond */.d)(state.time, state.time, clock);
    const deltaTime = (0,operators/* min */.VV)((0,operators/* sub */.lu)(clock, lastTime), MAX_STEPS_MS);
    const c = config.damping;
    const m = config.mass;
    const k = config.stiffness;
    const v0 = (0,operators/* multiply */.Jp)(-1, state.velocity);
    const x0 = (0,operators/* sub */.lu)(config.toValue, state.position);
    const zeta = (0,operators/* divide */.cs)(c, (0,operators/* multiply */.Jp)(2, (0,operators/* sqrt */._b)((0,operators/* multiply */.Jp)(k, m)))); // damping ratio
    const omega0 = (0,operators/* sqrt */._b)((0,operators/* divide */.cs)(k, m)); // undamped angular frequency of the oscillator (rad/ms)
    const omega1 = (0,operators/* multiply */.Jp)(omega0, (0,operators/* sqrt */._b)((0,operators/* sub */.lu)(1, (0,operators/* multiply */.Jp)(zeta, zeta)))); // exponential decay
    const t = (0,operators/* divide */.cs)(deltaTime, 1000); // in seconds
    const sin1 = (0,operators/* sin */.O$)((0,operators/* multiply */.Jp)(omega1, t));
    const cos1 = (0,operators/* cos */.mC)((0,operators/* multiply */.Jp)(omega1, t));
    // under damped
    const underDampedEnvelope = (0,operators/* exp */.Qq)((0,operators/* multiply */.Jp)(-1, zeta, omega0, t));
    const underDampedFrag1 = (0,operators/* multiply */.Jp)(underDampedEnvelope, (0,operators/* add */.IH)((0,operators/* multiply */.Jp)(sin1, (0,operators/* divide */.cs)((0,operators/* add */.IH)(v0, (0,operators/* multiply */.Jp)(zeta, omega0, x0)), omega1)), (0,operators/* multiply */.Jp)(x0, cos1)));
    const underDampedPosition = (0,operators/* sub */.lu)(config.toValue, underDampedFrag1);
    // This looks crazy -- it's actually just the derivative of the oscillation function
    const underDampedVelocity = (0,operators/* sub */.lu)((0,operators/* multiply */.Jp)(zeta, omega0, underDampedFrag1), (0,operators/* multiply */.Jp)(underDampedEnvelope, (0,operators/* sub */.lu)((0,operators/* multiply */.Jp)(cos1, (0,operators/* add */.IH)(v0, (0,operators/* multiply */.Jp)(zeta, omega0, x0))), (0,operators/* multiply */.Jp)(omega1, x0, sin1))));
    // critically damped
    const criticallyDampedEnvelope = (0,operators/* exp */.Qq)((0,operators/* multiply */.Jp)(-1, omega0, t));
    const criticallyDampedPosition = (0,operators/* sub */.lu)(config.toValue, (0,operators/* multiply */.Jp)(criticallyDampedEnvelope, (0,operators/* add */.IH)(x0, (0,operators/* multiply */.Jp)((0,operators/* add */.IH)(v0, (0,operators/* multiply */.Jp)(omega0, x0)), t))));
    const criticallyDampedVelocity = (0,operators/* multiply */.Jp)(criticallyDampedEnvelope, (0,operators/* add */.IH)((0,operators/* multiply */.Jp)(v0, (0,operators/* sub */.lu)((0,operators/* multiply */.Jp)(t, omega0), 1)), (0,operators/* multiply */.Jp)(t, x0, omega0, omega0)));
    // conditions for stopping the spring animations
    const prevPosition = state.prevPosition ? state.prevPosition : new InternalAnimatedValue/* default */.Z(0);
    const isOvershooting = (0,AnimatedCond/* createAnimatedCond */.d)((0,operators/* and */.xD)(config.overshootClamping, (0,operators/* neq */.uH)(config.stiffness, 0)), (0,AnimatedCond/* createAnimatedCond */.d)((0,operators/* lessThan */.Qj)(prevPosition, config.toValue), (0,operators/* greaterThan */.tS)(state.position, config.toValue), (0,operators/* lessThan */.Qj)(state.position, config.toValue)));
    const isVelocity = (0,operators/* lessThan */.Qj)((0,operators/* abs */.Wn)(state.velocity), config.restSpeedThreshold);
    const isDisplacement = (0,operators.or)((0,operators.eq)(config.stiffness, 0), (0,operators/* lessThan */.Qj)((0,operators/* abs */.Wn)((0,operators/* sub */.lu)(config.toValue, state.position)), config.restDisplacementThreshold));
    return (0,AnimatedBlock/* createAnimatedBlock */.F)([
        createAnimatedSet(prevPosition, state.position),
        (0,AnimatedCond/* createAnimatedCond */.d)((0,operators/* lessThan */.Qj)(zeta, 1), [
            createAnimatedSet(state.position, underDampedPosition),
            createAnimatedSet(state.velocity, underDampedVelocity)
        ], [
            createAnimatedSet(state.position, criticallyDampedPosition),
            createAnimatedSet(state.velocity, criticallyDampedVelocity)
        ]),
        createAnimatedSet(state.time, clock),
        (0,AnimatedCond/* createAnimatedCond */.d)((0,operators.or)(isOvershooting, (0,operators/* and */.xD)(isVelocity, isDisplacement)), [
            (0,AnimatedCond/* createAnimatedCond */.d)((0,operators/* neq */.uH)(config.stiffness, 0), [
                createAnimatedSet(state.velocity, 0),
                createAnimatedSet(state.position, config.toValue)
            ]),
            createAnimatedSet(state.finished, 1)
        ])
    ]);
}
const procSpring = createAnimatedFunction((finished, velocity, position, time, prevPosition, toValue, damping, mass, stiffness, overshootClamping, restSpeedThreshold, restDisplacementThreshold, clock)=>spring(clock, {
        finished,
        velocity,
        position,
        time,
        prevPosition
    }, {
        toValue,
        damping,
        mass,
        stiffness,
        overshootClamping,
        restDisplacementThreshold,
        restSpeedThreshold
    }));
function springAnimation(clock, { finished, velocity, position, time, prevPosition }, { toValue, damping, mass, stiffness, overshootClamping, restDisplacementThreshold, restSpeedThreshold }) {
    return procSpring(finished, velocity, position, time, prevPosition, toValue, damping, mass, stiffness, overshootClamping, restSpeedThreshold, restDisplacementThreshold, clock);
}

;// CONCATENATED MODULE: ./node_modules/react-native-reanimated/lib/reanimated1/animations/Animation.js

class Animation {
    static springDefaultState() {
        return {
            position: new InternalAnimatedValue/* default */.Z(0),
            finished: new InternalAnimatedValue/* default */.Z(0),
            velocity: new InternalAnimatedValue/* default */.Z(0),
            time: new InternalAnimatedValue/* default */.Z(0)
        };
    }
    static decayDefaultState() {
        return {
            position: new InternalAnimatedValue/* default */.Z(0),
            finished: new InternalAnimatedValue/* default */.Z(0),
            velocity: new InternalAnimatedValue/* default */.Z(0),
            time: new InternalAnimatedValue/* default */.Z(0)
        };
    }
    static timingDefaultState() {
        return {
            position: new InternalAnimatedValue/* default */.Z(0),
            finished: new InternalAnimatedValue/* default */.Z(0),
            time: new InternalAnimatedValue/* default */.Z(0),
            frameTime: new InternalAnimatedValue/* default */.Z(0)
        };
    }
}
/* harmony default export */ const animations_Animation = (Animation);

;// CONCATENATED MODULE: ./node_modules/react-native-reanimated/lib/reanimated1/Transitioning.js




const TransitioningContext = /*#__PURE__*/ external_react_default().createContext();
function configFromProps(type, props) {
    const config = {
        type
    };
    if ("durationMs" in props) {
        config.durationMs = props.durationMs;
    }
    if ("interpolation" in props) {
        config.interpolation = props.interpolation;
    }
    if ("type" in props) {
        config.animation = props.type;
    }
    if ("delayMs" in props) {
        config.delayMs = props.delayMs;
    }
    if ("propagation" in props) {
        config.propagation = props.propagation;
    }
    return config;
}
/**
 * The below wrapper is used to support legacy context API with Context.Consumer
 * render prop. We need it as we want to access `context` from within
 * `componentDidMount` callback. If we decided to drop support for older
 * react native we could rewrite it using hooks or `static contextType` API.
 */ function wrapTransitioningContext(Comp) {
    return (props)=>{
        return /*#__PURE__*/ (0,jsx_runtime.jsx)(TransitioningContext.Consumer, {
            children: (context)=>/*#__PURE__*/ (0,jsx_runtime.jsx)(Comp, {
                    context: context,
                    ...props
                })
        });
    };
}
class In extends (external_react_default()).Component {
    componentDidMount() {
        this.props.context.push(configFromProps("in", this.props));
    }
    render() {
        return this.props.children || null;
    }
}
class Change extends (external_react_default()).Component {
    componentDidMount() {
        this.props.context.push(configFromProps("change", this.props));
    }
    render() {
        return this.props.children || null;
    }
}
class Out extends (external_react_default()).Component {
    componentDidMount() {
        this.props.context.push(configFromProps("out", this.props));
    }
    render() {
        return this.props.children || null;
    }
}
class Together extends (external_react_default()).Component {
    componentDidMount() {
        const config = configFromProps("group", this.props);
        config.transitions = this.transitions;
        this.props.context.push(config);
    }
    render() {
        return /*#__PURE__*/ (0,jsx_runtime.jsx)(TransitioningContext.Provider, {
            value: this.transitions,
            children: this.props.children
        });
    }
    constructor(...args){
        super(...args);
        this.transitions = [];
    }
}
class Sequence extends (external_react_default()).Component {
    componentDidMount() {
        const config = configFromProps("group", this.props);
        config.sequence = true;
        config.transitions = this.transitions;
        this.props.context.push(config);
    }
    render() {
        return /*#__PURE__*/ (0,jsx_runtime.jsx)(TransitioningContext.Provider, {
            value: this.transitions,
            children: this.props.children
        });
    }
    constructor(...args){
        super(...args);
        this.transitions = [];
    }
}
function createTransitioningComponent(Component) {
    class Wrapped extends (external_react_default()).Component {
        componentDidMount() {
            if (this.props.animateMount) {
                this.animateNextTransition();
            }
        }
        setNativeProps(props) {
            this.viewRef.current.setNativeProps(props);
        }
        animateNextTransition() {
            const viewTag = (0,cjs.findNodeHandle)(this.viewRef.current);
            ReanimatedModule/* default */.Z.animateNextTransition(viewTag, {
                transitions: this.transitions
            });
        }
        render() {
            const { transition, ...rest } = this.props;
            return /*#__PURE__*/ (0,jsx_runtime.jsxs)((external_react_default()).Fragment, {
                children: [
                    /*#__PURE__*/ (0,jsx_runtime.jsx)(TransitioningContext.Provider, {
                        value: this.transitions,
                        children: transition
                    }),
                    /*#__PURE__*/ (0,jsx_runtime.jsx)(Component, {
                        ...rest,
                        ref: this.viewRef,
                        collapsable: false
                    })
                ]
            });
        }
        constructor(...args){
            super(...args);
            this.propTypes = Component.propTypes;
            this.transitions = [];
            this.viewRef = /*#__PURE__*/ external_react_default().createRef();
        }
    }
    return Wrapped;
}
const Transitioning = {
    View: createTransitioningComponent(cjs.View)
};
const Transition = {
    Sequence: wrapTransitioningContext(Sequence),
    Together: wrapTransitioningContext(Together),
    In: wrapTransitioningContext(In),
    Out: wrapTransitioningContext(Out),
    Change: wrapTransitioningContext(Change)
};


;// CONCATENATED MODULE: ./node_modules/react-native-reanimated/lib/reanimated1/animations/SpringUtils.js


function stiffnessFromOrigamiValue(oValue) {
    return (oValue - 30) * 3.62 + 194;
}
function dampingFromOrigamiValue(oValue) {
    return (oValue - 8) * 3 + 25;
}
function stiffnessFromOrigamiNode(oValue) {
    return (0,operators/* add */.IH)((0,operators/* multiply */.Jp)((0,operators/* sub */.lu)(oValue, 30), 3.62), 194);
}
function dampingFromOrigamiNode(oValue) {
    return (0,operators/* add */.IH)((0,operators/* multiply */.Jp)((0,operators/* sub */.lu)(oValue, 8), 3), 25);
}
function makeConfigFromOrigamiTensionAndFriction(prevConfig) {
    const { tension, friction, ...rest } = prevConfig;
    return {
        ...rest,
        stiffness: typeof tension === "number" ? stiffnessFromOrigamiValue(tension) : stiffnessFromOrigamiNode(tension),
        damping: typeof friction === "number" ? dampingFromOrigamiValue(friction) : dampingFromOrigamiNode(friction)
    };
}
function makeConfigFromBouncinessAndSpeed(prevConfig) {
    const { bounciness, speed, ...rest } = prevConfig;
    if (typeof bounciness === "number" && typeof speed === "number") {
        return fromBouncinessAndSpeedNumbers(bounciness, speed, rest);
    }
    return fromBouncinessAndSpeedNodes(bounciness, speed, rest);
}
function fromBouncinessAndSpeedNodes(bounciness, speed, rest) {
    function normalize(value, startValue, endValue) {
        return (0,operators/* divide */.cs)((0,operators/* sub */.lu)(value, startValue), (0,operators/* sub */.lu)(endValue, startValue));
    }
    function projectNormal(n, start, end) {
        return (0,operators/* add */.IH)(start, (0,operators/* multiply */.Jp)(n, (0,operators/* sub */.lu)(end, start)));
    }
    function linearInterpolation(t, start, end) {
        return (0,operators/* add */.IH)((0,operators/* multiply */.Jp)(t, end), (0,operators/* multiply */.Jp)((0,operators/* sub */.lu)(1, t), start));
    }
    function quadraticOutInterpolation(t, start, end) {
        return linearInterpolation((0,operators/* sub */.lu)((0,operators/* multiply */.Jp)(2, t), (0,operators/* multiply */.Jp)(t, t)), start, end);
    }
    function b3Friction1(x) {
        return (0,operators/* add */.IH)((0,operators/* sub */.lu)((0,operators/* multiply */.Jp)(0.0007, (0,operators/* pow */.sQ)(x, 3)), (0,operators/* multiply */.Jp)(0.031, (0,operators/* pow */.sQ)(x, 2))), (0,operators/* multiply */.Jp)(0.64, x), 1.28);
    }
    function b3Friction2(x) {
        return (0,operators/* add */.IH)((0,operators/* sub */.lu)((0,operators/* multiply */.Jp)(0.000044, (0,operators/* pow */.sQ)(x, 3)), (0,operators/* multiply */.Jp)(0.006, (0,operators/* pow */.sQ)(x, 2))), (0,operators/* multiply */.Jp)(0.36, x), 2);
    }
    function b3Friction3(x) {
        return (0,operators/* add */.IH)((0,operators/* sub */.lu)((0,operators/* multiply */.Jp)(0.00000045, (0,operators/* pow */.sQ)(x, 3)), (0,operators/* multiply */.Jp)(0.000332, (0,operators/* pow */.sQ)(x, 2))), (0,operators/* multiply */.Jp)(0.1078, x), 5.84);
    }
    function b3Nobounce(tension) {
        return (0,AnimatedCond/* createAnimatedCond */.d)((0,operators/* lessOrEq */.w5)(tension, 18), b3Friction1(tension), (0,AnimatedCond/* createAnimatedCond */.d)((0,operators/* and */.xD)((0,operators/* greaterThan */.tS)(tension, 18), (0,operators/* lessOrEq */.w5)(tension, 44)), b3Friction2(tension), b3Friction3(tension)));
    }
    let b = normalize((0,operators/* divide */.cs)(bounciness, 1.7), 0, 20);
    b = projectNormal(b, 0, 0.8);
    const s = normalize((0,operators/* divide */.cs)(speed, 1.7), 0, 20);
    const bouncyTension = projectNormal(s, 0.5, 200);
    const bouncyFriction = quadraticOutInterpolation(b, b3Nobounce(bouncyTension), 0.01);
    return {
        ...rest,
        stiffness: stiffnessFromOrigamiNode(bouncyTension),
        damping: dampingFromOrigamiNode(bouncyFriction)
    };
}
function fromBouncinessAndSpeedNumbers(bounciness, speed, rest) {
    function normalize(value, startValue, endValue) {
        return (value - startValue) / (endValue - startValue);
    }
    function projectNormal(n, start, end) {
        return start + n * (end - start);
    }
    function linearInterpolation(t, start, end) {
        return t * end + (1 - t) * start;
    }
    function quadraticOutInterpolation(t, start, end) {
        return linearInterpolation(2 * t - t * t, start, end);
    }
    function b3Friction1(x) {
        return 0.0007 * Math.pow(x, 3) - 0.031 * Math.pow(x, 2) + 0.64 * x + 1.28;
    }
    function b3Friction2(x) {
        return 0.000044 * Math.pow(x, 3) - 0.006 * Math.pow(x, 2) + 0.36 * x + 2;
    }
    function b3Friction3(x) {
        return 0.00000045 * Math.pow(x, 3) - 0.000332 * Math.pow(x, 2) + 0.1078 * x + 5.84;
    }
    function b3Nobounce(tension) {
        if (tension <= 18) {
            return b3Friction1(tension);
        } else if (tension > 18 && tension <= 44) {
            return b3Friction2(tension);
        } else {
            return b3Friction3(tension);
        }
    }
    let b = normalize(bounciness / 1.7, 0, 20);
    b = projectNormal(b, 0, 0.8);
    const s = normalize(speed / 1.7, 0, 20);
    const bouncyTension = projectNormal(s, 0.5, 200);
    const bouncyFriction = quadraticOutInterpolation(b, b3Nobounce(bouncyTension), 0.01);
    return {
        ...rest,
        stiffness: stiffnessFromOrigamiValue(bouncyTension),
        damping: dampingFromOrigamiValue(bouncyFriction)
    };
}
function makeDefaultConfig() {
    return {
        stiffness: new InternalAnimatedValue/* default */.Z(100),
        mass: new InternalAnimatedValue/* default */.Z(1),
        damping: new InternalAnimatedValue/* default */.Z(10),
        overshootClamping: false,
        restSpeedThreshold: 0.001,
        restDisplacementThreshold: 0.001,
        toValue: new InternalAnimatedValue/* default */.Z(0)
    };
}
/* harmony default export */ const SpringUtils = ({
    makeDefaultConfig,
    makeConfigFromBouncinessAndSpeed,
    makeConfigFromOrigamiTensionAndFriction
});

;// CONCATENATED MODULE: ./node_modules/react-native-reanimated/lib/reanimated1/useValue.js


function useValue(initialValue) {
    const ref = external_react_default().useRef(null);
    if (ref.current === null) {
        ref.current = new AnimatedValue(initialValue);
    }
    return ref.current;
}

;// CONCATENATED MODULE: ./node_modules/react-native-reanimated/lib/reanimated1/core/AnimatedClockTest.js

class AnimatedClockTest extends core_AnimatedNode/* default */.ZP {
    constructor(clockNode){
        super({
            type: "clockTest",
            clock: clockNode
        });
        this._clockNode = clockNode;
    }
    toString() {
        return `AnimatedClockTest, id: ${this.__nodeID}`;
    }
    __onEvaluate() {
        return this._clockNode.isStarted() ? 1 : 0;
    }
}
function createAnimatedClockTest(clock) {
    return new AnimatedClockTest(clock);
}

;// CONCATENATED MODULE: ./node_modules/react-native-reanimated/lib/reanimated1/core/AnimatedStartClock.js




class AnimatedStartClock extends core_AnimatedNode/* default */.ZP {
    constructor(clockNode){
        external_invariant_default()(clockNode instanceof AnimatedClock || clockNode instanceof AnimatedParam, `Reanimated: Animated.startClock argument should be of type AnimatedClock but got ${clockNode}`);
        super({
            type: "clockStart",
            clock: clockNode
        });
        this._clockNode = clockNode;
    }
    toString() {
        return `AnimatedStartClock, id: ${this.__nodeID}`;
    }
    __onEvaluate() {
        this._clockNode.start();
        return 0;
    }
}
function createAnimatedStartClock(clock) {
    return new AnimatedStartClock(clock);
}

;// CONCATENATED MODULE: ./node_modules/react-native-reanimated/lib/reanimated1/core/AnimatedStopClock.js




class AnimatedStopClock extends core_AnimatedNode/* default */.ZP {
    constructor(clockNode){
        external_invariant_default()(clockNode instanceof AnimatedClock || clockNode instanceof AnimatedParam, `Reanimated: Animated.stopClock argument should be of type AnimatedClock but got ${clockNode}`);
        super({
            type: "clockStop",
            clock: clockNode
        });
        this._clockNode = clockNode;
    }
    toString() {
        return `AnimatedStopClock, id: ${this.__nodeID}`;
    }
    __onEvaluate() {
        this._clockNode.stop();
        return 0;
    }
}
function createAnimatedStopClock(clock) {
    return new AnimatedStopClock(clock);
}

;// CONCATENATED MODULE: ./node_modules/react-native-reanimated/lib/reanimated1/animations/backwardCompatibleAnimWrapper.js



function createOldAnimationObject(node, animationStateDefaults, value, config) {
    const newClock = new AnimatedClock();
    const currentState = animationStateDefaults();
    let alwaysNode;
    let isStarted = false;
    let isDone = false;
    let wasStopped = false;
    let animationCallback;
    const animation = {
        start: (currentAnimationCallback)=>{
            animationCallback = currentAnimationCallback;
            if (isStarted) {
                animationCallback && animationCallback({
                    finished: false
                });
                return;
            }
            if (isDone) {
                console.warn("Animation has been finished before");
                // inconsistent with React Native
                return;
            }
            if (!value.isNativelyInitialized()) {
                return;
            }
            isStarted = true;
            evaluateOnce(createAnimatedSet(currentState.position, value), currentState.position, ()=>{
                alwaysNode = createAnimatedAlways(createAnimatedSet(value, (0,AnimatedBlock/* createAnimatedBlock */.F)([
                    (0,AnimatedCond/* createAnimatedCond */.d)(createAnimatedClockTest(newClock), 0, createAnimatedStartClock(newClock)),
                    node(newClock, currentState, config),
                    (0,AnimatedCond/* createAnimatedCond */.d)(currentState.finished, [
                        createAnimatedCall([], ()=>{
                            isStarted = false;
                            if (!wasStopped) {
                                isDone = true;
                            }
                            value.__detachAnimation(animation);
                            isDone = true;
                            if (!wasStopped) {
                                wasStopped = false;
                            }
                        }),
                        createAnimatedStopClock(newClock)
                    ]),
                    currentState.position
                ])));
                value.__attachAnimation(animation);
                alwaysNode.__addChild(value);
            });
        },
        __detach: ()=>{
            animationCallback && animationCallback({
                finished: isDone
            });
            animationCallback = null;
            value.__initialized && alwaysNode.__removeChild(value);
        },
        stop: ()=>{
            if (isDone) {
                console.warn("Calling stop has no effect as the animation has already completed");
                return;
            }
            if (!isStarted) {
                console.warn("Calling stop has no effect as the animation hasn't been started");
                return;
            }
            wasStopped = true;
            evaluateOnce(createAnimatedSet(currentState.finished, 1), currentState.finished);
        },
        __stopImmediately_testOnly: (result)=>{
            animation.stop();
            isDone = result;
            value.__detachAnimation(animation);
        }
    };
    return animation;
}
/**
 * Depending on the arguments list we either return animation node or return an
 * animation object that is compatible with the original Animated API
 */ function backwardsCompatibleAnimWrapper(node, animationStateDefaults) {
    return (clock, state, config)=>{
        if (config !== undefined) {
            return node(clock, state, config);
        }
        return createOldAnimationObject(node, animationStateDefaults, clock, state);
    };
}

;// CONCATENATED MODULE: ./node_modules/react-native-reanimated/lib/reanimated1/core/AnimatedDebug.js






class AnimatedDebug extends (/* unused pure expression or super */ null && (AnimatedNode)) {
    constructor(message, value){
        invariant(typeof message === "string", `Reanimated: Animated.debug node first argument should be of type string but got ${message}`);
        invariant(value instanceof AnimatedNode, `Reanimated: Animated.debug node second argument should be of type AnimatedNode but got ${value}`);
        super({
            type: "debug",
            message,
            value
        }, [
            value
        ]);
        this._message = message;
        this._value = value;
    }
    toString() {
        return `AnimatedDebug, id: ${this.__nodeID}`;
    }
    __onEvaluate() {
        const value = val(this._value);
        console.log(this._message, value);
        return value;
    }
}
function createAnimatedDebug(message, value) {
    if (false) {}
    // Debugging is disabled in PROD
    return value;
}

;// CONCATENATED MODULE: ./node_modules/react-native-reanimated/lib/reanimated1/core/AnimatedConcat.js




class AnimatedConcat extends core_AnimatedNode/* default */.ZP {
    constructor(input){
        external_invariant_default()(input.every((el)=>el instanceof core_AnimatedNode/* default */.ZP || typeof el === "number" || typeof el === "string"), `Reanimated: Animated.concat node arguments should be of type AnimatedNode or String or Number. One or more of them are not of that type. Node: ${input}`);
        super({
            type: "concat",
            input
        }, input);
        this._input = input;
    }
    __onEvaluate() {
        return this._input.reduce((prev, current)=>prev + (0,reanimated1_val/* val */.P)(current), "");
    }
    toString() {
        return `AnimatedConcat, id: ${this.__nodeID}`;
    }
}
function createAnimatedConcat(...args) {
    return new AnimatedConcat(args.map(AnimatedBlock/* adapt */.p));
}

;// CONCATENATED MODULE: ./node_modules/react-native-reanimated/lib/reanimated1/base.js














;// CONCATENATED MODULE: ./node_modules/react-native-reanimated/lib/reanimated1/derived/acc.js


const procAcc = createAnimatedFunction(function(v, acc) {
    return createAnimatedSet(acc, (0,operators/* add */.IH)(acc, v));
});
function acc(v) {
    const acc = new InternalAnimatedValue/* default */.Z(0);
    return procAcc(v, acc);
}

;// CONCATENATED MODULE: ./node_modules/react-native-reanimated/lib/reanimated1/derived/color.js



const procColor = createAnimatedFunction(function(r, g, b, a) {
    const color = (0,operators/* add */.IH)((0,operators/* multiply */.Jp)(a, 1 << 24), (0,operators/* multiply */.Jp)((0,operators/* round */.NM)(r), 1 << 16), (0,operators/* multiply */.Jp)((0,operators/* round */.NM)(g), 1 << 8), (0,operators/* round */.NM)(b));
    if (cjs.Platform.OS === "android") {
        // on Android color is represented as signed 32 bit int
        return (0,AnimatedCond/* createAnimatedCond */.d)((0,operators/* lessThan */.Qj)(color, 1 << 31 >>> 0), color, (0,operators/* sub */.lu)(color, Math.pow(2, 32)));
    }
    return color;
});
function color(r, g, b, a = 1) {
    if (cjs.Platform.OS === "web") {
        // doesn't support bit shifting
        return createAnimatedConcat("rgba(", r, ",", g, ",", b, ",", a, ")");
    }
    if (a instanceof core_AnimatedNode/* default */.ZP) {
        a = (0,operators/* round */.NM)((0,operators/* multiply */.Jp)(a, 255));
    } else {
        a = Math.round(a * 255);
    }
    return procColor(r, g, b, a);
}

;// CONCATENATED MODULE: ./node_modules/react-native-reanimated/lib/reanimated1/derived/diff.js


const procDiff = createAnimatedFunction(function(v, stash, prev) {
    return (0,AnimatedBlock/* createAnimatedBlock */.F)([
        createAnimatedSet(stash, (0,AnimatedCond/* createAnimatedCond */.d)((0,operators/* defined */.ri)(prev), (0,operators/* sub */.lu)(v, prev), 0)),
        createAnimatedSet(prev, v),
        stash
    ]);
});
function diff(v) {
    const stash = new InternalAnimatedValue/* default */.Z(0);
    const prev = new InternalAnimatedValue/* default */.Z();
    return procDiff(v, stash, prev);
}

;// CONCATENATED MODULE: ./node_modules/react-native-reanimated/lib/reanimated1/derived/diffClamp.js



function diffClamp(a, minVal, maxVal) {
    const value = new InternalAnimatedValue/* default */.Z();
    return createAnimatedSet(value, (0,operators/* min */.VV)((0,operators/* max */.Fp)((0,operators/* add */.IH)((0,AnimatedCond/* createAnimatedCond */.d)((0,operators/* defined */.ri)(value), value, a), diff(a)), minVal), maxVal));
}

;// CONCATENATED MODULE: ./node_modules/react-native-reanimated/lib/reanimated1/derived/interpolateColors.js




function red(c) {
    return c >> 16 & 255;
}
function green(c) {
    return c >> 8 & 255;
}
function blue(c) {
    return c & 255;
}
function opacity(c) {
    return (c >> 24 & 255) / 255;
}
/**
 * Use this if you want to interpolate an `Animated.Value` into color values.
 *
 * #### Why is this needed?
 *
 * Unfortunately, if you'll pass color values directly into the `outputRange` option
 * of `interpolate()` function, that won't really work (at least at the moment).
 * See https://github.com/software-mansion/react-native-reanimated/issues/181 .
 *
 * So, for now you can just use this helper instead.
 */ function interpolateColors(animationValue, options) {
    const { inputRange, outputColorRange } = options;
    const colors = outputColorRange.map(cjs.processColor);
    const r = (0,operators/* round */.NM)(interpolate(animationValue, {
        inputRange,
        outputRange: colors.map(red),
        extrapolate: Extrapolate.CLAMP
    }));
    const g = (0,operators/* round */.NM)(interpolate(animationValue, {
        inputRange,
        outputRange: colors.map(green),
        extrapolate: Extrapolate.CLAMP
    }));
    const b = (0,operators/* round */.NM)(interpolate(animationValue, {
        inputRange,
        outputRange: colors.map(blue),
        extrapolate: Extrapolate.CLAMP
    }));
    const a = interpolate(animationValue, {
        inputRange,
        outputRange: colors.map(opacity),
        extrapolate: Extrapolate.CLAMP
    });
    return color(r, g, b, a);
}

;// CONCATENATED MODULE: ./node_modules/react-native-reanimated/lib/reanimated1/derived/onChange.js


const procOnChange = createAnimatedFunction(function(value, action, prevValue) {
    return (0,AnimatedBlock/* createAnimatedBlock */.F)([
        (0,AnimatedCond/* createAnimatedCond */.d)((0,operators/* not */.ff)((0,operators/* defined */.ri)(prevValue)), createAnimatedSet(prevValue, value)),
        (0,AnimatedCond/* createAnimatedCond */.d)((0,operators/* neq */.uH)(value, prevValue), [
            createAnimatedSet(prevValue, value),
            action
        ])
    ]);
});
function onChange(value, action) {
    const prevValue = new InternalAnimatedValue/* default */.Z();
    return procOnChange(value, action, prevValue);
}

;// CONCATENATED MODULE: ./node_modules/react-native-reanimated/lib/reanimated1/derived/index.js









;// CONCATENATED MODULE: ./node_modules/react-native-reanimated/lib/reanimated1/index.js













const decayWrapper = backwardsCompatibleAnimWrapper(decayAnimation, animations_Animation.decayDefaultState);
const timingWrapper = backwardsCompatibleAnimWrapper(timing, animations_Animation.timingDefaultState);
const springWrapper = backwardsCompatibleAnimWrapper(springAnimation, animations_Animation.springDefaultState);
// operations




;// CONCATENATED MODULE: ./node_modules/react-native-reanimated/lib/Animated.js







// @ts-ignore backward compatibility with treeshaking


;// CONCATENATED MODULE: ./node_modules/react-native-reanimated/lib/reanimated2/js-reanimated/global.js
// In order to keep bundle size down, we treat this file as a polyfill for Web.

const initializeGlobalsForWeb = ()=>{
    if ((0,PlatformChecker/* shouldBeUseWeb */.Wr)()) {
        global._frameTimestamp = null;
        global._setGlobalConsole = (_val)=>{
        // noop
        };
        global._measure = ()=>{
            console.warn("[Reanimated] You can't use `measure` with Chrome Debugger or with web version");
            return {
                x: 0,
                y: 0,
                width: 0,
                height: 0,
                pageX: 0,
                pageY: 0
            };
        };
        global._scrollTo = ()=>{
            console.warn("[Reanimated] You can't use `scrollTo` with Chrome Debugger or with web version");
        };
        global._setGestureState = ()=>{
            console.warn("[Reanimated] You can't use `setGestureState` with Chrome Debugger or with web version");
        };
    }
    return true;
};
/*
  If a file doesn't export anything, tree shaking doesn't pack
  it into the JS bundle. In effect, the code inside of this file
  will never execute. That is why we wrapped initialization code
  into a function, and we call this one during creating
  the module export object.
*/ /* harmony default export */ const js_reanimated_global = (initializeGlobalsForWeb());

// EXTERNAL MODULE: ./node_modules/react-native-reanimated/lib/reanimated2/hook/useAnimatedStyle.js + 1 modules
var useAnimatedStyle = __webpack_require__(55633);
;// CONCATENATED MODULE: ./node_modules/react-native-reanimated/lib/reanimated2/hook/Hooks.js


// TODO: we should make sure that when useAP is used we are not assigning styles
// when you need styles to animated you should always use useAS
const useAnimatedProps = useAnimatedStyle/* useAnimatedStyle */.l;
function useWorkletCallback(fun, deps) {
    return (0,external_react_.useCallback)(fun, deps !== null && deps !== void 0 ? deps : []);
}


// EXTERNAL MODULE: ./node_modules/react-native-reanimated/lib/reanimated2/hook/utils.js
var utils = __webpack_require__(19496);
// EXTERNAL MODULE: ./node_modules/react-native-reanimated/lib/reanimated2/hook/useSharedValue.js
var useSharedValue = __webpack_require__(2957);
;// CONCATENATED MODULE: ./node_modules/react-native-reanimated/lib/reanimated2/hook/useAnimatedGestureHandler.js

var EventType;
(function(EventType) {
    EventType[EventType["UNDETERMINED"] = 0] = "UNDETERMINED";
    EventType[EventType["FAILED"] = 1] = "FAILED";
    EventType[EventType["BEGAN"] = 2] = "BEGAN";
    EventType[EventType["CANCELLED"] = 3] = "CANCELLED";
    EventType[EventType["ACTIVE"] = 4] = "ACTIVE";
    EventType[EventType["END"] = 5] = "END";
})(EventType || (EventType = {}));
function useAnimatedGestureHandler(handlers, dependencies) {
    const { context, doDependenciesDiffer, useWeb } = (0,utils/* useHandler */.Ak)(handlers, dependencies);
    const handler = (e)=>{
        "worklet";
        const event = useWeb ? e.nativeEvent : e;
        if (event.state === EventType.BEGAN && handlers.onStart) {
            handlers.onStart(event, context);
        }
        if (event.state === EventType.ACTIVE && handlers.onActive) {
            handlers.onActive(event, context);
        }
        if (event.oldState === EventType.ACTIVE && event.state === EventType.END && handlers.onEnd) {
            handlers.onEnd(event, context);
        }
        if (event.oldState === EventType.BEGAN && event.state === EventType.FAILED && handlers.onFail) {
            handlers.onFail(event, context);
        }
        if (event.oldState === EventType.ACTIVE && event.state === EventType.CANCELLED && handlers.onCancel) {
            handlers.onCancel(event, context);
        }
        if ((event.oldState === EventType.BEGAN || event.oldState === EventType.ACTIVE) && event.state !== EventType.BEGAN && event.state !== EventType.ACTIVE && handlers.onFinish) {
            handlers.onFinish(event, context, event.state === EventType.CANCELLED || event.state === EventType.FAILED);
        }
    };
    if (useWeb) {
        return handler;
    }
    return (0,utils/* useEvent */.zX)(handler, [
        "onGestureHandlerStateChange",
        "onGestureHandlerEvent"
    ], doDependenciesDiffer);
}

;// CONCATENATED MODULE: ./node_modules/react-native-reanimated/lib/reanimated2/hook/useAnimatedReaction.js



/**
 * @param prepare - worklet used for data preparation for the second parameter
 * @param react - worklet which takes data prepared by the one in the first parameter and performs certain actions
 * the first worklet defines the inputs, in other words on which shared values change will it be called.
 * the second one can modify any shared values but those which are mentioned in the first worklet. Beware of that, because this may result in endless loop and high cpu usage.
 */ function useAnimatedReaction(prepare, react, dependencies) {
    var _a, _b;
    const previous = (0,useSharedValue/* useSharedValue */.y)(null);
    if (dependencies === undefined) {
        dependencies = [
            Object.values((_a = prepare._closure) !== null && _a !== void 0 ? _a : {}),
            Object.values((_b = react._closure) !== null && _b !== void 0 ? _b : {}),
            prepare.__workletHash,
            react.__workletHash
        ];
    } else {
        dependencies.push(prepare.__workletHash, react.__workletHash);
    }
    (0,external_react_.useEffect)(()=>{
        var _a;
        const fun = ()=>{
            "worklet";
            const input = prepare();
            react(input, previous.value);
            previous.value = input;
        };
        const mapperId = (0,core/* startMapper */.Rn)(fun, Object.values((_a = prepare._closure) !== null && _a !== void 0 ? _a : {}), []);
        return ()=>{
            (0,core/* stopMapper */.BV)(mapperId);
        };
    }, dependencies);
}

;// CONCATENATED MODULE: ./node_modules/react-native-reanimated/lib/reanimated2/NativeMethods.js


function getTag(view) {
    return (0,cjs.findNodeHandle)(view);
}
const isNative = !(0,PlatformChecker/* shouldBeUseWeb */.Wr)();
let measure;
if ((0,PlatformChecker/* isWeb */.$L)()) {
    measure = (animatedRef)=>{
        const element = animatedRef(); // TODO: fix typing of animated refs on web
        const viewportOffset = element.getBoundingClientRect();
        return {
            width: element.offsetWidth,
            height: element.offsetHeight,
            x: element.offsetLeft,
            y: element.offsetTop,
            pageX: viewportOffset.left,
            pageY: viewportOffset.top
        };
    };
} else if ((0,PlatformChecker/* isChromeDebugger */.f1)()) {
    measure = (_animatedRef)=>{
        console.warn("[Reanimated] measure() cannot be used with Chrome Debugger.");
        return null;
    };
} else {
    measure = (animatedRef)=>{
        "worklet";
        if (!_WORKLET) {
            console.warn("[Reanimated] measure() was called from the main JS context. Measure is " + "only available in the UI runtime. This may also happen if measure() " + "was called by a worklet in the useAnimatedStyle hook, because useAnimatedStyle " + "calls the given worklet on the JS runtime during render. If you want to " + "prevent this warning then wrap the call with `if (_WORKLET)`. Then it will " + "only be called on the UI runtime after the render has been completed.");
            return null;
        }
        const viewTag = animatedRef();
        if (viewTag === -1) {
            console.warn(`[Reanimated] The view with tag ${viewTag} is not a valid argument for measure(). This may be because the view is not currently rendered, which may not be a bug (e.g. an off-screen FlatList item).`);
            return null;
        }
        const measured = _measure(viewTag);
        if (measured === null) {
            console.warn(`[Reanimated] The view with tag ${viewTag} has some undefined, not-yet-computed or meaningless value of \`LayoutMetrics\` type. This may be because the view is not currently rendered, which may not be a bug (e.g. an off-screen FlatList item).`);
            return null;
        } else if (measured.x === -1234567) {
            console.warn(`[Reanimated] The view with tag ${viewTag} returned an invalid measurement response.`);
            return null;
        } else if (isNaN(measured.x)) {
            console.warn(`[Reanimated] The view with tag ${viewTag} gets view-flattened on Android. To disable view-flattening, set \`collapsable={false}\` on this component.`);
            return null;
        } else {
            return measured;
        }
    };
}
let scrollTo;
if ((0,PlatformChecker/* isWeb */.$L)()) {
    scrollTo = (animatedRef, x, y, animated)=>{
        "worklet";
        const element = animatedRef();
        // @ts-ignore same call as in react-native-web
        element.scrollTo({
            x,
            y,
            animated
        });
    };
} else if (isNative) {
    scrollTo = (animatedRef, x, y, animated)=>{
        "worklet";
        if (!_WORKLET) {
            return;
        }
        const viewTag = animatedRef();
        _scrollTo(viewTag, x, y, animated);
    };
} else {
    scrollTo = (_animatedRef, _x, _y)=>{
    // no-op
    };
}
function setGestureState(handlerTag, newState) {
    "worklet";
    if (!_WORKLET || !isNative) {
        console.warn("[Reanimated] You can not use setGestureState in non-worklet function.");
        return;
    }
    _setGestureState(handlerTag, newState);
}

;// CONCATENATED MODULE: ./node_modules/react-native-reanimated/lib/reanimated2/hook/useAnimatedRef.js



function useAnimatedRef() {
    const tag = (0,useSharedValue/* useSharedValue */.y)(-1);
    const ref = (0,external_react_.useRef)();
    if (!ref.current) {
        const fun = (component)=>{
            "worklet";
            // enters when ref is set by attaching to a component
            if (component) {
                tag.value = getTag(component);
                fun.current = component;
            }
            return tag.value;
        };
        Object.defineProperty(fun, "current", {
            value: null,
            writable: true,
            enumerable: false
        });
        ref.current = fun;
    }
    return ref.current;
}

;// CONCATENATED MODULE: ./node_modules/react-native-reanimated/lib/reanimated2/hook/useAnimatedScrollHandler.js

function useAnimatedScrollHandler(handlers, dependencies) {
    // case when handlers is a function
    const scrollHandlers = typeof handlers === "function" ? {
        onScroll: handlers
    } : handlers;
    const { context, doDependenciesDiffer } = (0,utils/* useHandler */.Ak)(scrollHandlers, dependencies);
    // build event subscription array
    const subscribeForEvents = [
        "onScroll"
    ];
    if (scrollHandlers.onBeginDrag !== undefined) {
        subscribeForEvents.push("onScrollBeginDrag");
    }
    if (scrollHandlers.onEndDrag !== undefined) {
        subscribeForEvents.push("onScrollEndDrag");
    }
    if (scrollHandlers.onMomentumBegin !== undefined) {
        subscribeForEvents.push("onMomentumScrollBegin");
    }
    if (scrollHandlers.onMomentumEnd !== undefined) {
        subscribeForEvents.push("onMomentumScrollEnd");
    }
    return (0,utils/* useEvent */.zX)((event)=>{
        "worklet";
        const { onScroll, onBeginDrag, onEndDrag, onMomentumBegin, onMomentumEnd } = scrollHandlers;
        if (onScroll && event.eventName.endsWith("onScroll")) {
            onScroll(event, context);
        } else if (onBeginDrag && event.eventName.endsWith("onScrollBeginDrag")) {
            onBeginDrag(event, context);
        } else if (onEndDrag && event.eventName.endsWith("onScrollEndDrag")) {
            onEndDrag(event, context);
        } else if (onMomentumBegin && event.eventName.endsWith("onMomentumScrollBegin")) {
            onMomentumBegin(event, context);
        } else if (onMomentumEnd && event.eventName.endsWith("onMomentumScrollEnd")) {
            onMomentumEnd(event, context);
        }
    }, subscribeForEvents, doDependenciesDiffer);
}

;// CONCATENATED MODULE: ./node_modules/react-native-reanimated/lib/reanimated2/hook/useDerivedValue.js



function useDerivedValue(processor, dependencies) {
    var _a;
    const initRef = (0,external_react_.useRef)(null);
    const inputs = Object.values((_a = processor._closure) !== null && _a !== void 0 ? _a : {});
    // build dependencies
    if (dependencies === undefined) {
        dependencies = [
            ...inputs,
            processor.__workletHash
        ];
    } else {
        dependencies.push(processor.__workletHash);
    }
    if (initRef.current === null) {
        initRef.current = (0,core/* makeMutable */.vG)((0,util/* initialUpdaterRun */.AX)(processor));
    }
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    const sharedValue = initRef.current;
    (0,external_react_.useEffect)(()=>{
        const fun = ()=>{
            "worklet";
            sharedValue.value = processor();
        };
        const mapperId = (0,core/* startMapper */.Rn)(fun, inputs, [
            sharedValue
        ]);
        return ()=>{
            (0,core/* stopMapper */.BV)(mapperId);
        };
    }, dependencies);
    (0,external_react_.useEffect)(()=>{
        return ()=>{
            initRef.current = null;
        };
    }, []);
    return sharedValue;
}

// EXTERNAL MODULE: ./node_modules/react-native-reanimated/lib/reanimated2/NativeReanimated/index.js
var NativeReanimated = __webpack_require__(87490);
;// CONCATENATED MODULE: ./node_modules/react-native-reanimated/lib/reanimated2/hook/useAnimatedSensor.js



var SensorType;
(function(SensorType) {
    SensorType[SensorType["ACCELEROMETER"] = 1] = "ACCELEROMETER";
    SensorType[SensorType["GYROSCOPE"] = 2] = "GYROSCOPE";
    SensorType[SensorType["GRAVITY"] = 3] = "GRAVITY";
    SensorType[SensorType["MAGNETIC_FIELD"] = 4] = "MAGNETIC_FIELD";
    SensorType[SensorType["ROTATION"] = 5] = "ROTATION";
})(SensorType || (SensorType = {}));
function useAnimatedSensor(sensorType, userConfig) {
    const ref = (0,external_react_.useRef)({
        sensor: null,
        unregister: ()=>{
        // NOOP
        },
        isAvailable: false,
        config: {
            interval: 0
        }
    });
    if (ref.current.sensor === null) {
        ref.current.config = Object.assign({
            interval: "auto"
        }, userConfig);
        let sensorData;
        if (sensorType === SensorType.ROTATION) {
            sensorData = {
                qw: 0,
                qx: 0,
                qy: 0,
                qz: 0,
                yaw: 0,
                pitch: 0,
                roll: 0
            };
        } else {
            sensorData = {
                x: 0,
                y: 0,
                z: 0
            };
        }
        ref.current.sensor = (0,core/* makeMutable */.vG)(sensorData);
    }
    (0,external_react_.useEffect)(()=>{
        ref.current.config = Object.assign({
            interval: "auto"
        }, userConfig);
        const id = NativeReanimated/* default */.Z.registerSensor(sensorType, ref.current.config.interval === "auto" ? -1 : ref.current.config.interval, ref.current.sensor);
        if (id !== -1) {
            // if sensor is available
            ref.current.unregister = ()=>NativeReanimated/* default */.Z.unregisterSensor(id);
            ref.current.isAvailable = true;
        } else {
            // if sensor is unavailable
            ref.current.unregister = ()=>{
            // NOOP
            };
            ref.current.isAvailable = false;
        }
        return ()=>{
            ref.current.unregister();
        };
    }, [
        sensorType,
        userConfig
    ]);
    return ref.current;
}

;// CONCATENATED MODULE: ./node_modules/react-native-reanimated/lib/reanimated2/frameCallback/FrameCallbackRegistryUI.js

const prepareUIRegistry = (0,core/* runOnUI */.m_)(()=>{
    "worklet";
    const frameCallbackRegistry = {
        frameCallbackRegistry: new Map(),
        activeFrameCallbacks: new Set(),
        previousFrameTimestamp: null,
        runCallbacks () {
            const loop = (timestamp)=>{
                if (this.previousFrameTimestamp === null) {
                    this.previousFrameTimestamp = timestamp;
                }
                const delta = timestamp - this.previousFrameTimestamp;
                this.activeFrameCallbacks.forEach((callbackId)=>{
                    const callbackDetails = this.frameCallbackRegistry.get(callbackId);
                    const { startTime } = callbackDetails;
                    if (startTime === null) {
                        // First frame
                        callbackDetails.startTime = timestamp;
                        callbackDetails.callback({
                            timestamp,
                            timeSincePreviousFrame: null,
                            timeSinceFirstFrame: 0
                        });
                    } else {
                        // Next frame
                        callbackDetails.callback({
                            timestamp,
                            timeSincePreviousFrame: delta,
                            timeSinceFirstFrame: timestamp - startTime
                        });
                    }
                });
                if (this.activeFrameCallbacks.size > 0) {
                    this.previousFrameTimestamp = timestamp;
                    requestAnimationFrame(loop);
                } else {
                    this.previousFrameTimestamp = null;
                }
            };
            // runCallback() should only be called after registering a callback,
            // so if there is only one active callback, then it means that there were
            // zero previously and the loop isn't running yet.
            if (this.activeFrameCallbacks.size === 1) {
                requestAnimationFrame(loop);
            }
        },
        registerFrameCallback (callback, callbackId) {
            this.frameCallbackRegistry.set(callbackId, {
                callback: callback,
                startTime: null
            });
        },
        unregisterFrameCallback (callbackId) {
            this.manageStateFrameCallback(callbackId, false);
            this.frameCallbackRegistry.delete(callbackId);
        },
        manageStateFrameCallback (callbackId, state) {
            if (callbackId === -1) {
                return;
            }
            if (state) {
                this.activeFrameCallbacks.add(callbackId);
                this.runCallbacks();
            } else {
                const callback = this.frameCallbackRegistry.get(callbackId);
                callback.startTime = null;
                this.activeFrameCallbacks.delete(callbackId);
            }
        }
    };
    global._frameCallbackRegistry = frameCallbackRegistry;
});

;// CONCATENATED MODULE: ./node_modules/react-native-reanimated/lib/reanimated2/frameCallback/FrameCallbackRegistryJS.js


class FrameCallbackRegistryJS {
    constructor(){
        this.nextCallbackId = 0;
        prepareUIRegistry();
    }
    registerFrameCallback(callback) {
        if (!callback) {
            return -1;
        }
        const callbackId = this.nextCallbackId;
        this.nextCallbackId++;
        (0,core/* runOnUI */.m_)(()=>{
            "worklet";
            global._frameCallbackRegistry.registerFrameCallback(callback, callbackId);
        })();
        return callbackId;
    }
    unregisterFrameCallback(callbackId) {
        (0,core/* runOnUI */.m_)(()=>{
            "worklet";
            global._frameCallbackRegistry.unregisterFrameCallback(callbackId);
        })();
    }
    manageStateFrameCallback(callbackId, state) {
        (0,core/* runOnUI */.m_)(()=>{
            "worklet";
            global._frameCallbackRegistry.manageStateFrameCallback(callbackId, state);
        })();
    }
}

;// CONCATENATED MODULE: ./node_modules/react-native-reanimated/lib/reanimated2/hook/useFrameCallback.js


const frameCallbackRegistry = new FrameCallbackRegistryJS();
function useFrameCallback(callback, autostart = true) {
    const ref = (0,external_react_.useRef)({
        setActive: (isActive)=>{
            frameCallbackRegistry.manageStateFrameCallback(ref.current.callbackId, isActive);
            ref.current.isActive = isActive;
        },
        isActive: autostart,
        callbackId: -1
    });
    (0,external_react_.useEffect)(()=>{
        ref.current.callbackId = frameCallbackRegistry.registerFrameCallback(callback);
        ref.current.setActive(ref.current.isActive);
        return ()=>{
            frameCallbackRegistry.unregisterFrameCallback(ref.current.callbackId);
            ref.current.callbackId = -1;
        };
    }, [
        callback,
        autostart
    ]);
    return ref.current;
}

;// CONCATENATED MODULE: ./node_modules/react-native-reanimated/lib/reanimated2/commonTypes.js
var KeyboardState;
(function(KeyboardState) {
    KeyboardState[KeyboardState["UNKNOWN"] = 0] = "UNKNOWN";
    KeyboardState[KeyboardState["OPENING"] = 1] = "OPENING";
    KeyboardState[KeyboardState["OPEN"] = 2] = "OPEN";
    KeyboardState[KeyboardState["CLOSING"] = 3] = "CLOSING";
    KeyboardState[KeyboardState["CLOSED"] = 4] = "CLOSED";
})(KeyboardState || (KeyboardState = {}));

;// CONCATENATED MODULE: ./node_modules/react-native-reanimated/lib/reanimated2/hook/useAnimatedKeyboard.js




function useAnimatedKeyboard() {
    const ref = (0,external_react_.useRef)(null);
    const listenerId = (0,external_react_.useRef)(-1);
    const isSubscribed = (0,external_react_.useRef)(false);
    if (ref.current === null) {
        const keyboardEventData = {
            state: (0,core/* makeMutable */.vG)(KeyboardState.UNKNOWN),
            height: (0,core/* makeMutable */.vG)(0)
        };
        listenerId.current = NativeReanimated/* default */.Z.subscribeForKeyboardEvents(keyboardEventData);
        ref.current = keyboardEventData;
        isSubscribed.current = true;
    }
    (0,external_react_.useEffect)(()=>{
        if (isSubscribed.current === false && ref.current !== null) {
            // subscribe again after Fast Refresh
            listenerId.current = NativeReanimated/* default */.Z.subscribeForKeyboardEvents(ref.current);
            isSubscribed.current = true;
        }
        return ()=>{
            NativeReanimated/* default */.Z.unsubscribeFromKeyboardEvents(listenerId.current);
            isSubscribed.current = false;
        };
    }, []);
    return ref.current;
}

;// CONCATENATED MODULE: ./node_modules/react-native-reanimated/lib/reanimated2/hook/useScrollViewOffset.js




const subscribeForEvents = [
    "onScroll",
    "onScrollBeginDrag",
    "onScrollEndDrag",
    "onMomentumScrollBegin",
    "onMomentumScrollEnd"
];
function useScrollViewOffset(aref) {
    const offsetRef = (0,external_react_.useRef)((0,useSharedValue/* useSharedValue */.y)(0));
    const event = (0,utils/* useEvent */.zX)((event)=>{
        "worklet";
        offsetRef.current.value = event.contentOffset.x === 0 ? event.contentOffset.y : event.contentOffset.x;
    }, subscribeForEvents);
    (0,external_react_.useEffect)(()=>{
        var _a;
        const viewTag = (0,cjs.findNodeHandle)(aref.current);
        (_a = event.current) === null || _a === void 0 ? void 0 : _a.registerForEvents(viewTag);
    }, [
        aref.current
    ]);
    return offsetRef.current;
}

;// CONCATENATED MODULE: ./node_modules/react-native-reanimated/lib/reanimated2/hook/index.js













// EXTERNAL MODULE: ./node_modules/react-native-reanimated/lib/reanimated2/animation/timing.js
var animation_timing = __webpack_require__(63156);
;// CONCATENATED MODULE: ./node_modules/react-native-reanimated/lib/reanimated2/animation/spring.js

function withSpring(toValue, userConfig, callback) {
    "worklet";
    return (0,util/* defineAnimation */.oF)(toValue, ()=>{
        "worklet";
        // TODO: figure out why we can't use spread or Object.assign here
        // when user config is "frozen object" we can't enumerate it (perhaps
        // something is wrong with the object prototype).
        const config = {
            damping: 10,
            mass: 1,
            stiffness: 100,
            overshootClamping: false,
            restDisplacementThreshold: 0.01,
            restSpeedThreshold: 2,
            velocity: 0
        };
        if (userConfig) {
            Object.keys(userConfig).forEach((key)=>config[key] = userConfig[key]);
        }
        function spring(animation, now) {
            const { toValue, lastTimestamp, current, velocity } = animation;
            const deltaTime = Math.min(now - lastTimestamp, 64);
            animation.lastTimestamp = now;
            const c = config.damping;
            const m = config.mass;
            const k = config.stiffness;
            const v0 = -velocity;
            const x0 = toValue - current;
            const zeta = c / (2 * Math.sqrt(k * m)); // damping ratio
            const omega0 = Math.sqrt(k / m); // undamped angular frequency of the oscillator (rad/ms)
            const omega1 = omega0 * Math.sqrt(1 - Math.pow(zeta, 2)); // exponential decay
            const t = deltaTime / 1000;
            const sin1 = Math.sin(omega1 * t);
            const cos1 = Math.cos(omega1 * t);
            // under damped
            const underDampedEnvelope = Math.exp(-zeta * omega0 * t);
            const underDampedFrag1 = underDampedEnvelope * (sin1 * ((v0 + zeta * omega0 * x0) / omega1) + x0 * cos1);
            const underDampedPosition = toValue - underDampedFrag1;
            // This looks crazy -- it's actually just the derivative of the oscillation function
            const underDampedVelocity = zeta * omega0 * underDampedFrag1 - underDampedEnvelope * (cos1 * (v0 + zeta * omega0 * x0) - omega1 * x0 * sin1);
            // critically damped
            const criticallyDampedEnvelope = Math.exp(-omega0 * t);
            const criticallyDampedPosition = toValue - criticallyDampedEnvelope * (x0 + (v0 + omega0 * x0) * t);
            const criticallyDampedVelocity = criticallyDampedEnvelope * (v0 * (t * omega0 - 1) + t * x0 * omega0 * omega0);
            const isOvershooting = ()=>{
                if (config.overshootClamping && config.stiffness !== 0) {
                    return current < toValue ? animation.current > toValue : animation.current < toValue;
                } else {
                    return false;
                }
            };
            const isVelocity = Math.abs(velocity) < config.restSpeedThreshold;
            const isDisplacement = config.stiffness === 0 || Math.abs(toValue - current) < config.restDisplacementThreshold;
            if (zeta < 1) {
                animation.current = underDampedPosition;
                animation.velocity = underDampedVelocity;
            } else {
                animation.current = criticallyDampedPosition;
                animation.velocity = criticallyDampedVelocity;
            }
            if (isOvershooting() || isVelocity && isDisplacement) {
                if (config.stiffness !== 0) {
                    animation.velocity = 0;
                    animation.current = toValue;
                }
                // clear lastTimestamp to avoid using stale value by the next spring animation that starts after this one
                animation.lastTimestamp = 0;
                return true;
            }
            return false;
        }
        function onStart(animation, value, now, previousAnimation) {
            animation.current = value;
            if (previousAnimation) {
                animation.velocity = previousAnimation.velocity || animation.velocity || 0;
                animation.lastTimestamp = previousAnimation.lastTimestamp || now;
            } else {
                animation.lastTimestamp = now;
            }
        }
        return {
            onFrame: spring,
            onStart,
            toValue,
            velocity: config.velocity || 0,
            current: toValue,
            callback,
            lastTimestamp: 0
        };
    });
}

;// CONCATENATED MODULE: ./node_modules/react-native-reanimated/lib/reanimated2/animation/decay.js


function withDecay(userConfig, callback) {
    "worklet";
    return (0,util/* defineAnimation */.oF)(0, ()=>{
        "worklet";
        var _a;
        const config = {
            deceleration: 0.998,
            velocityFactor: cjs.Platform.OS !== "web" ? 1 : 1000,
            velocity: 0
        };
        if (userConfig) {
            Object.keys(userConfig).forEach((key)=>config[key] = userConfig[key]);
        }
        const VELOCITY_EPS = cjs.Platform.OS !== "web" ? 1 : 1 / 20;
        const SLOPE_FACTOR = 0.1;
        function decay(animation, now) {
            const { lastTimestamp, startTimestamp, initialVelocity, current, velocity } = animation;
            const deltaTime = Math.min(now - lastTimestamp, 64);
            const v = velocity * Math.exp(-(1 - config.deceleration) * (now - startTimestamp) * SLOPE_FACTOR);
            animation.current = current + v * config.velocityFactor * deltaTime / 1000; // /1000 because time is in ms not in s
            animation.velocity = v;
            animation.lastTimestamp = now;
            if (config.clamp) {
                if (initialVelocity < 0 && animation.current <= config.clamp[0]) {
                    animation.current = config.clamp[0];
                    return true;
                } else if (initialVelocity > 0 && animation.current >= config.clamp[1]) {
                    animation.current = config.clamp[1];
                    return true;
                }
            }
            return Math.abs(v) < VELOCITY_EPS;
        }
        function validateConfig() {
            if (config.clamp) {
                if (!Array.isArray(config.clamp)) {
                    throw Error(`config.clamp must be an array but is ${typeof config.clamp}`);
                }
                if (config.clamp.length !== 2) {
                    throw Error(`clamp array must contain 2 items but is given ${config.clamp.length}`);
                }
            }
            if (config.velocityFactor <= 0) {
                throw Error(`config.velocityFactor must be greather then 0 but is ${config.velocityFactor}`);
            }
        }
        function onStart(animation, value, now) {
            animation.current = value;
            animation.lastTimestamp = now;
            animation.startTimestamp = now;
            animation.initialVelocity = config.velocity;
            validateConfig();
        }
        return {
            onFrame: decay,
            onStart,
            callback,
            velocity: (_a = config.velocity) !== null && _a !== void 0 ? _a : 0,
            initialVelocity: 0,
            current: 0,
            lastTimestamp: 0,
            startTimestamp: 0
        };
    });
}

;// CONCATENATED MODULE: ./node_modules/react-native-reanimated/lib/reanimated2/animation/delay.js

function withDelay(delayMs, _nextAnimation) {
    "worklet";
    return (0,util/* defineAnimation */.oF)(_nextAnimation, ()=>{
        "worklet";
        const nextAnimation = typeof _nextAnimation === "function" ? _nextAnimation() : _nextAnimation;
        function delay(animation, now) {
            const { startTime, started, previousAnimation } = animation;
            if (now - startTime > delayMs) {
                if (!started) {
                    nextAnimation.onStart(nextAnimation, animation.current, now, previousAnimation);
                    animation.previousAnimation = null;
                    animation.started = true;
                }
                const finished = nextAnimation.onFrame(nextAnimation, now);
                animation.current = nextAnimation.current;
                return finished;
            } else if (previousAnimation) {
                const finished = previousAnimation.finished || previousAnimation.onFrame(previousAnimation, now);
                animation.current = previousAnimation.current;
                if (finished) {
                    animation.previousAnimation = null;
                }
            }
            return false;
        }
        function onStart(animation, value, now, previousAnimation) {
            animation.startTime = now;
            animation.started = false;
            animation.current = value;
            if (previousAnimation === animation) {
                animation.previousAnimation = previousAnimation.previousAnimation;
            } else {
                animation.previousAnimation = previousAnimation;
            }
        }
        const callback = (finished)=>{
            if (nextAnimation.callback) {
                nextAnimation.callback(finished);
            }
        };
        return {
            isHigherOrder: true,
            onFrame: delay,
            onStart,
            current: nextAnimation.current,
            callback,
            previousAnimation: null,
            startTime: 0,
            started: false
        };
    });
}
/**
 * @deprecated Kept for backward compatibility. Will be removed soon.
 */ function delay(delayMs, _nextAnimation) {
    "worklet";
    console.warn("Method `delay` is deprecated. Please use `withDelay` instead");
    return withDelay(delayMs, _nextAnimation);
}

;// CONCATENATED MODULE: ./node_modules/react-native-reanimated/lib/reanimated2/animation/repeat.js

function withRepeat(_nextAnimation, numberOfReps = 2, reverse = false, callback) {
    "worklet";
    return (0,util/* defineAnimation */.oF)(_nextAnimation, ()=>{
        "worklet";
        const nextAnimation = typeof _nextAnimation === "function" ? _nextAnimation() : _nextAnimation;
        function repeat(animation, now) {
            const finished = nextAnimation.onFrame(nextAnimation, now);
            animation.current = nextAnimation.current;
            if (finished) {
                animation.reps += 1;
                // call inner animation's callback on every repetition
                // as the second argument the animation's current value is passed
                if (nextAnimation.callback) {
                    nextAnimation.callback(true, animation.current);
                }
                if (numberOfReps > 0 && animation.reps >= numberOfReps) {
                    return true;
                }
                const startValue = reverse ? nextAnimation.current : animation.startValue;
                if (reverse) {
                    nextAnimation.toValue = animation.startValue;
                    animation.startValue = startValue;
                }
                nextAnimation.onStart(nextAnimation, startValue, now, nextAnimation.previousAnimation);
                return false;
            }
            return false;
        }
        const repCallback = (finished)=>{
            if (callback) {
                callback(finished);
            }
            // when cancelled call inner animation's callback
            if (!finished && nextAnimation.callback) {
                nextAnimation.callback(false);
            }
        };
        function onStart(animation, value, now, previousAnimation) {
            animation.startValue = value;
            animation.reps = 0;
            nextAnimation.onStart(nextAnimation, value, now, previousAnimation);
        }
        return {
            isHigherOrder: true,
            onFrame: repeat,
            onStart,
            reps: 0,
            current: nextAnimation.current,
            callback: repCallback,
            startValue: 0
        };
    });
}
/**
 * @deprecated Kept for backward compatibility. Will be removed soon.
 */ function repeat(_nextAnimation, numberOfReps = 2, reverse = false, callback) {
    "worklet";
    console.warn("Method `repeat` is deprecated. Please use `withRepeat` instead");
    return withRepeat(_nextAnimation, numberOfReps, reverse, callback);
}
function loop(nextAnimation, numberOfLoops = 1) {
    "worklet";
    console.warn("Method `loop` is deprecated. Please use `withRepeat` instead");
    return repeat(nextAnimation, Math.round(numberOfLoops * 2), true);
}

;// CONCATENATED MODULE: ./node_modules/react-native-reanimated/lib/reanimated2/animation/sequence.js

function withSequence(..._animations) {
    "worklet";
    return (0,util/* defineAnimation */.oF)(_animations[0], ()=>{
        "worklet";
        const animations = _animations.map((a)=>{
            const result = typeof a === "function" ? a() : a;
            result.finished = false;
            return result;
        });
        const firstAnimation = animations[0];
        const callback = (finished)=>{
            if (finished) {
                // we want to call the callback after every single animation
                // not after all of them
                return;
            }
            // this is going to be called only if sequence has been cancelled
            animations.forEach((animation)=>{
                if (typeof animation.callback === "function" && !animation.finished) {
                    animation.callback(finished);
                }
            });
        };
        function sequence(animation, now) {
            const currentAnim = animations[animation.animationIndex];
            const finished = currentAnim.onFrame(currentAnim, now);
            animation.current = currentAnim.current;
            if (finished) {
                // we want to call the callback after every single animation
                if (currentAnim.callback) {
                    currentAnim.callback(true);
                }
                currentAnim.finished = true;
                animation.animationIndex += 1;
                if (animation.animationIndex < animations.length) {
                    const nextAnim = animations[animation.animationIndex];
                    nextAnim.onStart(nextAnim, currentAnim.current, now, currentAnim);
                    return false;
                }
                return true;
            }
            return false;
        }
        function onStart(animation, value, now, previousAnimation) {
            animation.animationIndex = 0;
            if (previousAnimation === undefined) {
                previousAnimation = animations[animations.length - 1];
            }
            firstAnimation.onStart(firstAnimation, value, now, previousAnimation);
        }
        return {
            isHigherOrder: true,
            onFrame: sequence,
            onStart,
            animationIndex: 0,
            current: firstAnimation.current,
            callback
        };
    });
}
/**
 * @deprecated Kept for backward compatibility. Will be removed soon.
 */ function sequence(..._animations) {
    "worklet";
    console.warn("Method `sequence` is deprecated. Please use `withSequence` instead");
    return withSequence(..._animations);
}

// EXTERNAL MODULE: ./node_modules/react-native-reanimated/lib/reanimated2/UpdateProps.js
var UpdateProps = __webpack_require__(77544);
// EXTERNAL MODULE: ./node_modules/react-native-reanimated/lib/reanimated2/Colors.js
var Colors = __webpack_require__(5367);
;// CONCATENATED MODULE: ./node_modules/react-native-reanimated/lib/reanimated2/animation/styleAnimation.js




// resolves path to value for nested objects
// if path cannot be resolved returns undefined
function resolvePath(obj, path) {
    "worklet";
    const keys = Array.isArray(path) ? path : [
        path
    ];
    return keys.reduce((acc, current)=>{
        if (Array.isArray(acc) && typeof current === "number") {
            return acc[current];
        } else if (typeof acc === "object" && current in acc) {
            return acc[current];
        }
        return undefined;
    }, obj);
}
function setPath(obj, path, value) {
    "worklet";
    const keys = Array.isArray(path) ? path : [
        path
    ];
    let currObj = obj;
    for(let i = 0; i < keys.length - 1; i++){
        // creates entry if there isn't one
        currObj = currObj;
        if (!(keys[i] in currObj)) {
            // if next key is a number create an array
            if (typeof keys[i + 1] === "number") {
                currObj[keys[i]] = [];
            } else {
                currObj[keys[i]] = {};
            }
        }
        currObj = currObj[keys[i]];
    }
    currObj[keys[keys.length - 1]] = value;
}
function withStyleAnimation(styleAnimations) {
    "worklet";
    return (0,util/* defineAnimation */.oF)({}, ()=>{
        "worklet";
        const onFrame = (animation, now)=>{
            let stillGoing = false;
            const entriesToCheck = [
                {
                    value: animation.styleAnimations,
                    path: []
                }
            ];
            while(entriesToCheck.length > 0){
                const currentEntry = entriesToCheck.pop();
                if (Array.isArray(currentEntry.value)) {
                    for(let index = 0; index < currentEntry.value.length; index++){
                        entriesToCheck.push({
                            value: currentEntry.value[index],
                            path: currentEntry.path.concat(index)
                        });
                    }
                } else if (typeof currentEntry.value === "object" && currentEntry.value.onFrame === undefined) {
                    // nested object
                    for (const key of Object.keys(currentEntry.value)){
                        entriesToCheck.push({
                            value: currentEntry.value[key],
                            path: currentEntry.path.concat(key)
                        });
                    }
                } else {
                    const currentStyleAnimation = currentEntry.value;
                    if (currentStyleAnimation.finished) {
                        continue;
                    }
                    const finished = currentStyleAnimation.onFrame(currentStyleAnimation, now);
                    if (finished) {
                        currentStyleAnimation.finished = true;
                        if (currentStyleAnimation.callback) {
                            currentStyleAnimation.callback(true);
                        }
                    } else {
                        stillGoing = true;
                    }
                    if (UpdateProps/* ColorProperties */.Ue.includes(currentEntry.path[0])) {
                        currentStyleAnimation.current = (0,Colors/* processColor */.aL)(currentStyleAnimation.current);
                    }
                    setPath(animation.current, currentEntry.path, currentStyleAnimation.current);
                }
            }
            return !stillGoing;
        };
        const onStart = (animation, value, now, previousAnimation)=>{
            const entriesToCheck = [
                {
                    value: styleAnimations,
                    path: []
                }
            ];
            while(entriesToCheck.length > 0){
                const currentEntry = entriesToCheck.pop();
                if (Array.isArray(currentEntry.value)) {
                    for(let index = 0; index < currentEntry.value.length; index++){
                        entriesToCheck.push({
                            value: currentEntry.value[index],
                            path: currentEntry.path.concat(index)
                        });
                    }
                } else if (typeof currentEntry.value === "object" && currentEntry.value.onStart === undefined) {
                    for (const key of Object.keys(currentEntry.value)){
                        entriesToCheck.push({
                            value: currentEntry.value[key],
                            path: currentEntry.path.concat(key)
                        });
                    }
                } else {
                    const prevAnimation = resolvePath(previousAnimation === null || previousAnimation === void 0 ? void 0 : previousAnimation.styleAnimations, currentEntry.path);
                    let prevVal = resolvePath(value, currentEntry.path);
                    if (prevAnimation && !prevVal) {
                        prevVal = prevAnimation.current;
                    }
                    if (prevVal === undefined) {
                        console.warn(`Initial values for animation are missing for property ${currentEntry.path.join(".")}`);
                    }
                    setPath(animation.current, currentEntry.path, prevVal);
                    let currentAnimation;
                    if (typeof currentEntry.value !== "object" || !currentEntry.value.onStart) {
                        currentAnimation = (0,animation_timing/* withTiming */.j)(currentEntry.value, {
                            duration: 0
                        });
                        setPath(animation.styleAnimations, currentEntry.path, currentAnimation);
                    } else {
                        currentAnimation = currentEntry.value;
                    }
                    currentAnimation.onStart(currentAnimation, prevVal, now, prevAnimation);
                }
            }
        };
        const callback = (finished)=>{
            if (!finished) {
                const animationsToCheck = [
                    styleAnimations
                ];
                while(animationsToCheck.length > 0){
                    const currentAnimation = animationsToCheck.pop();
                    if (Array.isArray(currentAnimation)) {
                        for (const element of currentAnimation){
                            animationsToCheck.push(element);
                        }
                    } else if (typeof currentAnimation === "object" && currentAnimation.onStart === undefined) {
                        for (const value of Object.values(currentAnimation)){
                            animationsToCheck.push(value);
                        }
                    } else {
                        const currentStyleAnimation = currentAnimation;
                        if (!currentStyleAnimation.finished && currentStyleAnimation.callback) {
                            currentStyleAnimation.callback(false);
                        }
                    }
                }
            }
        };
        return {
            isHigherOrder: true,
            onFrame,
            onStart,
            current: {},
            styleAnimations,
            callback
        };
    });
}

;// CONCATENATED MODULE: ./node_modules/react-native-reanimated/lib/reanimated2/animation/index.js









;// CONCATENATED MODULE: ./node_modules/react-native-reanimated/lib/reanimated2/interpolation.js
// @ts-ignore JS file

var Extrapolation;
(function(Extrapolation) {
    Extrapolation["IDENTITY"] = "identity";
    Extrapolation["CLAMP"] = "clamp";
    Extrapolation["EXTEND"] = "extend";
})(Extrapolation || (Extrapolation = {}));
function isNode(x) {
    "worklet";
    return x.__nodeId !== undefined;
}
function getVal(type, coef, val, leftEdgeOutput, rightEdgeOutput, x) {
    "worklet";
    switch(type){
        case Extrapolation.IDENTITY:
            return x;
        case Extrapolation.CLAMP:
            if (coef * val < coef * leftEdgeOutput) {
                return leftEdgeOutput;
            }
            return rightEdgeOutput;
        case Extrapolation.EXTEND:
        default:
            return val;
    }
}
function isExtrapolate(value) {
    "worklet";
    return value === Extrapolation.EXTEND || value === Extrapolation.CLAMP || value === Extrapolation.IDENTITY;
}
// validates extrapolations type
// if type is correct, converts it to ExtrapolationConfig
function validateType(type) {
    "worklet";
    // initialize extrapolationConfig with default extrapolation
    const extrapolationConfig = {
        extrapolateLeft: Extrapolation.EXTEND,
        extrapolateRight: Extrapolation.EXTEND
    };
    if (!type) {
        return extrapolationConfig;
    }
    if (typeof type === "string") {
        if (!isExtrapolate(type)) {
            throw new Error(`Reanimated: not supported value for "interpolate" \nSupported values: ["extend", "clamp", "identity", Extrapolatation.CLAMP, Extrapolatation.EXTEND, Extrapolatation.IDENTITY]\n Valid example:
        interpolate(value, [inputRange], [outputRange], "clamp")`);
        }
        extrapolationConfig.extrapolateLeft = type;
        extrapolationConfig.extrapolateRight = type;
        return extrapolationConfig;
    }
    // otherwise type is extrapolation config object
    if (type.extrapolateLeft && !isExtrapolate(type.extrapolateLeft) || type.extrapolateRight && !isExtrapolate(type.extrapolateRight)) {
        throw new Error(`Reanimated: not supported value for "interpolate" \nSupported values: ["extend", "clamp", "identity", Extrapolatation.CLAMP, Extrapolatation.EXTEND, Extrapolatation.IDENTITY]\n Valid example:
      interpolate(value, [inputRange], [outputRange], {
        extrapolateLeft: Extrapolation.CLAMP,
        extrapolateRight: Extrapolation.IDENTITY
      }})`);
    }
    Object.assign(extrapolationConfig, type);
    return extrapolationConfig;
}
function internalInterpolate(x, narrowedInput, extrapolationConfig) {
    "worklet";
    const { leftEdgeInput, rightEdgeInput, leftEdgeOutput, rightEdgeOutput } = narrowedInput;
    if (rightEdgeInput - leftEdgeInput === 0) return leftEdgeOutput;
    const progress = (x - leftEdgeInput) / (rightEdgeInput - leftEdgeInput);
    const val = leftEdgeOutput + progress * (rightEdgeOutput - leftEdgeOutput);
    const coef = rightEdgeOutput >= leftEdgeOutput ? 1 : -1;
    if (coef * val < coef * leftEdgeOutput) {
        return getVal(extrapolationConfig.extrapolateLeft, coef, val, leftEdgeOutput, rightEdgeOutput, x);
    } else if (coef * val > coef * rightEdgeOutput) {
        return getVal(extrapolationConfig.extrapolateRight, coef, val, leftEdgeOutput, rightEdgeOutput, x);
    }
    return val;
}
// TODO: support default values in worklets:
// e.g. function interpolate(x, input, output, type = Extrapolatation.CLAMP)
function interpolation_interpolate(x, input, output, type) {
    "worklet";
    if (input.length < 2 || output.length < 2) {
        throw Error("Interpolation input and output should contain at least two values.");
    }
    const extrapolationConfig = validateType(type);
    if (isNode(x)) {
        console.warn(`interpolate() was renamed to interpolateNode() in Reanimated 2. Please use interpolateNode() instead`);
        return interpolate(x, {
            inputRange: input,
            outputRange: output,
            extrapolateLeft: extrapolationConfig.extrapolateLeft,
            extrapolateRight: extrapolationConfig.extrapolateRight
        });
    }
    const length = input.length;
    const narrowedInput = {
        leftEdgeInput: input[0],
        rightEdgeInput: input[1],
        leftEdgeOutput: output[0],
        rightEdgeOutput: output[1]
    };
    if (length > 2) {
        if (x > input[length - 1]) {
            narrowedInput.leftEdgeInput = input[length - 2];
            narrowedInput.rightEdgeInput = input[length - 1];
            narrowedInput.leftEdgeOutput = output[length - 2];
            narrowedInput.rightEdgeOutput = output[length - 1];
        } else {
            for(let i = 1; i < length; ++i){
                if (x <= input[i]) {
                    narrowedInput.leftEdgeInput = input[i - 1];
                    narrowedInput.rightEdgeInput = input[i];
                    narrowedInput.leftEdgeOutput = output[i - 1];
                    narrowedInput.rightEdgeOutput = output[i];
                    break;
                }
            }
        }
    }
    return internalInterpolate(x, narrowedInput, extrapolationConfig);
}

;// CONCATENATED MODULE: ./node_modules/react-native-reanimated/lib/reanimated2/interpolateColor.js



// @ts-ignore JS file


const interpolateColorsHSV = (value, inputRange, colors, options)=>{
    "worklet";
    let h = 0;
    const { useCorrectedHSVInterpolation = true } = options;
    if (useCorrectedHSVInterpolation) {
        // if the difference between hues in a range is > 180 deg
        // then move the hue at the right end of the range +/- 360 deg
        // and add the next point in the original place + 0.00001 with original hue
        // to not break the next range
        const correctedInputRange = [
            inputRange[0]
        ];
        const originalH = colors.h;
        const correctedH = [
            originalH[0]
        ];
        for(let i = 1; i < originalH.length; ++i){
            const d = originalH[i] - originalH[i - 1];
            if (originalH[i] > originalH[i - 1] && d > 0.5) {
                correctedInputRange.push(inputRange[i]);
                correctedInputRange.push(inputRange[i] + 0.00001);
                correctedH.push(originalH[i] - 1);
                correctedH.push(originalH[i]);
            } else if (originalH[i] < originalH[i - 1] && d < -0.5) {
                correctedInputRange.push(inputRange[i]);
                correctedInputRange.push(inputRange[i] + 0.00001);
                correctedH.push(originalH[i] + 1);
                correctedH.push(originalH[i]);
            } else {
                correctedInputRange.push(inputRange[i]);
                correctedH.push(originalH[i]);
            }
        }
        h = (interpolation_interpolate(value, correctedInputRange, correctedH, Extrapolate.CLAMP) + 1) % 1;
    } else {
        h = interpolation_interpolate(value, inputRange, colors.h, Extrapolate.CLAMP);
    }
    const s = interpolation_interpolate(value, inputRange, colors.s, Extrapolate.CLAMP);
    const v = interpolation_interpolate(value, inputRange, colors.v, Extrapolate.CLAMP);
    const a = interpolation_interpolate(value, inputRange, colors.a, Extrapolate.CLAMP);
    return (0,Colors/* hsvToColor */.De)(h, s, v, a);
};
const toLinearSpace = (x, gamma)=>{
    "worklet";
    return x.map((v)=>Math.pow(v / 255, gamma));
};
const toGammaSpace = (x, gamma)=>{
    "worklet";
    return Math.round(Math.pow(x, 1 / gamma) * 255);
};
const interpolateColorsRGB = (value, inputRange, colors, options)=>{
    "worklet";
    const { gamma = 2.2 } = options;
    let { r: outputR, g: outputG, b: outputB } = colors;
    if (gamma !== 1) {
        outputR = toLinearSpace(outputR, gamma);
        outputG = toLinearSpace(outputG, gamma);
        outputB = toLinearSpace(outputB, gamma);
    }
    const r = interpolation_interpolate(value, inputRange, outputR, Extrapolate.CLAMP);
    const g = interpolation_interpolate(value, inputRange, outputG, Extrapolate.CLAMP);
    const b = interpolation_interpolate(value, inputRange, outputB, Extrapolate.CLAMP);
    const a = interpolation_interpolate(value, inputRange, colors.a, Extrapolate.CLAMP);
    if (gamma === 1) {
        return (0,Colors/* rgbaColor */.qX)(r, g, b, a);
    }
    return (0,Colors/* rgbaColor */.qX)(toGammaSpace(r, gamma), toGammaSpace(g, gamma), toGammaSpace(b, gamma), a);
};
const getInterpolateRGB = (colors)=>{
    "worklet";
    const r = [];
    const g = [];
    const b = [];
    const a = [];
    for(let i = 0; i < colors.length; ++i){
        const color = colors[i];
        const processedColor = (0,Colors/* processColor */.aL)(color);
        // explicit check in case if processedColor is 0
        if (processedColor !== null && processedColor !== undefined) {
            r.push((0,Colors/* red */.Q6)(processedColor));
            g.push((0,Colors/* green */.ek)(processedColor));
            b.push((0,Colors/* blue */.iN)(processedColor));
            a.push((0,Colors/* opacity */.Oh)(processedColor));
        }
    }
    return {
        r,
        g,
        b,
        a
    };
};
const getInterpolateHSV = (colors)=>{
    "worklet";
    const h = [];
    const s = [];
    const v = [];
    const a = [];
    for(let i = 0; i < colors.length; ++i){
        const color = colors[i];
        const processedColor = (0,Colors/* processColor */.aL)(color);
        if (typeof processedColor === "number") {
            const processedHSVColor = (0,Colors/* RGBtoHSV */.Ls)((0,Colors/* red */.Q6)(processedColor), (0,Colors/* green */.ek)(processedColor), (0,Colors/* blue */.iN)(processedColor));
            h.push(processedHSVColor.h);
            s.push(processedHSVColor.s);
            v.push(processedHSVColor.v);
            a.push((0,Colors/* opacity */.Oh)(processedColor));
        }
    }
    return {
        h,
        s,
        v,
        a
    };
};
const interpolateColor = (value, inputRange, outputRange, colorSpace = "RGB", options = {})=>{
    "worklet";
    if (colorSpace === "HSV") {
        return interpolateColorsHSV(value, inputRange, getInterpolateHSV(outputRange), options);
    } else if (colorSpace === "RGB") {
        return interpolateColorsRGB(value, inputRange, getInterpolateRGB(outputRange), options);
    }
    throw new Error(`Invalid color space provided: ${colorSpace}. Supported values are: ['RGB', 'HSV']`);
};
var ColorSpace;
(function(ColorSpace) {
    ColorSpace[ColorSpace["RGB"] = 0] = "RGB";
    ColorSpace[ColorSpace["HSV"] = 1] = "HSV";
})(ColorSpace || (ColorSpace = {}));
function useInterpolateConfig(inputRange, outputRange, colorSpace = ColorSpace.RGB, options = {}) {
    return (0,useSharedValue/* useSharedValue */.y)({
        inputRange,
        outputRange,
        colorSpace,
        cache: (0,core/* makeMutable */.vG)(null),
        options
    });
}
const interpolateSharableColor = (value, interpolateConfig)=>{
    "worklet";
    let colors = interpolateConfig.value.cache.value;
    if (interpolateConfig.value.colorSpace === ColorSpace.RGB) {
        if (!colors) {
            colors = getInterpolateRGB(interpolateConfig.value.outputRange);
            interpolateConfig.value.cache.value = colors;
        }
        return interpolateColorsRGB(value, interpolateConfig.value.inputRange, colors, interpolateConfig.value.options);
    } else if (interpolateConfig.value.colorSpace === ColorSpace.HSV) {
        if (!colors) {
            colors = getInterpolateHSV(interpolateConfig.value.outputRange);
            interpolateConfig.value.cache.value = colors;
        }
        return interpolateColorsHSV(value, interpolateConfig.value.inputRange, colors, interpolateConfig.value.options);
    }
    throw new Error(`Invalid color space provided: ${interpolateConfig.value.colorSpace}. Supported values are: ['RGB', 'HSV']`);
};

// EXTERNAL MODULE: ./node_modules/react-native-reanimated/lib/reanimated2/Easing.js + 1 modules
var reanimated2_Easing = __webpack_require__(89890);
;// CONCATENATED MODULE: ./node_modules/react-native-reanimated/lib/reanimated2/PropAdapters.js

function createAnimatedPropAdapter(adapter, nativeProps) {
    const nativePropsToAdd = {};
    // eslint-disable-next-line no-unused-expressions
    nativeProps === null || nativeProps === void 0 ? void 0 : nativeProps.forEach((prop)=>{
        nativePropsToAdd[prop] = true;
    });
    addWhitelistedNativeProps(nativePropsToAdd);
    return adapter;
}
// ADAPTERS
const SVGAdapter = createAnimatedPropAdapter((props)=>{
    "worklet";
    var _a, _b;
    const keys = Object.keys(props);
    // transform
    if (keys.includes("transform")) {
        if (Array.isArray(props.transform)) {
            // case of array with 6 values => https://github.com/react-native-svg/react-native-svg/blob/b2e2c355204ff4b10973d3afce1495f7e4167ff7/src/elements/Shape.tsx#L200
            if (props.transform.length !== 6) {
                throw new Error(`invalid transform length of ${props.transform.length}, should be 6`);
            }
            const transform = props.transform;
            const x = (_a = props.x) !== null && _a !== void 0 ? _a : 0;
            const y = (_b = props.y) !== null && _b !== void 0 ? _b : 0;
            props.transform = [
                {
                    translateX: transform[0] * x + transform[2] * y + transform[4]
                },
                {
                    translateY: transform[1] * x + transform[3] * y + transform[5]
                }
            ];
        } else if (typeof props.transform === "string") {
            // case of string 'translate(translateX translateY)'
            // todo: handle other cases of transform string like here https://github.com/react-native-svg/react-native-svg/blob/b2e2c355204ff4b10973d3afce1495f7e4167ff7/src/lib/extract/extractTransform.ts#L184
            const transform = props.transform;
            const arr = transform.replace("translate(", "").replace(")", "").split(" ");
            props.transform = [
                {
                    translateX: parseFloat(arr[0])
                },
                {
                    translateY: parseFloat(arr[1])
                }
            ];
        }
    }
// todo: other props
});
const TextInputAdapter = createAnimatedPropAdapter((props)=>{
    "worklet";
    const keys = Object.keys(props);
    // convert text to value like RN does here: https://github.com/facebook/react-native/blob/f2c6279ca497b34d5a2bfbb6f2d33dc7a7bea02a/Libraries/Components/TextInput/TextInput.js#L878
    if (keys.includes("value")) {
        props.text = props.value;
        delete props.value;
    }
}, [
    "text"
]);

;// CONCATENATED MODULE: ./node_modules/react-native-reanimated/lib/reanimated2/layoutReanimation/animationBuilder/BaseAnimationBuilder.js

class BaseAnimationBuilder {
    constructor(){
        this.randomizeDelay = false;
        this.build = ()=>{
            throw Error("Unimplemented method in child class.");
        };
    }
    static duration(durationMs) {
        const instance = this.createInstance();
        return instance.duration(durationMs);
    }
    duration(durationMs) {
        this.durationV = durationMs;
        return this;
    }
    static delay(delayMs) {
        const instance = this.createInstance();
        return instance.delay(delayMs);
    }
    delay(delayMs) {
        this.delayV = delayMs;
        return this;
    }
    static withCallback(callback) {
        const instance = this.createInstance();
        return instance.withCallback(callback);
    }
    withCallback(callback) {
        this.callbackV = callback;
        return this;
    }
    // 300ms is the default animation duration. If any animation has different default has to override this method.
    static getDuration() {
        return 300;
    }
    getDuration() {
        var _a;
        return (_a = this.durationV) !== null && _a !== void 0 ? _a : 300;
    }
    static randomDelay() {
        const instance = this.createInstance();
        return instance.randomDelay();
    }
    randomDelay() {
        this.randomizeDelay = true;
        return this;
    }
    // when randomizeDelay is set to true, randomize delay between 0 and provided value (or 1000ms if delay is not provided)
    getDelay() {
        var _a, _b;
        return this.randomizeDelay ? Math.random() * ((_a = this.delayV) !== null && _a !== void 0 ? _a : 1000) : (_b = this.delayV) !== null && _b !== void 0 ? _b : 0;
    }
    getDelayFunction() {
        const isDelayProvided = this.randomizeDelay || this.delayV;
        return isDelayProvided ? withDelay : (_, animation)=>{
            "worklet";
            return animation;
        };
    }
    static build() {
        const instance = this.createInstance();
        return instance.build();
    }
}

;// CONCATENATED MODULE: ./node_modules/react-native-reanimated/lib/reanimated2/layoutReanimation/animationBuilder/ComplexAnimationBuilder.js


class ComplexAnimationBuilder extends BaseAnimationBuilder {
    static easing(easingFunction) {
        const instance = this.createInstance();
        return instance.easing(easingFunction);
    }
    easing(easingFunction) {
        this.easingV = easingFunction;
        return this;
    }
    static rotate(degree) {
        const instance = this.createInstance();
        return instance.rotate(degree);
    }
    rotate(degree) {
        this.rotateV = degree;
        return this;
    }
    static springify() {
        const instance = this.createInstance();
        return instance.springify();
    }
    springify() {
        this.type = withSpring;
        return this;
    }
    static damping(damping) {
        const instance = this.createInstance();
        return instance.damping(damping);
    }
    damping(damping) {
        this.dampingV = damping;
        return this;
    }
    static mass(mass) {
        const instance = this.createInstance();
        return instance.mass(mass);
    }
    mass(mass) {
        this.massV = mass;
        return this;
    }
    static stiffness(stiffness) {
        const instance = this.createInstance();
        return instance.stiffness(stiffness);
    }
    stiffness(stiffness) {
        this.stiffnessV = stiffness;
        return this;
    }
    static overshootClamping(overshootClamping) {
        const instance = this.createInstance();
        return instance.overshootClamping(overshootClamping);
    }
    overshootClamping(overshootClamping) {
        this.overshootClampingV = overshootClamping;
        return this;
    }
    static restDisplacementThreshold(restDisplacementThreshold) {
        const instance = this.createInstance();
        return instance.restDisplacementThreshold(restDisplacementThreshold);
    }
    restDisplacementThreshold(restDisplacementThreshold) {
        this.restDisplacementThresholdV = restDisplacementThreshold;
        return this;
    }
    static restSpeedThreshold(restSpeedThreshold) {
        const instance = this.createInstance();
        return instance.restSpeedThreshold(restSpeedThreshold);
    }
    restSpeedThreshold(restSpeedThreshold) {
        this.restSpeedThresholdV = restSpeedThreshold;
        return this;
    }
    static withInitialValues(values) {
        const instance = this.createInstance();
        return instance.withInitialValues(values);
    }
    withInitialValues(values) {
        this.initialValues = values;
        return this;
    }
    getAnimationAndConfig() {
        const duration = this.durationV;
        const easing = this.easingV;
        const rotate = this.rotateV;
        const type = this.type ? this.type : animation_timing/* withTiming */.j;
        const damping = this.dampingV;
        const mass = this.massV;
        const stiffness = this.stiffnessV;
        const overshootClamping = this.overshootClampingV;
        const restDisplacementThreshold = this.restDisplacementThresholdV;
        const restSpeedThreshold = this.restSpeedThresholdV;
        const animation = type;
        const config = {};
        if (type === animation_timing/* withTiming */.j) {
            if (easing) {
                config.easing = easing;
            }
            if (duration) {
                config.duration = duration;
            }
            if (rotate) {
                config.rotate = rotate;
            }
        } else {
            if (damping) {
                config.damping = damping;
            }
            if (mass) {
                config.mass = mass;
            }
            if (stiffness) {
                config.stiffness = stiffness;
            }
            if (overshootClamping) {
                config.overshootClamping = overshootClamping;
            }
            if (restDisplacementThreshold) {
                config.restDisplacementThreshold = restDisplacementThreshold;
            }
            if (restSpeedThreshold) {
                config.restSpeedThreshold = restSpeedThreshold;
            }
            if (rotate) {
                config.rotate = rotate;
            }
        }
        return [
            animation,
            config
        ];
    }
}

;// CONCATENATED MODULE: ./node_modules/react-native-reanimated/lib/reanimated2/layoutReanimation/animationBuilder/Keyframe.js


class Keyframe {
    /*
      Keyframe definition should be passed in the constructor as the map
      which keys are between range 0 - 100 (%) and correspond to the point in the animation progress.
    */ constructor(definitions){
        this.build = ()=>{
            const delay = this.delayV;
            const delayFunction = this.getDelayFunction();
            const { keyframes, initialValues } = this.parseDefinitions();
            const callback = this.callbackV;
            return (_targetValues)=>{
                "worklet";
                const animations = {};
                /*
                      For each style property, an animations sequence is created that corresponds with its key points.
                      Transform style properties require special handling because of their nested structure.
                */ const addAnimation = (key)=>{
                    var _a;
                    const keyframePoints = keyframes[key];
                    // in case if property was only passed as initial value
                    if (keyframePoints.length === 0) return;
                    const animation = delayFunction(delay, keyframePoints.length === 1 ? (0,animation_timing/* withTiming */.j)(keyframePoints[0].value, {
                        duration: keyframePoints[0].duration,
                        easing: keyframePoints[0].easing ? keyframePoints[0].easing : reanimated2_Easing/* Easing */.o.linear
                    }) : withSequence.apply(this, keyframePoints.map((keyframePoint)=>(0,animation_timing/* withTiming */.j)(keyframePoint.value, {
                            duration: keyframePoint.duration,
                            easing: keyframePoint.easing ? keyframePoint.easing : reanimated2_Easing/* Easing */.o.linear
                        }))));
                    if (key.includes("transform")) {
                        if (!("transform" in animations)) {
                            animations.transform = [];
                        }
                        (_a = animations.transform) === null || _a === void 0 ? void 0 : _a.push({
                            [key.split(":")[1]]: animation
                        });
                    } else {
                        animations[key] = animation;
                    }
                };
                Object.keys(initialValues).forEach((key)=>{
                    if (key.includes("transform")) {
                        initialValues[key].forEach((transformProp, index)=>{
                            Object.keys(transformProp).forEach((transformPropKey)=>{
                                addAnimation(index.toString() + "_transform:" + transformPropKey);
                            });
                        });
                    } else {
                        addAnimation(key);
                    }
                });
                return {
                    animations: animations,
                    initialValues: initialValues,
                    callback: callback
                };
            };
        };
        this.definitions = definitions;
    }
    parseDefinitions() {
        /*
            Each style property contain an array with all their key points:
            value, duration of transition to that value, and optional easing function (defaults to Linear)
        */ const parsedKeyframes = {};
        /*
          Parsing keyframes 'from' and 'to'.
        */ if (this.definitions.from) {
            if (this.definitions["0"]) {
                throw Error("You cannot provide both keyframe 0 and 'from' as they both specified initial values");
            }
            this.definitions["0"] = this.definitions.from;
            delete this.definitions.from;
        }
        if (this.definitions.to) {
            if (this.definitions["100"]) {
                throw Error("You cannot provide both keyframe 100 and 'to' as they both specified values at the end of the animation.");
            }
            this.definitions["100"] = this.definitions.to;
            delete this.definitions.to;
        }
        /*
           One of the assumptions is that keyframe  0 is required to properly set initial values.
           Every other keyframe should contain properties from the set provided as initial values.
        */ if (!this.definitions["0"]) {
            throw Error("Please provide 0, or 'from' keyframe with initial state of your object.");
        }
        const initialValues = this.definitions["0"];
        /*
          Initialize parsedKeyframes for properties provided in initial keyframe
        */ Object.keys(initialValues).forEach((styleProp)=>{
            var _a;
            if (styleProp === "transform") {
                (_a = initialValues[styleProp]) === null || _a === void 0 ? void 0 : _a.forEach((transformStyle, index)=>{
                    Object.keys(transformStyle).forEach((transformProp)=>{
                        parsedKeyframes[index.toString() + "_transform:" + transformProp] = [];
                    });
                });
            } else {
                parsedKeyframes[styleProp] = [];
            }
        });
        const duration = this.durationV ? this.durationV : 500;
        const animationKeyPoints = Array.from(Object.keys(this.definitions));
        const getAnimationDuration = (key, currentKeyPoint)=>{
            const maxDuration = currentKeyPoint / 100 * duration;
            const currentDuration = parsedKeyframes[key].reduce((acc, value)=>acc + value.duration, 0);
            return maxDuration - currentDuration;
        };
        /*
           Other keyframes can't contain properties that were not specified in initial keyframe.
        */ const addKeyPoint = ({ key, value, currentKeyPoint, easing })=>{
            if (!(key in parsedKeyframes)) {
                throw Error("Keyframe can contain only that set of properties that were provide with initial values (keyframe 0 or 'from')");
            }
            parsedKeyframes[key].push({
                duration: getAnimationDuration(key, currentKeyPoint),
                value: value,
                easing: easing
            });
        };
        animationKeyPoints.filter((value)=>parseInt(value) !== 0).sort((a, b)=>parseInt(a) - parseInt(b)).forEach((keyPoint)=>{
            if (parseInt(keyPoint) < 0 || parseInt(keyPoint) > 100) {
                throw Error("Keyframe should be in between range 0 - 100.");
            }
            const keyframe = this.definitions[keyPoint];
            const easing = keyframe.easing;
            delete keyframe.easing;
            const addKeyPointWith = (key, value)=>addKeyPoint({
                    key,
                    value,
                    currentKeyPoint: parseInt(keyPoint),
                    easing
                });
            Object.keys(keyframe).forEach((key)=>{
                var _a;
                if (key === "transform") {
                    (_a = keyframe[key]) === null || _a === void 0 ? void 0 : _a.forEach((transformStyle, index)=>{
                        Object.keys(transformStyle).forEach((transformProp)=>{
                            addKeyPointWith(index.toString() + "_transform:" + transformProp, transformStyle[transformProp]);
                        });
                    });
                } else {
                    addKeyPointWith(key, keyframe[key]);
                }
            });
        });
        return {
            initialValues: initialValues,
            keyframes: parsedKeyframes
        };
    }
    duration(durationMs) {
        this.durationV = durationMs;
        return this;
    }
    delay(delayMs) {
        this.delayV = delayMs;
        return this;
    }
    withCallback(callback) {
        this.callbackV = callback;
        return this;
    }
    getDelayFunction() {
        const delay = this.delayV;
        return delay ? withDelay : (_, animation)=>{
            "worklet";
            return animation;
        };
    }
}

;// CONCATENATED MODULE: ./node_modules/react-native-reanimated/lib/reanimated2/layoutReanimation/animationBuilder/index.js




;// CONCATENATED MODULE: ./node_modules/react-native-reanimated/lib/reanimated2/layoutReanimation/defaultAnimations/Flip.js

class FlipInXUp extends ComplexAnimationBuilder {
    constructor(){
        super(...arguments);
        this.build = ()=>{
            const delayFunction = this.getDelayFunction();
            const [animation, config] = this.getAnimationAndConfig();
            const delay = this.getDelay();
            const callback = this.callbackV;
            const initialValues = this.initialValues;
            return (targetValues)=>{
                "worklet";
                return {
                    initialValues: Object.assign({
                        transform: [
                            {
                                perspective: 500
                            },
                            {
                                rotateX: "90deg"
                            },
                            {
                                translateY: -targetValues.targetHeight
                            }
                        ]
                    }, initialValues),
                    animations: {
                        transform: [
                            {
                                perspective: 500
                            },
                            {
                                rotateX: delayFunction(delay, animation("0deg", config))
                            },
                            {
                                translateY: delayFunction(delay, animation(0, config))
                            }
                        ]
                    },
                    callback: callback
                };
            };
        };
    }
    static createInstance() {
        return new FlipInXUp();
    }
}
class FlipInYLeft extends ComplexAnimationBuilder {
    constructor(){
        super(...arguments);
        this.build = ()=>{
            const delayFunction = this.getDelayFunction();
            const [animation, config] = this.getAnimationAndConfig();
            const delay = this.getDelay();
            const callback = this.callbackV;
            const initialValues = this.initialValues;
            return (targetValues)=>{
                "worklet";
                return {
                    initialValues: Object.assign({
                        transform: [
                            {
                                perspective: 500
                            },
                            {
                                rotateY: "-90deg"
                            },
                            {
                                translateX: -targetValues.targetWidth
                            }
                        ]
                    }, initialValues),
                    animations: {
                        transform: [
                            {
                                perspective: delayFunction(delay, animation(500, config))
                            },
                            {
                                rotateY: delayFunction(delay, animation("0deg", config))
                            },
                            {
                                translateX: delayFunction(delay, animation(0, config))
                            }
                        ]
                    },
                    callback: callback
                };
            };
        };
    }
    static createInstance() {
        return new FlipInYLeft();
    }
}
class FlipInXDown extends ComplexAnimationBuilder {
    constructor(){
        super(...arguments);
        this.build = ()=>{
            const delayFunction = this.getDelayFunction();
            const [animation, config] = this.getAnimationAndConfig();
            const delay = this.getDelay();
            const callback = this.callbackV;
            const initialValues = this.initialValues;
            return (targetValues)=>{
                "worklet";
                return {
                    initialValues: Object.assign({
                        transform: [
                            {
                                perspective: 500
                            },
                            {
                                rotateX: "-90deg"
                            },
                            {
                                translateY: targetValues.targetHeight
                            }
                        ]
                    }, initialValues),
                    animations: {
                        transform: [
                            {
                                perspective: delayFunction(delay, animation(500, config))
                            },
                            {
                                rotateX: delayFunction(delay, animation("0deg", config))
                            },
                            {
                                translateY: delayFunction(delay, animation(0, config))
                            }
                        ]
                    },
                    callback: callback
                };
            };
        };
    }
    static createInstance() {
        return new FlipInXDown();
    }
}
class FlipInYRight extends ComplexAnimationBuilder {
    constructor(){
        super(...arguments);
        this.build = ()=>{
            const delayFunction = this.getDelayFunction();
            const [animation, config] = this.getAnimationAndConfig();
            const delay = this.getDelay();
            const callback = this.callbackV;
            const initialValues = this.initialValues;
            return (targetValues)=>{
                "worklet";
                return {
                    initialValues: Object.assign({
                        transform: [
                            {
                                perspective: 500
                            },
                            {
                                rotateY: "90deg"
                            },
                            {
                                translateX: targetValues.targetWidth
                            }
                        ]
                    }, initialValues),
                    animations: {
                        transform: [
                            {
                                perspective: delayFunction(delay, animation(500, config))
                            },
                            {
                                rotateY: delayFunction(delay, animation("0deg", config))
                            },
                            {
                                translateX: delayFunction(delay, animation(0, config))
                            }
                        ]
                    },
                    callback: callback
                };
            };
        };
    }
    static createInstance() {
        return new FlipInYRight();
    }
}
class FlipInEasyX extends ComplexAnimationBuilder {
    constructor(){
        super(...arguments);
        this.build = ()=>{
            const delayFunction = this.getDelayFunction();
            const [animation, config] = this.getAnimationAndConfig();
            const delay = this.getDelay();
            const callback = this.callbackV;
            const initialValues = this.initialValues;
            return ()=>{
                "worklet";
                return {
                    initialValues: Object.assign({
                        transform: [
                            {
                                perspective: 500
                            },
                            {
                                rotateX: "90deg"
                            }
                        ]
                    }, initialValues),
                    animations: {
                        transform: [
                            {
                                perspective: delayFunction(delay, animation(500, config))
                            },
                            {
                                rotateX: delayFunction(delay, animation("0deg", config))
                            }
                        ]
                    },
                    callback: callback
                };
            };
        };
    }
    static createInstance() {
        return new FlipInEasyX();
    }
}
class FlipInEasyY extends ComplexAnimationBuilder {
    constructor(){
        super(...arguments);
        this.build = ()=>{
            const delayFunction = this.getDelayFunction();
            const [animation, config] = this.getAnimationAndConfig();
            const delay = this.getDelay();
            const callback = this.callbackV;
            const initialValues = this.initialValues;
            return ()=>{
                "worklet";
                return {
                    initialValues: Object.assign({
                        transform: [
                            {
                                perspective: 500
                            },
                            {
                                rotateY: "90deg"
                            }
                        ]
                    }, initialValues),
                    animations: {
                        transform: [
                            {
                                perspective: delayFunction(delay, animation(500, config))
                            },
                            {
                                rotateY: delayFunction(delay, animation("0deg", config))
                            }
                        ]
                    },
                    callback: callback
                };
            };
        };
    }
    static createInstance() {
        return new FlipInEasyY();
    }
}
class FlipOutXUp extends ComplexAnimationBuilder {
    constructor(){
        super(...arguments);
        this.build = ()=>{
            const delayFunction = this.getDelayFunction();
            const [animation, config] = this.getAnimationAndConfig();
            const delay = this.getDelay();
            const callback = this.callbackV;
            const initialValues = this.initialValues;
            return (targetValues)=>{
                "worklet";
                return {
                    initialValues: Object.assign({
                        transform: [
                            {
                                perspective: 500
                            },
                            {
                                rotateX: "0deg"
                            },
                            {
                                translateY: 0
                            }
                        ]
                    }, initialValues),
                    animations: {
                        transform: [
                            {
                                perspective: delayFunction(delay, animation(500, config))
                            },
                            {
                                rotateX: delayFunction(delay, animation("90deg", config))
                            },
                            {
                                translateY: delayFunction(delay, animation(-targetValues.currentHeight, config))
                            }
                        ]
                    },
                    callback: callback
                };
            };
        };
    }
    static createInstance() {
        return new FlipOutXUp();
    }
}
class FlipOutYLeft extends ComplexAnimationBuilder {
    constructor(){
        super(...arguments);
        this.build = ()=>{
            const delayFunction = this.getDelayFunction();
            const [animation, config] = this.getAnimationAndConfig();
            const delay = this.getDelay();
            const callback = this.callbackV;
            const initialValues = this.initialValues;
            return (targetValues)=>{
                "worklet";
                return {
                    initialValues: Object.assign({
                        transform: [
                            {
                                perspective: 500
                            },
                            {
                                rotateY: "0deg"
                            },
                            {
                                translateX: 0
                            }
                        ]
                    }, initialValues),
                    animations: {
                        transform: [
                            {
                                perspective: delayFunction(delay, animation(500, config))
                            },
                            {
                                rotateY: delayFunction(delay, animation("-90deg", config))
                            },
                            {
                                translateX: delayFunction(delay, animation(-targetValues.currentWidth, config))
                            }
                        ]
                    },
                    callback: callback
                };
            };
        };
    }
    static createInstance() {
        return new FlipOutYLeft();
    }
}
class FlipOutXDown extends ComplexAnimationBuilder {
    constructor(){
        super(...arguments);
        this.build = ()=>{
            const delayFunction = this.getDelayFunction();
            const [animation, config] = this.getAnimationAndConfig();
            const delay = this.getDelay();
            const callback = this.callbackV;
            const initialValues = this.initialValues;
            return (targetValues)=>{
                "worklet";
                return {
                    initialValues: Object.assign({
                        transform: [
                            {
                                perspective: 500
                            },
                            {
                                rotateX: "0deg"
                            },
                            {
                                translateY: 0
                            }
                        ]
                    }, initialValues),
                    animations: {
                        transform: [
                            {
                                perspective: delayFunction(delay, animation(500, config))
                            },
                            {
                                rotateX: delayFunction(delay, animation("-90deg", config))
                            },
                            {
                                translateY: delayFunction(delay, animation(targetValues.currentHeight, config))
                            }
                        ]
                    },
                    callback: callback
                };
            };
        };
    }
    static createInstance() {
        return new FlipOutXDown();
    }
}
class FlipOutYRight extends ComplexAnimationBuilder {
    constructor(){
        super(...arguments);
        this.build = ()=>{
            const delayFunction = this.getDelayFunction();
            const [animation, config] = this.getAnimationAndConfig();
            const delay = this.getDelay();
            const callback = this.callbackV;
            const initialValues = this.initialValues;
            return (targetValues)=>{
                "worklet";
                return {
                    initialValues: Object.assign({
                        transform: [
                            {
                                perspective: 500
                            },
                            {
                                rotateY: "0deg"
                            },
                            {
                                translateX: 0
                            }
                        ]
                    }, initialValues),
                    animations: {
                        transform: [
                            {
                                perspective: delayFunction(delay, animation(500, config))
                            },
                            {
                                rotateY: delayFunction(delay, animation("90deg", config))
                            },
                            {
                                translateX: delayFunction(delay, animation(targetValues.currentWidth, config))
                            }
                        ]
                    },
                    callback: callback
                };
            };
        };
    }
    static createInstance() {
        return new FlipOutYRight();
    }
}
class FlipOutEasyX extends ComplexAnimationBuilder {
    constructor(){
        super(...arguments);
        this.build = ()=>{
            const delayFunction = this.getDelayFunction();
            const [animation, config] = this.getAnimationAndConfig();
            const delay = this.getDelay();
            const callback = this.callbackV;
            const initialValues = this.initialValues;
            return ()=>{
                "worklet";
                return {
                    initialValues: Object.assign({
                        transform: [
                            {
                                perspective: 500
                            },
                            {
                                rotateX: "0deg"
                            }
                        ]
                    }, initialValues),
                    animations: {
                        transform: [
                            {
                                perspective: delayFunction(delay, animation(500, config))
                            },
                            {
                                rotateX: delayFunction(delay, animation("90deg", config))
                            }
                        ]
                    },
                    callback: callback
                };
            };
        };
    }
    static createInstance() {
        return new FlipOutEasyX();
    }
}
class FlipOutEasyY extends ComplexAnimationBuilder {
    constructor(){
        super(...arguments);
        this.build = ()=>{
            const delayFunction = this.getDelayFunction();
            const [animation, config] = this.getAnimationAndConfig();
            const delay = this.getDelay();
            const callback = this.callbackV;
            const initialValues = this.initialValues;
            return ()=>{
                "worklet";
                return {
                    initialValues: Object.assign({
                        transform: [
                            {
                                perspective: 500
                            },
                            {
                                rotateY: "0deg"
                            }
                        ]
                    }, initialValues),
                    animations: {
                        transform: [
                            {
                                perspective: delayFunction(delay, animation(500, config))
                            },
                            {
                                rotateY: delayFunction(delay, animation("90deg", config))
                            }
                        ]
                    },
                    callback: callback
                };
            };
        };
    }
    static createInstance() {
        return new FlipOutEasyY();
    }
}

;// CONCATENATED MODULE: ./node_modules/react-native-reanimated/lib/reanimated2/layoutReanimation/defaultAnimations/Stretch.js

class StretchInX extends ComplexAnimationBuilder {
    constructor(){
        super(...arguments);
        this.build = ()=>{
            const delayFunction = this.getDelayFunction();
            const [animation, config] = this.getAnimationAndConfig();
            const delay = this.getDelay();
            const callback = this.callbackV;
            const initialValues = this.initialValues;
            return ()=>{
                "worklet";
                return {
                    animations: {
                        transform: [
                            {
                                scaleX: delayFunction(delay, animation(1, config))
                            }
                        ]
                    },
                    initialValues: Object.assign({
                        transform: [
                            {
                                scaleX: 0
                            }
                        ]
                    }, initialValues),
                    callback: callback
                };
            };
        };
    }
    static createInstance() {
        return new StretchInX();
    }
}
class StretchInY extends ComplexAnimationBuilder {
    constructor(){
        super(...arguments);
        this.build = ()=>{
            const delayFunction = this.getDelayFunction();
            const [animation, config] = this.getAnimationAndConfig();
            const delay = this.getDelay();
            const callback = this.callbackV;
            const initialValues = this.initialValues;
            return ()=>{
                "worklet";
                return {
                    animations: {
                        transform: [
                            {
                                scaleY: delayFunction(delay, animation(1, config))
                            }
                        ]
                    },
                    initialValues: Object.assign({
                        transform: [
                            {
                                scaleY: 0
                            }
                        ]
                    }, initialValues),
                    callback: callback
                };
            };
        };
    }
    static createInstance() {
        return new StretchInY();
    }
}
class StretchOutX extends ComplexAnimationBuilder {
    constructor(){
        super(...arguments);
        this.build = ()=>{
            const delayFunction = this.getDelayFunction();
            const [animation, config] = this.getAnimationAndConfig();
            const delay = this.getDelay();
            const callback = this.callbackV;
            const initialValues = this.initialValues;
            return ()=>{
                "worklet";
                return {
                    animations: {
                        transform: [
                            {
                                scaleX: delayFunction(delay, animation(0, config))
                            }
                        ]
                    },
                    initialValues: Object.assign({
                        transform: [
                            {
                                scaleX: 1
                            }
                        ]
                    }, initialValues),
                    callback: callback
                };
            };
        };
    }
    static createInstance() {
        return new StretchOutX();
    }
}
class StretchOutY extends ComplexAnimationBuilder {
    constructor(){
        super(...arguments);
        this.build = ()=>{
            const delayFunction = this.getDelayFunction();
            const [animation, config] = this.getAnimationAndConfig();
            const delay = this.getDelay();
            const callback = this.callbackV;
            const initialValues = this.initialValues;
            return ()=>{
                "worklet";
                return {
                    animations: {
                        transform: [
                            {
                                scaleY: delayFunction(delay, animation(0, config))
                            }
                        ]
                    },
                    initialValues: Object.assign({
                        transform: [
                            {
                                scaleY: 1
                            }
                        ]
                    }, initialValues),
                    callback: callback
                };
            };
        };
    }
    static createInstance() {
        return new StretchOutY();
    }
}

;// CONCATENATED MODULE: ./node_modules/react-native-reanimated/lib/reanimated2/layoutReanimation/defaultAnimations/Fade.js

class FadeIn extends ComplexAnimationBuilder {
    constructor(){
        super(...arguments);
        this.build = ()=>{
            const delayFunction = this.getDelayFunction();
            const [animation, config] = this.getAnimationAndConfig();
            const callback = this.callbackV;
            const initialValues = this.initialValues;
            const delay = this.getDelay();
            return (_)=>{
                "worklet";
                return {
                    animations: {
                        opacity: delayFunction(delay, animation(1, config))
                    },
                    initialValues: Object.assign({
                        opacity: 0
                    }, initialValues),
                    callback: callback
                };
            };
        };
    }
    static createInstance() {
        return new FadeIn();
    }
}
class FadeInRight extends ComplexAnimationBuilder {
    constructor(){
        super(...arguments);
        this.build = ()=>{
            const delayFunction = this.getDelayFunction();
            const [animation, config] = this.getAnimationAndConfig();
            const callback = this.callbackV;
            const initialValues = this.initialValues;
            const delay = this.getDelay();
            return ()=>{
                "worklet";
                return {
                    animations: {
                        opacity: delayFunction(delay, animation(1, config)),
                        transform: [
                            {
                                translateX: delayFunction(delay, animation(0, config))
                            }
                        ]
                    },
                    initialValues: Object.assign({
                        opacity: 0,
                        transform: [
                            {
                                translateX: 25
                            }
                        ]
                    }, initialValues),
                    callback: callback
                };
            };
        };
    }
    static createInstance() {
        return new FadeInRight();
    }
}
class FadeInLeft extends ComplexAnimationBuilder {
    constructor(){
        super(...arguments);
        this.build = ()=>{
            const delayFunction = this.getDelayFunction();
            const [animation, config] = this.getAnimationAndConfig();
            const callback = this.callbackV;
            const initialValues = this.initialValues;
            const delay = this.getDelay();
            return ()=>{
                "worklet";
                return {
                    animations: {
                        opacity: delayFunction(delay, animation(1, config)),
                        transform: [
                            {
                                translateX: delayFunction(delay, animation(0, config))
                            }
                        ]
                    },
                    initialValues: Object.assign({
                        opacity: 0,
                        transform: [
                            {
                                translateX: -25
                            }
                        ]
                    }, initialValues),
                    callback: callback
                };
            };
        };
    }
    static createInstance() {
        return new FadeInLeft();
    }
}
class FadeInUp extends ComplexAnimationBuilder {
    constructor(){
        super(...arguments);
        this.build = ()=>{
            const delayFunction = this.getDelayFunction();
            const [animation, config] = this.getAnimationAndConfig();
            const callback = this.callbackV;
            const initialValues = this.initialValues;
            const delay = this.getDelay();
            return ()=>{
                "worklet";
                return {
                    animations: {
                        opacity: delayFunction(delay, animation(1, config)),
                        transform: [
                            {
                                translateY: delayFunction(delay, animation(0, config))
                            }
                        ]
                    },
                    initialValues: Object.assign({
                        opacity: 0,
                        transform: [
                            {
                                translateY: -25
                            }
                        ]
                    }, initialValues),
                    callback: callback
                };
            };
        };
    }
    static createInstance() {
        return new FadeInUp();
    }
}
class FadeInDown extends ComplexAnimationBuilder {
    constructor(){
        super(...arguments);
        this.build = ()=>{
            const delayFunction = this.getDelayFunction();
            const [animation, config] = this.getAnimationAndConfig();
            const callback = this.callbackV;
            const initialValues = this.initialValues;
            const delay = this.getDelay();
            return ()=>{
                "worklet";
                return {
                    animations: {
                        opacity: delayFunction(delay, animation(1, config)),
                        transform: [
                            {
                                translateY: delayFunction(delay, animation(0, config))
                            }
                        ]
                    },
                    initialValues: Object.assign({
                        opacity: 0,
                        transform: [
                            {
                                translateY: 25
                            }
                        ]
                    }, initialValues),
                    callback: callback
                };
            };
        };
    }
    static createInstance() {
        return new FadeInDown();
    }
}
class FadeOut extends ComplexAnimationBuilder {
    constructor(){
        super(...arguments);
        this.build = ()=>{
            const delayFunction = this.getDelayFunction();
            const [animation, config] = this.getAnimationAndConfig();
            const callback = this.callbackV;
            const initialValues = this.initialValues;
            const delay = this.getDelay();
            return (_)=>{
                "worklet";
                return {
                    animations: {
                        opacity: delayFunction(delay, animation(0, config))
                    },
                    initialValues: Object.assign({
                        opacity: 1
                    }, initialValues),
                    callback: callback
                };
            };
        };
    }
    static createInstance() {
        return new FadeOut();
    }
}
class FadeOutRight extends ComplexAnimationBuilder {
    constructor(){
        super(...arguments);
        this.build = ()=>{
            const delayFunction = this.getDelayFunction();
            const [animation, config] = this.getAnimationAndConfig();
            const callback = this.callbackV;
            const initialValues = this.initialValues;
            const delay = this.getDelay();
            return ()=>{
                "worklet";
                return {
                    animations: {
                        opacity: delayFunction(delay, animation(0, config)),
                        transform: [
                            {
                                translateX: delayFunction(delay, animation(25, config))
                            }
                        ]
                    },
                    initialValues: Object.assign({
                        opacity: 1,
                        transform: [
                            {
                                translateX: 0
                            }
                        ]
                    }, initialValues),
                    callback: callback
                };
            };
        };
    }
    static createInstance() {
        return new FadeOutRight();
    }
}
class FadeOutLeft extends ComplexAnimationBuilder {
    constructor(){
        super(...arguments);
        this.build = ()=>{
            const delayFunction = this.getDelayFunction();
            const [animation, config] = this.getAnimationAndConfig();
            const callback = this.callbackV;
            const initialValues = this.initialValues;
            const delay = this.getDelay();
            return ()=>{
                "worklet";
                return {
                    animations: {
                        opacity: delayFunction(delay, animation(0, config)),
                        transform: [
                            {
                                translateX: delayFunction(delay, animation(-25, config))
                            }
                        ]
                    },
                    initialValues: Object.assign({
                        opacity: 1,
                        transform: [
                            {
                                translateX: 0
                            }
                        ]
                    }, initialValues),
                    callback: callback
                };
            };
        };
    }
    static createInstance() {
        return new FadeOutLeft();
    }
}
class FadeOutUp extends ComplexAnimationBuilder {
    constructor(){
        super(...arguments);
        this.build = ()=>{
            const delayFunction = this.getDelayFunction();
            const [animation, config] = this.getAnimationAndConfig();
            const callback = this.callbackV;
            const initialValues = this.initialValues;
            const delay = this.getDelay();
            return ()=>{
                "worklet";
                return {
                    animations: {
                        opacity: delayFunction(delay, animation(0, config)),
                        transform: [
                            {
                                translateY: delayFunction(delay, animation(-25, config))
                            }
                        ]
                    },
                    initialValues: Object.assign({
                        opacity: 1,
                        transform: [
                            {
                                translateY: 0
                            }
                        ]
                    }, initialValues),
                    callback: callback
                };
            };
        };
    }
    static createInstance() {
        return new FadeOutUp();
    }
}
class FadeOutDown extends ComplexAnimationBuilder {
    constructor(){
        super(...arguments);
        this.build = ()=>{
            const delayFunction = this.getDelayFunction();
            const [animation, config] = this.getAnimationAndConfig();
            const callback = this.callbackV;
            const initialValues = this.initialValues;
            const delay = this.getDelay();
            return ()=>{
                "worklet";
                return {
                    animations: {
                        opacity: delayFunction(delay, animation(0, config)),
                        transform: [
                            {
                                translateY: delayFunction(delay, animation(25, config))
                            }
                        ]
                    },
                    initialValues: Object.assign({
                        opacity: 1,
                        transform: [
                            {
                                translateY: 0
                            }
                        ]
                    }, initialValues),
                    callback: callback
                };
            };
        };
    }
    static createInstance() {
        return new FadeOutDown();
    }
}

;// CONCATENATED MODULE: ./node_modules/react-native-reanimated/lib/reanimated2/layoutReanimation/defaultAnimations/Slide.js

class SlideInRight extends ComplexAnimationBuilder {
    constructor(){
        super(...arguments);
        this.build = ()=>{
            const delayFunction = this.getDelayFunction();
            const [animation, config] = this.getAnimationAndConfig();
            const delay = this.getDelay();
            const callback = this.callbackV;
            const initialValues = this.initialValues;
            return (values)=>{
                "worklet";
                return {
                    animations: {
                        originX: delayFunction(delay, animation(values.targetOriginX, config))
                    },
                    initialValues: Object.assign({
                        originX: values.targetOriginX + values.windowWidth
                    }, initialValues),
                    callback: callback
                };
            };
        };
    }
    static createInstance() {
        return new SlideInRight();
    }
}
class SlideInLeft extends ComplexAnimationBuilder {
    constructor(){
        super(...arguments);
        this.build = ()=>{
            const delayFunction = this.getDelayFunction();
            const [animation, config] = this.getAnimationAndConfig();
            const delay = this.getDelay();
            const callback = this.callbackV;
            const initialValues = this.initialValues;
            return (values)=>{
                "worklet";
                return {
                    animations: {
                        originX: delayFunction(delay, animation(values.targetOriginX, config))
                    },
                    initialValues: Object.assign({
                        originX: values.targetOriginX - values.windowWidth
                    }, initialValues),
                    callback: callback
                };
            };
        };
    }
    static createInstance() {
        return new SlideInLeft();
    }
}
class SlideOutRight extends ComplexAnimationBuilder {
    constructor(){
        super(...arguments);
        this.build = ()=>{
            const delayFunction = this.getDelayFunction();
            const [animation, config] = this.getAnimationAndConfig();
            const delay = this.getDelay();
            const callback = this.callbackV;
            const initialValues = this.initialValues;
            return (values)=>{
                "worklet";
                return {
                    animations: {
                        originX: delayFunction(delay, animation(Math.max(values.currentOriginX + values.windowWidth, values.windowWidth), config))
                    },
                    initialValues: Object.assign({
                        originX: values.currentOriginX
                    }, initialValues),
                    callback: callback
                };
            };
        };
    }
    static createInstance() {
        return new SlideOutRight();
    }
}
class SlideOutLeft extends ComplexAnimationBuilder {
    constructor(){
        super(...arguments);
        this.build = ()=>{
            const delayFunction = this.getDelayFunction();
            const [animation, config] = this.getAnimationAndConfig();
            const delay = this.getDelay();
            const callback = this.callbackV;
            const initialValues = this.initialValues;
            return (values)=>{
                "worklet";
                return {
                    animations: {
                        originX: delayFunction(delay, animation(Math.min(values.currentOriginX - values.windowWidth, -values.windowWidth), config))
                    },
                    initialValues: Object.assign({
                        originX: values.currentOriginX
                    }, initialValues),
                    callback: callback
                };
            };
        };
    }
    static createInstance() {
        return new SlideOutLeft();
    }
}
class SlideInUp extends ComplexAnimationBuilder {
    constructor(){
        super(...arguments);
        this.build = ()=>{
            const delayFunction = this.getDelayFunction();
            const [animation, config] = this.getAnimationAndConfig();
            const delay = this.getDelay();
            const callback = this.callbackV;
            const initialValues = this.initialValues;
            return (values)=>{
                "worklet";
                return {
                    animations: {
                        originY: delayFunction(delay, animation(values.targetOriginY, config))
                    },
                    initialValues: Object.assign({
                        originY: -values.windowHeight
                    }, initialValues),
                    callback: callback
                };
            };
        };
    }
    static createInstance() {
        return new SlideInUp();
    }
}
class SlideInDown extends ComplexAnimationBuilder {
    constructor(){
        super(...arguments);
        this.build = ()=>{
            const delayFunction = this.getDelayFunction();
            const [animation, config] = this.getAnimationAndConfig();
            const delay = this.getDelay();
            const callback = this.callbackV;
            const initialValues = this.initialValues;
            return (values)=>{
                "worklet";
                return {
                    animations: {
                        originY: delayFunction(delay, animation(values.targetOriginY, config))
                    },
                    initialValues: Object.assign({
                        originY: values.targetOriginY + values.windowHeight
                    }, initialValues),
                    callback: callback
                };
            };
        };
    }
    static createInstance() {
        return new SlideInDown();
    }
}
class SlideOutUp extends ComplexAnimationBuilder {
    constructor(){
        super(...arguments);
        this.build = ()=>{
            const delayFunction = this.getDelayFunction();
            const [animation, config] = this.getAnimationAndConfig();
            const delay = this.getDelay();
            const callback = this.callbackV;
            const initialValues = this.initialValues;
            return (values)=>{
                "worklet";
                return {
                    animations: {
                        originY: delayFunction(delay, animation(Math.min(values.currentOriginY - values.windowHeight, -values.windowHeight), config))
                    },
                    initialValues: Object.assign({
                        originY: values.currentOriginY
                    }, initialValues),
                    callback: callback
                };
            };
        };
    }
    static createInstance() {
        return new SlideOutUp();
    }
}
class SlideOutDown extends ComplexAnimationBuilder {
    constructor(){
        super(...arguments);
        this.build = ()=>{
            const delayFunction = this.getDelayFunction();
            const [animation, config] = this.getAnimationAndConfig();
            const delay = this.getDelay();
            const callback = this.callbackV;
            const initialValues = this.initialValues;
            return (values)=>{
                "worklet";
                return {
                    animations: {
                        originY: delayFunction(delay, animation(Math.max(values.currentOriginY + values.windowHeight, values.windowHeight), config))
                    },
                    initialValues: Object.assign({
                        originY: values.currentOriginY
                    }, initialValues),
                    callback: callback
                };
            };
        };
    }
    static createInstance() {
        return new SlideOutDown();
    }
}

;// CONCATENATED MODULE: ./node_modules/react-native-reanimated/lib/reanimated2/layoutReanimation/defaultAnimations/Zoom.js

class ZoomIn extends ComplexAnimationBuilder {
    constructor(){
        super(...arguments);
        this.build = ()=>{
            const delayFunction = this.getDelayFunction();
            const [animation, config] = this.getAnimationAndConfig();
            const delay = this.getDelay();
            const callback = this.callbackV;
            const initialValues = this.initialValues;
            return ()=>{
                "worklet";
                return {
                    animations: {
                        transform: [
                            {
                                scale: delayFunction(delay, animation(1, config))
                            }
                        ]
                    },
                    initialValues: Object.assign({
                        transform: [
                            {
                                scale: 0
                            }
                        ]
                    }, initialValues),
                    callback: callback
                };
            };
        };
    }
    static createInstance() {
        return new ZoomIn();
    }
}
class ZoomInRotate extends ComplexAnimationBuilder {
    constructor(){
        super(...arguments);
        this.build = ()=>{
            const delayFunction = this.getDelayFunction();
            const [animation, config] = this.getAnimationAndConfig();
            const delay = this.getDelay();
            const rotate = this.rotateV ? this.rotateV : "0.3";
            const callback = this.callbackV;
            const initialValues = this.initialValues;
            return ()=>{
                "worklet";
                return {
                    animations: {
                        transform: [
                            {
                                scale: delayFunction(delay, animation(1, config))
                            },
                            {
                                rotate: delayFunction(delay, animation(0, config))
                            }
                        ]
                    },
                    initialValues: Object.assign({
                        transform: [
                            {
                                scale: 0
                            },
                            {
                                rotate: rotate
                            }
                        ]
                    }, initialValues),
                    callback: callback
                };
            };
        };
    }
    static createInstance() {
        return new ZoomInRotate();
    }
}
class ZoomInLeft extends ComplexAnimationBuilder {
    constructor(){
        super(...arguments);
        this.build = ()=>{
            const delayFunction = this.getDelayFunction();
            const [animation, config] = this.getAnimationAndConfig();
            const delay = this.getDelay();
            const callback = this.callbackV;
            const initialValues = this.initialValues;
            return (values)=>{
                "worklet";
                return {
                    animations: {
                        transform: [
                            {
                                translateX: delayFunction(delay, animation(0, config))
                            },
                            {
                                scale: delayFunction(delay, animation(1, config))
                            }
                        ]
                    },
                    initialValues: Object.assign({
                        transform: [
                            {
                                translateX: -values.windowWidth
                            },
                            {
                                scale: 0
                            }
                        ]
                    }, initialValues),
                    callback: callback
                };
            };
        };
    }
    static createInstance() {
        return new ZoomInLeft();
    }
}
class ZoomInRight extends ComplexAnimationBuilder {
    constructor(){
        super(...arguments);
        this.build = ()=>{
            const delayFunction = this.getDelayFunction();
            const [animation, config] = this.getAnimationAndConfig();
            const delay = this.getDelay();
            const callback = this.callbackV;
            const initialValues = this.initialValues;
            return (values)=>{
                "worklet";
                return {
                    animations: {
                        transform: [
                            {
                                translateX: delayFunction(delay, animation(0, config))
                            },
                            {
                                scale: delayFunction(delay, animation(1, config))
                            }
                        ]
                    },
                    initialValues: Object.assign({
                        transform: [
                            {
                                translateX: values.windowWidth
                            },
                            {
                                scale: 0
                            }
                        ]
                    }, initialValues),
                    callback: callback
                };
            };
        };
    }
    static createInstance() {
        return new ZoomInRight();
    }
}
class ZoomInUp extends ComplexAnimationBuilder {
    constructor(){
        super(...arguments);
        this.build = ()=>{
            const delayFunction = this.getDelayFunction();
            const [animation, config] = this.getAnimationAndConfig();
            const delay = this.getDelay();
            const callback = this.callbackV;
            const initialValues = this.initialValues;
            return (values)=>{
                "worklet";
                return {
                    animations: {
                        transform: [
                            {
                                translateY: delayFunction(delay, animation(0, config))
                            },
                            {
                                scale: delayFunction(delay, animation(1, config))
                            }
                        ]
                    },
                    initialValues: Object.assign({
                        transform: [
                            {
                                translateY: -values.windowHeight
                            },
                            {
                                scale: 0
                            }
                        ]
                    }, initialValues),
                    callback: callback
                };
            };
        };
    }
    static createInstance() {
        return new ZoomInUp();
    }
}
class ZoomInDown extends ComplexAnimationBuilder {
    constructor(){
        super(...arguments);
        this.build = ()=>{
            const delayFunction = this.getDelayFunction();
            const [animation, config] = this.getAnimationAndConfig();
            const delay = this.getDelay();
            const callback = this.callbackV;
            const initialValues = this.initialValues;
            return (values)=>{
                "worklet";
                return {
                    animations: {
                        transform: [
                            {
                                translateY: delayFunction(delay, animation(0, config))
                            },
                            {
                                scale: delayFunction(delay, animation(1, config))
                            }
                        ]
                    },
                    initialValues: Object.assign({
                        transform: [
                            {
                                translateY: values.windowHeight
                            },
                            {
                                scale: 0
                            }
                        ]
                    }, initialValues),
                    callback: callback
                };
            };
        };
    }
    static createInstance() {
        return new ZoomInDown();
    }
}
class ZoomInEasyUp extends ComplexAnimationBuilder {
    constructor(){
        super(...arguments);
        this.build = ()=>{
            const delayFunction = this.getDelayFunction();
            const [animation, config] = this.getAnimationAndConfig();
            const delay = this.getDelay();
            const callback = this.callbackV;
            const initialValues = this.initialValues;
            return (values)=>{
                "worklet";
                return {
                    animations: {
                        transform: [
                            {
                                translateY: delayFunction(delay, animation(0, config))
                            },
                            {
                                scale: delayFunction(delay, animation(1, config))
                            }
                        ]
                    },
                    initialValues: Object.assign({
                        transform: [
                            {
                                translateY: -values.targetHeight
                            },
                            {
                                scale: 0
                            }
                        ]
                    }, initialValues),
                    callback: callback
                };
            };
        };
    }
    static createInstance() {
        return new ZoomInEasyUp();
    }
}
class ZoomInEasyDown extends ComplexAnimationBuilder {
    constructor(){
        super(...arguments);
        this.build = ()=>{
            const delayFunction = this.getDelayFunction();
            const [animation, config] = this.getAnimationAndConfig();
            const delay = this.getDelay();
            const callback = this.callbackV;
            const initialValues = this.initialValues;
            return (values)=>{
                "worklet";
                return {
                    animations: {
                        transform: [
                            {
                                translateY: delayFunction(delay, animation(0, config))
                            },
                            {
                                scale: delayFunction(delay, animation(1, config))
                            }
                        ]
                    },
                    initialValues: Object.assign({
                        transform: [
                            {
                                translateY: values.targetHeight
                            },
                            {
                                scale: 0
                            }
                        ]
                    }, initialValues),
                    callback: callback
                };
            };
        };
    }
    static createInstance() {
        return new ZoomInEasyDown();
    }
}
class ZoomOut extends ComplexAnimationBuilder {
    constructor(){
        super(...arguments);
        this.build = ()=>{
            const delayFunction = this.getDelayFunction();
            const [animation, config] = this.getAnimationAndConfig();
            const delay = this.getDelay();
            const callback = this.callbackV;
            const initialValues = this.initialValues;
            return ()=>{
                "worklet";
                return {
                    animations: {
                        transform: [
                            {
                                scale: delayFunction(delay, animation(0, config))
                            }
                        ]
                    },
                    initialValues: Object.assign({
                        transform: [
                            {
                                scale: 1
                            }
                        ]
                    }, initialValues),
                    callback: callback
                };
            };
        };
    }
    static createInstance() {
        return new ZoomOut();
    }
}
class ZoomOutRotate extends ComplexAnimationBuilder {
    constructor(){
        super(...arguments);
        this.build = ()=>{
            const delayFunction = this.getDelayFunction();
            const [animation, config] = this.getAnimationAndConfig();
            const delay = this.getDelay();
            const rotate = this.rotateV ? this.rotateV : "0.3";
            const callback = this.callbackV;
            const initialValues = this.initialValues;
            return ()=>{
                "worklet";
                return {
                    animations: {
                        transform: [
                            {
                                scale: delayFunction(delay, animation(0, config))
                            },
                            {
                                rotate: delayFunction(delay, animation(rotate, config))
                            }
                        ]
                    },
                    initialValues: Object.assign({
                        transform: [
                            {
                                scale: 1
                            },
                            {
                                rotate: "0"
                            }
                        ]
                    }, initialValues),
                    callback: callback
                };
            };
        };
    }
    static createInstance() {
        return new ZoomOutRotate();
    }
}
class ZoomOutLeft extends ComplexAnimationBuilder {
    constructor(){
        super(...arguments);
        this.build = ()=>{
            const delayFunction = this.getDelayFunction();
            const [animation, config] = this.getAnimationAndConfig();
            const delay = this.getDelay();
            const callback = this.callbackV;
            const initialValues = this.initialValues;
            return (values)=>{
                "worklet";
                return {
                    animations: {
                        transform: [
                            {
                                translateX: delayFunction(delay, animation(-values.windowWidth, config))
                            },
                            {
                                scale: delayFunction(delay, animation(0, config))
                            }
                        ]
                    },
                    initialValues: Object.assign({
                        transform: [
                            {
                                translateX: 0
                            },
                            {
                                scale: 1
                            }
                        ]
                    }, initialValues),
                    callback: callback
                };
            };
        };
    }
    static createInstance() {
        return new ZoomOutLeft();
    }
}
class ZoomOutRight extends ComplexAnimationBuilder {
    constructor(){
        super(...arguments);
        this.build = ()=>{
            const delayFunction = this.getDelayFunction();
            const [animation, config] = this.getAnimationAndConfig();
            const delay = this.getDelay();
            const callback = this.callbackV;
            const initialValues = this.initialValues;
            return (values)=>{
                "worklet";
                return {
                    animations: {
                        transform: [
                            {
                                translateX: delayFunction(delay, animation(values.windowWidth, config))
                            },
                            {
                                scale: delayFunction(delay, animation(0, config))
                            }
                        ]
                    },
                    initialValues: Object.assign({
                        transform: [
                            {
                                translateX: 0
                            },
                            {
                                scale: 1
                            }
                        ]
                    }, initialValues),
                    callback: callback
                };
            };
        };
    }
    static createInstance() {
        return new ZoomOutRight();
    }
}
class ZoomOutUp extends ComplexAnimationBuilder {
    constructor(){
        super(...arguments);
        this.build = ()=>{
            const delayFunction = this.getDelayFunction();
            const [animation, config] = this.getAnimationAndConfig();
            const delay = this.getDelay();
            const callback = this.callbackV;
            const initialValues = this.initialValues;
            return (values)=>{
                "worklet";
                return {
                    animations: {
                        transform: [
                            {
                                translateY: delayFunction(delay, animation(-values.windowHeight, config))
                            },
                            {
                                scale: delayFunction(delay, animation(0, config))
                            }
                        ]
                    },
                    initialValues: Object.assign({
                        transform: [
                            {
                                translateY: 0
                            },
                            {
                                scale: 1
                            }
                        ]
                    }, initialValues),
                    callback: callback
                };
            };
        };
    }
    static createInstance() {
        return new ZoomOutUp();
    }
}
class ZoomOutDown extends ComplexAnimationBuilder {
    constructor(){
        super(...arguments);
        this.build = ()=>{
            const delayFunction = this.getDelayFunction();
            const [animation, config] = this.getAnimationAndConfig();
            const delay = this.getDelay();
            const callback = this.callbackV;
            const initialValues = this.initialValues;
            return (values)=>{
                "worklet";
                return {
                    animations: {
                        transform: [
                            {
                                translateY: delayFunction(delay, animation(values.windowHeight, config))
                            },
                            {
                                scale: delayFunction(delay, animation(0, config))
                            }
                        ]
                    },
                    initialValues: Object.assign({
                        transform: [
                            {
                                translateY: 0
                            },
                            {
                                scale: 1
                            }
                        ]
                    }, initialValues),
                    callback: callback
                };
            };
        };
    }
    static createInstance() {
        return new ZoomOutDown();
    }
}
class ZoomOutEasyUp extends ComplexAnimationBuilder {
    constructor(){
        super(...arguments);
        this.build = ()=>{
            const delayFunction = this.getDelayFunction();
            const [animation, config] = this.getAnimationAndConfig();
            const delay = this.getDelay();
            const callback = this.callbackV;
            const initialValues = this.initialValues;
            return (values)=>{
                "worklet";
                return {
                    animations: {
                        transform: [
                            {
                                translateY: delayFunction(delay, animation(-values.currentHeight, config))
                            },
                            {
                                scale: delayFunction(delay, animation(0, config))
                            }
                        ]
                    },
                    initialValues: Object.assign({
                        transform: [
                            {
                                translateY: 0
                            },
                            {
                                scale: 1
                            }
                        ]
                    }, initialValues),
                    callback: callback
                };
            };
        };
    }
    static createInstance() {
        return new ZoomOutEasyUp();
    }
}
class ZoomOutEasyDown extends ComplexAnimationBuilder {
    constructor(){
        super(...arguments);
        this.build = ()=>{
            const delayFunction = this.getDelayFunction();
            const [animation, config] = this.getAnimationAndConfig();
            const delay = this.getDelay();
            const callback = this.callbackV;
            const initialValues = this.initialValues;
            return (values)=>{
                "worklet";
                return {
                    animations: {
                        transform: [
                            {
                                translateY: delayFunction(delay, animation(values.currentHeight, config))
                            },
                            {
                                scale: delayFunction(delay, animation(0, config))
                            }
                        ]
                    },
                    initialValues: Object.assign({
                        transform: [
                            {
                                translateY: 0
                            },
                            {
                                scale: 1
                            }
                        ]
                    }, initialValues),
                    callback: callback
                };
            };
        };
    }
    static createInstance() {
        return new ZoomOutEasyDown();
    }
}

;// CONCATENATED MODULE: ./node_modules/react-native-reanimated/lib/reanimated2/layoutReanimation/defaultAnimations/Bounce.js


class BounceIn extends ComplexAnimationBuilder {
    constructor(){
        super(...arguments);
        this.build = ()=>{
            const delayFunction = this.getDelayFunction();
            const delay = this.getDelay();
            const duration = this.getDuration();
            const callback = this.callbackV;
            const initialValues = this.initialValues;
            return ()=>{
                "worklet";
                return {
                    animations: {
                        transform: [
                            {
                                scale: delayFunction(delay, withSequence((0,animation_timing/* withTiming */.j)(1.2, {
                                    duration: duration * 0.55
                                }), (0,animation_timing/* withTiming */.j)(0.9, {
                                    duration: duration * 0.15
                                }), (0,animation_timing/* withTiming */.j)(1.1, {
                                    duration: duration * 0.15
                                }), (0,animation_timing/* withTiming */.j)(1, {
                                    duration: duration * 0.15
                                })))
                            }
                        ]
                    },
                    initialValues: Object.assign({
                        transform: [
                            {
                                scale: 0
                            }
                        ]
                    }, initialValues),
                    callback: callback
                };
            };
        };
    }
    static createInstance() {
        return new BounceIn();
    }
    static getDuration() {
        return 600;
    }
    getDuration() {
        var _a;
        return (_a = this.durationV) !== null && _a !== void 0 ? _a : 600;
    }
}
class BounceInDown extends ComplexAnimationBuilder {
    constructor(){
        super(...arguments);
        this.build = ()=>{
            const delayFunction = this.getDelayFunction();
            const delay = this.getDelay();
            const duration = this.getDuration();
            const callback = this.callbackV;
            const initialValues = this.initialValues;
            return (values)=>{
                "worklet";
                return {
                    animations: {
                        transform: [
                            {
                                translateY: delayFunction(delay, withSequence((0,animation_timing/* withTiming */.j)(-20, {
                                    duration: duration * 0.55
                                }), (0,animation_timing/* withTiming */.j)(10, {
                                    duration: duration * 0.15
                                }), (0,animation_timing/* withTiming */.j)(-10, {
                                    duration: duration * 0.15
                                }), (0,animation_timing/* withTiming */.j)(0, {
                                    duration: duration * 0.15
                                })))
                            }
                        ]
                    },
                    initialValues: Object.assign({
                        transform: [
                            {
                                translateY: values.windowHeight
                            }
                        ]
                    }, initialValues),
                    callback: callback
                };
            };
        };
    }
    static createInstance() {
        return new BounceInDown();
    }
    static getDuration() {
        return 600;
    }
    getDuration() {
        var _a;
        return (_a = this.durationV) !== null && _a !== void 0 ? _a : 600;
    }
}
class BounceInUp extends ComplexAnimationBuilder {
    constructor(){
        super(...arguments);
        this.build = ()=>{
            const delayFunction = this.getDelayFunction();
            const delay = this.getDelay();
            const duration = this.getDuration();
            const callback = this.callbackV;
            const initialValues = this.initialValues;
            return (values)=>{
                "worklet";
                return {
                    animations: {
                        transform: [
                            {
                                translateY: delayFunction(delay, withSequence((0,animation_timing/* withTiming */.j)(20, {
                                    duration: duration * 0.55
                                }), (0,animation_timing/* withTiming */.j)(-10, {
                                    duration: duration * 0.15
                                }), (0,animation_timing/* withTiming */.j)(10, {
                                    duration: duration * 0.15
                                }), (0,animation_timing/* withTiming */.j)(0, {
                                    duration: duration * 0.15
                                })))
                            }
                        ]
                    },
                    initialValues: Object.assign({
                        transform: [
                            {
                                translateY: -values.windowHeight
                            }
                        ]
                    }, initialValues),
                    callback: callback
                };
            };
        };
    }
    static createInstance() {
        return new BounceInUp();
    }
    static getDuration() {
        return 600;
    }
    getDuration() {
        var _a;
        return (_a = this.durationV) !== null && _a !== void 0 ? _a : 600;
    }
}
class BounceInLeft extends ComplexAnimationBuilder {
    constructor(){
        super(...arguments);
        this.build = ()=>{
            const delayFunction = this.getDelayFunction();
            const delay = this.getDelay();
            const duration = this.getDuration();
            const callback = this.callbackV;
            const initialValues = this.initialValues;
            return (values)=>{
                "worklet";
                return {
                    animations: {
                        transform: [
                            {
                                translateX: delayFunction(delay, withSequence((0,animation_timing/* withTiming */.j)(20, {
                                    duration: duration * 0.55
                                }), (0,animation_timing/* withTiming */.j)(-10, {
                                    duration: duration * 0.15
                                }), (0,animation_timing/* withTiming */.j)(10, {
                                    duration: duration * 0.15
                                }), (0,animation_timing/* withTiming */.j)(0, {
                                    duration: duration * 0.15
                                })))
                            }
                        ]
                    },
                    initialValues: Object.assign({
                        transform: [
                            {
                                translateX: -values.windowWidth
                            }
                        ]
                    }, initialValues),
                    callback: callback
                };
            };
        };
    }
    static createInstance() {
        return new BounceInLeft();
    }
    static getDuration() {
        return 600;
    }
    getDuration() {
        var _a;
        return (_a = this.durationV) !== null && _a !== void 0 ? _a : 600;
    }
}
class BounceInRight extends ComplexAnimationBuilder {
    constructor(){
        super(...arguments);
        this.build = ()=>{
            const delayFunction = this.getDelayFunction();
            const delay = this.getDelay();
            const duration = this.getDuration();
            const callback = this.callbackV;
            const initialValues = this.initialValues;
            return (values)=>{
                "worklet";
                return {
                    animations: {
                        transform: [
                            {
                                translateX: delayFunction(delay, withSequence((0,animation_timing/* withTiming */.j)(-20, {
                                    duration: duration * 0.55
                                }), (0,animation_timing/* withTiming */.j)(10, {
                                    duration: duration * 0.15
                                }), (0,animation_timing/* withTiming */.j)(-10, {
                                    duration: duration * 0.15
                                }), (0,animation_timing/* withTiming */.j)(0, {
                                    duration: duration * 0.15
                                })))
                            }
                        ]
                    },
                    initialValues: Object.assign({
                        transform: [
                            {
                                translateX: values.windowWidth
                            }
                        ]
                    }, initialValues),
                    callback: callback
                };
            };
        };
    }
    static createInstance() {
        return new BounceInRight();
    }
    static getDuration() {
        return 600;
    }
    getDuration() {
        var _a;
        return (_a = this.durationV) !== null && _a !== void 0 ? _a : 600;
    }
}
class BounceOut extends ComplexAnimationBuilder {
    constructor(){
        super(...arguments);
        this.build = ()=>{
            const delayFunction = this.getDelayFunction();
            const delay = this.getDelay();
            const duration = this.getDuration();
            const callback = this.callbackV;
            const initialValues = this.initialValues;
            return ()=>{
                "worklet";
                return {
                    animations: {
                        transform: [
                            {
                                scale: delayFunction(delay, withSequence((0,animation_timing/* withTiming */.j)(1.1, {
                                    duration: duration * 0.15
                                }), (0,animation_timing/* withTiming */.j)(0.9, {
                                    duration: duration * 0.15
                                }), (0,animation_timing/* withTiming */.j)(1.2, {
                                    duration: duration * 0.15
                                }), (0,animation_timing/* withTiming */.j)(0, {
                                    duration: duration * 0.55
                                })))
                            }
                        ]
                    },
                    initialValues: Object.assign({
                        transform: [
                            {
                                scale: 1
                            }
                        ]
                    }, initialValues),
                    callback: callback
                };
            };
        };
    }
    static createInstance() {
        return new BounceOut();
    }
    static getDuration() {
        return 600;
    }
    getDuration() {
        var _a;
        return (_a = this.durationV) !== null && _a !== void 0 ? _a : 600;
    }
}
class BounceOutDown extends ComplexAnimationBuilder {
    constructor(){
        super(...arguments);
        this.build = ()=>{
            const delayFunction = this.getDelayFunction();
            const delay = this.getDelay();
            const duration = this.getDuration();
            const callback = this.callbackV;
            const initialValues = this.initialValues;
            return (values)=>{
                "worklet";
                return {
                    animations: {
                        transform: [
                            {
                                translateY: delayFunction(delay, withSequence((0,animation_timing/* withTiming */.j)(-10, {
                                    duration: duration * 0.15
                                }), (0,animation_timing/* withTiming */.j)(10, {
                                    duration: duration * 0.15
                                }), (0,animation_timing/* withTiming */.j)(-20, {
                                    duration: duration * 0.15
                                }), (0,animation_timing/* withTiming */.j)(values.windowHeight, {
                                    duration: duration * 0.55
                                })))
                            }
                        ]
                    },
                    initialValues: Object.assign({
                        transform: [
                            {
                                translateY: 0
                            }
                        ]
                    }, initialValues),
                    callback: callback
                };
            };
        };
    }
    static createInstance() {
        return new BounceOutDown();
    }
    static getDuration() {
        return 600;
    }
    getDuration() {
        var _a;
        return (_a = this.durationV) !== null && _a !== void 0 ? _a : 600;
    }
}
class BounceOutUp extends ComplexAnimationBuilder {
    constructor(){
        super(...arguments);
        this.build = ()=>{
            const delayFunction = this.getDelayFunction();
            const delay = this.getDelay();
            const duration = this.getDuration();
            const callback = this.callbackV;
            const initialValues = this.initialValues;
            return (values)=>{
                "worklet";
                return {
                    animations: {
                        transform: [
                            {
                                translateY: delayFunction(delay, withSequence((0,animation_timing/* withTiming */.j)(10, {
                                    duration: duration * 0.15
                                }), (0,animation_timing/* withTiming */.j)(-10, {
                                    duration: duration * 0.15
                                }), (0,animation_timing/* withTiming */.j)(20, {
                                    duration: duration * 0.15
                                }), (0,animation_timing/* withTiming */.j)(-values.windowHeight, {
                                    duration: duration * 0.55
                                })))
                            }
                        ]
                    },
                    initialValues: Object.assign({
                        transform: [
                            {
                                translateY: 0
                            }
                        ]
                    }, initialValues),
                    callback: callback
                };
            };
        };
    }
    static createInstance() {
        return new BounceOutUp();
    }
    static getDuration() {
        return 600;
    }
    getDuration() {
        var _a;
        return (_a = this.durationV) !== null && _a !== void 0 ? _a : 600;
    }
}
class BounceOutLeft extends ComplexAnimationBuilder {
    constructor(){
        super(...arguments);
        this.build = ()=>{
            const delayFunction = this.getDelayFunction();
            const delay = this.getDelay();
            const duration = this.getDuration();
            const callback = this.callbackV;
            const initialValues = this.initialValues;
            return (values)=>{
                "worklet";
                return {
                    animations: {
                        transform: [
                            {
                                translateX: delayFunction(delay, withSequence((0,animation_timing/* withTiming */.j)(10, {
                                    duration: duration * 0.15
                                }), (0,animation_timing/* withTiming */.j)(-10, {
                                    duration: duration * 0.15
                                }), (0,animation_timing/* withTiming */.j)(20, {
                                    duration: duration * 0.15
                                }), (0,animation_timing/* withTiming */.j)(-values.windowWidth, {
                                    duration: duration * 0.55
                                })))
                            }
                        ]
                    },
                    initialValues: Object.assign({
                        transform: [
                            {
                                translateX: 0
                            }
                        ]
                    }, initialValues),
                    callback: callback
                };
            };
        };
    }
    static createInstance() {
        return new BounceOutLeft();
    }
    static getDuration() {
        return 600;
    }
    getDuration() {
        var _a;
        return (_a = this.durationV) !== null && _a !== void 0 ? _a : 600;
    }
}
class BounceOutRight extends ComplexAnimationBuilder {
    constructor(){
        super(...arguments);
        this.build = ()=>{
            const delayFunction = this.getDelayFunction();
            const delay = this.getDelay();
            const duration = this.getDuration();
            const callback = this.callbackV;
            const initialValues = this.initialValues;
            return (values)=>{
                "worklet";
                return {
                    animations: {
                        transform: [
                            {
                                translateX: delayFunction(delay, withSequence((0,animation_timing/* withTiming */.j)(-10, {
                                    duration: duration * 0.15
                                }), (0,animation_timing/* withTiming */.j)(10, {
                                    duration: duration * 0.15
                                }), (0,animation_timing/* withTiming */.j)(-20, {
                                    duration: duration * 0.15
                                }), (0,animation_timing/* withTiming */.j)(values.windowWidth, {
                                    duration: duration * 0.55
                                })))
                            }
                        ]
                    },
                    initialValues: Object.assign({
                        transform: [
                            {
                                translateX: 0
                            }
                        ]
                    }, initialValues),
                    callback: callback
                };
            };
        };
    }
    static createInstance() {
        return new BounceOutRight();
    }
    static getDuration() {
        return 600;
    }
    getDuration() {
        var _a;
        return (_a = this.durationV) !== null && _a !== void 0 ? _a : 600;
    }
}

;// CONCATENATED MODULE: ./node_modules/react-native-reanimated/lib/reanimated2/layoutReanimation/defaultAnimations/Lightspeed.js


class LightSpeedInRight extends ComplexAnimationBuilder {
    constructor(){
        super(...arguments);
        this.build = ()=>{
            const delayFunction = this.getDelayFunction();
            const [animation, config] = this.getAnimationAndConfig();
            const delay = this.getDelay();
            const duration = this.getDuration();
            const callback = this.callbackV;
            const initialValues = this.initialValues;
            return (values)=>{
                "worklet";
                return {
                    animations: {
                        opacity: delayFunction(delay, (0,animation_timing/* withTiming */.j)(1, {
                            duration: duration
                        })),
                        transform: [
                            {
                                translateX: delayFunction(delay, animation(0, Object.assign(Object.assign({}, config), {
                                    duration: duration * 0.7
                                })))
                            },
                            {
                                skewX: delayFunction(delay, withSequence((0,animation_timing/* withTiming */.j)("10deg", {
                                    duration: duration * 0.7
                                }), (0,animation_timing/* withTiming */.j)("-5deg", {
                                    duration: duration * 0.15
                                }), (0,animation_timing/* withTiming */.j)("0deg", {
                                    duration: duration * 0.15
                                })))
                            }
                        ]
                    },
                    initialValues: Object.assign({
                        opacity: 0,
                        transform: [
                            {
                                translateX: values.windowWidth
                            },
                            {
                                skewX: "-45deg"
                            }
                        ]
                    }, initialValues),
                    callback: callback
                };
            };
        };
    }
    static createInstance() {
        return new LightSpeedInRight();
    }
}
class LightSpeedInLeft extends ComplexAnimationBuilder {
    constructor(){
        super(...arguments);
        this.build = ()=>{
            const delayFunction = this.getDelayFunction();
            const [animation, config] = this.getAnimationAndConfig();
            const delay = this.getDelay();
            const duration = this.getDuration();
            const callback = this.callbackV;
            const initialValues = this.initialValues;
            return (values)=>{
                "worklet";
                return {
                    animations: {
                        opacity: delayFunction(delay, (0,animation_timing/* withTiming */.j)(1, {
                            duration: duration
                        })),
                        transform: [
                            {
                                translateX: delayFunction(delay, animation(0, Object.assign(Object.assign({}, config), {
                                    duration: duration * 0.7
                                })))
                            },
                            {
                                skewX: delayFunction(delay, withSequence((0,animation_timing/* withTiming */.j)("-10deg", {
                                    duration: duration * 0.7
                                }), (0,animation_timing/* withTiming */.j)("5deg", {
                                    duration: duration * 0.15
                                }), (0,animation_timing/* withTiming */.j)("0deg", {
                                    duration: duration * 0.15
                                })))
                            }
                        ]
                    },
                    initialValues: Object.assign({
                        opacity: 0,
                        transform: [
                            {
                                translateX: -values.windowWidth
                            },
                            {
                                skewX: "45deg"
                            }
                        ]
                    }, initialValues),
                    callback: callback
                };
            };
        };
    }
    static createInstance() {
        return new LightSpeedInLeft();
    }
}
class LightSpeedOutRight extends ComplexAnimationBuilder {
    constructor(){
        super(...arguments);
        this.build = ()=>{
            const delayFunction = this.getDelayFunction();
            const [animation, config] = this.getAnimationAndConfig();
            const delay = this.getDelay();
            const callback = this.callbackV;
            const initialValues = this.initialValues;
            return (values)=>{
                "worklet";
                return {
                    animations: {
                        opacity: delayFunction(delay, animation(0, config)),
                        transform: [
                            {
                                translateX: delayFunction(delay, animation(values.windowWidth, config))
                            },
                            {
                                skewX: delayFunction(delay, animation("-45deg", config))
                            }
                        ]
                    },
                    initialValues: Object.assign({
                        opacity: 1,
                        transform: [
                            {
                                translateX: 0
                            },
                            {
                                skewX: "0deg"
                            }
                        ]
                    }, initialValues),
                    callback: callback
                };
            };
        };
    }
    static createInstance() {
        return new LightSpeedOutRight();
    }
}
class LightSpeedOutLeft extends ComplexAnimationBuilder {
    constructor(){
        super(...arguments);
        this.build = ()=>{
            const delayFunction = this.getDelayFunction();
            const [animation, config] = this.getAnimationAndConfig();
            const delay = this.getDelay();
            const callback = this.callbackV;
            const initialValues = this.initialValues;
            return (values)=>{
                "worklet";
                return {
                    animations: {
                        opacity: delayFunction(delay, animation(0, config)),
                        transform: [
                            {
                                translateX: delayFunction(delay, animation(-values.windowWidth, config))
                            },
                            {
                                skewX: delayFunction(delay, animation("45deg", config))
                            }
                        ]
                    },
                    initialValues: Object.assign({
                        opacity: 1,
                        transform: [
                            {
                                translateX: 0
                            },
                            {
                                skewX: "0deg"
                            }
                        ]
                    }, initialValues),
                    callback: callback
                };
            };
        };
    }
    static createInstance() {
        return new LightSpeedOutLeft();
    }
}

;// CONCATENATED MODULE: ./node_modules/react-native-reanimated/lib/reanimated2/layoutReanimation/defaultAnimations/Pinwheel.js

class PinwheelIn extends ComplexAnimationBuilder {
    constructor(){
        super(...arguments);
        this.build = ()=>{
            const delayFunction = this.getDelayFunction();
            const [animation, config] = this.getAnimationAndConfig();
            const delay = this.getDelay();
            const callback = this.callbackV;
            const initialValues = this.initialValues;
            return (_values)=>{
                "worklet";
                return {
                    animations: {
                        opacity: delayFunction(delay, animation(1, config)),
                        transform: [
                            {
                                scale: delayFunction(delay, animation(1, config))
                            },
                            {
                                rotate: delayFunction(delay, animation("0", config))
                            }
                        ]
                    },
                    initialValues: Object.assign({
                        opacity: 0,
                        transform: [
                            {
                                scale: 0
                            },
                            {
                                rotate: "5"
                            }
                        ]
                    }, initialValues),
                    callback: callback
                };
            };
        };
    }
    static createInstance() {
        return new PinwheelIn();
    }
}
class PinwheelOut extends ComplexAnimationBuilder {
    constructor(){
        super(...arguments);
        this.build = ()=>{
            const delayFunction = this.getDelayFunction();
            const [animation, config] = this.getAnimationAndConfig();
            const delay = this.getDelay();
            const callback = this.callbackV;
            const initialValues = this.initialValues;
            return (_values)=>{
                "worklet";
                return {
                    animations: {
                        opacity: delayFunction(delay, animation(0, config)),
                        transform: [
                            {
                                scale: delayFunction(delay, animation(0, config))
                            },
                            {
                                rotate: delayFunction(delay, animation("5", config))
                            }
                        ]
                    },
                    initialValues: Object.assign({
                        opacity: 1,
                        transform: [
                            {
                                scale: 1
                            },
                            {
                                rotate: "0"
                            }
                        ]
                    }, initialValues),
                    callback: callback
                };
            };
        };
    }
    static createInstance() {
        return new PinwheelOut();
    }
}

;// CONCATENATED MODULE: ./node_modules/react-native-reanimated/lib/reanimated2/layoutReanimation/defaultAnimations/Rotate.js

class RotateInDownLeft extends ComplexAnimationBuilder {
    constructor(){
        super(...arguments);
        this.build = ()=>{
            const delayFunction = this.getDelayFunction();
            const [animation, config] = this.getAnimationAndConfig();
            const delay = this.getDelay();
            const callback = this.callbackV;
            const initialValues = this.initialValues;
            return (values)=>{
                "worklet";
                return {
                    animations: {
                        opacity: delayFunction(delay, animation(1, config)),
                        transform: [
                            {
                                rotate: delayFunction(delay, animation("0deg", config))
                            },
                            {
                                translateX: delayFunction(delay, animation(0, config))
                            },
                            {
                                translateY: delayFunction(delay, animation(0, config))
                            }
                        ]
                    },
                    initialValues: Object.assign({
                        opacity: 0,
                        transform: [
                            {
                                rotate: "-90deg"
                            },
                            {
                                translateX: values.targetWidth / 2 - values.targetHeight / 2
                            },
                            {
                                translateY: -(values.targetWidth / 2 - values.targetHeight / 2)
                            }
                        ]
                    }, initialValues),
                    callback: callback
                };
            };
        };
    }
    static createInstance() {
        return new RotateInDownLeft();
    }
}
class RotateInDownRight extends ComplexAnimationBuilder {
    constructor(){
        super(...arguments);
        this.build = ()=>{
            const delayFunction = this.getDelayFunction();
            const [animation, config] = this.getAnimationAndConfig();
            const delay = this.getDelay();
            const callback = this.callbackV;
            const initialValues = this.initialValues;
            return (values)=>{
                "worklet";
                return {
                    animations: {
                        opacity: delayFunction(delay, animation(1, config)),
                        transform: [
                            {
                                rotate: delayFunction(delay, animation("0deg", config))
                            },
                            {
                                translateX: delayFunction(delay, animation(0, config))
                            },
                            {
                                translateY: delayFunction(delay, animation(0, config))
                            }
                        ]
                    },
                    initialValues: Object.assign({
                        opacity: 0,
                        transform: [
                            {
                                rotate: "90deg"
                            },
                            {
                                translateX: -(values.targetWidth / 2 - values.targetHeight / 2)
                            },
                            {
                                translateY: -(values.targetWidth / 2 - values.targetHeight / 2)
                            }
                        ]
                    }, initialValues),
                    callback: callback
                };
            };
        };
    }
    static createInstance() {
        return new RotateInDownRight();
    }
}
class RotateInUpLeft extends ComplexAnimationBuilder {
    constructor(){
        super(...arguments);
        this.build = ()=>{
            const delayFunction = this.getDelayFunction();
            const [animation, config] = this.getAnimationAndConfig();
            const delay = this.getDelay();
            const callback = this.callbackV;
            const initialValues = this.initialValues;
            return (values)=>{
                "worklet";
                return {
                    animations: {
                        opacity: delayFunction(delay, animation(1, config)),
                        transform: [
                            {
                                rotate: delayFunction(delay, animation("0deg", config))
                            },
                            {
                                translateX: delayFunction(delay, animation(0, config))
                            },
                            {
                                translateY: delayFunction(delay, animation(0, config))
                            }
                        ]
                    },
                    initialValues: Object.assign({
                        opacity: 0,
                        transform: [
                            {
                                rotate: "90deg"
                            },
                            {
                                translateX: values.targetWidth / 2 - values.targetHeight / 2
                            },
                            {
                                translateY: values.targetWidth / 2 - values.targetHeight / 2
                            }
                        ]
                    }, initialValues),
                    callback: callback
                };
            };
        };
    }
    static createInstance() {
        return new RotateInUpLeft();
    }
}
class RotateInUpRight extends ComplexAnimationBuilder {
    constructor(){
        super(...arguments);
        this.build = ()=>{
            const delayFunction = this.getDelayFunction();
            const [animation, config] = this.getAnimationAndConfig();
            const delay = this.getDelay();
            const callback = this.callbackV;
            const initialValues = this.initialValues;
            return (values)=>{
                "worklet";
                return {
                    animations: {
                        opacity: delayFunction(delay, animation(1, config)),
                        transform: [
                            {
                                rotate: delayFunction(delay, animation("0deg", config))
                            },
                            {
                                translateX: delayFunction(delay, animation(0, config))
                            },
                            {
                                translateY: delayFunction(delay, animation(0, config))
                            }
                        ]
                    },
                    initialValues: Object.assign({
                        opacity: 0,
                        transform: [
                            {
                                rotate: "-90deg"
                            },
                            {
                                translateX: -(values.targetWidth / 2 - values.targetHeight / 2)
                            },
                            {
                                translateY: values.targetWidth / 2 - values.targetHeight / 2
                            }
                        ]
                    }, initialValues),
                    callback: callback
                };
            };
        };
    }
    static createInstance() {
        return new RotateInUpRight();
    }
}
class RotateOutDownLeft extends ComplexAnimationBuilder {
    constructor(){
        super(...arguments);
        this.build = ()=>{
            const delayFunction = this.getDelayFunction();
            const [animation, config] = this.getAnimationAndConfig();
            const delay = this.getDelay();
            const callback = this.callbackV;
            const initialValues = this.initialValues;
            return (values)=>{
                "worklet";
                return {
                    animations: {
                        opacity: delayFunction(delay, animation(0, config)),
                        transform: [
                            {
                                rotate: delayFunction(delay, animation("90deg", config))
                            },
                            {
                                translateX: delayFunction(delay, animation(values.currentWidth / 2 - values.currentHeight / 2, config))
                            },
                            {
                                translateY: delayFunction(delay, animation(values.currentWidth / 2 - values.currentHeight / 2, config))
                            }
                        ]
                    },
                    initialValues: Object.assign({
                        opacity: 1,
                        transform: [
                            {
                                rotate: "0deg"
                            },
                            {
                                translateX: 0
                            },
                            {
                                translateY: 0
                            }
                        ]
                    }, initialValues),
                    callback: callback
                };
            };
        };
    }
    static createInstance() {
        return new RotateOutDownLeft();
    }
}
class RotateOutDownRight extends ComplexAnimationBuilder {
    constructor(){
        super(...arguments);
        this.build = ()=>{
            const delayFunction = this.getDelayFunction();
            const [animation, config] = this.getAnimationAndConfig();
            const delay = this.getDelay();
            const callback = this.callbackV;
            const initialValues = this.initialValues;
            return (values)=>{
                "worklet";
                return {
                    animations: {
                        opacity: delayFunction(delay, animation(0, config)),
                        transform: [
                            {
                                rotate: delayFunction(delay, animation("-90deg", config))
                            },
                            {
                                translateX: delayFunction(delay, animation(-(values.currentWidth / 2 - values.currentHeight / 2), config))
                            },
                            {
                                translateY: delayFunction(delay, animation(values.currentWidth / 2 - values.currentHeight / 2, config))
                            }
                        ]
                    },
                    initialValues: Object.assign({
                        opacity: 1,
                        transform: [
                            {
                                rotate: "0deg"
                            },
                            {
                                translateX: 0
                            },
                            {
                                translateY: 0
                            }
                        ]
                    }, initialValues),
                    callback: callback
                };
            };
        };
    }
    static createInstance() {
        return new RotateOutDownRight();
    }
}
class RotateOutUpLeft extends ComplexAnimationBuilder {
    constructor(){
        super(...arguments);
        this.build = ()=>{
            const delayFunction = this.getDelayFunction();
            const [animation, config] = this.getAnimationAndConfig();
            const delay = this.getDelay();
            const callback = this.callbackV;
            const initialValues = this.initialValues;
            return (values)=>{
                "worklet";
                return {
                    animations: {
                        opacity: delayFunction(delay, animation(0, config)),
                        transform: [
                            {
                                rotate: delayFunction(delay, animation("-90deg", config))
                            },
                            {
                                translateX: delayFunction(delay, animation(values.currentWidth / 2 - values.currentHeight / 2, config))
                            },
                            {
                                translateY: delayFunction(delay, animation(-(values.currentWidth / 2 - values.currentHeight / 2), config))
                            }
                        ]
                    },
                    initialValues: Object.assign({
                        opacity: 1,
                        transform: [
                            {
                                rotate: "0deg"
                            },
                            {
                                translateX: 0
                            },
                            {
                                translateY: 0
                            }
                        ]
                    }, initialValues),
                    callback: callback
                };
            };
        };
    }
    static createInstance() {
        return new RotateOutUpLeft();
    }
}
class RotateOutUpRight extends ComplexAnimationBuilder {
    constructor(){
        super(...arguments);
        this.build = ()=>{
            const delayFunction = this.getDelayFunction();
            const [animation, config] = this.getAnimationAndConfig();
            const delay = this.getDelay();
            const callback = this.callbackV;
            const initialValues = this.initialValues;
            return (values)=>{
                "worklet";
                return {
                    animations: {
                        opacity: delayFunction(delay, animation(0, config)),
                        transform: [
                            {
                                rotate: delayFunction(delay, animation("90deg", config))
                            },
                            {
                                translateX: delayFunction(delay, animation(-(values.currentWidth / 2 - values.currentHeight / 2), config))
                            },
                            {
                                translateY: delayFunction(delay, animation(-(values.currentWidth / 2 - values.currentHeight / 2), config))
                            }
                        ]
                    },
                    initialValues: Object.assign({
                        opacity: 1,
                        transform: [
                            {
                                rotate: "0deg"
                            },
                            {
                                translateX: 0
                            },
                            {
                                translateY: 0
                            }
                        ]
                    }, initialValues),
                    callback: callback
                };
            };
        };
    }
    static createInstance() {
        return new RotateOutUpRight();
    }
}

;// CONCATENATED MODULE: ./node_modules/react-native-reanimated/lib/reanimated2/layoutReanimation/defaultAnimations/Roll.js

class RollInLeft extends ComplexAnimationBuilder {
    constructor(){
        super(...arguments);
        this.build = ()=>{
            const delayFunction = this.getDelayFunction();
            const [animation, config] = this.getAnimationAndConfig();
            const delay = this.getDelay();
            const callback = this.callbackV;
            const initialValues = this.initialValues;
            return (values)=>{
                "worklet";
                return {
                    animations: {
                        transform: [
                            {
                                translateX: delayFunction(delay, animation(0), config)
                            },
                            {
                                rotate: delayFunction(delay, animation("0deg", config))
                            }
                        ]
                    },
                    initialValues: Object.assign({
                        transform: [
                            {
                                translateX: -values.windowWidth
                            },
                            {
                                rotate: "-180deg"
                            }
                        ]
                    }, initialValues),
                    callback: callback
                };
            };
        };
    }
    static createInstance() {
        return new RollInLeft();
    }
}
class RollInRight extends ComplexAnimationBuilder {
    constructor(){
        super(...arguments);
        this.build = ()=>{
            const delayFunction = this.getDelayFunction();
            const [animation, config] = this.getAnimationAndConfig();
            const delay = this.getDelay();
            const callback = this.callbackV;
            const initialValues = this.initialValues;
            return (values)=>{
                "worklet";
                return {
                    animations: {
                        transform: [
                            {
                                translateX: delayFunction(delay, animation(0, config))
                            },
                            {
                                rotate: delayFunction(delay, animation("0deg", config))
                            }
                        ]
                    },
                    initialValues: Object.assign({
                        transform: [
                            {
                                translateX: values.windowWidth
                            },
                            {
                                rotate: "180deg"
                            }
                        ]
                    }, initialValues),
                    callback: callback
                };
            };
        };
    }
    static createInstance() {
        return new RollInRight();
    }
}
class RollOutLeft extends ComplexAnimationBuilder {
    constructor(){
        super(...arguments);
        this.build = ()=>{
            const delayFunction = this.getDelayFunction();
            const [animation, config] = this.getAnimationAndConfig();
            const delay = this.getDelay();
            const callback = this.callbackV;
            const initialValues = this.initialValues;
            return (values)=>{
                "worklet";
                return {
                    animations: {
                        transform: [
                            {
                                translateX: delayFunction(delay, animation(-values.windowWidth, config))
                            },
                            {
                                rotate: delayFunction(delay, animation("-180deg", config))
                            }
                        ]
                    },
                    initialValues: Object.assign({
                        transform: [
                            {
                                translateX: 0
                            },
                            {
                                rotate: "0deg"
                            }
                        ]
                    }, initialValues),
                    callback: callback
                };
            };
        };
    }
    static createInstance() {
        return new RollOutLeft();
    }
}
class RollOutRight extends ComplexAnimationBuilder {
    constructor(){
        super(...arguments);
        this.build = ()=>{
            const delayFunction = this.getDelayFunction();
            const [animation, config] = this.getAnimationAndConfig();
            const delay = this.getDelay();
            const callback = this.callbackV;
            const initialValues = this.initialValues;
            return (values)=>{
                "worklet";
                return {
                    animations: {
                        transform: [
                            {
                                translateX: delayFunction(delay, animation(values.windowWidth, config))
                            },
                            {
                                rotate: delayFunction(delay, animation("180deg", config))
                            }
                        ]
                    },
                    initialValues: Object.assign({
                        transform: [
                            {
                                translateX: 0
                            },
                            {
                                rotate: "0deg"
                            }
                        ]
                    }, initialValues),
                    callback: callback
                };
            };
        };
    }
    static createInstance() {
        return new RollOutRight();
    }
}

;// CONCATENATED MODULE: ./node_modules/react-native-reanimated/lib/reanimated2/layoutReanimation/defaultAnimations/index.js











;// CONCATENATED MODULE: ./node_modules/react-native-reanimated/lib/reanimated2/layoutReanimation/defaultTransitions/LinearTransition.js

class LinearTransition extends ComplexAnimationBuilder {
    constructor(){
        super(...arguments);
        this.build = ()=>{
            const delayFunction = this.getDelayFunction();
            const [animation, config] = this.getAnimationAndConfig();
            const callback = this.callbackV;
            const delay = this.getDelay();
            return (values)=>{
                "worklet";
                return {
                    initialValues: {
                        originX: values.currentOriginX,
                        originY: values.currentOriginY,
                        width: values.currentWidth,
                        height: values.currentHeight
                    },
                    animations: {
                        originX: delayFunction(delay, animation(values.targetOriginX, config)),
                        originY: delayFunction(delay, animation(values.targetOriginY, config)),
                        width: delayFunction(delay, animation(values.targetWidth, config)),
                        height: delayFunction(delay, animation(values.targetHeight, config))
                    },
                    callback: callback
                };
            };
        };
    }
    static createInstance() {
        return new LinearTransition();
    }
}
const Layout = LinearTransition;

;// CONCATENATED MODULE: ./node_modules/react-native-reanimated/lib/reanimated2/layoutReanimation/defaultTransitions/FadingTransition.js


class FadingTransition extends BaseAnimationBuilder {
    constructor(){
        super(...arguments);
        this.build = ()=>{
            var _a;
            const delayFunction = this.getDelayFunction();
            const callback = this.callbackV;
            const delay = this.getDelay();
            const duration = (_a = this.durationV) !== null && _a !== void 0 ? _a : 500;
            return (values)=>{
                "worklet";
                return {
                    initialValues: {
                        opacity: 1,
                        originX: values.currentOriginX,
                        originY: values.currentOriginY,
                        width: values.currentWidth,
                        height: values.currentHeight
                    },
                    animations: {
                        opacity: delayFunction(delay, withSequence((0,animation_timing/* withTiming */.j)(0, {
                            duration: duration
                        }), (0,animation_timing/* withTiming */.j)(1, {
                            duration: duration
                        }))),
                        originX: delayFunction(delay + duration, (0,animation_timing/* withTiming */.j)(values.targetOriginX, {
                            duration: 50
                        })),
                        originY: delayFunction(delay + duration, (0,animation_timing/* withTiming */.j)(values.targetOriginY, {
                            duration: 50
                        })),
                        width: delayFunction(delay + duration, (0,animation_timing/* withTiming */.j)(values.targetWidth, {
                            duration: 50
                        })),
                        height: delayFunction(delay + duration, (0,animation_timing/* withTiming */.j)(values.targetHeight, {
                            duration: 50
                        }))
                    },
                    callback: callback
                };
            };
        };
    }
    static createInstance() {
        return new FadingTransition();
    }
}

;// CONCATENATED MODULE: ./node_modules/react-native-reanimated/lib/reanimated2/layoutReanimation/defaultTransitions/SequencedTransition.js


class SequencedTransition extends BaseAnimationBuilder {
    constructor(){
        super(...arguments);
        this.reversed = false;
        this.build = ()=>{
            var _a;
            const delayFunction = this.getDelayFunction();
            const callback = this.callbackV;
            const delay = this.getDelay();
            const sequenceDuration = ((_a = this.durationV) !== null && _a !== void 0 ? _a : 500) / 2;
            const config = {
                duration: sequenceDuration
            };
            const reverse = this.reversed;
            return (values)=>{
                "worklet";
                return {
                    initialValues: {
                        originX: values.currentOriginX,
                        originY: values.currentOriginY,
                        width: values.currentWidth,
                        height: values.currentHeight
                    },
                    animations: {
                        originX: delayFunction(delay, withSequence((0,animation_timing/* withTiming */.j)(reverse ? values.currentOriginX : values.targetOriginX, config), (0,animation_timing/* withTiming */.j)(values.targetOriginX, config))),
                        originY: delayFunction(delay, withSequence((0,animation_timing/* withTiming */.j)(reverse ? values.targetOriginY : values.currentOriginY, config), (0,animation_timing/* withTiming */.j)(values.targetOriginY, config))),
                        width: delayFunction(delay, withSequence((0,animation_timing/* withTiming */.j)(reverse ? values.currentWidth : values.targetWidth, config), (0,animation_timing/* withTiming */.j)(values.targetWidth, config))),
                        height: delayFunction(delay, withSequence((0,animation_timing/* withTiming */.j)(reverse ? values.targetHeight : values.currentHeight, config), (0,animation_timing/* withTiming */.j)(values.targetHeight, config)))
                    },
                    callback: callback
                };
            };
        };
    }
    static createInstance() {
        return new SequencedTransition();
    }
    static reverse() {
        const instance = SequencedTransition.createInstance();
        return instance.reverse();
    }
    reverse() {
        this.reversed = !this.reversed;
        return this;
    }
}

;// CONCATENATED MODULE: ./node_modules/react-native-reanimated/lib/reanimated2/layoutReanimation/defaultTransitions/JumpingTransition.js



class JumpingTransition extends BaseAnimationBuilder {
    constructor(){
        super(...arguments);
        this.build = ()=>{
            var _a;
            const delayFunction = this.getDelayFunction();
            const callback = this.callbackV;
            const delay = this.getDelay();
            const duration = ((_a = this.durationV) !== null && _a !== void 0 ? _a : 300) / 2;
            const config = {
                duration: duration * 2
            };
            return (values)=>{
                "worklet";
                const d = Math.max(Math.abs(values.targetOriginX - values.currentOriginX), Math.abs(values.targetOriginY - values.currentOriginY));
                return {
                    initialValues: {
                        originX: values.currentOriginX,
                        originY: values.currentOriginY,
                        width: values.currentWidth,
                        height: values.currentHeight
                    },
                    animations: {
                        originX: delayFunction(delay, (0,animation_timing/* withTiming */.j)(values.targetOriginX, config)),
                        originY: delayFunction(delay, withSequence((0,animation_timing/* withTiming */.j)(Math.min(values.targetOriginY, values.currentOriginY) - d, {
                            duration,
                            easing: reanimated2_Easing/* Easing */.o.out(reanimated2_Easing/* Easing */.o.exp)
                        }), (0,animation_timing/* withTiming */.j)(values.targetOriginY, Object.assign(Object.assign({}, config), {
                            duration,
                            easing: reanimated2_Easing/* Easing */.o.bounce
                        })))),
                        width: delayFunction(delay, (0,animation_timing/* withTiming */.j)(values.targetWidth, config)),
                        height: delayFunction(delay, (0,animation_timing/* withTiming */.j)(values.targetHeight, config))
                    },
                    callback: callback
                };
            };
        };
    }
    static createInstance() {
        return new JumpingTransition();
    }
}

;// CONCATENATED MODULE: ./node_modules/react-native-reanimated/lib/reanimated2/layoutReanimation/defaultTransitions/CurvedTransition.js



class CurvedTransition extends BaseAnimationBuilder {
    constructor(){
        super(...arguments);
        this.easingXV = reanimated2_Easing/* Easing */.o.in(reanimated2_Easing/* Easing */.o.ease);
        this.easingYV = reanimated2_Easing/* Easing */.o.out(reanimated2_Easing/* Easing */.o.ease);
        this.easingWidthV = reanimated2_Easing/* Easing */.o.in(reanimated2_Easing/* Easing */.o.exp);
        this.easingHeightV = reanimated2_Easing/* Easing */.o.out(reanimated2_Easing/* Easing */.o.exp);
        this.build = ()=>{
            var _a;
            const delayFunction = this.getDelayFunction();
            const callback = this.callbackV;
            const delay = this.getDelay();
            const duration = (_a = this.durationV) !== null && _a !== void 0 ? _a : 300;
            const easing = {
                easingX: this.easingXV,
                easingY: this.easingYV,
                easingWidth: this.easingWidthV,
                easingHeight: this.easingHeightV
            };
            return (values)=>{
                "worklet";
                return {
                    initialValues: {
                        originX: values.currentOriginX,
                        originY: values.currentOriginY,
                        width: values.currentWidth,
                        height: values.currentHeight
                    },
                    animations: {
                        originX: delayFunction(delay, (0,animation_timing/* withTiming */.j)(values.targetOriginX, {
                            duration,
                            easing: easing.easingX
                        })),
                        originY: delayFunction(delay, (0,animation_timing/* withTiming */.j)(values.targetOriginY, {
                            duration,
                            easing: easing.easingY
                        })),
                        width: delayFunction(delay, (0,animation_timing/* withTiming */.j)(values.targetWidth, {
                            duration,
                            easing: easing.easingWidth
                        })),
                        height: delayFunction(delay, (0,animation_timing/* withTiming */.j)(values.targetHeight, {
                            duration,
                            easing: easing.easingHeight
                        }))
                    },
                    callback: callback
                };
            };
        };
    }
    static createInstance() {
        return new CurvedTransition();
    }
    static easingX(easing) {
        const instance = this.createInstance();
        return instance.easingX(easing);
    }
    easingX(easing) {
        this.easingXV = easing;
        return this;
    }
    static easingY(easing) {
        const instance = this.createInstance();
        return instance.easingY(easing);
    }
    easingY(easing) {
        this.easingYV = easing;
        return this;
    }
    static easingWidth(easing) {
        const instance = this.createInstance();
        return instance.easingWidth(easing);
    }
    easingWidth(easing) {
        this.easingWidthV = easing;
        return this;
    }
    static easingHeight(easing) {
        const instance = this.createInstance();
        return instance.easingHeight(easing);
    }
    easingHeight(easing) {
        this.easingHeightV = easing;
        return this;
    }
}

;// CONCATENATED MODULE: ./node_modules/react-native-reanimated/lib/reanimated2/layoutReanimation/defaultTransitions/EntryExitTransition.js



class EntryExitTransition extends BaseAnimationBuilder {
    constructor(){
        super(...arguments);
        this.enteringV = FadeIn;
        this.exitingV = FadeOut;
        this.build = ()=>{
            const delayFunction = this.getDelayFunction();
            const callback = this.callbackV;
            const delay = this.getDelay();
            const enteringAnimation = this.enteringV.build();
            const exitingAnimation = this.exitingV.build();
            const exitingDuration = this.exitingV.getDuration();
            return (values)=>{
                "worklet";
                var _a, _b, _c, _d;
                const enteringValues = enteringAnimation(values);
                const exitingValues = exitingAnimation(values);
                const animations = {
                    transform: []
                };
                for (const prop of Object.keys(exitingValues.animations)){
                    if (prop === "transform") {
                        (_a = exitingValues.animations[prop]) === null || _a === void 0 ? void 0 : _a.forEach((value, index)=>{
                            var _a;
                            for (const transformProp of Object.keys(value)){
                                (_a = animations.transform) === null || _a === void 0 ? void 0 : _a.push({
                                    [transformProp]: delayFunction(delay, withSequence(value[transformProp], (0,animation_timing/* withTiming */.j)(exitingValues.initialValues.transform ? exitingValues.initialValues.transform[index][transformProp] : 0, {
                                        duration: 0
                                    })))
                                });
                            }
                        });
                    } else {
                        const sequence = enteringValues.animations[prop] !== undefined ? [
                            exitingValues.animations[prop],
                            (0,animation_timing/* withTiming */.j)(enteringValues.initialValues[prop], {
                                duration: 0
                            }),
                            enteringValues.animations[prop]
                        ] : [
                            exitingValues.animations[prop],
                            (0,animation_timing/* withTiming */.j)(Object.keys(values).includes(prop) ? values[prop] : exitingValues.initialValues[prop], {
                                duration: 0
                            })
                        ];
                        animations[prop] = delayFunction(delay, withSequence(...sequence));
                    }
                }
                for (const prop of Object.keys(enteringValues.animations)){
                    if (prop === "transform") {
                        (_b = enteringValues.animations[prop]) === null || _b === void 0 ? void 0 : _b.forEach((value, index)=>{
                            var _a;
                            for (const transformProp of Object.keys(value)){
                                (_a = animations.transform) === null || _a === void 0 ? void 0 : _a.push({
                                    [transformProp]: delayFunction(delay + exitingDuration, withSequence((0,animation_timing/* withTiming */.j)(enteringValues.initialValues.transform ? enteringValues.initialValues.transform[index][transformProp] : 0, {
                                        duration: exitingDuration
                                    }), value[transformProp]))
                                });
                            }
                        });
                    } else if (animations[prop] !== undefined) {
                        continue;
                    } else {
                        animations[prop] = delayFunction(delay, withSequence((0,animation_timing/* withTiming */.j)(enteringValues.initialValues[prop], {
                            duration: 0
                        }), enteringValues.animations[prop]));
                    }
                }
                const mergedTransform = ((_c = exitingValues.initialValues.transform) !== null && _c !== void 0 ? _c : []).concat(((_d = enteringValues.animations.transform) !== null && _d !== void 0 ? _d : []).map((value)=>{
                    const objectKeys = Object.keys(value);
                    if ((objectKeys === null || objectKeys === void 0 ? void 0 : objectKeys.length) < 1) {
                        console.error(`[Reanimated]: \${value} is not a valid Transform object`);
                        return value;
                    }
                    const transformProp = objectKeys[0];
                    const current = value[transformProp].current;
                    if (typeof current === "string") {
                        if (current.includes("deg")) return {
                            [transformProp]: "0deg"
                        };
                        else return {
                            [transformProp]: "0"
                        };
                    } else if (transformProp.includes("translate")) {
                        return {
                            [transformProp]: 0
                        };
                    } else {
                        return {
                            [transformProp]: 1
                        };
                    }
                    return value;
                }));
                return {
                    initialValues: Object.assign(Object.assign({}, exitingValues.initialValues), {
                        originX: values.currentOriginX,
                        originY: values.currentOriginY,
                        width: values.currentWidth,
                        height: values.currentHeight,
                        transform: mergedTransform
                    }),
                    animations: Object.assign({
                        originX: delayFunction(delay + exitingDuration, (0,animation_timing/* withTiming */.j)(values.targetOriginX, {
                            duration: exitingDuration
                        })),
                        originY: delayFunction(delay + exitingDuration, (0,animation_timing/* withTiming */.j)(values.targetOriginY, {
                            duration: exitingDuration
                        })),
                        width: delayFunction(delay + exitingDuration, (0,animation_timing/* withTiming */.j)(values.targetWidth, {
                            duration: exitingDuration
                        })),
                        height: delayFunction(delay + exitingDuration, (0,animation_timing/* withTiming */.j)(values.targetHeight, {
                            duration: exitingDuration
                        }))
                    }, animations),
                    callback: callback
                };
            };
        };
    }
    static createInstance() {
        return new EntryExitTransition();
    }
    static entering(animation) {
        const instance = this.createInstance();
        return instance.entering(animation);
    }
    entering(animation) {
        this.enteringV = animation;
        return this;
    }
    static exiting(animation) {
        const instance = this.createInstance();
        return instance.exiting(animation);
    }
    exiting(animation) {
        this.exitingV = animation;
        return this;
    }
}
function combineTransition(exiting, entering) {
    return EntryExitTransition.entering(entering).exiting(exiting);
}

;// CONCATENATED MODULE: ./node_modules/react-native-reanimated/lib/reanimated2/layoutReanimation/defaultTransitions/index.js







;// CONCATENATED MODULE: ./node_modules/react-native-reanimated/lib/reanimated2/layoutReanimation/index.js





;// CONCATENATED MODULE: ./node_modules/react-native-reanimated/lib/reanimated2/utils.js

/**
 * Given an absolute position and a component ref, returns the relative
 * position in the component's local coordinate space.
 */ function getRelativeCoords(parentRef, absoluteX, absoluteY) {
    "worklet";
    const parentCoords = measure(parentRef);
    if (parentCoords === null) {
        return null;
    }
    return {
        x: absoluteX - parentCoords.x,
        y: absoluteY - parentCoords.y
    };
}

;// CONCATENATED MODULE: ./node_modules/react-native-reanimated/lib/reanimated2/index.js













;// CONCATENATED MODULE: ./node_modules/react-native-reanimated/lib/index.js


if (!js_reanimated_global) {
    /*
      `webGlobalIsInitialized` should always be `true`,
      but we need to use `webGlobalIsInitialized` somewhere to ensure function execution,
      in another way, the bundler can remove unused variables.
    */ console.error("[Reanimated] Unable to initialize global objects for web.");
}
// @ts-ignore backward compatibility with treeshaking


/* harmony default export */ const lib = (Animated_namespaceObject);


/***/ }),

/***/ 88593:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  Z: () => (/* binding */ Easing)
});

// EXTERNAL MODULE: ./node_modules/react-native-reanimated/lib/reanimated1/operators.js + 1 modules
var operators = __webpack_require__(66889);
// EXTERNAL MODULE: ./node_modules/react-native-reanimated/lib/reanimated1/core/AnimatedCond.js
var AnimatedCond = __webpack_require__(14584);
// EXTERNAL MODULE: ./node_modules/react-native-reanimated/lib/reanimated1/val.js
var val = __webpack_require__(47599);
// EXTERNAL MODULE: ./node_modules/react-native-reanimated/lib/reanimated1/core/AnimatedNode.js
var AnimatedNode = __webpack_require__(70009);
// EXTERNAL MODULE: external "invariant"
var external_invariant_ = __webpack_require__(67644);
var external_invariant_default = /*#__PURE__*/__webpack_require__.n(external_invariant_);
;// CONCATENATED MODULE: ./node_modules/react-native-reanimated/lib/reanimated1/core/AnimatedBezier.js



// These values are established by empiricism with tests (tradeoff: performance VS precision)
var NEWTON_ITERATIONS = 4;
var NEWTON_MIN_SLOPE = 0.001;
var SUBDIVISION_PRECISION = 0.0000001;
var SUBDIVISION_MAX_ITERATIONS = 10;
var kSplineTableSize = 11;
var kSampleStepSize = 1.0 / (kSplineTableSize - 1.0);
var float32ArraySupported = typeof Float32Array === "function";
function A(aA1, aA2) {
    return 1.0 - 3.0 * aA2 + 3.0 * aA1;
}
function B(aA1, aA2) {
    return 3.0 * aA2 - 6.0 * aA1;
}
function C(aA1) {
    return 3.0 * aA1;
}
// Returns x(t) given t, x1, and x2, or y(t) given t, y1, and y2.
function calcBezier(aT, aA1, aA2) {
    return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT;
}
// Returns dx/dt given t, x1, and x2, or dy/dt given t, y1, and y2.
function getSlope(aT, aA1, aA2) {
    return 3.0 * A(aA1, aA2) * aT * aT + 2.0 * B(aA1, aA2) * aT + C(aA1);
}
function binarySubdivide(aX, aA, aB, mX1, mX2) {
    var currentX = 0;
    var currentT = 0;
    var i = 0;
    do {
        currentT = aA + (aB - aA) / 2.0;
        currentX = calcBezier(currentT, mX1, mX2) - aX;
        if (currentX > 0.0) {
            aB = currentT;
        } else {
            aA = currentT;
        }
    }while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);
    return currentT;
}
function newtonRaphsonIterate(aX, aGuessT, mX1, mX2) {
    for(var i = 0; i < NEWTON_ITERATIONS; ++i){
        var currentSlope = getSlope(aGuessT, mX1, mX2);
        if (currentSlope === 0.0) {
            return aGuessT;
        }
        var currentX = calcBezier(aGuessT, mX1, mX2) - aX;
        aGuessT -= currentX / currentSlope;
    }
    return aGuessT;
}
function bezier(mX1, mY1, mX2, mY2) {
    // Precompute samples table
    var sampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize);
    if (mX1 !== mY1 || mX2 !== mY2) {
        for(var i = 0; i < kSplineTableSize; ++i){
            sampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);
        }
    }
    function getTForX(aX) {
        var intervalStart = 0.0;
        var currentSample = 1;
        var lastSample = kSplineTableSize - 1;
        for(; currentSample !== lastSample && sampleValues[currentSample] <= aX; ++currentSample){
            intervalStart += kSampleStepSize;
        }
        --currentSample;
        // Interpolate to provide an initial guess for t
        var dist = (aX - sampleValues[currentSample]) / (sampleValues[currentSample + 1] - sampleValues[currentSample]);
        var guessForT = intervalStart + dist * kSampleStepSize;
        var initialSlope = getSlope(guessForT, mX1, mX2);
        if (initialSlope >= NEWTON_MIN_SLOPE) {
            return newtonRaphsonIterate(aX, guessForT, mX1, mX2);
        } else if (initialSlope === 0.0) {
            return guessForT;
        } else {
            return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);
        }
    }
    return function BezierEasing(x) {
        if (mX1 === mY1 && mX2 === mY2) {
            return x; // linear
        }
        // Because JavaScript number are imprecise, we should guarantee the extremes are right.
        if (x === 0) {
            return 0;
        }
        if (x === 1) {
            return 1;
        }
        return calcBezier(getTForX(x), mY1, mY2);
    };
}
class AnimatedBezier extends AnimatedNode/* default */.ZP {
    constructor(value, mX1, mY1, mX2, mY2){
        external_invariant_default()(value instanceof AnimatedNode/* default */.ZP, `Reanimated: Bezier node argument should be of type AnimatedNode but got ${value}`);
        super({
            type: "bezier",
            mX1,
            mY1,
            mX2,
            mY2,
            input: value
        }, [
            value
        ]);
        this._value = value;
        this._bezier = bezier(mX1, mY1, mX2, mY2);
    }
    toString() {
        return `AnimatedBezier, id: ${this.__nodeID}`;
    }
    __onEvaluate() {
        return this._bezier((0,val/* val */.P)(this._value));
    }
}

;// CONCATENATED MODULE: ./node_modules/react-native-reanimated/lib/reanimated1/Easing.js


/**
 * The `Easing` module implements common easing functions. This module is used
 * by [Animate.timing()](docs/animate.html#timing) to convey physically
 * believable motion in animations.
 *
 * You can find a visualization of some common easing functions at
 * http://easings.net/
 *
 * ### Predefined animations
 *
 * The `Easing` module provides several predefined animations through the
 * following methods:
 *
 * - [`back`](docs/easing.html#back) provides a simple animation where the
 *   object goes slightly back before moving forward
 * - [`bounce`](docs/easing.html#bounce) provides a bouncing animation
 * - [`ease`](docs/easing.html#ease) provides a simple inertial animation
 * - [`elastic`](docs/easing.html#elastic) provides a simple spring interaction
 *
 * ### Standard functions
 *
 * Three standard easing functions are provided:
 *
 * - [`linear`](docs/easing.html#linear)
 * - [`quad`](docs/easing.html#quad)
 * - [`cubic`](docs/easing.html#cubic)
 *
 * The [`poly`](docs/easing.html#poly) function can be used to implement
 * quartic, quintic, and other higher power functions.
 *
 * ### Additional functions
 *
 * Additional mathematical functions are provided by the following methods:
 *
 * - [`bezier`](docs/easing.html#bezier) provides a cubic bezier curve
 * - [`circle`](docs/easing.html#circle) provides a circular function
 * - [`sin`](docs/easing.html#sin) provides a sinusoidal function
 * - [`exp`](docs/easing.html#exp) provides an exponential function
 *
 * The following helpers are used to modify other easing functions.
 *
 * - [`in`](docs/easing.html#in) runs an easing function forwards
 * - [`inOut`](docs/easing.html#inout) makes any easing function symmetrical
 * - [`out`](docs/easing.html#out) runs an easing function backwards
 */ class Easing {
    /**
   * A linear function, `f(t) = t`. Position correlates to elapsed time one to
   * one.
   *
   * http://cubic-bezier.com/#0,0,1,1
   */ static linear(t) {
        return t;
    }
    /**
   * A simple inertial interaction, similar to an object slowly accelerating to
   * speed.
   *
   * http://cubic-bezier.com/#.42,0,1,1
   */ static ease(t) {
        return new AnimatedBezier(t, 0.42, 0, 1, 1);
    }
    /**
   * A quadratic function, `f(t) = t * t`. Position equals the square of elapsed
   * time.
   *
   * http://easings.net/#easeInQuad
   */ static quad(t) {
        return (0,operators/* multiply */.Jp)(t, t);
    }
    /**
   * A cubic function, `f(t) = t * t * t`. Position equals the cube of elapsed
   * time.
   *
   * http://easings.net/#easeInCubic
   */ static cubic(t) {
        return (0,operators/* multiply */.Jp)(t, t, t);
    }
    /**
   * A power function. Position is equal to the Nth power of elapsed time.
   *
   * n = 4: http://easings.net/#easeInQuart
   * n = 5: http://easings.net/#easeInQuint
   */ static poly(n) {
        return (t)=>(0,operators/* pow */.sQ)(t, n);
    }
    /**
   * A sinusoidal function.
   *
   * http://easings.net/#easeInSine
   */ static sin(t) {
        return (0,operators/* sub */.lu)(1, (0,operators/* cos */.mC)((0,operators/* multiply */.Jp)(t, Math.PI, 0.5)));
    }
    /**
   * A circular function.
   *
   * http://easings.net/#easeInCirc
   */ static circle(t) {
        return (0,operators/* sub */.lu)(1, (0,operators/* sqrt */._b)((0,operators/* sub */.lu)(1, (0,operators/* multiply */.Jp)(t, t))));
    }
    /**
   * An exponential function.
   *
   * http://easings.net/#easeInExpo
   */ static exp(t) {
        return (0,operators/* pow */.sQ)(2, (0,operators/* multiply */.Jp)(10, (0,operators/* sub */.lu)(t, 1)));
    }
    /**
   * A simple elastic interaction, similar to a spring oscillating back and
   * forth.
   *
   * Default bounciness is 1, which overshoots a little bit once. 0 bounciness
   * doesn't overshoot at all, and bounciness of N > 1 will overshoot about N
   * times.
   *
   * http://easings.net/#easeInElastic
   */ static elastic(bounciness = 1) {
        const p = bounciness * Math.PI;
        return (t)=>(0,operators/* sub */.lu)(1, (0,operators/* multiply */.Jp)((0,operators/* pow */.sQ)((0,operators/* cos */.mC)((0,operators/* multiply */.Jp)(t, Math.PI, 0.5)), 3), (0,operators/* cos */.mC)((0,operators/* multiply */.Jp)(t, p))));
    }
    /**
   * Use with `Animated.parallel()` to create a simple effect where the object
   * animates back slightly as the animation starts.
   *
   * Wolfram Plot:
   *
   * - http://tiny.cc/back_default (s = 1.70158, default)
   */ static back(s) {
        if (s === undefined) {
            s = 1.70158;
        }
        return (t)=>(0,operators/* multiply */.Jp)(t, t, (0,operators/* sub */.lu)((0,operators/* multiply */.Jp)((0,operators/* add */.IH)(s, 1), t), s));
    }
    /**
   * Provides a simple bouncing effect.
   *
   * http://easings.net/#easeInBounce
   */ static bounce(t) {
        const sq = (v)=>(0,operators/* multiply */.Jp)(7.5625, v, v);
        return (0,AnimatedCond/* createAnimatedCond */.d)((0,operators/* lessThan */.Qj)(t, 1 / 2.75), sq(t), (0,AnimatedCond/* createAnimatedCond */.d)((0,operators/* lessThan */.Qj)(t, 2 / 2.75), (0,operators/* add */.IH)(0.75, sq((0,operators/* sub */.lu)(t, 1.5 / 2.75))), (0,AnimatedCond/* createAnimatedCond */.d)((0,operators/* lessThan */.Qj)(t, 2.5 / 2.76), (0,operators/* add */.IH)(0.9375, sq((0,operators/* sub */.lu)(t, 2.25 / 2.75))), (0,operators/* add */.IH)(0.984375, sq((0,operators/* sub */.lu)(t, 2.625 / 2.75))))));
    }
    /**
   * Provides a cubic bezier curve, equivalent to CSS Transitions'
   * `transition-timing-function`.
   *
   * A useful tool to visualize cubic bezier curves can be found at
   * http://cubic-bezier.com/
   */ static bezier(x1, y1, x2, y2) {
        return (t)=>new AnimatedBezier(t, x1, y1, x2, y2);
    }
    /**
   * Runs an easing function forwards.
   */ static in(easing) {
        return easing;
    }
    /**
   * Runs an easing function backwards.
   */ static out(easing) {
        return (t)=>(0,operators/* sub */.lu)(1, easing((0,operators/* sub */.lu)(1, t)));
    }
    /**
   * Makes any easing function symmetrical. The easing function will run
   * forwards for half of the duration, then backwards for the rest of the
   * duration.
   */ static inOut(easing) {
        return (t)=>(0,AnimatedCond/* createAnimatedCond */.d)((0,operators/* lessThan */.Qj)(t, 0.5), (0,operators/* divide */.cs)(easing((0,operators/* multiply */.Jp)(t, 2)), 2), (0,operators/* sub */.lu)(1, (0,operators/* divide */.cs)(easing((0,operators/* multiply */.Jp)((0,operators/* sub */.lu)(1, t), 2)), 2)));
    }
}


/***/ }),

/***/ 48282:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   F: () => (/* binding */ createAnimatedBlock),
/* harmony export */   p: () => (/* binding */ adapt)
/* harmony export */ });
/* harmony import */ var invariant__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(67644);
/* harmony import */ var invariant__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(invariant__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _val__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(47599);
/* harmony import */ var _AnimatedNode__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(70009);
/* harmony import */ var _InternalAnimatedValue__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(93513);




class AnimatedBlock extends _AnimatedNode__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .ZP {
    constructor(array){
        invariant__WEBPACK_IMPORTED_MODULE_0___default()(array.every((el)=>el instanceof _AnimatedNode__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .ZP), `Reanimated: Animated.block node argument should be an array with elements of type AnimatedNode. One or more of them are not AnimatedNodes`);
        super({
            type: "block",
            block: array
        }, array);
        this._array = array;
    }
    toString() {
        return `AnimatedBlock, id: ${this.__nodeID}`;
    }
    __onEvaluate() {
        let result;
        this._array.forEach((node)=>{
            result = (0,_val__WEBPACK_IMPORTED_MODULE_2__/* .val */ .P)(node);
        });
        return result;
    }
}
function createAnimatedBlock(items) {
    return adapt(items);
}
function nodify(v) {
    if (typeof v === "object" && v?.__isProxy) {
        if (!v.__val) {
            v.__val = new _InternalAnimatedValue__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z(0);
        }
        return v.__val;
    }
    // TODO: cache some typical static values (e.g. 0, 1, -1)
    return v instanceof _AnimatedNode__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .ZP ? v : _InternalAnimatedValue__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z.valueForConstant(v);
}
function adapt(v) {
    return Array.isArray(v) ? new AnimatedBlock(v.map((node)=>adapt(node))) : nodify(v);
}


/***/ }),

/***/ 14584:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   d: () => (/* binding */ createAnimatedCond)
/* harmony export */ });
/* harmony import */ var invariant__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(67644);
/* harmony import */ var invariant__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(invariant__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _core_AnimatedBlock__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(48282);
/* harmony import */ var _val__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(47599);
/* harmony import */ var _AnimatedNode__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(70009);




class AnimatedCond extends _AnimatedNode__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .ZP {
    constructor(condition, ifBlock, elseBlock){
        invariant__WEBPACK_IMPORTED_MODULE_0___default()(condition instanceof _AnimatedNode__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .ZP, `Reanimated: Animated.cond node first argument should be of type AnimatedNode but got ${condition}`);
        invariant__WEBPACK_IMPORTED_MODULE_0___default()(ifBlock instanceof _AnimatedNode__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .ZP, `Reanimated: Animated.cond node second argument should be of type AnimatedNode but got ${ifBlock}`);
        invariant__WEBPACK_IMPORTED_MODULE_0___default()(elseBlock instanceof _AnimatedNode__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .ZP || elseBlock === undefined, `Reanimated: Animated.cond node third argument should be of type AnimatedNode or should be undefined but got ${elseBlock}`);
        super({
            type: "cond",
            cond: condition,
            ifBlock,
            elseBlock
        }, [
            condition,
            ifBlock,
            elseBlock
        ]);
        this._condition = condition;
        this._ifBlock = ifBlock;
        this._elseBlock = elseBlock;
    }
    toString() {
        return `AnimatedCond, id: ${this.__nodeID}`;
    }
    __onEvaluate() {
        if ((0,_val__WEBPACK_IMPORTED_MODULE_2__/* .val */ .P)(this._condition)) {
            return (0,_val__WEBPACK_IMPORTED_MODULE_2__/* .val */ .P)(this._ifBlock);
        } else {
            return this._elseBlock !== undefined ? (0,_val__WEBPACK_IMPORTED_MODULE_2__/* .val */ .P)(this._elseBlock) : undefined;
        }
    }
}
function createAnimatedCond(cond, ifBlock, elseBlock) {
    return new AnimatedCond((0,_core_AnimatedBlock__WEBPACK_IMPORTED_MODULE_3__/* .adapt */ .p)(cond), (0,_core_AnimatedBlock__WEBPACK_IMPORTED_MODULE_3__/* .adapt */ .p)(ifBlock), elseBlock === undefined ? undefined : (0,_core_AnimatedBlock__WEBPACK_IMPORTED_MODULE_3__/* .adapt */ .p)(elseBlock));
}


/***/ }),

/***/ 70009:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $I: () => (/* binding */ setCallID),
/* harmony export */   I: () => (/* binding */ getCallID),
/* harmony export */   ZP: () => (/* binding */ AnimatedNode)
/* harmony export */ });
/* harmony import */ var _ReanimatedModule__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(30665);
/* harmony import */ var react_native__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(83849);


const UPDATED_NODES = [];
let loopID = 1;
let propUpdatesEnqueued = null;
let nodeCount = 0;
let callID = "";
function getCallID() {
    return callID;
}
function setCallID(nextCallID) {
    callID = nextCallID;
}
function sanitizeConfig(config) {
    if (react_native__WEBPACK_IMPORTED_MODULE_0__.Platform.OS === "web" || react_native__WEBPACK_IMPORTED_MODULE_0__.Platform.OS === "windows" || react_native__WEBPACK_IMPORTED_MODULE_0__.Platform.OS === "macos" || [
        "undefined",
        "string",
        "function",
        "boolean",
        "number"
    ].includes(typeof config)) {
        return config;
    } else if (Array.isArray(config)) {
        return config.map(sanitizeConfig);
    } else if (config instanceof AnimatedNode) {
        return config.__nodeID;
    } else if (typeof config === "object") {
        const output = {};
        for(const property in config){
            if (property in config) {
                output[property] = sanitizeConfig(config[property]);
            }
        }
        return output;
    }
    // unhandled
    return config;
}
function runPropUpdates() {
    const visitedNodes = new Set();
    const findAndUpdateNodes = (node)=>{
        if (!node) {
            console.warn("findAndUpdateNodes was passed a nullish node");
            return;
        }
        if (visitedNodes.has(node)) {
            return;
        } else {
            visitedNodes.add(node);
        }
        if (typeof node.update === "function") {
            node.update();
        } else {
            const nodes = node.__getChildren();
            if (nodes) {
                for(let i = 0, l = nodes.length; i < l; i++){
                    findAndUpdateNodes(nodes[i]);
                }
            }
        }
    };
    for(let i = 0; i < UPDATED_NODES.length; i++){
        const node = UPDATED_NODES[i];
        findAndUpdateNodes(node);
    }
    UPDATED_NODES.length = 0; // clear array
    propUpdatesEnqueued = null;
    loopID += 1;
}
const scheduleUpdates = react_native__WEBPACK_IMPORTED_MODULE_0__.Platform.OS === "web" ? requestAnimationFrame : setImmediate;
class AnimatedNode {
    constructor(nodeConfig, inputNodes){
        this.__lastLoopID = {
            "": -1
        };
        this.__memoizedValue = {
            "": null
        };
        this.__children = [];
        this.__nodeID = ++nodeCount;
        this.__nodeConfig = sanitizeConfig(nodeConfig);
        this.__initialized = false;
        this.__inputNodes = inputNodes && inputNodes.filter((node)=>node instanceof AnimatedNode);
    }
    toString() {
        return `AnimatedNode, id: ${this.__nodeID}`;
    }
    __attach() {
        this.__nativeInitialize();
        const nodes = this.__inputNodes;
        if (nodes) {
            for(let i = 0, l = nodes.length; i < l; i++){
                nodes[i].__addChild(this);
            }
        }
    }
    __detach() {
        const nodes = this.__inputNodes;
        if (nodes) {
            for(let i = 0, l = nodes.length; i < l; i++){
                nodes[i].__removeChild(this);
            }
        }
        this.__nativeTearDown();
    }
    __getValue() {
        if (!(callID in this.__lastLoopID) || this.__lastLoopID[callID] < loopID) {
            this.__lastLoopID[callID] = loopID;
            const result = this.__onEvaluate();
            this.__memoizedValue[callID] = result;
            return result;
        }
        return this.__memoizedValue[callID];
    }
    __forceUpdateCache(newValue) {
        this.__memoizedValue[callID] = newValue;
        this.__markUpdated();
    }
    __dangerouslyRescheduleEvaluate() {
        this.__lastLoopID[callID] = -1;
        this.__markUpdated();
    }
    __markUpdated() {
        UPDATED_NODES.push(this);
        if (!propUpdatesEnqueued) {
            propUpdatesEnqueued = scheduleUpdates(runPropUpdates);
        }
    }
    __nativeInitialize() {
        if (!this.__initialized) {
            _ReanimatedModule__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z.createNode(this.__nodeID, {
                ...this.__nodeConfig
            });
            this.__initialized = true;
        }
    }
    __nativeTearDown() {
        if (this.__initialized) {
            _ReanimatedModule__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z.dropNode(this.__nodeID);
            this.__initialized = false;
        }
    }
    isNativelyInitialized() {
        return this.__initialized;
    }
    __onEvaluate() {
        throw new Error("Missing implementation of onEvaluate");
    }
    __getProps() {
        return this.__getValue();
    }
    __getChildren() {
        return this.__children;
    }
    __addChild(child) {
        if (this.__children.length === 0) {
            this.__attach();
        }
        this.__children.push(child);
        child.__nativeInitialize();
        if (_ReanimatedModule__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z.connectNodes) {
            _ReanimatedModule__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z.connectNodes(this.__nodeID, child.__nodeID);
        } else {
            child.__dangerouslyRescheduleEvaluate();
        }
    }
    __removeChild(child) {
        const index = this.__children.indexOf(child);
        if (index === -1) {
            console.warn("Trying to remove a child that doesn't exist");
            return;
        }
        if (_ReanimatedModule__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z.disconnectNodes) {
            _ReanimatedModule__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z.disconnectNodes(this.__nodeID, child.__nodeID);
        }
        this.__children.splice(index, 1);
        if (this.__children.length === 0) {
            this.__detach();
        }
    }
    _connectAnimatedView(nativeViewTag) {
        if (_ReanimatedModule__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z.connectNodeToView) {
            _ReanimatedModule__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z.connectNodeToView(this.__nodeID, nativeViewTag);
        } else {
            this.__dangerouslyRescheduleEvaluate();
        }
    }
    _disconnectAnimatedView(nativeViewTag) {
        _ReanimatedModule__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z.disconnectNodeFromView(this.__nodeID, nativeViewTag);
    }
}


/***/ }),

/***/ 93513:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Z: () => (/* binding */ InternalAnimatedValue)
/* harmony export */ });
/* harmony import */ var _AnimatedNode__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(70009);
/* harmony import */ var _val__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(47599);
/* harmony import */ var _ReanimatedModule__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(30665);
/* harmony import */ var invariant__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(67644);
/* harmony import */ var invariant__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(invariant__WEBPACK_IMPORTED_MODULE_0__);




function sanitizeValue(value) {
    return value === null || value === undefined || typeof value === "string" ? value : Number(value);
}
const CONSTANT_VALUES = new Map();
function initializeConstantValues() {
    if (CONSTANT_VALUES.size !== 0) {
        return;
    }
    [
        0,
        -1,
        1,
        -2,
        2
    ].forEach((v)=>CONSTANT_VALUES.set(v, new InternalAnimatedValue(v, true)));
}
/**
 * This class has been made internal in order to omit dependencies' cycles which
 * were caused by imperative setValue and interpolate  they are currently exposed with AnimatedValue.js
 */ class InternalAnimatedValue extends _AnimatedNode__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .ZP {
    static valueForConstant(number) {
        initializeConstantValues();
        return CONSTANT_VALUES.get(number) || new InternalAnimatedValue(number, true);
    }
    constructor(value, constant = false){
        invariant__WEBPACK_IMPORTED_MODULE_0___default()(value !== null, "Animated.Value cannot be set to the null");
        super({
            type: "value",
            value: sanitizeValue(value)
        });
        this._startingValue = this._value = value;
        this._animation = null;
        this._constant = constant;
    }
    __detach() {
        if (!this._constant) {
            if (_ReanimatedModule__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z.getValue) {
                _ReanimatedModule__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z.getValue(this.__nodeID, (val)=>this.__nodeConfig.value = val);
            } else {
                this.__nodeConfig.value = this.__getValue();
            }
        }
        this.__detachAnimation(this._animation);
        super.__detach();
    }
    __detachAnimation(animation) {
        animation && animation.__detach();
        if (this._animation === animation) {
            this._animation = null;
        }
    }
    __attachAnimation(animation) {
        this.__detachAnimation(this._animation);
        this._animation = animation;
    }
    __onEvaluate() {
        if (this.__inputNodes && this.__inputNodes.length) {
            this.__inputNodes.forEach(_val__WEBPACK_IMPORTED_MODULE_3__/* .val */ .P);
        }
        return this._value;
    }
    // AnimatedValue will override this method to modify the value of a native node.
    setValue(value) {
        this.__detachAnimation(this._animation);
        this._updateValue(value);
    }
    _updateValue(value) {
        this._value = value;
        this.__forceUpdateCache(value);
    }
}


/***/ }),

/***/ 66889:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  Wn: () => (/* binding */ abs),
  Kh: () => (/* binding */ acos),
  IH: () => (/* binding */ add),
  xD: () => (/* binding */ and),
  ZR: () => (/* binding */ asin),
  z4: () => (/* binding */ atan),
  mD: () => (/* binding */ ceil),
  mC: () => (/* binding */ cos),
  ri: () => (/* binding */ defined),
  cs: () => (/* binding */ divide),
  eq: () => (/* binding */ eq),
  Qq: () => (/* binding */ exp),
  GW: () => (/* binding */ floor),
  l7: () => (/* binding */ greaterOrEq),
  tS: () => (/* binding */ greaterThan),
  w5: () => (/* binding */ lessOrEq),
  Qj: () => (/* binding */ lessThan),
  cM: () => (/* binding */ log),
  Fp: () => (/* binding */ max),
  VV: () => (/* binding */ min),
  $W: () => (/* binding */ modulo),
  Jp: () => (/* binding */ multiply),
  uH: () => (/* binding */ neq),
  ff: () => (/* binding */ not),
  or: () => (/* binding */ or),
  sQ: () => (/* binding */ pow),
  NM: () => (/* binding */ round),
  O$: () => (/* binding */ sin),
  _b: () => (/* binding */ sqrt),
  lu: () => (/* binding */ sub),
  OR: () => (/* binding */ tan)
});

// EXTERNAL MODULE: ./node_modules/react-native-reanimated/lib/reanimated1/core/AnimatedNode.js
var AnimatedNode = __webpack_require__(70009);
// EXTERNAL MODULE: ./node_modules/react-native-reanimated/lib/reanimated1/val.js
var val = __webpack_require__(47599);
// EXTERNAL MODULE: external "invariant"
var external_invariant_ = __webpack_require__(67644);
var external_invariant_default = /*#__PURE__*/__webpack_require__.n(external_invariant_);
// EXTERNAL MODULE: ./node_modules/react-native-reanimated/lib/reanimated1/core/AnimatedBlock.js
var AnimatedBlock = __webpack_require__(48282);
;// CONCATENATED MODULE: ./node_modules/react-native-reanimated/lib/reanimated1/core/AnimatedOperator.js




function reduce(fn) {
    return (input)=>input.reduce((a, b)=>fn((0,val/* val */.P)(a), (0,val/* val */.P)(b)));
}
function reduceFrom(fn, initialValue) {
    return (input)=>input.reduce((a, b)=>fn((0,val/* val */.P)(a), (0,val/* val */.P)(b)), initialValue);
}
function infix(fn) {
    return (input)=>fn((0,val/* val */.P)(input[0]), (0,val/* val */.P)(input[1]));
}
function single(fn) {
    return (input)=>fn((0,val/* val */.P)(input[0]));
}
const OPERATIONS = {
    // arithmetic
    add: reduce((a, b)=>a + b),
    sub: reduce((a, b)=>a - b),
    multiply: reduce((a, b)=>a * b),
    divide: reduce((a, b)=>a / b),
    pow: reduce((a, b)=>Math.pow(a, b)),
    modulo: reduce((a, b)=>(a % b + b) % b),
    sqrt: single((a)=>Math.sqrt(a)),
    log: single((a)=>Math.log(a)),
    sin: single((a)=>Math.sin(a)),
    cos: single((a)=>Math.cos(a)),
    tan: single((a)=>Math.tan(a)),
    acos: single((a)=>Math.acos(a)),
    asin: single((a)=>Math.asin(a)),
    atan: single((a)=>Math.atan(a)),
    exp: single((a)=>Math.exp(a)),
    round: single((a)=>Math.round(a)),
    abs: single((a)=>Math.abs(a)),
    ceil: single((a)=>Math.ceil(a)),
    floor: single((a)=>Math.floor(a)),
    max: reduce((a, b)=>Math.max(a, b)),
    min: reduce((a, b)=>Math.min(a, b)),
    // logical
    and: reduceFrom((a, b)=>a && b, true),
    or: reduceFrom((a, b)=>a || b, false),
    not: single((a)=>!a),
    defined: single((a)=>a !== null && a !== undefined && !isNaN(a)),
    // comparing
    lessThan: infix((a, b)=>a < b),
    /* eslint-disable-next-line eqeqeq */ eq: infix((a, b)=>a == b),
    greaterThan: infix((a, b)=>a > b),
    lessOrEq: infix((a, b)=>a <= b),
    greaterOrEq: infix((a, b)=>a >= b),
    /* eslint-disable-next-line eqeqeq */ neq: infix((a, b)=>a != b)
};
class AnimatedOperator extends AnimatedNode/* default */.ZP {
    constructor(operator, input){
        external_invariant_default()(typeof operator === "string", `Reanimated: Animated.operator node first argument should be of type String, but got: ${operator}`);
        external_invariant_default()(input.every((el)=>el instanceof AnimatedNode/* default */.ZP || typeof el === "string" || typeof el === "number"), `Reanimated: Animated.operator node second argument should be one or more of type AnimatedNode, String or Number but got ${input}`);
        super({
            type: "op",
            op: operator,
            input
        }, input);
        this._op = operator;
        this._input = input;
    }
    toString() {
        return `AnimatedOperator, id: ${this.__nodeID}`;
    }
    __onEvaluate() {
        if (!this._operation) {
            this._operation = OPERATIONS[this._op];
            external_invariant_default()(this._operation, `Illegal operator '%s'`, this._op);
        }
        return this._operation(this._input);
    }
}
function createAnimatedOperator(name) {
    return (...args)=>new AnimatedOperator(name, args.map(AnimatedBlock/* adapt */.p));
}

;// CONCATENATED MODULE: ./node_modules/react-native-reanimated/lib/reanimated1/operators.js

const operator = createAnimatedOperator;
const add = operator("add");
const sub = operator("sub");
const multiply = operator("multiply");
const divide = operator("divide");
const pow = operator("pow");
const modulo = operator("modulo");
const sqrt = operator("sqrt");
const log = operator("log");
const sin = operator("sin");
const cos = operator("cos");
const exp = operator("exp");
const round = operator("round");
const lessThan = operator("lessThan");
const eq = operator("eq");
const greaterThan = operator("greaterThan");
const lessOrEq = operator("lessOrEq");
const greaterOrEq = operator("greaterOrEq");
const neq = operator("neq");
const and = operator("and");
const or = operator("or");
const defined = operator("defined");
const not = operator("not");
const tan = operator("tan");
const acos = operator("acos");
const asin = operator("asin");
const atan = operator("atan");
const abs = operator("abs");
const ceil = operator("ceil");
const floor = operator("floor");
const max = operator("max");
const min = operator("min");


/***/ }),

/***/ 47599:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   P: () => (/* binding */ val)
/* harmony export */ });
function val(v) {
    return v && v.__getValue ? v.__getValue() : v || 0;
}


/***/ }),

/***/ 5367:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   D5: () => (/* binding */ isColor),
/* harmony export */   De: () => (/* binding */ hsvToColor),
/* harmony export */   GM: () => (/* binding */ rgbaArrayToRGBAColor),
/* harmony export */   Ls: () => (/* binding */ RGBtoHSV),
/* harmony export */   Oh: () => (/* binding */ opacity),
/* harmony export */   Q6: () => (/* binding */ red),
/* harmony export */   YU: () => (/* binding */ toLinearSpace),
/* harmony export */   _k: () => (/* binding */ convertToRGBA),
/* harmony export */   aL: () => (/* binding */ processColor),
/* harmony export */   ek: () => (/* binding */ green),
/* harmony export */   gv: () => (/* binding */ processColorInitially),
/* harmony export */   iN: () => (/* binding */ blue),
/* harmony export */   o7: () => (/* binding */ toGammaSpace),
/* harmony export */   qX: () => (/* binding */ rgbaColor)
/* harmony export */ });
/* harmony import */ var react_native__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(83849);
/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(86095);
/* global _WORKLET */ /**
 * Copied from:
 * react-native/Libraries/StyleSheet/normalizeColor.js
 * react-native/Libraries/StyleSheet/processColor.js
 * https://github.com/wcandillon/react-native-redash/blob/master/src/Colors.ts
 */ /* eslint no-bitwise: 0 */ 

// var INTEGER = '[-+]?\\d+';
const NUMBER = "[-+]?(?:\\d+(?:\\.\\d*)?|\\.\\d+)";
const PERCENTAGE = NUMBER + "%";
function call(...args) {
    "worklet";
    return "\\(\\s*(" + args.join(")\\s*,\\s*(") + ")\\s*\\)";
}
// matchers use RegExp objects which needs to be created separately on JS and on
// the UI thread. We keep separate cache of Regexes for UI and JS using the below
// objects, then pick the right cache in getMatchers() method.
const jsCachedMatchers = {};
const uiCachedMatchers = !(0,_core__WEBPACK_IMPORTED_MODULE_0__/* .isConfigured */ .lF)() ? {} : (0,_core__WEBPACK_IMPORTED_MODULE_0__/* .makeRemote */ .I1)({});
function getMatchers() {
    "worklet";
    const cachedMatchers = _WORKLET ? uiCachedMatchers : jsCachedMatchers;
    if (cachedMatchers.rgb === undefined) {
        cachedMatchers.rgb = new RegExp("rgb" + call(NUMBER, NUMBER, NUMBER));
        cachedMatchers.rgba = new RegExp("rgba" + call(NUMBER, NUMBER, NUMBER, NUMBER));
        cachedMatchers.hsl = new RegExp("hsl" + call(NUMBER, PERCENTAGE, PERCENTAGE));
        cachedMatchers.hsla = new RegExp("hsla" + call(NUMBER, PERCENTAGE, PERCENTAGE, NUMBER));
        cachedMatchers.hex3 = /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/;
        cachedMatchers.hex4 = /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/;
        cachedMatchers.hex6 = /^#([0-9a-fA-F]{6})$/;
        cachedMatchers.hex8 = /^#([0-9a-fA-F]{8})$/;
    }
    return cachedMatchers;
}
// cachedMatchers is lazy loaded and it is frozen when worklet is being created,
// it is possible to call getMatchers() when the object is frozen, then cachedMatchers
// has no assigned regexes
getMatchers();
function hue2rgb(p, q, t) {
    "worklet";
    if (t < 0) {
        t += 1;
    }
    if (t > 1) {
        t -= 1;
    }
    if (t < 1 / 6) {
        return p + (q - p) * 6 * t;
    }
    if (t < 1 / 2) {
        return q;
    }
    if (t < 2 / 3) {
        return p + (q - p) * (2 / 3 - t) * 6;
    }
    return p;
}
function hslToRgb(h, s, l) {
    "worklet";
    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
    const p = 2 * l - q;
    const r = hue2rgb(p, q, h + 1 / 3);
    const g = hue2rgb(p, q, h);
    const b = hue2rgb(p, q, h - 1 / 3);
    return Math.round(r * 255) << 24 | Math.round(g * 255) << 16 | Math.round(b * 255) << 8;
}
function parse255(str) {
    "worklet";
    const int = Number.parseInt(str, 10);
    if (int < 0) {
        return 0;
    }
    if (int > 255) {
        return 255;
    }
    return int;
}
function parse360(str) {
    "worklet";
    const int = Number.parseFloat(str);
    return (int % 360 + 360) % 360 / 360;
}
function parse1(str) {
    "worklet";
    const num = Number.parseFloat(str);
    if (num < 0) {
        return 0;
    }
    if (num > 1) {
        return 255;
    }
    return Math.round(num * 255);
}
function parsePercentage(str) {
    "worklet";
    // parseFloat conveniently ignores the final %
    const int = Number.parseFloat(str);
    if (int < 0) {
        return 0;
    }
    if (int > 100) {
        return 1;
    }
    return int / 100;
}
const names = !(0,_core__WEBPACK_IMPORTED_MODULE_0__/* .isConfigured */ .lF)() ? null : (0,_core__WEBPACK_IMPORTED_MODULE_0__/* .makeShareable */ .Uv)({
    transparent: 0x00000000,
    // http://www.w3.org/TR/css3-color/#svg-color
    aliceblue: 0xf0f8ffff,
    antiquewhite: 0xfaebd7ff,
    aqua: 0x00ffffff,
    aquamarine: 0x7fffd4ff,
    azure: 0xf0ffffff,
    beige: 0xf5f5dcff,
    bisque: 0xffe4c4ff,
    black: 0x000000ff,
    blanchedalmond: 0xffebcdff,
    blue: 0x0000ffff,
    blueviolet: 0x8a2be2ff,
    brown: 0xa52a2aff,
    burlywood: 0xdeb887ff,
    burntsienna: 0xea7e5dff,
    cadetblue: 0x5f9ea0ff,
    chartreuse: 0x7fff00ff,
    chocolate: 0xd2691eff,
    coral: 0xff7f50ff,
    cornflowerblue: 0x6495edff,
    cornsilk: 0xfff8dcff,
    crimson: 0xdc143cff,
    cyan: 0x00ffffff,
    darkblue: 0x00008bff,
    darkcyan: 0x008b8bff,
    darkgoldenrod: 0xb8860bff,
    darkgray: 0xa9a9a9ff,
    darkgreen: 0x006400ff,
    darkgrey: 0xa9a9a9ff,
    darkkhaki: 0xbdb76bff,
    darkmagenta: 0x8b008bff,
    darkolivegreen: 0x556b2fff,
    darkorange: 0xff8c00ff,
    darkorchid: 0x9932ccff,
    darkred: 0x8b0000ff,
    darksalmon: 0xe9967aff,
    darkseagreen: 0x8fbc8fff,
    darkslateblue: 0x483d8bff,
    darkslategray: 0x2f4f4fff,
    darkslategrey: 0x2f4f4fff,
    darkturquoise: 0x00ced1ff,
    darkviolet: 0x9400d3ff,
    deeppink: 0xff1493ff,
    deepskyblue: 0x00bfffff,
    dimgray: 0x696969ff,
    dimgrey: 0x696969ff,
    dodgerblue: 0x1e90ffff,
    firebrick: 0xb22222ff,
    floralwhite: 0xfffaf0ff,
    forestgreen: 0x228b22ff,
    fuchsia: 0xff00ffff,
    gainsboro: 0xdcdcdcff,
    ghostwhite: 0xf8f8ffff,
    gold: 0xffd700ff,
    goldenrod: 0xdaa520ff,
    gray: 0x808080ff,
    green: 0x008000ff,
    greenyellow: 0xadff2fff,
    grey: 0x808080ff,
    honeydew: 0xf0fff0ff,
    hotpink: 0xff69b4ff,
    indianred: 0xcd5c5cff,
    indigo: 0x4b0082ff,
    ivory: 0xfffff0ff,
    khaki: 0xf0e68cff,
    lavender: 0xe6e6faff,
    lavenderblush: 0xfff0f5ff,
    lawngreen: 0x7cfc00ff,
    lemonchiffon: 0xfffacdff,
    lightblue: 0xadd8e6ff,
    lightcoral: 0xf08080ff,
    lightcyan: 0xe0ffffff,
    lightgoldenrodyellow: 0xfafad2ff,
    lightgray: 0xd3d3d3ff,
    lightgreen: 0x90ee90ff,
    lightgrey: 0xd3d3d3ff,
    lightpink: 0xffb6c1ff,
    lightsalmon: 0xffa07aff,
    lightseagreen: 0x20b2aaff,
    lightskyblue: 0x87cefaff,
    lightslategray: 0x778899ff,
    lightslategrey: 0x778899ff,
    lightsteelblue: 0xb0c4deff,
    lightyellow: 0xffffe0ff,
    lime: 0x00ff00ff,
    limegreen: 0x32cd32ff,
    linen: 0xfaf0e6ff,
    magenta: 0xff00ffff,
    maroon: 0x800000ff,
    mediumaquamarine: 0x66cdaaff,
    mediumblue: 0x0000cdff,
    mediumorchid: 0xba55d3ff,
    mediumpurple: 0x9370dbff,
    mediumseagreen: 0x3cb371ff,
    mediumslateblue: 0x7b68eeff,
    mediumspringgreen: 0x00fa9aff,
    mediumturquoise: 0x48d1ccff,
    mediumvioletred: 0xc71585ff,
    midnightblue: 0x191970ff,
    mintcream: 0xf5fffaff,
    mistyrose: 0xffe4e1ff,
    moccasin: 0xffe4b5ff,
    navajowhite: 0xffdeadff,
    navy: 0x000080ff,
    oldlace: 0xfdf5e6ff,
    olive: 0x808000ff,
    olivedrab: 0x6b8e23ff,
    orange: 0xffa500ff,
    orangered: 0xff4500ff,
    orchid: 0xda70d6ff,
    palegoldenrod: 0xeee8aaff,
    palegreen: 0x98fb98ff,
    paleturquoise: 0xafeeeeff,
    palevioletred: 0xdb7093ff,
    papayawhip: 0xffefd5ff,
    peachpuff: 0xffdab9ff,
    peru: 0xcd853fff,
    pink: 0xffc0cbff,
    plum: 0xdda0ddff,
    powderblue: 0xb0e0e6ff,
    purple: 0x800080ff,
    rebeccapurple: 0x663399ff,
    red: 0xff0000ff,
    rosybrown: 0xbc8f8fff,
    royalblue: 0x4169e1ff,
    saddlebrown: 0x8b4513ff,
    salmon: 0xfa8072ff,
    sandybrown: 0xf4a460ff,
    seagreen: 0x2e8b57ff,
    seashell: 0xfff5eeff,
    sienna: 0xa0522dff,
    silver: 0xc0c0c0ff,
    skyblue: 0x87ceebff,
    slateblue: 0x6a5acdff,
    slategray: 0x708090ff,
    slategrey: 0x708090ff,
    snow: 0xfffafaff,
    springgreen: 0x00ff7fff,
    steelblue: 0x4682b4ff,
    tan: 0xd2b48cff,
    teal: 0x008080ff,
    thistle: 0xd8bfd8ff,
    tomato: 0xff6347ff,
    turquoise: 0x40e0d0ff,
    violet: 0xee82eeff,
    wheat: 0xf5deb3ff,
    white: 0xffffffff,
    whitesmoke: 0xf5f5f5ff,
    yellow: 0xffff00ff,
    yellowgreen: 0x9acd32ff
});
function normalizeColor(color) {
    "worklet";
    var _a, _b, _c, _d, _e, _f, _g, _h;
    if (typeof color === "number") {
        if (color >>> 0 === color && color >= 0 && color <= 0xffffffff) {
            return color;
        }
        return null;
    }
    if (typeof color !== "string") {
        return null;
    }
    const matchers = getMatchers();
    let match;
    // Ordered based on occurrences on Facebook codebase
    if (match = (_a = matchers === null || matchers === void 0 ? void 0 : matchers.hex6) === null || _a === void 0 ? void 0 : _a.exec(color)) {
        return Number.parseInt(match[1] + "ff", 16) >>> 0;
    }
    if (names[color] !== undefined) {
        return names[color];
    }
    if (match = (_b = matchers === null || matchers === void 0 ? void 0 : matchers.rgb) === null || _b === void 0 ? void 0 : _b.exec(color)) {
        return(// b
        (parse255(match[1]) << 24 | // r
        parse255(match[2]) << 16 | // g
        parse255(match[3]) << 8 | 0x000000ff) >>> // a
        0);
    }
    if (match = (_c = matchers === null || matchers === void 0 ? void 0 : matchers.rgba) === null || _c === void 0 ? void 0 : _c.exec(color)) {
        return(// b
        (parse255(match[1]) << 24 | // r
        parse255(match[2]) << 16 | // g
        parse255(match[3]) << 8 | parse1(match[4])) >>> // a
        0);
    }
    if (match = (_d = matchers === null || matchers === void 0 ? void 0 : matchers.hex3) === null || _d === void 0 ? void 0 : _d.exec(color)) {
        return Number.parseInt(match[1] + match[1] + // r
        match[2] + match[2] + // g
        match[3] + match[3] + // b
        "ff", 16) >>> 0;
    }
    // https://drafts.csswg.org/css-color-4/#hex-notation
    if (match = (_e = matchers === null || matchers === void 0 ? void 0 : matchers.hex8) === null || _e === void 0 ? void 0 : _e.exec(color)) {
        return Number.parseInt(match[1], 16) >>> 0;
    }
    if (match = (_f = matchers === null || matchers === void 0 ? void 0 : matchers.hex4) === null || _f === void 0 ? void 0 : _f.exec(color)) {
        return Number.parseInt(match[1] + match[1] + // r
        match[2] + match[2] + // g
        match[3] + match[3] + // b
        match[4] + match[4], 16) >>> 0;
    }
    if (match = (_g = matchers === null || matchers === void 0 ? void 0 : matchers.hsl) === null || _g === void 0 ? void 0 : _g.exec(color)) {
        return (hslToRgb(parse360(match[1]), parsePercentage(match[2]), parsePercentage(match[3]) // l
        ) | 0x000000ff) >>> // a
        0;
    }
    if (match = (_h = matchers === null || matchers === void 0 ? void 0 : matchers.hsla) === null || _h === void 0 ? void 0 : _h.exec(color)) {
        return (hslToRgb(parse360(match[1]), parsePercentage(match[2]), parsePercentage(match[3]) // l
        ) | parse1(match[4])) >>> // a
        0;
    }
    return null;
}
const opacity = (c)=>{
    "worklet";
    return (c >> 24 & 255) / 255;
};
const red = (c)=>{
    "worklet";
    return c >> 16 & 255;
};
const green = (c)=>{
    "worklet";
    return c >> 8 & 255;
};
const blue = (c)=>{
    "worklet";
    return c & 255;
};
const rgbaColor = (r, g, b, alpha = 1)=>{
    "worklet";
    if (react_native__WEBPACK_IMPORTED_MODULE_1__.Platform.OS === "web" || !_WORKLET) {
        return `rgba(${r}, ${g}, ${b}, ${alpha})`;
    }
    const c = Math.round(alpha * 255) * (1 << 24) + Math.round(r) * (1 << 16) + Math.round(g) * (1 << 8) + Math.round(b);
    if (react_native__WEBPACK_IMPORTED_MODULE_1__.Platform.OS === "android") {
        // on Android color is represented as signed 32 bit int
        return c < 1 << 31 >>> 0 ? c : c - 4294967296; // 4294967296 == Math.pow(2, 32);
    }
    return c;
};
function RGBtoHSV(r, g, b) {
    "worklet";
    /* eslint-disable */ if (arguments.length === 1) {
        g = r.g;
        b = r.b;
        r = r.r;
    }
    const max = Math.max(r, g, b);
    const min = Math.min(r, g, b);
    const d = max - min;
    const s = max === 0 ? 0 : d / max;
    const v = max / 255;
    let h;
    switch(max){
        default:
        /* fallthrough */ case min:
            h = 0;
            break;
        case r:
            h = g - b + d * (g < b ? 6 : 0);
            h /= 6 * d;
            break;
        case g:
            h = b - r + d * 2;
            h /= 6 * d;
            break;
        case b:
            h = r - g + d * 4;
            h /= 6 * d;
            break;
    }
    return {
        h: h,
        s: s,
        v: v
    };
/* eslint-enable */ }
function HSVtoRGB(h, s, v) {
    "worklet";
    /* eslint-disable */ var r, g, b, i, f, p, q, t;
    if (arguments.length === 1) {
        s = h.s;
        v = h.v;
        h = h.h;
    }
    i = Math.floor(h * 6);
    f = h * 6 - i;
    p = v * (1 - s);
    q = v * (1 - f * s);
    t = v * (1 - (1 - f) * s);
    switch(i % 6){
        case 0:
            r = v, g = t, b = p;
            break;
        case 1:
            r = q, g = v, b = p;
            break;
        case 2:
            r = p, g = v, b = t;
            break;
        case 3:
            r = p, g = q, b = v;
            break;
        case 4:
            r = t, g = p, b = v;
            break;
        case 5:
            r = v, g = p, b = q;
            break;
    }
    return {
        r: Math.round(r * 255),
        g: Math.round(g * 255),
        b: Math.round(b * 255)
    };
/* eslint-enable */ }
const hsvToColor = (h, s, v, a)=>{
    "worklet";
    const { r, g, b } = HSVtoRGB(h, s, v);
    return rgbaColor(r, g, b, a);
};
function processColorInitially(color) {
    "worklet";
    if (color === null || color === undefined || typeof color === "number") {
        return color;
    }
    let normalizedColor = normalizeColor(color);
    if (normalizedColor === null || normalizedColor === undefined) {
        return undefined;
    }
    if (typeof normalizedColor !== "number") {
        return null;
    }
    normalizedColor = (normalizedColor << 24 | normalizedColor >>> 8) >>> 0; // argb
    return normalizedColor;
}
function isColor(value) {
    "worklet";
    if (typeof value !== "string") {
        return false;
    }
    return processColorInitially(value) != null;
}
function processColor(color) {
    "worklet";
    let normalizedColor = processColorInitially(color);
    if (normalizedColor === null || normalizedColor === undefined) {
        return undefined;
    }
    if (typeof normalizedColor !== "number") {
        return null;
    }
    if (react_native__WEBPACK_IMPORTED_MODULE_1__.Platform.OS === "android") {
        // Android use 32 bit *signed* integer to represent the color
        // We utilize the fact that bitwise operations in JS also operates on
        // signed 32 bit integers, so that we can use those to convert from
        // *unsigned* to *signed* 32bit int that way.
        normalizedColor = normalizedColor | 0x0;
    }
    return normalizedColor;
}
function convertToRGBA(color) {
    "worklet";
    const processedColor = processColorInitially(color); // argb;
    const a = (processedColor >>> 24) / 255;
    const r = (processedColor << 8 >>> 24) / 255;
    const g = (processedColor << 16 >>> 24) / 255;
    const b = (processedColor << 24 >>> 24) / 255;
    return [
        r,
        g,
        b,
        a
    ];
}
function rgbaArrayToRGBAColor(RGBA) {
    "worklet";
    return `rgba(${Math.round(RGBA[0] * 255)}, ${Math.round(RGBA[1] * 255)}, ${Math.round(RGBA[2] * 255)}, ${RGBA[3]})`;
}
function toLinearSpace(RGBA, gamma = 2.2) {
    "worklet";
    const res = [];
    for(let i = 0; i < 3; ++i){
        res.push(Math.pow(RGBA[i], gamma));
    }
    res.push(RGBA[3]);
    return res;
}
function toGammaSpace(RGBA, gamma = 2.2) {
    "worklet";
    const res = [];
    for(let i = 0; i < 3; ++i){
        res.push(Math.pow(RGBA[i], 1 / gamma));
    }
    res.push(RGBA[3]);
    return res;
}


/***/ }),

/***/ 89890:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  o: () => (/* binding */ Easing_Easing)
});

// EXTERNAL MODULE: ./node_modules/react-native-reanimated/lib/reanimated1/Easing.js + 1 modules
var Easing = __webpack_require__(88593);
;// CONCATENATED MODULE: ./node_modules/react-native-reanimated/lib/reanimated2/Bezier.js
/**
 * https://github.com/gre/bezier-easing
 * BezierEasing - use bezier curve for transition easing function
 * by Gatan Renaudeau 2014 - 2015  MIT License
 */ // These values are established by empiricism with tests (tradeoff: performance VS precision)
function Bezier(mX1, mY1, mX2, mY2) {
    "worklet";
    const NEWTON_ITERATIONS = 4;
    const NEWTON_MIN_SLOPE = 0.001;
    const SUBDIVISION_PRECISION = 0.0000001;
    const SUBDIVISION_MAX_ITERATIONS = 10;
    const kSplineTableSize = 11;
    const kSampleStepSize = 1.0 / (kSplineTableSize - 1.0);
    function A(aA1, aA2) {
        "worklet";
        return 1.0 - 3.0 * aA2 + 3.0 * aA1;
    }
    function B(aA1, aA2) {
        "worklet";
        return 3.0 * aA2 - 6.0 * aA1;
    }
    function C(aA1) {
        "worklet";
        return 3.0 * aA1;
    }
    // Returns x(t) given t, x1, and x2, or y(t) given t, y1, and y2.
    function calcBezier(aT, aA1, aA2) {
        "worklet";
        return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT;
    }
    // Returns dx/dt given t, x1, and x2, or dy/dt given t, y1, and y2.
    function getSlope(aT, aA1, aA2) {
        "worklet";
        return 3.0 * A(aA1, aA2) * aT * aT + 2.0 * B(aA1, aA2) * aT + C(aA1);
    }
    function binarySubdivide(aX, aA, aB, mX1, mX2) {
        "worklet";
        let currentX;
        let currentT;
        let i = 0;
        do {
            currentT = aA + (aB - aA) / 2.0;
            currentX = calcBezier(currentT, mX1, mX2) - aX;
            if (currentX > 0.0) {
                aB = currentT;
            } else {
                aA = currentT;
            }
        }while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);
        return currentT;
    }
    function newtonRaphsonIterate(aX, aGuessT, mX1, mX2) {
        "worklet";
        for(let i = 0; i < NEWTON_ITERATIONS; ++i){
            const currentSlope = getSlope(aGuessT, mX1, mX2);
            if (currentSlope === 0.0) {
                return aGuessT;
            }
            const currentX = calcBezier(aGuessT, mX1, mX2) - aX;
            aGuessT -= currentX / currentSlope;
        }
        return aGuessT;
    }
    function LinearEasing(x) {
        "worklet";
        return x;
    }
    if (!(mX1 >= 0 && mX1 <= 1 && mX2 >= 0 && mX2 <= 1)) {
        throw new Error("bezier x values must be in [0, 1] range");
    }
    if (mX1 === mY1 && mX2 === mY2) {
        return LinearEasing;
    }
    // FIXME: Float32Array is not available in Hermes right now
    //
    // var float32ArraySupported = typeof Float32Array === 'function';
    // const sampleValues = float32ArraySupported
    // ? new Float32Array(kSplineTableSize)
    // : new Array(kSplineTableSize);
    // Precompute samples table
    const sampleValues = new Array(kSplineTableSize);
    for(let i = 0; i < kSplineTableSize; ++i){
        sampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);
    }
    function getTForX(aX) {
        "worklet";
        let intervalStart = 0.0;
        let currentSample = 1;
        const lastSample = kSplineTableSize - 1;
        for(; currentSample !== lastSample && sampleValues[currentSample] <= aX; ++currentSample){
            intervalStart += kSampleStepSize;
        }
        --currentSample;
        // Interpolate to provide an initial guess for t
        const dist = (aX - sampleValues[currentSample]) / (sampleValues[currentSample + 1] - sampleValues[currentSample]);
        const guessForT = intervalStart + dist * kSampleStepSize;
        const initialSlope = getSlope(guessForT, mX1, mX2);
        if (initialSlope >= NEWTON_MIN_SLOPE) {
            return newtonRaphsonIterate(aX, guessForT, mX1, mX2);
        } else if (initialSlope === 0.0) {
            return guessForT;
        } else {
            return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);
        }
    }
    return function BezierEasing(x) {
        "worklet";
        if (mX1 === mY1 && mX2 === mY2) {
            return x; // linear
        }
        // Because JavaScript number are imprecise, we should guarantee the extremes are right.
        if (x === 0) {
            return 0;
        }
        if (x === 1) {
            return 1;
        }
        return calcBezier(getTForX(x), mY1, mY2);
    };
}

;// CONCATENATED MODULE: ./node_modules/react-native-reanimated/lib/reanimated2/Easing.js
// spread and rest parameters can't be used in worklets right now
/* eslint-disable prefer-rest-params */ /* eslint-disable prefer-spread */ /* global _WORKLET */ // @ts-ignore reanimated1/Easing is JS file


/**
 * A linear function, `f(t) = t`. Position correlates to elapsed time one to
 * one.
 *
 * http://cubic-bezier.com/#0,0,1,1
 */ function linear(t) {
    "worklet";
    return t;
}
/**
 * A simple inertial interaction, similar to an object slowly accelerating to
 * speed.
 *
 * http://cubic-bezier.com/#.42,0,1,1
 */ function ease(t) {
    "worklet";
    return Bezier(0.42, 0, 1, 1)(t);
}
/**
 * A quadratic function, `f(t) = t * t`. Position equals the square of elapsed
 * time.
 *
 * http://easings.net/#easeInQuad
 */ function quad(t) {
    "worklet";
    return t * t;
}
/**
 * A cubic function, `f(t) = t * t * t`. Position equals the cube of elapsed
 * time.
 *
 * http://easings.net/#easeInCubic
 */ function cubic(t) {
    "worklet";
    return t * t * t;
}
/**
 * A power function. Position is equal to the Nth power of elapsed time.
 *
 * n = 4: http://easings.net/#easeInQuart
 * n = 5: http://easings.net/#easeInQuint
 */ function poly(n) {
    "worklet";
    return (t)=>{
        "worklet";
        return Math.pow(t, n);
    };
}
/**
 * A sinusoidal function.
 *
 * http://easings.net/#easeInSine
 */ function sin(t) {
    "worklet";
    return 1 - Math.cos(t * Math.PI / 2);
}
/**
 * A circular function.
 *
 * http://easings.net/#easeInCirc
 */ function circle(t) {
    "worklet";
    return 1 - Math.sqrt(1 - t * t);
}
/**
 * An exponential function.
 *
 * http://easings.net/#easeInExpo
 */ function exp(t) {
    "worklet";
    return Math.pow(2, 10 * (t - 1));
}
/**
 * A simple elastic interaction, similar to a spring oscillating back and
 * forth.
 *
 * Default bounciness is 1, which overshoots a little bit once. 0 bounciness
 * doesn't overshoot at all, and bounciness of N > 1 will overshoot about N
 * times.
 *
 * http://easings.net/#easeInElastic
 */ function elastic(bounciness = 1) {
    "worklet";
    const p = bounciness * Math.PI;
    return (t)=>{
        "worklet";
        return 1 - Math.pow(Math.cos(t * Math.PI / 2), 3) * Math.cos(t * p);
    };
}
/**
 * Use with `Animated.parallel()` to create a simple effect where the object
 * animates back slightly as the animation starts.
 *
 * Wolfram Plot:
 *
 * - http://tiny.cc/back_default (s = 1.70158, default)
 */ function back(s = 1.70158) {
    "worklet";
    return (t)=>{
        "worklet";
        return t * t * ((s + 1) * t - s);
    };
}
/**
 * Provides a simple bouncing effect.
 *
 * http://easings.net/#easeInBounce
 */ function bounce(t) {
    "worklet";
    if (t < 1 / 2.75) {
        return 7.5625 * t * t;
    }
    if (t < 2 / 2.75) {
        const t2 = t - 1.5 / 2.75;
        return 7.5625 * t2 * t2 + 0.75;
    }
    if (t < 2.5 / 2.75) {
        const t2 = t - 2.25 / 2.75;
        return 7.5625 * t2 * t2 + 0.9375;
    }
    const t2 = t - 2.625 / 2.75;
    return 7.5625 * t2 * t2 + 0.984375;
}
/**
 * Provides a cubic bezier curve, equivalent to CSS Transitions'
 * `transition-timing-function`.
 *
 * A useful tool to visualize cubic bezier curves can be found at
 * http://cubic-bezier.com/
 */ function bezier(x1, y1, x2, y2) {
    "worklet";
    return {
        factory: ()=>{
            "worklet";
            return Bezier(x1, y1, x2, y2);
        }
    };
}
function bezierFn(x1, y1, x2, y2) {
    "worklet";
    return Bezier(x1, y1, x2, y2);
}
/**
 * Runs an easing function forwards.
 */ function in_(easing) {
    "worklet";
    return easing;
}
/**
 * Runs an easing function backwards.
 */ function out(easing) {
    "worklet";
    return (t)=>{
        "worklet";
        return 1 - easing(1 - t);
    };
}
/**
 * Makes any easing function symmetrical. The easing function will run
 * forwards for half of the duration, then backwards for the rest of the
 * duration.
 */ function inOut(easing) {
    "worklet";
    return (t)=>{
        "worklet";
        if (t < 0.5) {
            return easing(t * 2) / 2;
        }
        return 1 - easing((1 - t) * 2) / 2;
    };
}
const EasingObject = {
    linear,
    ease,
    quad,
    cubic,
    poly,
    sin,
    circle,
    exp,
    elastic,
    back,
    bounce,
    bezier,
    bezierFn,
    in: in_,
    out,
    inOut
};
// TODO type worklets
function createChecker(worklet, workletName, prevArgs) {
    /* should return Animated.Value or worklet */ function checkIfReaOne() {
        "worklet";
        if (arguments && !_WORKLET) {
            for(let i = 0; i < arguments.length; i++){
                const arg = arguments[i];
                if (arg && arg.__nodeID) {
                    console.warn(`Easing was renamed to EasingNode in Reanimated 2. Please use EasingNode instead`);
                    if (prevArgs) {
                        return Easing/* default */.Z[workletName].apply(undefined, prevArgs).apply(undefined, arguments);
                    }
                    return Easing/* default */.Z[workletName].apply(undefined, arguments);
                }
            }
        }
        // @ts-ignore this is implicitly any - TODO
        const res = worklet.apply(this, arguments);
        if (!_WORKLET && res && typeof res === "function" && res.__workletHash) {
            return createChecker(res, workletName, arguments);
        }
        return res;
    }
    // use original worklet on UI side
    checkIfReaOne._closure = worklet._closure;
    checkIfReaOne.asString = worklet.asString;
    checkIfReaOne.__workletHash = worklet.__workletHash;
    checkIfReaOne.__location = worklet.__location;
    return checkIfReaOne;
}
Object.keys(EasingObject).forEach((key)=>{
    EasingObject[key] = createChecker(EasingObject[key], key);
});
const Easing_Easing = EasingObject;


/***/ }),

/***/ 40098:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  E: () => (/* binding */ NativeReanimated)
});

// EXTERNAL MODULE: ./node_modules/react-native-web/dist/cjs/index.js
var cjs = __webpack_require__(83849);
;// CONCATENATED MODULE: ./node_modules/react-native-reanimated/lib/reanimated2/platform-specific/checkVersion.web.js
/* eslint-disable @typescript-eslint/no-empty-function */ /**
 * Checks that native and js versions of reanimated match.
 * Stubbed for web, where this check is unnecessary.
 */ function checkVersion() {}

;// CONCATENATED MODULE: ./node_modules/react-native-reanimated/lib/reanimated2/NativeReanimated/NativeReanimated.js


class NativeReanimated {
    constructor(native = true){
        if (global.__reanimatedModuleProxy === undefined && native) {
            const { ReanimatedModule } = cjs.NativeModules;
            ReanimatedModule === null || ReanimatedModule === void 0 ? void 0 : ReanimatedModule.installTurboModule();
        }
        this.InnerNativeModule = global.__reanimatedModuleProxy;
        this.native = native;
        if (native) {
            checkVersion();
        }
    }
    installCoreFunctions(valueSetter) {
        return this.InnerNativeModule.installCoreFunctions(valueSetter);
    }
    makeShareable(value) {
        return this.InnerNativeModule.makeShareable(value);
    }
    makeMutable(value) {
        return this.InnerNativeModule.makeMutable(value);
    }
    makeRemote(object = {}) {
        return this.InnerNativeModule.makeRemote(object);
    }
    registerSensor(sensorType, interval, sensorData) {
        return this.InnerNativeModule.registerSensor(sensorType, interval, sensorData);
    }
    unregisterSensor(sensorId) {
        return this.InnerNativeModule.unregisterSensor(sensorId);
    }
    startMapper(mapper, inputs = [], outputs = [], updater, viewDescriptors) {
        return this.InnerNativeModule.startMapper(mapper, inputs, outputs, updater, viewDescriptors);
    }
    stopMapper(mapperId) {
        return this.InnerNativeModule.stopMapper(mapperId);
    }
    registerEventHandler(eventHash, eventHandler) {
        return this.InnerNativeModule.registerEventHandler(eventHash, eventHandler);
    }
    unregisterEventHandler(id) {
        return this.InnerNativeModule.unregisterEventHandler(id);
    }
    getViewProp(viewTag, propName, callback) {
        return this.InnerNativeModule.getViewProp(viewTag, propName, callback);
    }
    enableLayoutAnimations(flag) {
        this.InnerNativeModule.enableLayoutAnimations(flag);
    }
    configureProps(uiProps, nativeProps) {
        this.InnerNativeModule.configureProps(uiProps, nativeProps);
    }
    subscribeForKeyboardEvents(keyboardEventData) {
        return this.InnerNativeModule.subscribeForKeyboardEvents(keyboardEventData);
    }
    unsubscribeFromKeyboardEvents(listenerId) {
        this.InnerNativeModule.unsubscribeFromKeyboardEvents(listenerId);
    }
}


/***/ }),

/***/ 87490:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Z: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _js_reanimated__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(90593);
/* harmony import */ var _PlatformChecker__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(39335);
/* harmony import */ var _NativeReanimated__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(40098);



let exportedModule;
if ((0,_PlatformChecker__WEBPACK_IMPORTED_MODULE_0__/* .shouldBeUseWeb */ .Wr)()) {
    exportedModule = _js_reanimated__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z;
} else {
    exportedModule = new _NativeReanimated__WEBPACK_IMPORTED_MODULE_2__/* .NativeReanimated */ .E();
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (exportedModule);


/***/ }),

/***/ 39335:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $L: () => (/* binding */ isWeb),
/* harmony export */   V5: () => (/* binding */ isJest),
/* harmony export */   Wr: () => (/* binding */ shouldBeUseWeb),
/* harmony export */   f1: () => (/* binding */ isChromeDebugger),
/* harmony export */   vq: () => (/* binding */ nativeShouldBeMock)
/* harmony export */ });
/* harmony import */ var react_native__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(83849);

function isJest() {
    return !!process.env.JEST_WORKER_ID;
}
function isChromeDebugger() {
    return !global.nativeCallSyncHook || global.__REMOTEDEV__;
}
function isWeb() {
    return react_native__WEBPACK_IMPORTED_MODULE_0__.Platform.OS === "web";
}
function shouldBeUseWeb() {
    return isJest() || isChromeDebugger() || isWeb();
}
function nativeShouldBeMock() {
    return isJest() || isChromeDebugger();
}


/***/ }),

/***/ 77544:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   RH: () => (/* binding */ updatePropsJestWrapper),
/* harmony export */   Ue: () => (/* binding */ ColorProperties),
/* harmony export */   ZP: () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   jI: () => (/* binding */ colorProps)
/* harmony export */ });
/* unused harmony export updateProps */
/* harmony import */ var _Colors__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(5367);
/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(86095);
/* harmony import */ var _js_reanimated__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(90593);
/* harmony import */ var _PlatformChecker__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(39335);




// copied from react-native/Libraries/Components/View/ReactNativeStyleAttributes
const colorProps = [
    "backgroundColor",
    "borderBottomColor",
    "borderColor",
    "borderLeftColor",
    "borderRightColor",
    "borderTopColor",
    "borderStartColor",
    "borderEndColor",
    "color",
    "shadowColor",
    "textDecorationColor",
    "tintColor",
    "textShadowColor",
    "overlayColor"
];
const ColorProperties = !(0,_core__WEBPACK_IMPORTED_MODULE_0__/* .isConfigured */ .lF)() ? [] : (0,_core__WEBPACK_IMPORTED_MODULE_0__/* .makeShareable */ .Uv)(colorProps);
let updatePropsByPlatform;
if ((0,_PlatformChecker__WEBPACK_IMPORTED_MODULE_1__/* .shouldBeUseWeb */ .Wr)()) {
    updatePropsByPlatform = (_, updates, maybeViewRef)=>{
        "worklet";
        if (maybeViewRef) {
            maybeViewRef.items.forEach((item, _)=>{
                (0,_js_reanimated__WEBPACK_IMPORTED_MODULE_2__/* ._updatePropsJS */ .n)(updates, item);
            });
        }
    };
} else {
    updatePropsByPlatform = (viewDescriptors, updates, _)=>{
        "worklet";
        for(const key in updates){
            if (ColorProperties.indexOf(key) !== -1) {
                updates[key] = (0,_Colors__WEBPACK_IMPORTED_MODULE_3__/* .processColor */ .aL)(updates[key]);
            }
        }
        viewDescriptors.value.forEach((viewDescriptor)=>{
            _updateProps(viewDescriptor.tag, viewDescriptor.name || "RCTView", updates);
        });
    };
}
const updateProps = updatePropsByPlatform;
const updatePropsJestWrapper = (viewDescriptors, updates, maybeViewRef, animatedStyle, adapters)=>{
    adapters.forEach((adapter)=>{
        adapter(updates);
    });
    animatedStyle.current.value = Object.assign(Object.assign({}, animatedStyle.current.value), updates);
    updateProps(viewDescriptors, updates, maybeViewRef);
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (updateProps);


/***/ }),

/***/ 95654:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Z: () => (/* binding */ WorkletEventHandler)
/* harmony export */ });
/* harmony import */ var _NativeReanimated__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(87490);

function jsListener(eventName, handler) {
    return (evt)=>{
        handler(Object.assign(Object.assign({}, evt.nativeEvent), {
            eventName
        }));
    };
}
class WorkletEventHandler {
    constructor(worklet, eventNames = []){
        this.worklet = worklet;
        this.eventNames = eventNames;
        this.reattachNeeded = false;
        this.listeners = {};
        this.viewTag = undefined;
        this.registrations = [];
        if (!_NativeReanimated__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z.native) {
            this.listeners = eventNames.reduce((acc, eventName)=>{
                acc[eventName] = jsListener(eventName, worklet);
                return acc;
            }, {});
        }
    }
    updateWorklet(newWorklet) {
        this.worklet = newWorklet;
        this.reattachNeeded = true;
    }
    registerForEvents(viewTag, fallbackEventName) {
        this.viewTag = viewTag;
        this.registrations = this.eventNames.map((eventName)=>_NativeReanimated__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z.registerEventHandler(viewTag + eventName, this.worklet));
        if (this.registrations.length === 0 && fallbackEventName) {
            this.registrations.push(_NativeReanimated__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z.registerEventHandler(viewTag + fallbackEventName, this.worklet));
        }
    }
    unregisterFromEvents() {
        this.registrations.forEach((id)=>_NativeReanimated__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z.unregisterEventHandler(id));
        this.registrations = [];
    }
}


/***/ }),

/***/ 63156:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   j: () => (/* binding */ withTiming)
/* harmony export */ });
/* harmony import */ var _Easing__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(89890);
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3138);


function withTiming(toValue, userConfig, callback) {
    "worklet";
    return (0,_util__WEBPACK_IMPORTED_MODULE_0__/* .defineAnimation */ .oF)(toValue, ()=>{
        "worklet";
        const config = {
            duration: 300,
            easing: _Easing__WEBPACK_IMPORTED_MODULE_1__/* .Easing */ .o.inOut(_Easing__WEBPACK_IMPORTED_MODULE_1__/* .Easing */ .o.quad)
        };
        if (userConfig) {
            Object.keys(userConfig).forEach((key)=>config[key] = userConfig[key]);
        }
        function timing(animation, now) {
            const { toValue, startTime, startValue } = animation;
            const runtime = now - startTime;
            if (runtime >= config.duration) {
                // reset startTime to avoid reusing finished animation config in `start` method
                animation.startTime = 0;
                animation.current = toValue;
                return true;
            }
            const progress = animation.easing(runtime / config.duration);
            animation.current = startValue + (toValue - startValue) * progress;
            return false;
        }
        function onStart(animation, value, now, previousAnimation) {
            if (previousAnimation && previousAnimation.type === "timing" && previousAnimation.toValue === toValue && previousAnimation.startTime) {
                // to maintain continuity of timing animations we check if we are starting
                // new timing over the old one with the same parameters. If so, we want
                // to copy animation timeline properties
                animation.startTime = previousAnimation.startTime;
                animation.startValue = previousAnimation.startValue;
            } else {
                animation.startTime = now;
                animation.startValue = value;
            }
            animation.current = value;
            if (typeof config.easing === "object") {
                animation.easing = config.easing.factory();
            } else {
                animation.easing = config.easing;
            }
        }
        return {
            type: "timing",
            onFrame: timing,
            onStart: onStart,
            progress: 0,
            toValue,
            startValue: 0,
            startTime: 0,
            easing: ()=>0,
            current: toValue,
            callback
        };
    });
}


/***/ }),

/***/ 3138:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AX: () => (/* binding */ initialUpdaterRun),
/* harmony export */   RE: () => (/* binding */ cancelAnimation),
/* harmony export */   oF: () => (/* binding */ defineAnimation)
/* harmony export */ });
/* unused harmony export withStartValue */
/* harmony import */ var _Colors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5367);
/* harmony import */ var _NativeReanimated__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(87490);
/* global _WORKLET */ 

let IN_STYLE_UPDATER = false;
function initialUpdaterRun(updater) {
    IN_STYLE_UPDATER = true;
    const result = updater();
    IN_STYLE_UPDATER = false;
    return result;
}
function recognizePrefixSuffix(value) {
    "worklet";
    var _a;
    if (typeof value === "string") {
        const match = value.match(/([A-Za-z]*)(-?\d*\.?\d*)([eE][-+]?[0-9]+)?([A-Za-z%]*)/);
        if (!match) {
            throw Error("Couldn't parse animation value. Check if there isn't any typo.");
        }
        const prefix = match[1];
        const suffix = match[4];
        // number with scientific notation
        const number = match[2] + ((_a = match[3]) !== null && _a !== void 0 ? _a : "");
        return {
            prefix,
            suffix,
            strippedValue: parseFloat(number)
        };
    } else {
        return {
            strippedValue: value
        };
    }
}
function decorateAnimation(animation) {
    "worklet";
    if (animation.isHigherOrder) {
        return;
    }
    const baseOnStart = animation.onStart;
    const baseOnFrame = animation.onFrame;
    const animationCopy = Object.assign({}, animation);
    delete animationCopy.callback;
    const prefNumberSuffOnStart = (animation, value, timestamp, previousAnimation)=>{
        var _a, _b, _c, _d;
        // recognize prefix, suffix, and updates stripped value on animation start
        const { prefix, suffix, strippedValue } = recognizePrefixSuffix(value);
        animation.__prefix = prefix;
        animation.__suffix = suffix;
        animation.strippedCurrent = strippedValue;
        const { strippedValue: strippedToValue } = recognizePrefixSuffix(animation.toValue);
        animation.current = strippedValue;
        animation.startValue = strippedValue;
        animation.toValue = strippedToValue;
        if (previousAnimation && previousAnimation !== animation) {
            const { prefix: paPrefix, suffix: paSuffix, strippedValue: paStrippedValue } = recognizePrefixSuffix(previousAnimation.current);
            previousAnimation.current = paStrippedValue;
            previousAnimation.__prefix = paPrefix;
            previousAnimation.__suffix = paSuffix;
        }
        baseOnStart(animation, strippedValue, timestamp, previousAnimation);
        animation.current = ((_a = animation.__prefix) !== null && _a !== void 0 ? _a : "") + animation.current + ((_b = animation.__suffix) !== null && _b !== void 0 ? _b : "");
        if (previousAnimation && previousAnimation !== animation) {
            previousAnimation.current = ((_c = previousAnimation.__prefix) !== null && _c !== void 0 ? _c : "") + previousAnimation.current + ((_d = previousAnimation.__suffix) !== null && _d !== void 0 ? _d : "");
        }
    };
    const prefNumberSuffOnFrame = (animation, timestamp)=>{
        var _a, _b;
        animation.current = animation.strippedCurrent;
        const res = baseOnFrame(animation, timestamp);
        animation.strippedCurrent = animation.current;
        animation.current = ((_a = animation.__prefix) !== null && _a !== void 0 ? _a : "") + animation.current + ((_b = animation.__suffix) !== null && _b !== void 0 ? _b : "");
        return res;
    };
    const tab = [
        "R",
        "G",
        "B",
        "A"
    ];
    const colorOnStart = (animation, value, timestamp, previousAnimation)=>{
        let RGBAValue;
        let RGBACurrent;
        let RGBAToValue;
        const res = [];
        if ((0,_Colors__WEBPACK_IMPORTED_MODULE_0__/* .isColor */ .D5)(value)) {
            RGBACurrent = (0,_Colors__WEBPACK_IMPORTED_MODULE_0__/* .toLinearSpace */ .YU)((0,_Colors__WEBPACK_IMPORTED_MODULE_0__/* .convertToRGBA */ ._k)(animation.current));
            RGBAValue = (0,_Colors__WEBPACK_IMPORTED_MODULE_0__/* .toLinearSpace */ .YU)((0,_Colors__WEBPACK_IMPORTED_MODULE_0__/* .convertToRGBA */ ._k)(value));
            if (animation.toValue) {
                RGBAToValue = (0,_Colors__WEBPACK_IMPORTED_MODULE_0__/* .toLinearSpace */ .YU)((0,_Colors__WEBPACK_IMPORTED_MODULE_0__/* .convertToRGBA */ ._k)(animation.toValue));
            }
        }
        tab.forEach((i, index)=>{
            animation[i] = Object.assign({}, animationCopy);
            animation[i].current = RGBACurrent[index];
            animation[i].toValue = RGBAToValue ? RGBAToValue[index] : undefined;
            animation[i].onStart(animation[i], RGBAValue[index], timestamp, previousAnimation ? previousAnimation[i] : undefined);
            res.push(animation[i].current);
        });
        animation.current = (0,_Colors__WEBPACK_IMPORTED_MODULE_0__/* .rgbaArrayToRGBAColor */ .GM)((0,_Colors__WEBPACK_IMPORTED_MODULE_0__/* .toGammaSpace */ .o7)(res));
    };
    const colorOnFrame = (animation, timestamp)=>{
        const RGBACurrent = (0,_Colors__WEBPACK_IMPORTED_MODULE_0__/* .toLinearSpace */ .YU)((0,_Colors__WEBPACK_IMPORTED_MODULE_0__/* .convertToRGBA */ ._k)(animation.current));
        const res = [];
        let finished = true;
        tab.forEach((i, index)=>{
            animation[i].current = RGBACurrent[index];
            // @ts-ignore: disable-next-line
            finished &= animation[i].onFrame(animation[i], timestamp);
            res.push(animation[i].current);
        });
        animation.current = (0,_Colors__WEBPACK_IMPORTED_MODULE_0__/* .rgbaArrayToRGBAColor */ .GM)((0,_Colors__WEBPACK_IMPORTED_MODULE_0__/* .toGammaSpace */ .o7)(res));
        return finished;
    };
    const arrayOnStart = (animation, value, timestamp, previousAnimation)=>{
        value.forEach((v, i)=>{
            animation[i] = Object.assign({}, animationCopy);
            animation[i].current = v;
            animation[i].toValue = animation.toValue[i];
            animation[i].onStart(animation[i], v, timestamp, previousAnimation ? previousAnimation[i] : undefined);
        });
        animation.current = value;
    };
    const arrayOnFrame = (animation, timestamp)=>{
        let finished = true;
        animation.current.forEach((v, i)=>{
            // @ts-ignore: disable-next-line
            finished &= animation[i].onFrame(animation[i], timestamp);
            animation.current[i] = animation[i].current;
        });
        return finished;
    };
    animation.onStart = (animation, value, timestamp, previousAnimation)=>{
        if ((0,_Colors__WEBPACK_IMPORTED_MODULE_0__/* .isColor */ .D5)(value)) {
            colorOnStart(animation, value, timestamp, previousAnimation);
            animation.onFrame = colorOnFrame;
            return;
        } else if (Array.isArray(value)) {
            arrayOnStart(animation, value, timestamp, previousAnimation);
            animation.onFrame = arrayOnFrame;
            return;
        } else if (typeof value === "string") {
            prefNumberSuffOnStart(animation, value, timestamp, previousAnimation);
            animation.onFrame = prefNumberSuffOnFrame;
            return;
        }
        baseOnStart(animation, value, timestamp, previousAnimation);
    };
}
function defineAnimation(starting, factory) {
    "worklet";
    if (IN_STYLE_UPDATER) {
        return starting;
    }
    const create = ()=>{
        "worklet";
        const animation = factory();
        decorateAnimation(animation);
        return animation;
    };
    if (_WORKLET || !_NativeReanimated__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z.native) {
        return create();
    }
    // @ts-ignore: eslint-disable-line
    return create;
}
function cancelAnimation(sharedValue) {
    "worklet";
    // setting the current value cancels the animation if one is currently running
    sharedValue.value = sharedValue.value; // eslint-disable-line no-self-assign
}
// TODO it should work only if there was no animation before.
function withStartValue(startValue, animation) {
    "worklet";
    return defineAnimation(startValue, ()=>{
        "worklet";
        if (!_WORKLET && typeof animation === "function") {
            animation = animation();
        }
        animation.current = startValue;
        return animation;
    });
}


/***/ }),

/***/ 86095:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BV: () => (/* binding */ stopMapper),
/* harmony export */   HD: () => (/* binding */ enableLayoutAnimations),
/* harmony export */   I1: () => (/* binding */ makeRemote),
/* harmony export */   N5: () => (/* binding */ isConfiguredCheck),
/* harmony export */   RR: () => (/* binding */ configureProps),
/* harmony export */   Rn: () => (/* binding */ startMapper),
/* harmony export */   UE: () => (/* binding */ getViewProp),
/* harmony export */   Uv: () => (/* binding */ makeShareable),
/* harmony export */   lF: () => (/* binding */ isConfigured),
/* harmony export */   m_: () => (/* binding */ runOnUI),
/* harmony export */   pT: () => (/* binding */ requestFrame),
/* harmony export */   rh: () => (/* binding */ checkPluginState),
/* harmony export */   tC: () => (/* binding */ runOnJS),
/* harmony export */   u3: () => (/* binding */ getTimestamp),
/* harmony export */   vG: () => (/* binding */ makeMutable),
/* harmony export */   z7: () => (/* binding */ jestResetJsReanimatedModule)
/* harmony export */ });
/* harmony import */ var _NativeReanimated__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(87490);
/* harmony import */ var react_native__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(83849);
/* harmony import */ var _PlatformChecker__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(39335);
/* global _WORKLET _getCurrentTime _frameTimestamp _eventTimestamp, _setGlobalConsole */ 


if (global._setGlobalConsole === undefined) {
    // it can happen when Reanimated plugin wasn't added, but the user uses the only API from version 1
    global._setGlobalConsole = ()=>{
    // noop
    };
}
const testWorklet = ()=>{
    "worklet";
};
const throwUninitializedReanimatedException = ()=>{
    throw new Error("Failed to initialize react-native-reanimated library, make sure you followed installation steps here: https://docs.swmansion.com/react-native-reanimated/docs/fundamentals/installation/ \n1) Make sure reanimated's babel plugin is installed in your babel.config.js (you should have 'react-native-reanimated/plugin' listed there - also see the above link for details) \n2) Make sure you reset build cache after updating the config, run: yarn start --reset-cache");
};
const checkPluginState = (throwError = true)=>{
    if (!testWorklet.__workletHash && !(0,_PlatformChecker__WEBPACK_IMPORTED_MODULE_0__/* .shouldBeUseWeb */ .Wr)()) {
        if (throwError) {
            throwUninitializedReanimatedException();
        }
        return false;
    }
    return true;
};
const isConfigured = (throwError = false)=>{
    return checkPluginState(throwError);
};
const isConfiguredCheck = ()=>{
    checkPluginState(true);
};
function pushFrame(frame) {
    _NativeReanimated__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z.pushFrame(frame);
}
function requestFrame(frame) {
    "worklet";
    if (_NativeReanimated__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z.native) {
        requestAnimationFrame(frame);
    } else {
        pushFrame(frame);
    }
}
global._WORKLET = false;
global._log = function(s) {
    console.log(s);
};
function runOnUI(worklet) {
    return makeShareable(worklet);
}
function makeShareable(value) {
    isConfiguredCheck();
    return _NativeReanimated__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z.makeShareable(value);
}
function getViewProp(viewTag, propName) {
    return new Promise((resolve, reject)=>{
        return _NativeReanimated__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z.getViewProp(viewTag, propName, (result)=>{
            if (typeof result === "string" && result.substr(0, 6) === "error:") {
                reject(result);
            } else {
                resolve(result);
            }
        });
    });
}
let _getTimestamp;
if ((0,_PlatformChecker__WEBPACK_IMPORTED_MODULE_0__/* .nativeShouldBeMock */ .vq)()) {
    _getTimestamp = ()=>{
        return _NativeReanimated__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z.getTimestamp();
    };
} else {
    _getTimestamp = ()=>{
        "worklet";
        if (_frameTimestamp) {
            return _frameTimestamp;
        }
        if (_eventTimestamp) {
            return _eventTimestamp;
        }
        return _getCurrentTime();
    };
}
function getTimestamp() {
    "worklet";
    if (react_native__WEBPACK_IMPORTED_MODULE_2__.Platform.OS === "web") {
        return _NativeReanimated__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z.getTimestamp();
    }
    return _getTimestamp();
}
function workletValueSetter(value) {
    "worklet";
    const previousAnimation = this._animation;
    if (previousAnimation) {
        previousAnimation.cancelled = true;
        this._animation = null;
    }
    if (typeof value === "function" || value !== null && typeof value === "object" && value.onFrame !== undefined) {
        const animation = typeof value === "function" ? value() : value;
        // prevent setting again to the same value
        // and triggering the mappers that treat this value as an input
        // this happens when the animation's target value(stored in animation.current until animation.onStart is called) is set to the same value as a current one(this._value)
        // built in animations that are not higher order(withTiming, withSpring) hold target value in .current
        if (this._value === animation.current && !animation.isHigherOrder) {
            animation.callback && animation.callback(true);
            return;
        }
        // animated set
        const initializeAnimation = (timestamp)=>{
            animation.onStart(animation, this.value, timestamp, previousAnimation);
        };
        initializeAnimation(getTimestamp());
        const step = (timestamp)=>{
            if (animation.cancelled) {
                animation.callback && animation.callback(false);
                return;
            }
            const finished = animation.onFrame(animation, timestamp);
            animation.finished = true;
            animation.timestamp = timestamp;
            this._value = animation.current;
            if (finished) {
                animation.callback && animation.callback(true);
            } else {
                requestAnimationFrame(step);
            }
        };
        this._animation = animation;
        if (_frameTimestamp) {
            // frame
            step(_frameTimestamp);
        } else {
            requestAnimationFrame(step);
        }
    } else {
        // prevent setting again to the same value
        // and triggering the mappers that treat this value as an input
        if (this._value === value) {
            return;
        }
        this._value = value;
    }
}
// We cannot use pushFrame
// so we use own implementation for js
function workletValueSetterJS(value) {
    const previousAnimation = this._animation;
    if (previousAnimation) {
        previousAnimation.cancelled = true;
        this._animation = null;
    }
    if (typeof value === "function" || value !== null && typeof value === "object" && value.onFrame) {
        // animated set
        const animation = typeof value === "function" ? value() : value;
        let initializeAnimation = (timestamp)=>{
            animation.onStart(animation, this.value, timestamp, previousAnimation);
        };
        const step = (timestamp)=>{
            if (animation.cancelled) {
                animation.callback && animation.callback(false);
                return;
            }
            if (initializeAnimation) {
                initializeAnimation(timestamp);
                initializeAnimation = null; // prevent closure from keeping ref to previous animation
            }
            const finished = animation.onFrame(animation, timestamp);
            animation.timestamp = timestamp;
            this._setValue && this._setValue(animation.current);
            if (finished) {
                animation.callback && animation.callback(true);
            } else {
                requestFrame(step);
            }
        };
        this._animation = animation;
        requestFrame(step);
    } else {
        this._setValue && this._setValue(value);
    }
}
function makeMutable(value) {
    isConfiguredCheck();
    return _NativeReanimated__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z.makeMutable(value);
}
function makeRemote(object = {}) {
    isConfiguredCheck();
    return _NativeReanimated__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z.makeRemote(object);
}
function startMapper(mapper, inputs = [], outputs = [], updater = ()=>{
// noop
}, viewDescriptors = []) {
    isConfiguredCheck();
    return _NativeReanimated__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z.startMapper(mapper, inputs, outputs, updater, viewDescriptors);
}
function stopMapper(mapperId) {
    _NativeReanimated__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z.stopMapper(mapperId);
}
function runOnJS(fun) {
    "worklet";
    if (!_WORKLET) {
        return fun;
    }
    if (!fun.__callAsync) {
        throw new Error("Attempting to call runOnJS with an object that is not a host function. Using runOnJS is only possible with methods that are defined on the main React-Native Javascript thread and that aren't marked as worklets");
    } else {
        return fun.__callAsync;
    }
}
_NativeReanimated__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z.installCoreFunctions(_NativeReanimated__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z.native ? workletValueSetter : workletValueSetterJS);
if (!(0,_PlatformChecker__WEBPACK_IMPORTED_MODULE_0__/* .isWeb */ .$L)() && isConfigured()) {
    const capturableConsole = console;
    runOnUI(()=>{
        "worklet";
        const console1 = {
            debug: runOnJS(capturableConsole.debug),
            log: runOnJS(capturableConsole.log),
            warn: runOnJS(capturableConsole.warn),
            error: runOnJS(capturableConsole.error),
            info: runOnJS(capturableConsole.info)
        };
        _setGlobalConsole(console1);
    })();
}
let featuresConfig = {
    enableLayoutAnimations: false,
    setByUser: false
};
function enableLayoutAnimations(flag, isCallByUser = true) {
    if (isCallByUser) {
        featuresConfig = {
            enableLayoutAnimations: flag,
            setByUser: true
        };
        _NativeReanimated__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z.enableLayoutAnimations(flag);
    } else if (!featuresConfig.setByUser && featuresConfig.enableLayoutAnimations !== flag) {
        featuresConfig.enableLayoutAnimations = flag;
        _NativeReanimated__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z.enableLayoutAnimations(flag);
    }
}
function configureProps(uiProps, nativeProps) {
    if (!(0,_PlatformChecker__WEBPACK_IMPORTED_MODULE_0__/* .nativeShouldBeMock */ .vq)()) {
        _NativeReanimated__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z.configureProps(uiProps, nativeProps);
    }
}
function jestResetJsReanimatedModule() {
    _NativeReanimated__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z.jestResetModule();
}


/***/ }),

/***/ 55633:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  l: () => (/* binding */ useAnimatedStyle)
});

// EXTERNAL MODULE: external "react"
var external_react_ = __webpack_require__(16689);
// EXTERNAL MODULE: ./node_modules/react-native-reanimated/lib/reanimated2/core.js
var core = __webpack_require__(86095);
// EXTERNAL MODULE: ./node_modules/react-native-reanimated/lib/reanimated2/UpdateProps.js
var UpdateProps = __webpack_require__(77544);
// EXTERNAL MODULE: ./node_modules/react-native-reanimated/lib/reanimated2/animation/util.js
var util = __webpack_require__(3138);
// EXTERNAL MODULE: ./node_modules/react-native-reanimated/lib/reanimated2/NativeReanimated/index.js
var NativeReanimated = __webpack_require__(87490);
// EXTERNAL MODULE: ./node_modules/react-native-reanimated/lib/reanimated2/hook/useSharedValue.js
var useSharedValue = __webpack_require__(2957);
// EXTERNAL MODULE: ./node_modules/react-native-reanimated/lib/reanimated2/hook/utils.js
var utils = __webpack_require__(19496);
// EXTERNAL MODULE: ./node_modules/react-native-reanimated/lib/reanimated2/PlatformChecker.js
var PlatformChecker = __webpack_require__(39335);
;// CONCATENATED MODULE: ./node_modules/react-native-reanimated/lib/reanimated2/ViewDescriptorsSet.js



const scheduleUpdates = (0,PlatformChecker/* shouldBeUseWeb */.Wr)() ? requestAnimationFrame : setImmediate;
function makeViewDescriptorsSet() {
    const ref = (0,external_react_.useRef)(null);
    if (ref.current === null) {
        const data = {
            batchToRemove: new Set(),
            tags: new Set(),
            waitForInsertSync: false,
            waitForRemoveSync: false,
            sharableViewDescriptors: (0,core/* makeMutable */.vG)([]),
            items: [],
            add: (item)=>{
                if (data.tags.has(item.tag)) {
                    return;
                }
                data.tags.add(item.tag);
                data.items.push(item);
                if (!data.waitForInsertSync) {
                    data.waitForInsertSync = true;
                    scheduleUpdates(()=>{
                        data.sharableViewDescriptors.value = data.items;
                        data.waitForInsertSync = false;
                    });
                }
            },
            remove: (viewTag)=>{
                data.batchToRemove.add(viewTag);
                if (!data.waitForRemoveSync) {
                    data.waitForRemoveSync = true;
                    scheduleUpdates(()=>{
                        const items = [];
                        for (const item of data.items){
                            if (data.batchToRemove.has(item.tag)) {
                                data.tags.delete(item.tag);
                            } else {
                                items.push(item);
                            }
                        }
                        data.items = items;
                        data.sharableViewDescriptors.value = items;
                        data.batchToRemove = new Set();
                        data.waitForRemoveSync = false;
                    });
                }
            },
            rebuildsharableViewDescriptors: (sharableViewDescriptors)=>{
                data.sharableViewDescriptors = sharableViewDescriptors;
            }
        };
        ref.current = data;
    }
    return ref.current;
}
function makeViewsRefSet() {
    const ref = (0,external_react_.useRef)(null);
    if (ref.current === null) {
        const data = {
            items: new Set(),
            add: (item)=>{
                if (data.items.has(item)) return;
                data.items.add(item);
            },
            remove: (item)=>{
                data.items.delete(item);
            }
        };
        ref.current = data;
    }
    return ref.current;
}

;// CONCATENATED MODULE: ./node_modules/react-native-reanimated/lib/reanimated2/hook/useAnimatedStyle.js
/* global _frameTimestamp */ 








function prepareAnimation(animatedProp, lastAnimation, lastValue) {
    "worklet";
    if (Array.isArray(animatedProp)) {
        animatedProp.forEach((prop, index)=>prepareAnimation(prop, lastAnimation && lastAnimation[index], lastValue && lastValue[index]));
    // return animatedProp;
    }
    if (typeof animatedProp === "object" && animatedProp.onFrame) {
        const animation = animatedProp;
        let value = animation.current;
        if (lastValue !== undefined) {
            if (typeof lastValue === "object") {
                if (lastValue.value !== undefined) {
                    // previously it was a shared value
                    value = lastValue.value;
                } else if (lastValue.onFrame !== undefined) {
                    if ((lastAnimation === null || lastAnimation === void 0 ? void 0 : lastAnimation.current) !== undefined) {
                        // it was an animation before, copy its state
                        value = lastAnimation.current;
                    } else if ((lastValue === null || lastValue === void 0 ? void 0 : lastValue.current) !== undefined) {
                        // it was initialized
                        value = lastValue.current;
                    }
                }
            } else {
                // previously it was a plain value, just set it as starting point
                value = lastValue;
            }
        }
        animation.callStart = (timestamp)=>{
            animation.onStart(animation, value, timestamp, lastAnimation);
        };
        animation.callStart((0,core/* getTimestamp */.u3)());
        animation.callStart = null;
    } else if (typeof animatedProp === "object") {
        // it is an object
        Object.keys(animatedProp).forEach((key)=>prepareAnimation(animatedProp[key], lastAnimation && lastAnimation[key], lastValue && lastValue[key]));
    }
}
function runAnimations(animation, timestamp, key, result, animationsActive) {
    "worklet";
    if (!animationsActive.value) {
        return true;
    }
    if (Array.isArray(animation)) {
        result[key] = [];
        let allFinished = true;
        animation.forEach((entry, index)=>{
            if (!runAnimations(entry, timestamp, index, result[key], animationsActive)) {
                allFinished = false;
            }
        });
        return allFinished;
    } else if (typeof animation === "object" && animation.onFrame) {
        let finished = true;
        if (!animation.finished) {
            if (animation.callStart) {
                animation.callStart(timestamp);
                animation.callStart = null;
            }
            finished = animation.onFrame(animation, timestamp);
            animation.timestamp = timestamp;
            if (finished) {
                animation.finished = true;
                animation.callback && animation.callback(true);
            }
        }
        result[key] = animation.current;
        return finished;
    } else if (typeof animation === "object") {
        result[key] = {};
        let allFinished = true;
        Object.keys(animation).forEach((k)=>{
            if (!runAnimations(animation[k], timestamp, k, result[key], animationsActive)) {
                allFinished = false;
            }
        });
        return allFinished;
    } else {
        result[key] = animation;
        return true;
    }
}
function styleUpdater(viewDescriptors, updater, state, maybeViewRef, animationsActive) {
    "worklet";
    var _a, _b;
    const animations = (_a = state.animations) !== null && _a !== void 0 ? _a : {};
    const newValues = (_b = updater()) !== null && _b !== void 0 ? _b : {};
    const oldValues = state.last;
    let hasAnimations = false;
    for(const key in newValues){
        const value = newValues[key];
        if ((0,utils/* isAnimated */.mE)(value)) {
            prepareAnimation(value, animations[key], oldValues[key]);
            animations[key] = value;
            hasAnimations = true;
        } else {
            delete animations[key];
        }
    }
    if (hasAnimations) {
        const frame = (timestamp)=>{
            const { animations, last, isAnimationCancelled } = state;
            if (isAnimationCancelled) {
                state.isAnimationRunning = false;
                return;
            }
            const updates = {};
            let allFinished = true;
            for(const propName in animations){
                const finished = runAnimations(animations[propName], timestamp, propName, updates, animationsActive);
                if (finished) {
                    last[propName] = updates[propName];
                    delete animations[propName];
                } else {
                    allFinished = false;
                }
            }
            if (updates) {
                (0,UpdateProps/* default */.ZP)(viewDescriptors, updates, maybeViewRef);
            }
            if (!allFinished) {
                (0,core/* requestFrame */.pT)(frame);
            } else {
                state.isAnimationRunning = false;
            }
        };
        state.animations = animations;
        if (!state.isAnimationRunning) {
            state.isAnimationCancelled = false;
            state.isAnimationRunning = true;
            if (_frameTimestamp) {
                frame(_frameTimestamp);
            } else {
                (0,core/* requestFrame */.pT)(frame);
            }
        }
        state.last = Object.assign({}, oldValues, newValues);
        const style = (0,utils/* getStyleWithoutAnimations */.U)(state.last);
        if (style) {
            (0,UpdateProps/* default */.ZP)(viewDescriptors, style, maybeViewRef);
        }
    } else {
        state.isAnimationCancelled = true;
        state.animations = [];
        const diff = (0,utils/* styleDiff */.Gp)(oldValues, newValues);
        state.last = Object.assign({}, oldValues, diff);
        if (diff) {
            (0,UpdateProps/* default */.ZP)(viewDescriptors, newValues, maybeViewRef);
        }
    }
}
function jestStyleUpdater(viewDescriptors, updater, state, maybeViewRef, animationsActive, animatedStyle, adapters = []) {
    "worklet";
    var _a, _b;
    const animations = (_a = state.animations) !== null && _a !== void 0 ? _a : {};
    const newValues = (_b = updater()) !== null && _b !== void 0 ? _b : {};
    const oldValues = state.last;
    // extract animated props
    let hasAnimations = false;
    Object.keys(animations).forEach((key)=>{
        const value = newValues[key];
        if (!(0,utils/* isAnimated */.mE)(value)) {
            delete animations[key];
        }
    });
    Object.keys(newValues).forEach((key)=>{
        const value = newValues[key];
        if ((0,utils/* isAnimated */.mE)(value)) {
            prepareAnimation(value, animations[key], oldValues[key]);
            animations[key] = value;
            hasAnimations = true;
        }
    });
    function frame(timestamp) {
        const { animations, last, isAnimationCancelled } = state;
        if (isAnimationCancelled) {
            state.isAnimationRunning = false;
            return;
        }
        const updates = {};
        let allFinished = true;
        Object.keys(animations).forEach((propName)=>{
            const finished = runAnimations(animations[propName], timestamp, propName, updates, animationsActive);
            if (finished) {
                last[propName] = updates[propName];
                delete animations[propName];
            } else {
                allFinished = false;
            }
        });
        if (Object.keys(updates).length) {
            (0,UpdateProps/* updatePropsJestWrapper */.RH)(viewDescriptors, updates, maybeViewRef, animatedStyle, adapters);
        }
        if (!allFinished) {
            (0,core/* requestFrame */.pT)(frame);
        } else {
            state.isAnimationRunning = false;
        }
    }
    if (hasAnimations) {
        state.animations = animations;
        if (!state.isAnimationRunning) {
            state.isAnimationCancelled = false;
            state.isAnimationRunning = true;
            if (_frameTimestamp) {
                frame(_frameTimestamp);
            } else {
                (0,core/* requestFrame */.pT)(frame);
            }
        }
    } else {
        state.isAnimationCancelled = true;
        state.animations = [];
    }
    // calculate diff
    const diff = (0,utils/* styleDiff */.Gp)(oldValues, newValues);
    state.last = Object.assign({}, oldValues, diff);
    if (Object.keys(diff).length !== 0) {
        (0,UpdateProps/* updatePropsJestWrapper */.RH)(viewDescriptors, diff, maybeViewRef, animatedStyle, adapters);
    }
}
// check for invalid usage of shared values in returned object
function checkSharedValueUsage(prop, currentKey) {
    if (Array.isArray(prop)) {
        // if it's an array (i.ex. transform) validate all its elements
        for (const element of prop){
            checkSharedValueUsage(element, currentKey);
        }
    } else if (typeof prop === "object" && prop.value === undefined) {
        // if it's a nested object, run validation for all its props
        for (const key of Object.keys(prop)){
            checkSharedValueUsage(prop[key], key);
        }
    } else if (currentKey !== undefined && typeof prop === "object" && prop.value !== undefined) {
        // if shared value is passed insted of its value, throw an error
        throw new Error(`invalid value passed to \`${currentKey}\`, maybe you forgot to use \`.value\`?`);
    }
}
function useAnimatedStyle(updater, dependencies, adapters) {
    var _a, _b;
    const viewsRef = makeViewsRefSet();
    const viewDescriptors = makeViewDescriptorsSet();
    const initRef = (0,external_react_.useRef)();
    const inputs = Object.values((_a = updater._closure) !== null && _a !== void 0 ? _a : {});
    const adaptersArray = adapters ? Array.isArray(adapters) ? adapters : [
        adapters
    ] : [];
    const adaptersHash = adapters ? (0,utils/* buildWorkletsHash */.Nq)(adaptersArray) : null;
    const animationsActive = (0,useSharedValue/* useSharedValue */.y)(true);
    const animatedStyle = (0,external_react_.useRef)({});
    // build dependencies
    if (!dependencies) {
        dependencies = [
            ...inputs,
            updater.__workletHash
        ];
    } else {
        dependencies.push(updater.__workletHash);
    }
    adaptersHash && dependencies.push(adaptersHash);
    if (!initRef.current) {
        const initialStyle = (0,util/* initialUpdaterRun */.AX)(updater);
        (0,utils/* validateAnimatedStyles */.Dl)(initialStyle);
        initRef.current = {
            initial: {
                value: initialStyle,
                updater: updater
            },
            remoteState: (0,core/* makeRemote */.I1)({
                last: initialStyle
            }),
            sharableViewDescriptors: (0,core/* makeMutable */.vG)([])
        };
        viewDescriptors.rebuildsharableViewDescriptors(// eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        initRef.current.sharableViewDescriptors);
    }
    dependencies.push((_b = initRef.current) === null || _b === void 0 ? void 0 : _b.sharableViewDescriptors.value);
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    const { initial, remoteState, sharableViewDescriptors } = initRef.current;
    const maybeViewRef = NativeReanimated/* default */.Z.native ? undefined : viewsRef;
    (0,external_react_.useEffect)(()=>{
        let fun;
        let updaterFn = updater;
        let optimalization = updater.__optimalization;
        if (adapters) {
            updaterFn = ()=>{
                "worklet";
                const newValues = updater();
                adaptersArray.forEach((adapter)=>{
                    adapter(newValues);
                });
                return newValues;
            };
        }
        if ((0,utils/* canApplyOptimalisation */.jl)(updaterFn) && !(0,PlatformChecker/* shouldBeUseWeb */.Wr)()) {
            if ((0,utils/* hasColorProps */.ed)(updaterFn())) {
                updaterFn = ()=>{
                    "worklet";
                    const newValues = updaterFn();
                    const oldValues = remoteState.last;
                    const diff = (0,utils/* styleDiff */.Gp)(oldValues, newValues);
                    remoteState.last = Object.assign({}, oldValues, newValues);
                    (0,utils/* parseColors */.Rx)(diff);
                    return diff;
                };
            } else {
                updaterFn = ()=>{
                    "worklet";
                    const newValues = updaterFn();
                    const oldValues = remoteState.last;
                    const diff = (0,utils/* styleDiff */.Gp)(oldValues, newValues);
                    remoteState.last = Object.assign({}, oldValues, newValues);
                    return diff;
                };
            }
        } else if (!(0,PlatformChecker/* shouldBeUseWeb */.Wr)()) {
            optimalization = 0;
            updaterFn = ()=>{
                "worklet";
                const style = updaterFn();
                (0,utils/* parseColors */.Rx)(style);
                return style;
            };
        }
        if (typeof updater.__optimalization !== undefined) {
            updaterFn.__optimalization = optimalization;
        }
        if ((0,PlatformChecker/* isJest */.V5)()) {
            fun = ()=>{
                "worklet";
                jestStyleUpdater(sharableViewDescriptors, updater, remoteState, maybeViewRef, animationsActive, animatedStyle, adaptersArray);
            };
        } else {
            fun = ()=>{
                "worklet";
                styleUpdater(sharableViewDescriptors, updaterFn, remoteState, maybeViewRef, animationsActive);
            };
        }
        const mapperId = (0,core/* startMapper */.Rn)(fun, inputs, [], updaterFn, // TODO fix this
        sharableViewDescriptors);
        return ()=>{
            (0,core/* stopMapper */.BV)(mapperId);
        };
    }, dependencies);
    (0,external_react_.useEffect)(()=>{
        animationsActive.value = true;
        return ()=>{
            // initRef.current = null;
            // viewsRef = null;
            animationsActive.value = false;
        };
    }, []);
    checkSharedValueUsage(initial.value);
    if (process.env.JEST_WORKER_ID) {
        return {
            viewDescriptors,
            initial: initial,
            viewsRef,
            animatedStyle
        };
    } else {
        return {
            viewDescriptors,
            initial: initial,
            viewsRef
        };
    }
}


/***/ }),

/***/ 2957:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   y: () => (/* binding */ useSharedValue)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(16689);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _animation__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(3138);
/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(86095);



function useSharedValue(init) {
    const ref = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)((0,_core__WEBPACK_IMPORTED_MODULE_1__/* .makeMutable */ .vG)(init));
    if (ref.current === null) {
        ref.current = (0,_core__WEBPACK_IMPORTED_MODULE_1__/* .makeMutable */ .vG)(init);
    }
    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{
        return ()=>{
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            (0,_animation__WEBPACK_IMPORTED_MODULE_2__/* .cancelAnimation */ .RE)(ref.current);
        };
    }, []);
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    return ref.current;
}


/***/ }),

/***/ 19496:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Ak: () => (/* binding */ useHandler),
/* harmony export */   Dl: () => (/* binding */ validateAnimatedStyles),
/* harmony export */   Gp: () => (/* binding */ styleDiff),
/* harmony export */   Nq: () => (/* binding */ buildWorkletsHash),
/* harmony export */   Rx: () => (/* binding */ parseColors),
/* harmony export */   U: () => (/* binding */ getStyleWithoutAnimations),
/* harmony export */   ed: () => (/* binding */ hasColorProps),
/* harmony export */   jl: () => (/* binding */ canApplyOptimalisation),
/* harmony export */   mE: () => (/* binding */ isAnimated),
/* harmony export */   zX: () => (/* binding */ useEvent)
/* harmony export */ });
/* unused harmony exports buildDependencies, areDependenciesEqual */
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(16689);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _Colors__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(5367);
/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(86095);
/* harmony import */ var _PlatformChecker__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(39335);
/* harmony import */ var _UpdateProps__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(77544);
/* harmony import */ var _WorkletEventHandler__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(95654);






function useEvent(handler, eventNames = [], rebuild = false) {
    const initRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);
    if (initRef.current === null) {
        initRef.current = new _WorkletEventHandler__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z(handler, eventNames);
    } else if (rebuild) {
        initRef.current.updateWorklet(handler);
    }
    return initRef;
}
function useHandler(handlers, dependencies) {
    const initRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);
    if (initRef.current === null) {
        initRef.current = {
            context: (0,_core__WEBPACK_IMPORTED_MODULE_2__/* .makeRemote */ .I1)({}),
            savedDependencies: []
        };
    }
    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{
        return ()=>{
            initRef.current = null;
        };
    }, []);
    const { context, savedDependencies } = initRef.current;
    dependencies = buildDependencies(dependencies, handlers);
    const doDependenciesDiffer = !areDependenciesEqual(dependencies, savedDependencies);
    initRef.current.savedDependencies = dependencies;
    const useWeb = (0,_PlatformChecker__WEBPACK_IMPORTED_MODULE_3__/* .isWeb */ .$L)() || (0,_PlatformChecker__WEBPACK_IMPORTED_MODULE_3__/* .isJest */ .V5)();
    return {
        context,
        doDependenciesDiffer,
        useWeb
    };
}
// builds one big hash from multiple worklets' hashes
function buildWorkletsHash(handlers) {
    return Object.values(handlers).reduce((acc, worklet)=>// eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        acc + worklet.__workletHash.toString(), "");
}
// builds dependencies array for gesture handlers
function buildDependencies(dependencies, handlers) {
    const handlersList = Object.values(handlers).filter((handler)=>handler !== undefined);
    if (!dependencies) {
        dependencies = handlersList.map((handler)=>{
            return {
                workletHash: handler.__workletHash,
                closure: handler._closure
            };
        });
    } else {
        dependencies.push(buildWorkletsHash(handlersList));
    }
    return dependencies;
}
// this is supposed to work as useEffect comparison
function areDependenciesEqual(nextDeps, prevDeps) {
    function is(x, y) {
        /* eslint-disable no-self-compare */ return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y;
    /* eslint-enable no-self-compare */ }
    const objectIs = typeof Object.is === "function" ? Object.is : is;
    function areHookInputsEqual(nextDeps, prevDeps) {
        if (!nextDeps || !prevDeps || prevDeps.length !== nextDeps.length) {
            return false;
        }
        for(let i = 0; i < prevDeps.length; ++i){
            if (!objectIs(nextDeps[i], prevDeps[i])) {
                return false;
            }
        }
        return true;
    }
    return areHookInputsEqual(nextDeps, prevDeps);
}
function hasColorProps(updates) {
    const colorPropsSet = new Set(_UpdateProps__WEBPACK_IMPORTED_MODULE_4__/* .colorProps */ .jI);
    for(const key in updates){
        if (colorPropsSet.has(key)) {
            return true;
        }
    }
    return false;
}
function parseColors(updates) {
    "worklet";
    for(const key in updates){
        if (_UpdateProps__WEBPACK_IMPORTED_MODULE_4__/* .colorProps */ .jI.indexOf(key) !== -1) {
            // value could be an animation in which case processColor will recognize it and will return undefined
            // -> in such a case we don't want to override style of that key
            const processedColor = (0,_Colors__WEBPACK_IMPORTED_MODULE_5__/* .processColor */ .aL)(updates[key]);
            if (processedColor !== undefined) {
                updates[key] = processedColor;
            }
        }
    }
}
function canApplyOptimalisation(upadterFn) {
    const FUNCTIONLESS_FLAG = 1;
    const STATEMENTLESS_FLAG = 2;
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    const optimalization = upadterFn.__optimalization;
    return optimalization & FUNCTIONLESS_FLAG && optimalization & STATEMENTLESS_FLAG;
}
function isAnimated(prop) {
    "worklet";
    if (Array.isArray(prop)) {
        return prop.some(isAnimated);
    } else if (typeof prop === "object") {
        if (prop.onFrame !== undefined) {
            return true;
        } else {
            return Object.values(prop).some(isAnimated);
        }
    }
    return false;
}
function styleDiff(oldStyle, newStyle) {
    "worklet";
    const diff = {};
    for(const key in oldStyle){
        if (newStyle[key] === undefined) {
            diff[key] = null;
        }
    }
    for(const key in newStyle){
        const value = newStyle[key];
        const oldValue = oldStyle[key];
        if (isAnimated(value)) {
            continue;
        }
        if (oldValue !== value) {
            diff[key] = value;
        }
    }
    return diff;
}
function getStyleWithoutAnimations(newStyle) {
    "worklet";
    const diff = {};
    for(const key in newStyle){
        const value = newStyle[key];
        if (isAnimated(value)) {
            continue;
        }
        diff[key] = value;
    }
    return diff;
}
const validateAnimatedStyles = (styles)=>{
    "worklet";
    if (typeof styles !== "object") {
        throw new Error(`useAnimatedStyle has to return an object, found ${typeof styles} instead`);
    } else if (Array.isArray(styles)) {
        throw new Error("useAnimatedStyle has to return an object and cannot return static styles combined with dynamic ones. Please do merging where a component receives props.");
    }
};


/***/ }),

/***/ 90593:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  n: () => (/* binding */ _updatePropsJS),
  Z: () => (/* binding */ js_reanimated)
});

;// CONCATENATED MODULE: ./node_modules/react-native-reanimated/lib/reanimated2/js-reanimated/MapperRegistry.js
class MapperRegistry {
    constructor(module){
        this.sortedMappers = [];
        this.mappers = new Map();
        this.updatedSinceLastExecute = false;
        this._module = module;
    }
    startMapper(mapper) {
        this.mappers.set(mapper.id, mapper);
        this.updatedSinceLastExecute = true;
        return mapper.id;
    }
    stopMapper(id) {
        this.mappers.delete(id);
        this.updatedSinceLastExecute = true;
    }
    execute() {
        if (this.updatedSinceLastExecute) {
            this.updateOrder();
            this.updatedSinceLastExecute = false;
        }
        for(let i = 0, len = this.sortedMappers.length; i < len; ++i){
            const mapper = this.sortedMappers[i];
            if (mapper.dirty) {
                mapper.execute();
            }
        }
    }
    updateOrder() {
        const nodes = [
            ...this.mappers.values()
        ].map((mapper)=>new Node(mapper));
        const mappersById = {};
        this.mappers.forEach((mapper)=>{
            mappersById[mapper.id] = mapper;
        });
        // create a graph from array of nodes
        for(let i = 0, nodesLen = nodes.length; i < nodesLen; ++i){
            const node = nodes[i];
            if (node.mapper.outputs.length === 0) {
                continue;
            }
            for(let j = 0; j < nodesLen; ++j){
                const restNode = nodes[j];
                if (i === j || restNode.mapper.inputs.length === 0) {
                    continue;
                }
                for(let outi = 0, outputsLen = node.mapper.outputs.length; outi < outputsLen; ++outi){
                    for(let resti = 0, restLen = restNode.mapper.inputs.length; resti < restLen; ++resti){
                        if (node.mapper.outputs[outi]._id === restNode.mapper.inputs[resti]._id) {
                            node.children.push(restNode);
                        }
                    }
                }
            }
        }
        const post = {};
        let postCounter = 1;
        const dfs = (node)=>{
            const index = nodes.indexOf(node);
            if (index === -1) {
                // this node has already been handled
                return;
            }
            ++postCounter;
            nodes.splice(index, 1);
            if (node.children.length === 0 && nodes.length > 0) {
                post[node.mapper.id] = postCounter++;
                dfs(nodes[0]);
                return;
            }
            for(let i = 0, len = node.children.length; i < len; ++i){
                dfs(node.children[i]);
            }
            post[node.mapper.id] = postCounter++;
        };
        while(nodes.length)dfs(nodes[0]);
        const postArray = Object.keys(post).map((key)=>{
            const num = parseInt(key);
            return [
                num,
                post[num]
            ];
        });
        postArray.sort((a, b)=>{
            return b[1] - a[1];
        });
        // clear sorted mappers
        this.sortedMappers = [];
        for(let i = 0, len = postArray.length; i < len; ++i){
            const [id] = postArray[i];
            this.sortedMappers.push(mappersById[id]);
        }
    }
    get needRunOnRender() {
        return this.updatedSinceLastExecute;
    }
}
class Node {
    constructor(mapper, children = []){
        this.mapper = mapper;
        this.children = children;
    }
}

;// CONCATENATED MODULE: ./node_modules/react-native-reanimated/lib/reanimated2/js-reanimated/MutableValue.js
class MutableValue {
    constructor(value, setter){
        this._animation = null;
        this._listeners = [];
        this._id = MutableValue.MUTABLE_ID++;
        this._value = value;
        this._setter = setter;
    }
    get value() {
        return this._value;
    }
    set value(nextValue) {
        this._setter(nextValue);
    }
    // this changes the value finally and is supposed to be called from this._setter
    _setValue(newValue) {
        this._value = newValue;
        this._triggerListener();
    }
    addListener(listener) {
        this._listeners.push(listener);
    }
    _triggerListener() {
        for(let i = 0, len = this._listeners.length; i < len; ++i){
            this._listeners[i]();
        }
    }
}
MutableValue.MUTABLE_ID = 1;

;// CONCATENATED MODULE: ./node_modules/react-native-reanimated/lib/reanimated2/js-reanimated/Mapper.js

class Mapper {
    constructor(module, mapper, inputs = [], outputs = []){
        this.dirty = true;
        this.id = Mapper.MAPPER_ID++;
        this.inputs = this.extractMutablesFromArray(inputs);
        this.outputs = this.extractMutablesFromArray(outputs);
        this.mapper = mapper;
        const markDirty = ()=>{
            this.dirty = true;
            module.maybeRequestRender();
        };
        this.inputs.forEach((input)=>{
            input.addListener(markDirty);
        });
    }
    execute() {
        this.dirty = false;
        this.mapper();
    }
    extractMutablesFromArray(array) {
        const res = [];
        function extractMutables(value) {
            if (value == null) {
            // return;
            } else if (value instanceof MutableValue) {
                res.push(value);
            } else if (Array.isArray(value)) {
                value.forEach((v)=>extractMutables(v));
            } else if (typeof value === "object") {
                Object.keys(value).forEach((key)=>{
                    extractMutables(value[key]);
                });
            }
        }
        extractMutables(array);
        return res;
    }
}
Mapper.MAPPER_ID = 1;

// EXTERNAL MODULE: ./node_modules/react-native-reanimated/lib/reanimated2/NativeReanimated/NativeReanimated.js + 1 modules
var NativeReanimated = __webpack_require__(40098);
// EXTERNAL MODULE: ./node_modules/react-native-reanimated/lib/reanimated2/PlatformChecker.js
var PlatformChecker = __webpack_require__(39335);
;// CONCATENATED MODULE: ./node_modules/react-native-reanimated/lib/reanimated2/js-reanimated/JSReanimated.js





class JSReanimated extends NativeReanimated/* NativeReanimated */.E {
    constructor(){
        super(false);
        this._valueSetter = undefined;
        this._renderRequested = false;
        this._mapperRegistry = new MapperRegistry(this);
        this._frames = [];
        if ((0,PlatformChecker/* isJest */.V5)()) {
            this.timeProvider = {
                now: ()=>global.ReanimatedDataMock.now()
            };
        } else {
            this.timeProvider = {
                now: ()=>window.performance.now()
            };
        }
    }
    pushFrame(frame) {
        this._frames.push(frame);
        this.maybeRequestRender();
    }
    getTimestamp() {
        return this.timeProvider.now();
    }
    maybeRequestRender() {
        if (!this._renderRequested) {
            this._renderRequested = true;
            requestAnimationFrame((_timestampMs)=>{
                this._renderRequested = false;
                this._onRender(this.getTimestamp());
            });
        }
    }
    _onRender(timestampMs) {
        this._mapperRegistry.execute();
        const frames = [
            ...this._frames
        ];
        this._frames = [];
        for(let i = 0, len = frames.length; i < len; ++i){
            frames[i](timestampMs);
        }
        if (this._mapperRegistry.needRunOnRender) {
            this._mapperRegistry.execute();
        }
    }
    installCoreFunctions(valueSetter) {
        this._valueSetter = valueSetter;
    }
    makeShareable(value) {
        return value;
    }
    makeMutable(value) {
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        return new MutableValue(value, this._valueSetter);
    }
    makeRemote(object = {}) {
        return object;
    }
    startMapper(mapper, inputs = [], outputs = []) {
        const instance = new Mapper(this, mapper, inputs, outputs);
        const mapperId = this._mapperRegistry.startMapper(instance);
        this.maybeRequestRender();
        return mapperId;
    }
    stopMapper(mapperId) {
        this._mapperRegistry.stopMapper(mapperId);
    }
    registerEventHandler(_, __) {
        // noop
        return "";
    }
    unregisterEventHandler(_) {
    // noop
    }
    enableLayoutAnimations() {
        console.warn("[Reanimated] enableLayoutAnimations is not available for WEB yet");
    }
    registerSensor() {
        console.warn("[Reanimated] useAnimatedSensor is not available on web yet.");
        return -1;
    }
    unregisterSensor() {
    // noop
    }
    jestResetModule() {
        if ((0,PlatformChecker/* isJest */.V5)()) {
            /**
             * If someone used timers to stop animation before the end,
             * then _renderRequested was set as true
             * and any new update from another test wasn't applied.
             */ this._renderRequested = false;
        } else {
            throw Error("This method can be only use in Jest testing.");
        }
    }
    subscribeForKeyboardEvents(_) {
        console.warn("[Reanimated] useAnimatedKeyboard is not available on web yet.");
        return -1;
    }
    unsubscribeFromKeyboardEvents(_) {
    // noop
    }
}

;// CONCATENATED MODULE: ./node_modules/react-native-reanimated/lib/reanimated2/js-reanimated/index.js

const reanimatedJS = new JSReanimated();
const _updatePropsJS = (updates, viewRef)=>{
    if (viewRef._component) {
        const component = viewRef._component;
        const [rawStyles] = Object.keys(updates).reduce((acc, key)=>{
            const value = updates[key];
            const index = typeof value === "function" ? 1 : 0;
            acc[index][key] = value;
            return acc;
        }, [
            {},
            {}
        ]);
        if (typeof component.setNativeProps === "function") {
            setNativeProps(component, rawStyles);
        } else if (Object.keys(component.props).length > 0) {
            Object.keys(component.props).forEach((key)=>{
                if (!rawStyles[key]) {
                    return;
                }
                const dashedKey = key.replace(/[A-Z]/g, (m)=>"-" + m.toLowerCase());
                component._touchableNode.setAttribute(dashedKey, rawStyles[key]);
            });
        } else {
            console.warn("It is not possible to manipulate component");
        }
    }
};
const setNativeProps = (component, style)=>{
    const previousStyle = component.previousStyle ? component.previousStyle : {};
    const currentStyle = Object.assign(Object.assign({}, previousStyle), style);
    component.previousStyle = currentStyle;
    component.setNativeProps({
        style: currentStyle
    });
};
/* harmony default export */ const js_reanimated = (reanimatedJS);


/***/ }),

/***/ 32157:
/***/ ((module) => {

"use strict";

// RNRender is not used for web. An export is still defined to eliminate warnings from bundlers such as esbuild.
module.exports = null;


/***/ }),

/***/ 88601:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.initialWindowSafeAreaInsets = exports.initialWindowMetrics = void 0;
const initialWindowMetrics = null;
/**
 * @deprecated
 */ exports.initialWindowMetrics = initialWindowMetrics;
const initialWindowSafeAreaInsets = null;
exports.initialWindowSafeAreaInsets = initialWindowSafeAreaInsets; //# sourceMappingURL=InitialWindow.js.map


/***/ }),

/***/ 3955:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.NativeSafeAreaProvider = NativeSafeAreaProvider;
var React = _interopRequireWildcard(__webpack_require__(16689));
var _reactNative = __webpack_require__(83849);
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interopRequireWildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {};
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
/* eslint-env browser */ /**
 * TODO:
 * Currently insets and frame are based on the window and are not
 * relative to the provider view. This is inconsistent with iOS and Android.
 * However in most cases if the provider view covers the screen this is not
 * an issue.
 */ const CSSTransitions = {
    WebkitTransition: "webkitTransitionEnd",
    Transition: "transitionEnd",
    MozTransition: "transitionend",
    MSTransition: "msTransitionEnd",
    OTransition: "oTransitionEnd"
};
function NativeSafeAreaProvider(_ref) {
    let { children, style, onInsetsChange } = _ref;
    React.useEffect(()=>{
        // Skip for SSR.
        if (typeof document === "undefined") {
            return;
        }
        const element = createContextElement();
        document.body.appendChild(element);
        const onEnd = ()=>{
            const { paddingTop, paddingBottom, paddingLeft, paddingRight } = window.getComputedStyle(element);
            const insets = {
                top: paddingTop ? parseInt(paddingTop, 10) : 0,
                bottom: paddingBottom ? parseInt(paddingBottom, 10) : 0,
                left: paddingLeft ? parseInt(paddingLeft, 10) : 0,
                right: paddingRight ? parseInt(paddingRight, 10) : 0
            };
            const frame = {
                x: 0,
                y: 0,
                width: document.documentElement.offsetWidth,
                height: document.documentElement.offsetHeight
            };
            // @ts-ignore: missing properties
            onInsetsChange({
                nativeEvent: {
                    insets,
                    frame
                }
            });
        };
        element.addEventListener(getSupportedTransitionEvent(), onEnd);
        onEnd();
        return ()=>{
            document.body.removeChild(element);
            element.removeEventListener(getSupportedTransitionEvent(), onEnd);
        };
    }, [
        onInsetsChange
    ]);
    return /*#__PURE__*/ React.createElement(_reactNative.View, {
        style: style
    }, children);
}
let _supportedTransitionEvent = null;
function getSupportedTransitionEvent() {
    if (_supportedTransitionEvent != null) {
        return _supportedTransitionEvent;
    }
    const element = document.createElement("invalidtype");
    _supportedTransitionEvent = CSSTransitions.Transition;
    for(const key in CSSTransitions){
        if (element.style[key] !== undefined) {
            _supportedTransitionEvent = CSSTransitions[key];
            break;
        }
    }
    return _supportedTransitionEvent;
}
let _supportedEnv = null;
function getSupportedEnv() {
    if (_supportedEnv !== null) {
        return _supportedEnv;
    }
    const { CSS } = window;
    if (CSS && CSS.supports && CSS.supports("top: constant(safe-area-inset-top)")) {
        _supportedEnv = "constant";
    } else {
        _supportedEnv = "env";
    }
    return _supportedEnv;
}
function getInset(side) {
    return `${getSupportedEnv()}(safe-area-inset-${side})`;
}
function createContextElement() {
    const element = document.createElement("div");
    const { style } = element;
    style.position = "fixed";
    style.left = "0";
    style.top = "0";
    style.width = "0";
    style.height = "0";
    style.zIndex = "-1";
    style.overflow = "hidden";
    style.visibility = "hidden";
    // Bacon: Anything faster than this and the callback will be invoked too early with the wrong insets
    style.transitionDuration = "0.05s";
    style.transitionProperty = "padding";
    style.transitionDelay = "0s";
    style.paddingTop = getInset("top");
    style.paddingBottom = getInset("bottom");
    style.paddingLeft = getInset("left");
    style.paddingRight = getInset("right");
    return element;
} //# sourceMappingURL=NativeSafeAreaProvider.web.js.map


/***/ }),

/***/ 47410:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
})); //# sourceMappingURL=SafeArea.types.js.map


/***/ }),

/***/ 10345:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.SafeAreaInsetsContext = exports.SafeAreaFrameContext = exports.SafeAreaContext = exports.SafeAreaConsumer = void 0;
exports.SafeAreaProvider = SafeAreaProvider;
exports.useSafeArea = useSafeArea;
exports.useSafeAreaFrame = useSafeAreaFrame;
exports.useSafeAreaInsets = useSafeAreaInsets;
exports.withSafeAreaInsets = withSafeAreaInsets;
var React = _interopRequireWildcard(__webpack_require__(16689));
var _reactNative = __webpack_require__(83849);
var _NativeSafeAreaProvider = __webpack_require__(3955);
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interopRequireWildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {};
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
function _extends() {
    _extends = Object.assign ? Object.assign.bind() : function(target) {
        for(var i = 1; i < arguments.length; i++){
            var source = arguments[i];
            for(var key in source){
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                }
            }
        }
        return target;
    };
    return _extends.apply(this, arguments);
}
const isDev = "production" !== "production";
const SafeAreaInsetsContext = /*#__PURE__*/ React.createContext(null);
exports.SafeAreaInsetsContext = SafeAreaInsetsContext;
if (isDev) {
    SafeAreaInsetsContext.displayName = "SafeAreaInsetsContext";
}
const SafeAreaFrameContext = /*#__PURE__*/ React.createContext(null);
exports.SafeAreaFrameContext = SafeAreaFrameContext;
if (isDev) {
    SafeAreaFrameContext.displayName = "SafeAreaFrameContext";
}
function SafeAreaProvider(_ref) {
    let { children, initialMetrics, initialSafeAreaInsets, style, ...others } = _ref;
    const parentInsets = useParentSafeAreaInsets();
    const parentFrame = useParentSafeAreaFrame();
    const [insets, setInsets] = React.useState((initialMetrics === null || initialMetrics === void 0 ? void 0 : initialMetrics.insets) ?? initialSafeAreaInsets ?? parentInsets ?? null);
    const [frame, setFrame] = React.useState((initialMetrics === null || initialMetrics === void 0 ? void 0 : initialMetrics.frame) ?? parentFrame ?? {
        // Backwards compat so we render anyway if we don't have frame.
        x: 0,
        y: 0,
        width: _reactNative.Dimensions.get("window").width,
        height: _reactNative.Dimensions.get("window").height
    });
    const onInsetsChange = React.useCallback((event)=>{
        const { nativeEvent: { frame: nextFrame, insets: nextInsets } } = event;
        if (// Backwards compat with old native code that won't send frame.
        nextFrame && (nextFrame.height !== frame.height || nextFrame.width !== frame.width || nextFrame.x !== frame.x || nextFrame.y !== frame.y)) {
            setFrame(nextFrame);
        }
        if (!insets || nextInsets.bottom !== insets.bottom || nextInsets.left !== insets.left || nextInsets.right !== insets.right || nextInsets.top !== insets.top) {
            setInsets(nextInsets);
        }
    }, [
        frame,
        insets
    ]);
    return /*#__PURE__*/ React.createElement(_NativeSafeAreaProvider.NativeSafeAreaProvider, _extends({
        style: [
            styles.fill,
            style
        ],
        onInsetsChange: onInsetsChange
    }, others), insets != null ? /*#__PURE__*/ React.createElement(SafeAreaFrameContext.Provider, {
        value: frame
    }, /*#__PURE__*/ React.createElement(SafeAreaInsetsContext.Provider, {
        value: insets
    }, children)) : null);
}
const styles = _reactNative.StyleSheet.create({
    fill: {
        flex: 1
    }
});
function useParentSafeAreaInsets() {
    return React.useContext(SafeAreaInsetsContext);
}
function useParentSafeAreaFrame() {
    return React.useContext(SafeAreaFrameContext);
}
const NO_INSETS_ERROR = "No safe area value available. Make sure you are rendering `<SafeAreaProvider>` at the top of your app.";
function useSafeAreaInsets() {
    const insets = React.useContext(SafeAreaInsetsContext);
    if (insets == null) {
        throw new Error(NO_INSETS_ERROR);
    }
    return insets;
}
function useSafeAreaFrame() {
    const frame = React.useContext(SafeAreaFrameContext);
    if (frame == null) {
        throw new Error(NO_INSETS_ERROR);
    }
    return frame;
}
function withSafeAreaInsets(WrappedComponent) {
    return /*#__PURE__*/ React.forwardRef((props, ref)=>{
        const insets = useSafeAreaInsets();
        return /*#__PURE__*/ React.createElement(WrappedComponent, _extends({}, props, {
            insets: insets,
            ref: ref
        }));
    });
}
/**
 * @deprecated
 */ function useSafeArea() {
    return useSafeAreaInsets();
}
/**
 * @deprecated
 */ const SafeAreaConsumer = SafeAreaInsetsContext.Consumer;
/**
 * @deprecated
 */ exports.SafeAreaConsumer = SafeAreaConsumer;
const SafeAreaContext = SafeAreaInsetsContext;
exports.SafeAreaContext = SafeAreaContext; //# sourceMappingURL=SafeAreaContext.js.map


/***/ }),

/***/ 30418:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.SafeAreaView = void 0;
var React = _interopRequireWildcard(__webpack_require__(16689));
var _reactNative = __webpack_require__(83849);
var _SafeAreaContext = __webpack_require__(10345);
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interopRequireWildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {};
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
function _extends() {
    _extends = Object.assign ? Object.assign.bind() : function(target) {
        for(var i = 1; i < arguments.length; i++){
            var source = arguments[i];
            for(var key in source){
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                }
            }
        }
        return target;
    };
    return _extends.apply(this, arguments);
}
// prettier-ignore
const TOP = 8, RIGHT = 4, BOTTOM = 2, LEFT = 1, ALL = 15;
/* eslint-disable no-bitwise */ const edgeBitmaskMap = {
    top: TOP,
    right: RIGHT,
    bottom: BOTTOM,
    left: LEFT
};
const SafeAreaView = /*#__PURE__*/ React.forwardRef((_ref, ref)=>{
    let { style = {}, mode, edges, ...rest } = _ref;
    const insets = (0, _SafeAreaContext.useSafeAreaInsets)();
    const edgeBitmask = edges != null ? Array.isArray(edges) ? edges.reduce((acc, edge)=>acc | edgeBitmaskMap[edge], 0) : Object.keys(edges).reduce((acc, edge)=>acc | edgeBitmaskMap[edge], 0) : ALL;
    const appliedStyle = React.useMemo(()=>{
        const insetTop = edgeBitmask & TOP ? insets.top : 0;
        const insetRight = edgeBitmask & RIGHT ? insets.right : 0;
        const insetBottom = edgeBitmask & BOTTOM ? insets.bottom : 0;
        const insetLeft = edgeBitmask & LEFT ? insets.left : 0;
        const flatStyle = _reactNative.StyleSheet.flatten(style);
        if (mode === "margin") {
            const { margin = 0, marginVertical = margin, marginHorizontal = margin, marginTop = marginVertical, marginRight = marginHorizontal, marginBottom = marginVertical, marginLeft = marginHorizontal } = flatStyle;
            const marginStyle = {
                marginTop: marginTop + insetTop,
                marginRight: marginRight + insetRight,
                marginBottom: marginBottom + insetBottom,
                marginLeft: marginLeft + insetLeft
            };
            return [
                style,
                marginStyle
            ];
        } else {
            const { padding = 0, paddingVertical = padding, paddingHorizontal = padding, paddingTop = paddingVertical, paddingRight = paddingHorizontal, paddingBottom = paddingVertical, paddingLeft = paddingHorizontal } = flatStyle;
            const paddingStyle = {
                paddingTop: paddingTop + insetTop,
                paddingRight: paddingRight + insetRight,
                paddingBottom: paddingBottom + insetBottom,
                paddingLeft: paddingLeft + insetLeft
            };
            return [
                style,
                paddingStyle
            ];
        }
    }, [
        style,
        insets,
        mode,
        edgeBitmask
    ]);
    return /*#__PURE__*/ React.createElement(_reactNative.View, _extends({
        style: appliedStyle
    }, rest, {
        ref: ref
    }));
});
exports.SafeAreaView = SafeAreaView; //# sourceMappingURL=SafeAreaView.web.js.map


/***/ }),

/***/ 30971:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var _SafeAreaContext = __webpack_require__(10345);
Object.keys(_SafeAreaContext).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _SafeAreaContext[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _SafeAreaContext[key];
        }
    });
});
var _SafeAreaView = __webpack_require__(30418);
Object.keys(_SafeAreaView).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _SafeAreaView[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _SafeAreaView[key];
        }
    });
});
var _InitialWindow = __webpack_require__(88601);
Object.keys(_InitialWindow).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _InitialWindow[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _InitialWindow[key];
        }
    });
});
var _SafeArea = __webpack_require__(47410);
Object.keys(_SafeArea).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _SafeArea[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _SafeArea[key];
        }
    });
}); //# sourceMappingURL=index.js.map


/***/ }),

/***/ 61476:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   n: () => (/* binding */ useLink)
/* harmony export */ });
/* harmony import */ var react_native__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(83849);
/* harmony import */ var _router__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(54403);


function useLink({ href, as, shallow, scroll, replace, experimental }) {
    const router = (0,_router__WEBPACK_IMPORTED_MODULE_0__/* .useRouter */ .t)();
    // https://github.com/react-navigation/react-navigation/blob/main/packages/native/src/useLinkProps.tsx#L64
    const onPress = (e)=>{
        let shouldHandle = false;
        if (react_native__WEBPACK_IMPORTED_MODULE_1__.Platform.OS !== "web" || !e) {
            shouldHandle = e ? !e.defaultPrevented : true;
        } else if (!e.defaultPrevented && // onPress prevented default
        // @ts-expect-error: these properties exist on web, but not in React Native
        !(e.metaKey || e.altKey || e.ctrlKey || e.shiftKey) && // ignore clicks with modifier keys
        // @ts-expect-error: these properties exist on web, but not in React Native
        (e.button == null || e.button === 0) && // ignore everything but left clicks
        // @ts-expect-error: these properties exist on web, but not in React Native
        [
            undefined,
            null,
            "",
            "self"
        ].includes(e.currentTarget?.target) // let browser handle "target=_blank" etc.
        ) {
            e.preventDefault();
            shouldHandle = true;
        }
        if (shouldHandle) {
            if (href === "#") {
                // this is a way on web to stay on the same page
                // useful for conditional hrefs
                return;
            }
            if (replace) {
                router.replace(href, as, {
                    shallow,
                    scroll,
                    experimental
                });
            } else {
                router.push(href, as, {
                    shallow,
                    scroll
                });
            }
        }
    };
    return {
        accessibilityRole: "link",
        onPress,
        href: router.parseNextPath(as || href)
    };
} //# sourceMappingURL=use-custom-link.js.map


/***/ }),

/***/ 54403:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  t: () => (/* binding */ useRouter)
});

// EXTERNAL MODULE: external "react"
var external_react_ = __webpack_require__(16689);
// EXTERNAL MODULE: ./node_modules/react-native-web/dist/cjs/index.js
var cjs = __webpack_require__(83849);
;// CONCATENATED MODULE: ./node_modules/solito/build/router/parse-next-path.js
const parseNextPath = (from)=>{
    let path = (typeof from == "string" ? from : from.pathname) || "";
    // replace each instance of [key] with the corresponding value from query[key]
    // this ensures we're navigating to the correct URL
    // it currently ignores [[...param]]
    // but I can't see why you would use this with RN + Next.js
    if (typeof from == "object" && from.query && typeof from.query == "object") {
        const query = {
            ...from.query
        };
        // replace dynamic routes
        // and [...param] syntax
        for(const key in query){
            if (path.includes(`[${key}]`)) {
                path = path.replace(`[${key}]`, `${query[key] ?? ""}`);
                delete query[key];
            } else if (path.includes(`[...${key}]`)) {
                const values = query[key];
                if (Array.isArray(values)) {
                    path = path.replace(`[...${key}]`, values.join("/"));
                    delete query[key];
                }
            }
        }
        if (Object.keys(query).length) {
            // add query param separator
            path += "?";
            for(const key in query){
                const value = query[key];
                if (Array.isArray(value)) {
                    value.forEach((item)=>{
                        path += `${key}=${item}&`;
                    });
                } else if (value != null) {
                    path += `${key}=${value}&`;
                }
            }
            if (path.endsWith("&") || path.endsWith("?")) {
                path = path.slice(0, -1);
            }
        }
    }
    return path;
};
 //# sourceMappingURL=parse-next-path.js.map

;// CONCATENATED MODULE: ./node_modules/solito/build/router/replace-helpers.web.js

const LinkingContext = /*#__PURE__*/ (0,external_react_.createContext)({
    options: undefined
});
let StackActions, getStateFromPath, getActionFromState;
 //# sourceMappingURL=replace-helpers.web.js.map

;// CONCATENATED MODULE: ./node_modules/solito/build/router/use-link-to.web.js
const noOp = ()=>{
    throw new Error("[use-link-to] is not supported on the web. Something went wrong if you called this.");
};
/**
 * @deprecated imported from the wrong file. Use `use-link-to` instead.
 */ const useLinkTo = ()=>noOp; //# sourceMappingURL=use-link-to.web.js.map

;// CONCATENATED MODULE: ./node_modules/solito/build/router/use-navigation.web.js
const useNavigation = ()=>undefined; //# sourceMappingURL=use-navigation.web.js.map

// EXTERNAL MODULE: external "next/router"
var router_ = __webpack_require__(71853);
;// CONCATENATED MODULE: ./node_modules/solito/build/router/use-router.js







function useRouter() {
    const linkTo = useLinkTo();
    const navigation = useNavigation();
    const nextRouter = (0,router_.useRouter)();
    const linking = (0,external_react_.useContext)(LinkingContext);
    return (0,external_react_.useMemo)(()=>({
            push: (url, as, transitionOptions)=>{
                if (cjs.Platform.OS === "web") {
                    nextRouter?.push(url, as, transitionOptions);
                } else {
                    const to = parseNextPath(as || url);
                    if (to) {
                        linkTo(to);
                    }
                }
            },
            replace: (url, as, transitionOptions)=>{
                if (cjs.Platform.OS === "web") {
                    nextRouter?.replace(url, as, transitionOptions);
                } else {
                    const to = parseNextPath(as || url);
                    if (to) {
                        if (transitionOptions?.experimental?.nativeBehavior === "stack-replace") {
                            if (linking?.options) {
                                // custom logic to create a replace() from a URL on native
                                // https://github.com/react-navigation/react-navigation/discussions/10517
                                const { options } = linking;
                                const state = options?.getStateFromPath ? options.getStateFromPath(to, options.config) : getStateFromPath(to, options?.config);
                                if (state) {
                                    const action = getActionFromState(state, options?.config);
                                    if (action !== undefined) {
                                        if ("payload" in action && action.payload && "name" in action.payload && action.payload.name) {
                                            const { name, params } = action.payload;
                                            if (transitionOptions?.experimental?.isNestedNavigator && params && "screen" in params && params.screen) {
                                                navigation?.dispatch(StackActions.replace(params.screen, params.params));
                                            } else {
                                                navigation?.dispatch(StackActions.replace(name, params));
                                            }
                                        } else {
                                            navigation?.dispatch(action);
                                        }
                                    } else {
                                        navigation?.reset(state);
                                    }
                                }
                            } else {
                                // fallback in case the linking context didn't work
                                console.warn(`[solito] replace("${to}") faced an issue. You should still see your new screen, but it probably didn't replace the previous one. This may be due to a breaking change in React Navigation. 
  Please open an issue at https://github.com/nandorojo/solito and report how this happened. Thanks!`);
                                linkTo(to);
                            }
                        } else {
                            linkTo(to);
                        }
                    }
                }
            },
            back: ()=>{
                if (cjs.Platform.OS === "web") {
                    nextRouter?.back();
                } else {
                    navigation?.goBack();
                }
            },
            parseNextPath: parseNextPath
        }), [
        linkTo,
        navigation
    ]);
} //# sourceMappingURL=use-router.js.map


/***/ }),

/***/ 80676:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
0 && (0);
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    default: function() {
        return isError;
    },
    getProperError: function() {
        return getProperError;
    }
});
const _isplainobject = __webpack_require__(78524);
function isError(err) {
    return typeof err === "object" && err !== null && "name" in err && "message" in err;
}
function getProperError(err) {
    if (isError(err)) {
        return err;
    }
    if (false) {}
    return new Error((0, _isplainobject.isPlainObject)(err) ? JSON.stringify(err) : err + "");
}

//# sourceMappingURL=is-error.js.map

/***/ }),

/***/ 95955:
/***/ ((__unused_webpack_module, exports) => {

"use strict";
var __webpack_unused_export__;
/*
MIT License

Copyright (c) Sindre Sorhus <sindresorhus@gmail.com> (sindresorhus.com)

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/ 
__webpack_unused_export__ = ({
    value: true
});
Object.defineProperty(exports, "Z", ({
    enumerable: true,
    get: function() {
        return prettyBytes;
    }
}));
const UNITS = [
    "B",
    "kB",
    "MB",
    "GB",
    "TB",
    "PB",
    "EB",
    "ZB",
    "YB"
];
/*
Formats the given number using `Number#toLocaleString`.
- If locale is a string, the value is expected to be a locale-key (for example: `de`).
- If locale is true, the system default locale is used for translation.
- If no value for locale is specified, the number is returned unmodified.
*/ const toLocaleString = (number, locale)=>{
    let result = number;
    if (typeof locale === "string") {
        result = number.toLocaleString(locale);
    } else if (locale === true) {
        result = number.toLocaleString();
    }
    return result;
};
function prettyBytes(number, options) {
    if (!Number.isFinite(number)) {
        throw new TypeError(`Expected a finite number, got ${typeof number}: ${number}`);
    }
    options = Object.assign({}, options);
    if (options.signed && number === 0) {
        return " 0 B";
    }
    const isNegative = number < 0;
    const prefix = isNegative ? "-" : options.signed ? "+" : "";
    if (isNegative) {
        number = -number;
    }
    if (number < 1) {
        const numberString = toLocaleString(number, options.locale);
        return prefix + numberString + " B";
    }
    const exponent = Math.min(Math.floor(Math.log10(number) / 3), UNITS.length - 1);
    number = Number((number / Math.pow(1000, exponent)).toPrecision(3));
    const numberString = toLocaleString(number, options.locale);
    const unit = UNITS[exponent];
    return prefix + numberString + " " + unit;
}

//# sourceMappingURL=pretty-bytes.js.map

/***/ }),

/***/ 23185:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
0 && (0);
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    PagesRouteModule: function() {
        return PagesRouteModule;
    },
    default: function() {
        return _default;
    }
});
const _routemodule = __webpack_require__(43076);
const _render = __webpack_require__(33100);
class PagesRouteModule extends _routemodule.RouteModule {
    constructor(options){
        super(options);
        this.components = options.components;
    }
    handle() {
        throw new Error("Method not implemented.");
    }
    render(req, res, context) {
        return (0, _render.renderToHTMLImpl)(req, res, context.page, context.query, context.renderOpts, {
            App: this.components.App,
            Document: this.components.Document
        });
    }
}
const _default = PagesRouteModule;

//# sourceMappingURL=module.js.map

/***/ }),

/***/ 56859:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(52488)


/***/ }),

/***/ 4298:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(92205)


/***/ }),

/***/ 51208:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var React = _interopRequireWildcard(__webpack_require__(16689));
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
var _default = /*#__PURE__*/React.createContext(undefined);
exports["default"] = _default;
//# sourceMappingURL=TransitionProgressContext.js.map

/***/ }),

/***/ 34206:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
var _exportNames = {
  enableScreens: true,
  screensEnabled: true,
  enableFreeze: true,
  NativeScreen: true,
  Screen: true,
  InnerScreen: true,
  ScreenContext: true,
  ScreenContainer: true,
  NativeScreenContainer: true,
  NativeScreenNavigationContainer: true,
  ScreenStack: true,
  FullWindowOverlay: true,
  ScreenStackHeaderBackButtonImage: true,
  ScreenStackHeaderRightView: true,
  ScreenStackHeaderLeftView: true,
  ScreenStackHeaderCenterView: true,
  ScreenStackHeaderSearchBarView: true,
  ScreenStackHeaderConfig: true,
  SearchBar: true,
  ScreenStackHeaderSubview: true,
  shouldUseActivityState: true,
  useTransitionProgress: true,
  isSearchBarAvailableForCurrentPlatform: true,
  isNewBackTitleImplementation: true,
  executeNativeBackPress: true
};
exports.SearchBar = exports.ScreenStackHeaderSubview = exports.ScreenStackHeaderSearchBarView = exports.ScreenStackHeaderRightView = exports.ScreenStackHeaderLeftView = exports.ScreenStackHeaderConfig = exports.ScreenStackHeaderCenterView = exports.ScreenStackHeaderBackButtonImage = exports.ScreenStack = exports.ScreenContext = exports.ScreenContainer = exports.Screen = exports.NativeScreenNavigationContainer = exports.NativeScreenContainer = exports.NativeScreen = exports.InnerScreen = exports.FullWindowOverlay = void 0;
exports.enableFreeze = enableFreeze;
exports.enableScreens = enableScreens;
Object.defineProperty(exports, "executeNativeBackPress", ({
  enumerable: true,
  get: function () {
    return _utils.executeNativeBackPress;
  }
}));
Object.defineProperty(exports, "isNewBackTitleImplementation", ({
  enumerable: true,
  get: function () {
    return _utils.isNewBackTitleImplementation;
  }
}));
Object.defineProperty(exports, "isSearchBarAvailableForCurrentPlatform", ({
  enumerable: true,
  get: function () {
    return _utils.isSearchBarAvailableForCurrentPlatform;
  }
}));
exports.screensEnabled = screensEnabled;
exports.shouldUseActivityState = void 0;
Object.defineProperty(exports, "useTransitionProgress", ({
  enumerable: true,
  get: function () {
    return _useTransitionProgress.default;
  }
}));
var _react = _interopRequireDefault(__webpack_require__(16689));
var _reactNative = __webpack_require__(83849);
var _types = __webpack_require__(81453);
Object.keys(_types).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _types[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _types[key];
    }
  });
});
var _useTransitionProgress = _interopRequireDefault(__webpack_require__(57838));
var _utils = __webpack_require__(2459);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }
let ENABLE_SCREENS = true;
function enableScreens() {
  let shouldEnableScreens = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
  ENABLE_SCREENS = shouldEnableScreens;
}
function screensEnabled() {
  return ENABLE_SCREENS;
}

// @ts-ignore function stub, freezing logic is located in index.native.tsx
// eslint-disable-next-line @typescript-eslint/no-unused-vars
function enableFreeze() {
  let shouldEnableReactFreeze = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
} // noop

class NativeScreen extends _react.default.Component {
  render() {
    let {
      active,
      activityState,
      style,
      enabled = ENABLE_SCREENS,
      ...rest
    } = this.props;
    if (enabled) {
      if (active !== undefined && activityState === undefined) {
        activityState = active !== 0 ? 2 : 0; // change taken from index.native.tsx
      }

      return /*#__PURE__*/_react.default.createElement(_reactNative.View
      // @ts-expect-error: hidden exists on web, but not in React Native
      , _extends({
        hidden: activityState === 0,
        style: [style, {
          display: activityState !== 0 ? 'flex' : 'none'
        }]
      }, rest));
    }
    return /*#__PURE__*/_react.default.createElement(_reactNative.View, rest);
  }
}
exports.NativeScreen = NativeScreen;
const Screen = _reactNative.Animated.createAnimatedComponent(NativeScreen);
exports.Screen = Screen;
const InnerScreen = _reactNative.View;
exports.InnerScreen = InnerScreen;
const ScreenContext = /*#__PURE__*/_react.default.createContext(Screen);
exports.ScreenContext = ScreenContext;
const ScreenContainer = _reactNative.View;
exports.ScreenContainer = ScreenContainer;
const NativeScreenContainer = _reactNative.View;
exports.NativeScreenContainer = NativeScreenContainer;
const NativeScreenNavigationContainer = _reactNative.View;
exports.NativeScreenNavigationContainer = NativeScreenNavigationContainer;
const ScreenStack = _reactNative.View;
exports.ScreenStack = ScreenStack;
const FullWindowOverlay = _reactNative.View;
exports.FullWindowOverlay = FullWindowOverlay;
const ScreenStackHeaderBackButtonImage = props => /*#__PURE__*/_react.default.createElement(_reactNative.View, null, /*#__PURE__*/_react.default.createElement(_reactNative.Image, _extends({
  resizeMode: "center",
  fadeDuration: 0
}, props)));
exports.ScreenStackHeaderBackButtonImage = ScreenStackHeaderBackButtonImage;
const ScreenStackHeaderRightView = props => /*#__PURE__*/_react.default.createElement(_reactNative.View, props);
exports.ScreenStackHeaderRightView = ScreenStackHeaderRightView;
const ScreenStackHeaderLeftView = props => /*#__PURE__*/_react.default.createElement(_reactNative.View, props);
exports.ScreenStackHeaderLeftView = ScreenStackHeaderLeftView;
const ScreenStackHeaderCenterView = props => /*#__PURE__*/_react.default.createElement(_reactNative.View, props);
exports.ScreenStackHeaderCenterView = ScreenStackHeaderCenterView;
const ScreenStackHeaderSearchBarView = props => /*#__PURE__*/_react.default.createElement(_reactNative.View, props);
exports.ScreenStackHeaderSearchBarView = ScreenStackHeaderSearchBarView;
const ScreenStackHeaderConfig = props => /*#__PURE__*/_react.default.createElement(_reactNative.View, props);

// @ts-expect-error: search bar props have no common props with View
exports.ScreenStackHeaderConfig = ScreenStackHeaderConfig;
const SearchBar = _reactNative.View;
exports.SearchBar = SearchBar;
const ScreenStackHeaderSubview = _reactNative.View;
exports.ScreenStackHeaderSubview = ScreenStackHeaderSubview;
const shouldUseActivityState = true;
exports.shouldUseActivityState = shouldUseActivityState;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 81453:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
//# sourceMappingURL=types.js.map

/***/ }),

/***/ 57838:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = useTransitionProgress;
var React = _interopRequireWildcard(__webpack_require__(16689));
var _TransitionProgressContext = _interopRequireDefault(__webpack_require__(51208));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function useTransitionProgress() {
  const progress = React.useContext(_TransitionProgressContext.default);
  if (progress === undefined) {
    throw new Error("Couldn't find values for transition progress. Are you inside a screen in Native Stack?");
  }
  return progress;
}
//# sourceMappingURL=useTransitionProgress.js.map

/***/ }),

/***/ 2459:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.executeNativeBackPress = executeNativeBackPress;
exports.isSearchBarAvailableForCurrentPlatform = exports.isNewBackTitleImplementation = void 0;
var _reactNative = __webpack_require__(83849);
const isSearchBarAvailableForCurrentPlatform = ['ios', 'android'].includes(_reactNative.Platform.OS);
exports.isSearchBarAvailableForCurrentPlatform = isSearchBarAvailableForCurrentPlatform;
function executeNativeBackPress() {
  // This function invokes the native back press event
  _reactNative.BackHandler.exitApp();
  return true;
}

// Because of a bug introduced in https://github.com/software-mansion/react-native-screens/pull/1646
// react-native-screens v3.21 changed how header's backTitle handles whitespace strings in https://github.com/software-mansion/react-native-screens/pull/1726
// To allow for backwards compatibility in @react-navigation/native-stack we need a way to check if this version or newer is used.
// See https://github.com/react-navigation/react-navigation/pull/11423 for more context.
const isNewBackTitleImplementation = true;
exports.isNewBackTitleImplementation = isNewBackTitleImplementation;
//# sourceMappingURL=utils.js.map

/***/ }),

/***/ 96329:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(64836)["default"]);

exports.__esModule = true;
exports["default"] = void 0;

var _canUseDom = _interopRequireDefault(__webpack_require__(24019));

/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
function isScreenReaderEnabled() {
  return new Promise((resolve, reject) => {
    resolve(true);
  });
}

var prefersReducedMotionMedia = _canUseDom.default && typeof window.matchMedia === 'function' ? window.matchMedia('(prefers-reduced-motion: reduce)') : null;

function isReduceMotionEnabled() {
  return new Promise((resolve, reject) => {
    resolve(prefersReducedMotionMedia ? prefersReducedMotionMedia.matches : true);
  });
}

function addChangeListener(fn) {
  if (prefersReducedMotionMedia != null) {
    prefersReducedMotionMedia.addEventListener != null ? prefersReducedMotionMedia.addEventListener('change', fn) : prefersReducedMotionMedia.addListener(fn);
  }
}

function removeChangeListener(fn) {
  if (prefersReducedMotionMedia != null) {
    prefersReducedMotionMedia.removeEventListener != null ? prefersReducedMotionMedia.removeEventListener('change', fn) : prefersReducedMotionMedia.removeListener(fn);
  }
}

var handlers = {};
var AccessibilityInfo = {
  /**
   * Query whether a screen reader is currently enabled.
   *
   * Returns a promise which resolves to a boolean.
   * The result is `true` when a screen reader is enabled and `false` otherwise.
   */
  isScreenReaderEnabled,

  /**
   * Query whether the user prefers reduced motion.
   *
   * Returns a promise which resolves to a boolean.
   * The result is `true` when a screen reader is enabled and `false` otherwise.
   */
  isReduceMotionEnabled,

  /**
   * Deprecated
   */
  fetch: isScreenReaderEnabled,

  /**
   * Add an event handler. Supported events: reduceMotionChanged
   */
  addEventListener: function addEventListener(eventName, handler) {
    if (eventName === 'reduceMotionChanged') {
      if (!prefersReducedMotionMedia) {
        return;
      }

      var listener = event => {
        handler(event.matches);
      };

      addChangeListener(listener);
      handlers[handler] = listener;
    }

    return {
      remove: () => AccessibilityInfo.removeEventListener(eventName, handler)
    };
  },

  /**
   * Set accessibility focus to a react component.
   */
  setAccessibilityFocus: function setAccessibilityFocus(reactTag) {},

  /**
   * Post a string to be announced by the screen reader.
   */
  announceForAccessibility: function announceForAccessibility(announcement) {},

  /**
   * Remove an event handler.
   */
  removeEventListener: function removeEventListener(eventName, handler) {
    if (eventName === 'reduceMotionChanged') {
      var listener = handlers[handler];

      if (!listener || !prefersReducedMotionMedia) {
        return;
      }

      removeChangeListener(listener);
    }

    return;
  }
};
var _default = AccessibilityInfo;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),

/***/ 89009:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(64836)["default"]);

var _interopRequireWildcard = (__webpack_require__(75263)["default"]);

exports.__esModule = true;
exports["default"] = void 0;

var _extends2 = _interopRequireDefault(__webpack_require__(10434));

var _objectWithoutPropertiesLoose2 = _interopRequireDefault(__webpack_require__(7071));

var React = _interopRequireWildcard(__webpack_require__(16689));

var _StyleSheet = _interopRequireDefault(__webpack_require__(84099));

var _View = _interopRequireDefault(__webpack_require__(79057));

var _excluded = ["animating", "color", "hidesWhenStopped", "size", "style"];

var createSvgCircle = style => /*#__PURE__*/React.createElement("circle", {
  cx: "16",
  cy: "16",
  fill: "none",
  r: "14",
  strokeWidth: "4",
  style: style
});

var ActivityIndicator = /*#__PURE__*/React.forwardRef((props, forwardedRef) => {
  var _props$animating = props.animating,
      animating = _props$animating === void 0 ? true : _props$animating,
      _props$color = props.color,
      color = _props$color === void 0 ? '#1976D2' : _props$color,
      _props$hidesWhenStopp = props.hidesWhenStopped,
      hidesWhenStopped = _props$hidesWhenStopp === void 0 ? true : _props$hidesWhenStopp,
      _props$size = props.size,
      size = _props$size === void 0 ? 'small' : _props$size,
      style = props.style,
      other = (0, _objectWithoutPropertiesLoose2.default)(props, _excluded);
  var svg = /*#__PURE__*/React.createElement("svg", {
    height: "100%",
    viewBox: "0 0 32 32",
    width: "100%"
  }, createSvgCircle({
    stroke: color,
    opacity: 0.2
  }), createSvgCircle({
    stroke: color,
    strokeDasharray: 80,
    strokeDashoffset: 60
  }));
  return /*#__PURE__*/React.createElement(_View.default, (0, _extends2.default)({}, other, {
    accessibilityRole: "progressbar",
    accessibilityValueMax: 1,
    accessibilityValueMin: 0,
    ref: forwardedRef,
    style: [styles.container, style]
  }), /*#__PURE__*/React.createElement(_View.default, {
    children: svg,
    style: [typeof size === 'number' ? {
      height: size,
      width: size
    } : indicatorSizes[size], styles.animation, !animating && styles.animationPause, !animating && hidesWhenStopped && styles.hidesWhenStopped]
  }));
});
ActivityIndicator.displayName = 'ActivityIndicator';

var styles = _StyleSheet.default.create({
  container: {
    alignItems: 'center',
    justifyContent: 'center'
  },
  hidesWhenStopped: {
    visibility: 'hidden'
  },
  animation: {
    animationDuration: '0.75s',
    animationKeyframes: [{
      '0%': {
        transform: [{
          rotate: '0deg'
        }]
      },
      '100%': {
        transform: [{
          rotate: '360deg'
        }]
      }
    }],
    animationTimingFunction: 'linear',
    animationIterationCount: 'infinite'
  },
  animationPause: {
    animationPlayState: 'paused'
  }
});

var indicatorSizes = _StyleSheet.default.create({
  small: {
    width: 20,
    height: 20
  },
  large: {
    width: 36,
    height: 36
  }
});

var _default = ActivityIndicator;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),

/***/ 7426:
/***/ ((module, exports) => {

"use strict";


exports.__esModule = true;
exports["default"] = void 0;

/**
 * Copyright (c) Nicolas Gallagher.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
class Alert {
  static alert() {}

}

var _default = Alert;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),

/***/ 31529:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(64836)["default"]);

exports.__esModule = true;
exports["default"] = void 0;

var _Animated = _interopRequireDefault(__webpack_require__(24262));

/**
 * Copyright (c) Nicolas Gallagher.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
var _default = _Animated.default;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),

/***/ 59947:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(64836)["default"]);

var _interopRequireWildcard = (__webpack_require__(75263)["default"]);

exports.__esModule = true;
exports["default"] = AppContainer;

var React = _interopRequireWildcard(__webpack_require__(16689));

var _StyleSheet = _interopRequireDefault(__webpack_require__(84099));

var _View = _interopRequireDefault(__webpack_require__(79057));

/**
 * Copyright (c) Nicolas Gallagher.
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
var RootTagContext = /*#__PURE__*/React.createContext(null);

function AppContainer(props) {
  var children = props.children,
      WrapperComponent = props.WrapperComponent;
  var innerView = /*#__PURE__*/React.createElement(_View.default, {
    children: children,
    key: 1,
    pointerEvents: "box-none",
    style: styles.appContainer
  });

  if (WrapperComponent) {
    innerView = /*#__PURE__*/React.createElement(WrapperComponent, null, innerView);
  }

  return /*#__PURE__*/React.createElement(RootTagContext.Provider, {
    value: props.rootTag
  }, /*#__PURE__*/React.createElement(_View.default, {
    pointerEvents: "box-none",
    style: styles.appContainer
  }, innerView));
}

var styles = _StyleSheet.default.create({
  appContainer: {
    flex: 1
  }
});

module.exports = exports.default;

/***/ }),

/***/ 10269:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireWildcard = (__webpack_require__(75263)["default"]);

var _interopRequireDefault = (__webpack_require__(64836)["default"]);

exports.__esModule = true;
exports["default"] = void 0;

var _objectSpread2 = _interopRequireDefault(__webpack_require__(42122));

var _invariant = _interopRequireDefault(__webpack_require__(44505));

var _unmountComponentAtNode = _interopRequireDefault(__webpack_require__(90993));

var _renderApplication = _interopRequireWildcard(__webpack_require__(33978));

/**
 * Copyright (c) Nicolas Gallagher.
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
var emptyObject = {};
var runnables = {};

var componentProviderInstrumentationHook = component => component();

var wrapperComponentProvider;
/**
 * `AppRegistry` is the JS entry point to running all React Native apps.
 */

class AppRegistry {
  static getAppKeys() {
    return Object.keys(runnables);
  }

  static getApplication(appKey, appParameters) {
    (0, _invariant.default)(runnables[appKey] && runnables[appKey].getApplication, "Application " + appKey + " has not been registered. " + 'This is either due to an import error during initialization or failure to call AppRegistry.registerComponent.');
    return runnables[appKey].getApplication(appParameters);
  }

  static registerComponent(appKey, componentProvider) {
    runnables[appKey] = {
      getApplication: appParameters => (0, _renderApplication.getApplication)(componentProviderInstrumentationHook(componentProvider), appParameters ? appParameters.initialProps : emptyObject, wrapperComponentProvider && wrapperComponentProvider(appParameters)),
      run: appParameters => (0, _renderApplication.default)(componentProviderInstrumentationHook(componentProvider), wrapperComponentProvider && wrapperComponentProvider(appParameters), appParameters.callback, {
        hydrate: appParameters.hydrate || false,
        initialProps: appParameters.initialProps || emptyObject,
        rootTag: appParameters.rootTag
      })
    };
    return appKey;
  }

  static registerConfig(config) {
    config.forEach(_ref => {
      var appKey = _ref.appKey,
          component = _ref.component,
          run = _ref.run;

      if (run) {
        AppRegistry.registerRunnable(appKey, run);
      } else {
        (0, _invariant.default)(component, 'No component provider passed in');
        AppRegistry.registerComponent(appKey, component);
      }
    });
  } // TODO: fix style sheet creation when using this method


  static registerRunnable(appKey, run) {
    runnables[appKey] = {
      run
    };
    return appKey;
  }

  static runApplication(appKey, appParameters) {
    var isDevelopment =  false && 0;

    if (isDevelopment) {
      var params = (0, _objectSpread2.default)({}, appParameters);
      params.rootTag = "#" + params.rootTag.id;
      console.log("Running application \"" + appKey + "\" with appParams:\n", params, "\nDevelopment-level warnings: " + (isDevelopment ? 'ON' : 'OFF') + "." + ("\nPerformance optimizations: " + (isDevelopment ? 'OFF' : 'ON') + "."));
    }

    (0, _invariant.default)(runnables[appKey] && runnables[appKey].run, "Application \"" + appKey + "\" has not been registered. " + 'This is either due to an import error during initialization or failure to call AppRegistry.registerComponent.');
    runnables[appKey].run(appParameters);
  }

  static setComponentProviderInstrumentationHook(hook) {
    componentProviderInstrumentationHook = hook;
  }

  static setWrapperComponentProvider(provider) {
    wrapperComponentProvider = provider;
  }

  static unmountApplicationComponentAtRootTag(rootTag) {
    (0, _unmountComponentAtNode.default)(rootTag);
  }

}

exports["default"] = AppRegistry;
module.exports = exports.default;

/***/ }),

/***/ 33978:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var _interopRequireWildcard = (__webpack_require__(75263)["default"]);

var _interopRequireDefault = (__webpack_require__(64836)["default"]);

exports.__esModule = true;
exports["default"] = renderApplication;
exports.getApplication = getApplication;

var _extends2 = _interopRequireDefault(__webpack_require__(10434));

var _AppContainer = _interopRequireDefault(__webpack_require__(59947));

var _invariant = _interopRequireDefault(__webpack_require__(44505));

var _render = _interopRequireWildcard(__webpack_require__(53291));

var _StyleSheet = _interopRequireDefault(__webpack_require__(84099));

var _react = _interopRequireDefault(__webpack_require__(16689));

/**
 * Copyright (c) Nicolas Gallagher.
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
function renderApplication(RootComponent, WrapperComponent, callback, options) {
  var shouldHydrate = options.hydrate,
      initialProps = options.initialProps,
      rootTag = options.rootTag;
  var renderFn = shouldHydrate ? _render.hydrate : _render.default;
  (0, _invariant.default)(rootTag, 'Expect to have a valid rootTag, instead got ', rootTag);
  renderFn( /*#__PURE__*/_react.default.createElement(_AppContainer.default, {
    WrapperComponent: WrapperComponent,
    rootTag: rootTag
  }, /*#__PURE__*/_react.default.createElement(RootComponent, initialProps)), rootTag, callback);
}

function getApplication(RootComponent, initialProps, WrapperComponent) {
  var element = /*#__PURE__*/_react.default.createElement(_AppContainer.default, {
    WrapperComponent: WrapperComponent,
    rootTag: {}
  }, /*#__PURE__*/_react.default.createElement(RootComponent, initialProps)); // Don't escape CSS text


  var getStyleElement = props => {
    var sheet = _StyleSheet.default.getSheet();

    return /*#__PURE__*/_react.default.createElement("style", (0, _extends2.default)({}, props, {
      dangerouslySetInnerHTML: {
        __html: sheet.textContent
      },
      id: sheet.id
    }));
  };

  return {
    element,
    getStyleElement
  };
}

/***/ }),

/***/ 42384:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(64836)["default"]);

exports.__esModule = true;
exports["default"] = void 0;

var _invariant = _interopRequireDefault(__webpack_require__(44505));

var _EventEmitter = _interopRequireDefault(__webpack_require__(67834));

var _canUseDom = _interopRequireDefault(__webpack_require__(24019));

/**
 * Copyright (c) Nicolas Gallagher.
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
// Android 4.4 browser
var isPrefixed = _canUseDom.default && !document.hasOwnProperty('hidden') && document.hasOwnProperty('webkitHidden');
var EVENT_TYPES = ['change', 'memoryWarning'];
var VISIBILITY_CHANGE_EVENT = isPrefixed ? 'webkitvisibilitychange' : 'visibilitychange';
var VISIBILITY_STATE_PROPERTY = isPrefixed ? 'webkitVisibilityState' : 'visibilityState';
var AppStates = {
  BACKGROUND: 'background',
  ACTIVE: 'active'
};
var changeEmitter = null;

class AppState {
  static get currentState() {
    if (!AppState.isAvailable) {
      return AppStates.ACTIVE;
    }

    switch (document[VISIBILITY_STATE_PROPERTY]) {
      case 'hidden':
      case 'prerender':
      case 'unloaded':
        return AppStates.BACKGROUND;

      default:
        return AppStates.ACTIVE;
    }
  }

  static addEventListener(type, handler) {
    if (AppState.isAvailable) {
      (0, _invariant.default)(EVENT_TYPES.indexOf(type) !== -1, 'Trying to subscribe to unknown event: "%s"', type);

      if (type === 'change') {
        if (!changeEmitter) {
          changeEmitter = new _EventEmitter.default();
          document.addEventListener(VISIBILITY_CHANGE_EVENT, () => {
            if (changeEmitter) {
              changeEmitter.emit('change', AppState.currentState);
            }
          }, false);
        }

        return changeEmitter.addListener(type, handler);
      }
    }
  }

  static removeEventListener(type, handler) {
    if (AppState.isAvailable) {
      console.error("AppState.removeListener('" + type + "', ...): Method has been " + 'deprecated. Please instead use `remove()` on the subscription ' + 'returned by `AppState.addEventListener`.');
      (0, _invariant.default)(EVENT_TYPES.indexOf(type) !== -1, 'Trying to remove listener for unknown event: "%s"', type);

      if (type === 'change' && changeEmitter) {
        changeEmitter.removeListener(handler);
      }
    }
  }

}

exports["default"] = AppState;
AppState.isAvailable = _canUseDom.default && document[VISIBILITY_STATE_PROPERTY];
module.exports = exports.default;

/***/ }),

/***/ 43433:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(64836)["default"]);

exports.__esModule = true;
exports["default"] = void 0;

var _canUseDom = _interopRequireDefault(__webpack_require__(24019));

/**
 * Copyright (c) Nicolas Gallagher.
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
function getQuery() {
  return _canUseDom.default && window.matchMedia != null ? window.matchMedia('(prefers-color-scheme: dark)') : null;
}

var query = getQuery();
var listenerMapping = new WeakMap();
var Appearance = {
  getColorScheme() {
    return query && query.matches ? 'dark' : 'light';
  },

  addChangeListener(listener) {
    var mappedListener = listenerMapping.get(listener);

    if (!mappedListener) {
      mappedListener = _ref => {
        var matches = _ref.matches;
        listener({
          colorScheme: matches ? 'dark' : 'light'
        });
      };

      listenerMapping.set(listener, mappedListener);
    }

    if (query) {
      query.addListener(mappedListener);
    }

    function remove() {
      var mappedListener = listenerMapping.get(listener);

      if (query && mappedListener) {
        query.removeListener(mappedListener);
      }

      listenerMapping.delete(listener);
    }

    return {
      remove
    };
  }

};
var _default = Appearance;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),

/***/ 97531:
/***/ ((module, exports) => {

"use strict";


exports.__esModule = true;
exports["default"] = void 0;

/**
 * Copyright (c) Nicolas Gallagher.
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
function emptyFunction() {}

var BackHandler = {
  exitApp: emptyFunction,

  addEventListener() {
    return {
      remove: emptyFunction
    };
  },

  removeEventListener: emptyFunction
};
var _default = BackHandler;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),

/***/ 25959:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(64836)["default"]);

var _interopRequireWildcard = (__webpack_require__(75263)["default"]);

exports.__esModule = true;
exports["default"] = void 0;

var React = _interopRequireWildcard(__webpack_require__(16689));

var _StyleSheet = _interopRequireDefault(__webpack_require__(84099));

var _TouchableOpacity = _interopRequireDefault(__webpack_require__(28908));

var _Text = _interopRequireDefault(__webpack_require__(48409));

/**
 * Copyright (c) Nicolas Gallagher.
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
var Button = /*#__PURE__*/React.forwardRef((props, forwardedRef) => {
  var accessibilityLabel = props.accessibilityLabel,
      color = props.color,
      disabled = props.disabled,
      onPress = props.onPress,
      testID = props.testID,
      title = props.title;
  return /*#__PURE__*/React.createElement(_TouchableOpacity.default, {
    accessibilityLabel: accessibilityLabel,
    accessibilityRole: "button",
    disabled: disabled,
    focusable: !disabled,
    onPress: onPress,
    ref: forwardedRef,
    style: [styles.button, color && {
      backgroundColor: color
    }, disabled && styles.buttonDisabled],
    testID: testID
  }, /*#__PURE__*/React.createElement(_Text.default, {
    style: [styles.text, disabled && styles.textDisabled]
  }, title));
});
Button.displayName = 'Button';

var styles = _StyleSheet.default.create({
  button: {
    backgroundColor: '#2196F3',
    borderRadius: 2
  },
  text: {
    color: '#fff',
    fontWeight: '500',
    padding: 8,
    textAlign: 'center',
    textTransform: 'uppercase'
  },
  buttonDisabled: {
    backgroundColor: '#dfdfdf'
  },
  textDisabled: {
    color: '#a1a1a1'
  }
});

var _default = Button;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),

/***/ 4857:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(64836)["default"]);

var _interopRequireWildcard = (__webpack_require__(75263)["default"]);

exports.__esModule = true;
exports["default"] = void 0;

var _objectSpread2 = _interopRequireDefault(__webpack_require__(42122));

var _extends2 = _interopRequireDefault(__webpack_require__(10434));

var _objectWithoutPropertiesLoose2 = _interopRequireDefault(__webpack_require__(7071));

var React = _interopRequireWildcard(__webpack_require__(16689));

var _createElement = _interopRequireDefault(__webpack_require__(63820));

var _StyleSheet = _interopRequireDefault(__webpack_require__(84099));

var _View = _interopRequireDefault(__webpack_require__(79057));

var _excluded = ["accessibilityReadOnly", "color", "disabled", "onChange", "onValueChange", "style", "value"];
var CheckBox = /*#__PURE__*/React.forwardRef((props, forwardedRef) => {
  var accessibilityReadOnly = props.accessibilityReadOnly,
      color = props.color,
      disabled = props.disabled,
      onChange = props.onChange,
      onValueChange = props.onValueChange,
      style = props.style,
      value = props.value,
      other = (0, _objectWithoutPropertiesLoose2.default)(props, _excluded);

  function handleChange(event) {
    var value = event.nativeEvent.target.checked;
    event.nativeEvent.value = value;
    onChange && onChange(event);
    onValueChange && onValueChange(value);
  }

  var fakeControl = /*#__PURE__*/React.createElement(_View.default, {
    style: [styles.fakeControl, value && styles.fakeControlChecked, // custom color
    value && color && {
      backgroundColor: color,
      borderColor: color
    }, disabled && styles.fakeControlDisabled, value && disabled && styles.fakeControlCheckedAndDisabled]
  });
  var nativeControl = (0, _createElement.default)('input', {
    checked: value,
    disabled: disabled,
    onChange: handleChange,
    readOnly: accessibilityReadOnly,
    ref: forwardedRef,
    style: [styles.nativeControl, styles.cursorInherit],
    type: 'checkbox'
  });
  return /*#__PURE__*/React.createElement(_View.default, (0, _extends2.default)({}, other, {
    accessibilityDisabled: disabled,
    accessibilityReadOnly: accessibilityReadOnly,
    style: [styles.root, style, disabled && styles.cursorDefault]
  }), fakeControl, nativeControl);
});
CheckBox.displayName = 'CheckBox';

var styles = _StyleSheet.default.create({
  root: {
    cursor: 'pointer',
    height: 16,
    userSelect: 'none',
    width: 16
  },
  cursorDefault: {
    cursor: 'default'
  },
  cursorInherit: {
    cursor: 'inherit'
  },
  fakeControl: {
    alignItems: 'center',
    backgroundColor: '#fff',
    borderColor: '#657786',
    borderRadius: 2,
    borderStyle: 'solid',
    borderWidth: 2,
    height: '100%',
    justifyContent: 'center',
    width: '100%'
  },
  fakeControlChecked: {
    backgroundColor: '#009688',
    backgroundImage: 'url("data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjxzdmcKICAgeG1sbnM6ZGM9Imh0dHA6Ly9wdXJsLm9yZy9kYy9lbGVtZW50cy8xLjEvIgogICB4bWxuczpjYz0iaHR0cDovL2NyZWF0aXZlY29tbW9ucy5vcmcvbnMjIgogICB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiCiAgIHhtbG5zOnN2Zz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciCiAgIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIKICAgdmVyc2lvbj0iMS4xIgogICB2aWV3Qm94PSIwIDAgMSAxIgogICBwcmVzZXJ2ZUFzcGVjdFJhdGlvPSJ4TWluWU1pbiBtZWV0Ij4KICA8cGF0aAogICAgIGQ9Ik0gMC4wNDAzODA1OSwwLjYyNjc3NjcgMC4xNDY0NDY2MSwwLjUyMDcxMDY4IDAuNDI5Mjg5MzIsMC44MDM1NTMzOSAwLjMyMzIyMzMsMC45MDk2MTk0MSB6IE0gMC4yMTcxNTcyOSwwLjgwMzU1MzM5IDAuODUzNTUzMzksMC4xNjcxNTcyOSAwLjk1OTYxOTQxLDAuMjczMjIzMyAwLjMyMzIyMzMsMC45MDk2MTk0MSB6IgogICAgIGlkPSJyZWN0Mzc4MCIKICAgICBzdHlsZT0iZmlsbDojZmZmZmZmO2ZpbGwtb3BhY2l0eToxO3N0cm9rZTpub25lIiAvPgo8L3N2Zz4K")',
    backgroundRepeat: 'no-repeat',
    borderColor: '#009688'
  },
  fakeControlDisabled: {
    borderColor: '#CCD6DD'
  },
  fakeControlCheckedAndDisabled: {
    backgroundColor: '#AAB8C2',
    borderColor: '#AAB8C2'
  },
  nativeControl: (0, _objectSpread2.default)((0, _objectSpread2.default)({}, _StyleSheet.default.absoluteFillObject), {}, {
    height: '100%',
    margin: 0,
    appearance: 'none',
    padding: 0,
    width: '100%'
  })
});

var _default = CheckBox;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),

/***/ 31993:
/***/ ((module, exports) => {

"use strict";


exports.__esModule = true;
exports["default"] = void 0;

/**
 * Copyright (c) Nicolas Gallagher.
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
var clipboardAvailable;

class Clipboard {
  static isAvailable() {
    if (clipboardAvailable === undefined) {
      clipboardAvailable = typeof document.queryCommandSupported === 'function' && document.queryCommandSupported('copy');
    }

    return clipboardAvailable;
  }

  static getString() {
    return Promise.resolve('');
  }

  static setString(text) {
    var success = false;
    var body = document.body;

    if (body) {
      // add the text to a hidden node
      var node = document.createElement('span');
      node.textContent = text;
      node.style.opacity = '0';
      node.style.position = 'absolute';
      node.style.whiteSpace = 'pre-wrap';
      node.style.userSelect = 'auto';
      body.appendChild(node); // select the text

      var selection = window.getSelection();
      selection.removeAllRanges();
      var range = document.createRange();
      range.selectNodeContents(node);
      selection.addRange(range); // attempt to copy

      try {
        document.execCommand('copy');
        success = true;
      } catch (e) {} // remove selection and node


      selection.removeAllRanges();
      body.removeChild(node);
    }

    return success;
  }

}

exports["default"] = Clipboard;
module.exports = exports.default;

/***/ }),

/***/ 84384:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(64836)["default"]);

exports.__esModule = true;
exports["default"] = void 0;

var _RCTDeviceEventEmitter = _interopRequireDefault(__webpack_require__(28939));

var _default = _RCTDeviceEventEmitter.default;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),

/***/ 95072:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(64836)["default"]);

exports.__esModule = true;
exports["default"] = void 0;

var _Dimensions = _interopRequireDefault(__webpack_require__(13256));

var _canUseDom = _interopRequireDefault(__webpack_require__(24019));

/**
 * Copyright (c) Nicolas Gallagher.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
var DeviceInfo = {
  Dimensions: {
    get windowPhysicalPixels() {
      var _Dimensions$get = _Dimensions.default.get('window'),
          width = _Dimensions$get.width,
          height = _Dimensions$get.height,
          fontScale = _Dimensions$get.fontScale,
          scale = _Dimensions$get.scale;

      return {
        width: width * scale,
        height: height * scale,
        scale,
        fontScale
      };
    },

    get screenPhysicalPixels() {
      var _Dimensions$get2 = _Dimensions.default.get('screen'),
          width = _Dimensions$get2.width,
          height = _Dimensions$get2.height,
          fontScale = _Dimensions$get2.fontScale,
          scale = _Dimensions$get2.scale;

      return {
        width: width * scale,
        height: height * scale,
        scale,
        fontScale
      };
    }

  },

  get locale() {
    if (_canUseDom.default) {
      if (navigator.languages) {
        return navigator.languages[0];
      } else {
        return navigator.language;
      }
    }
  },

  get totalMemory() {
    // $FlowIssue deviceMemory not defined in navigator
    return _canUseDom.default ? navigator.deviceMemory : undefined;
  },

  get userAgent() {
    return _canUseDom.default ? navigator.userAgent : '';
  }

};
var _default = DeviceInfo;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),

/***/ 13256:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(64836)["default"]);

exports.__esModule = true;
exports["default"] = void 0;

var _invariant = _interopRequireDefault(__webpack_require__(44505));

var _canUseDom = _interopRequireDefault(__webpack_require__(24019));

/**
 * Copyright (c) Nicolas Gallagher.
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
var dimensions = {
  window: {
    fontScale: 1,
    height: 0,
    scale: 1,
    width: 0
  },
  screen: {
    fontScale: 1,
    height: 0,
    scale: 1,
    width: 0
  }
};
var listeners = {};
var shouldInit = _canUseDom.default;

function update() {
  if (!_canUseDom.default) {
    return;
  }

  var win = window;
  var height;
  var width;
  /**
   * iOS does not update viewport dimensions on keyboard open/close.
   * window.visualViewport(https://developer.mozilla.org/en-US/docs/Web/API/VisualViewport)
   * is used instead of document.documentElement.clientHeight (which remains as a fallback)
   */

  if (win.visualViewport) {
    var visualViewport = win.visualViewport;
    height = Math.round(visualViewport.height);
    width = Math.round(visualViewport.width);
  } else {
    var docEl = win.document.documentElement;
    height = docEl.clientHeight;
    width = docEl.clientWidth;
  }

  dimensions.window = {
    fontScale: 1,
    height,
    scale: win.devicePixelRatio || 1,
    width
  };
  dimensions.screen = {
    fontScale: 1,
    height: win.screen.height,
    scale: win.devicePixelRatio || 1,
    width: win.screen.width
  };
}

function handleResize() {
  update();

  if (Array.isArray(listeners['change'])) {
    listeners['change'].forEach(handler => handler(dimensions));
  }
}

class Dimensions {
  static get(dimension) {
    if (shouldInit) {
      shouldInit = false;
      update();
    }

    (0, _invariant.default)(dimensions[dimension], "No dimension set for key " + dimension);
    return dimensions[dimension];
  }

  static set(initialDimensions) {
    if (initialDimensions) {
      if (_canUseDom.default) {
        (0, _invariant.default)(false, 'Dimensions cannot be set in the browser');
      } else {
        if (initialDimensions.screen != null) {
          dimensions.screen = initialDimensions.screen;
        }

        if (initialDimensions.window != null) {
          dimensions.window = initialDimensions.window;
        }
      }
    }
  }

  static addEventListener(type, handler) {
    listeners[type] = listeners[type] || [];
    listeners[type].push(handler);
    return {
      remove: () => {
        this.removeEventListener(type, handler);
      }
    };
  }

  static removeEventListener(type, handler) {
    if (Array.isArray(listeners[type])) {
      listeners[type] = listeners[type].filter(_handler => _handler !== handler);
    }
  }

}

exports["default"] = Dimensions;

if (_canUseDom.default) {
  if (window.visualViewport) {
    window.visualViewport.addEventListener('resize', handleResize, false);
  } else {
    window.addEventListener('resize', handleResize, false);
  }
}

module.exports = exports.default;

/***/ }),

/***/ 75487:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(64836)["default"]);

exports.__esModule = true;
exports["default"] = void 0;

var _UnimplementedView = _interopRequireDefault(__webpack_require__(85261));

var _default = _UnimplementedView.default;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),

/***/ 5717:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(64836)["default"]);

exports.__esModule = true;
exports["default"] = void 0;

var _Easing = _interopRequireDefault(__webpack_require__(49266));

/**
 * Copyright (c) Nicolas Gallagher.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
var _default = _Easing.default;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),

/***/ 70035:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(64836)["default"]);

exports.__esModule = true;
exports["default"] = void 0;

var _FlatList = _interopRequireDefault(__webpack_require__(63392));

/**
 * Copyright (c) Nicolas Gallagher.
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
var _default = _FlatList.default;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),

/***/ 4020:
/***/ ((module, exports) => {

"use strict";


exports.__esModule = true;
exports["default"] = void 0;

/**
 * Copyright (c) Nicolas Gallagher.
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
var I18nManager = {
  allowRTL() {
    return;
  },

  forceRTL() {
    return;
  },

  getConstants() {
    return {
      isRTL: false
    };
  }

};
var _default = I18nManager;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),

/***/ 75296:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(64836)["default"]);

var _interopRequireWildcard = (__webpack_require__(75263)["default"]);

exports.__esModule = true;
exports["default"] = void 0;

var _extends2 = _interopRequireDefault(__webpack_require__(10434));

var _objectWithoutPropertiesLoose2 = _interopRequireDefault(__webpack_require__(7071));

var React = _interopRequireWildcard(__webpack_require__(16689));

var _Image = _interopRequireDefault(__webpack_require__(94965));

var _StyleSheet = _interopRequireDefault(__webpack_require__(84099));

var _View = _interopRequireDefault(__webpack_require__(79057));

var _excluded = ["children", "style", "imageStyle", "imageRef"];
var emptyObject = {};
/**
 * Very simple drop-in replacement for <Image> which supports nesting views.
 */

var ImageBackground = /*#__PURE__*/(0, React.forwardRef)((props, forwardedRef) => {
  var children = props.children,
      _props$style = props.style,
      style = _props$style === void 0 ? emptyObject : _props$style,
      imageStyle = props.imageStyle,
      imageRef = props.imageRef,
      rest = (0, _objectWithoutPropertiesLoose2.default)(props, _excluded);

  var _StyleSheet$flatten = _StyleSheet.default.flatten(style),
      height = _StyleSheet$flatten.height,
      width = _StyleSheet$flatten.width;

  return /*#__PURE__*/React.createElement(_View.default, {
    ref: forwardedRef,
    style: style
  }, /*#__PURE__*/React.createElement(_Image.default, (0, _extends2.default)({}, rest, {
    ref: imageRef,
    style: [{
      // Temporary Workaround:
      // Current (imperfect yet) implementation of <Image> overwrites width and height styles
      // (which is not quite correct), and these styles conflict with explicitly set styles
      // of <ImageBackground> and with our internal layout model here.
      // So, we have to proxy/reapply these styles explicitly for actual <Image> component.
      // This workaround should be removed after implementing proper support of
      // intrinsic content size of the <Image>.
      width,
      height,
      zIndex: -1
    }, _StyleSheet.default.absoluteFill, imageStyle]
  })), children);
});
ImageBackground.displayName = 'ImageBackground';
var _default = ImageBackground;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),

/***/ 94965:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(64836)["default"]);

var _interopRequireWildcard = (__webpack_require__(75263)["default"]);

exports.__esModule = true;
exports["default"] = void 0;

var _objectSpread2 = _interopRequireDefault(__webpack_require__(42122));

var _extends2 = _interopRequireDefault(__webpack_require__(10434));

var _objectWithoutPropertiesLoose2 = _interopRequireDefault(__webpack_require__(7071));

var React = _interopRequireWildcard(__webpack_require__(16689));

var _createElement = _interopRequireDefault(__webpack_require__(63820));

var _AssetRegistry = __webpack_require__(39025);

var _preprocess = __webpack_require__(27874);

var _ImageLoader = _interopRequireDefault(__webpack_require__(39096));

var _PixelRatio = _interopRequireDefault(__webpack_require__(5238));

var _StyleSheet = _interopRequireDefault(__webpack_require__(84099));

var _TextAncestorContext = _interopRequireDefault(__webpack_require__(47905));

var _View = _interopRequireDefault(__webpack_require__(79057));

var _excluded = ["accessibilityLabel", "blurRadius", "defaultSource", "draggable", "onError", "onLayout", "onLoad", "onLoadEnd", "onLoadStart", "pointerEvents", "source", "style"];
var ERRORED = 'ERRORED';
var LOADED = 'LOADED';
var LOADING = 'LOADING';
var IDLE = 'IDLE';
var _filterId = 0;
var svgDataUriPattern = /^(data:image\/svg\+xml;utf8,)(.*)/;

function createTintColorSVG(tintColor, id) {
  return tintColor && id != null ? /*#__PURE__*/React.createElement("svg", {
    style: {
      position: 'absolute',
      height: 0,
      visibility: 'hidden',
      width: 0
    }
  }, /*#__PURE__*/React.createElement("defs", null, /*#__PURE__*/React.createElement("filter", {
    id: "tint-" + id,
    suppressHydrationWarning: true
  }, /*#__PURE__*/React.createElement("feFlood", {
    floodColor: "" + tintColor,
    key: tintColor
  }), /*#__PURE__*/React.createElement("feComposite", {
    in2: "SourceAlpha",
    operator: "atop"
  })))) : null;
}

function getFlatStyle(style, blurRadius, filterId) {
  var flatStyle = _StyleSheet.default.flatten(style);

  var filter = flatStyle.filter,
      resizeMode = flatStyle.resizeMode,
      shadowOffset = flatStyle.shadowOffset,
      tintColor = flatStyle.tintColor; // Add CSS filters
  // React Native exposes these features as props and proprietary styles

  var filters = [];
  var _filter = null;

  if (filter) {
    filters.push(filter);
  }

  if (blurRadius) {
    filters.push("blur(" + blurRadius + "px)");
  }

  if (shadowOffset) {
    var shadowString = (0, _preprocess.createBoxShadowValue)(flatStyle);

    if (shadowString) {
      filters.push("drop-shadow(" + shadowString + ")");
    }
  }

  if (tintColor && filterId != null) {
    filters.push("url(#tint-" + filterId + ")");
  }

  if (filters.length > 0) {
    _filter = filters.join(' ');
  } // These styles are converted to CSS filters applied to the
  // element displaying the background image.


  delete flatStyle.blurRadius;
  delete flatStyle.shadowColor;
  delete flatStyle.shadowOpacity;
  delete flatStyle.shadowOffset;
  delete flatStyle.shadowRadius;
  delete flatStyle.tintColor; // These styles are not supported on View

  delete flatStyle.overlayColor;
  delete flatStyle.resizeMode;
  return [flatStyle, resizeMode, _filter, tintColor];
}

function resolveAssetDimensions(source) {
  if (typeof source === 'number') {
    var _getAssetByID = (0, _AssetRegistry.getAssetByID)(source),
        _height = _getAssetByID.height,
        _width = _getAssetByID.width;

    return {
      height: _height,
      width: _width
    };
  } else if (source != null && !Array.isArray(source) && typeof source === 'object') {
    var _height2 = source.height,
        _width2 = source.width;
    return {
      height: _height2,
      width: _width2
    };
  }
}

function resolveAssetUri(source) {
  var uri = null;

  if (typeof source === 'number') {
    // get the URI from the packager
    var asset = (0, _AssetRegistry.getAssetByID)(source);

    if (asset == null) {
      throw new Error("Image: asset with ID \"" + source + "\" could not be found. Please check the image source or packager.");
    }

    var scale = asset.scales[0];

    if (asset.scales.length > 1) {
      var preferredScale = _PixelRatio.default.get(); // Get the scale which is closest to the preferred scale


      scale = asset.scales.reduce((prev, curr) => Math.abs(curr - preferredScale) < Math.abs(prev - preferredScale) ? curr : prev);
    }

    var scaleSuffix = scale !== 1 ? "@" + scale + "x" : '';
    uri = asset ? asset.httpServerLocation + "/" + asset.name + scaleSuffix + "." + asset.type : '';
  } else if (typeof source === 'string') {
    uri = source;
  } else if (source && typeof source.uri === 'string') {
    uri = source.uri;
  }

  if (uri) {
    var match = uri.match(svgDataUriPattern); // inline SVG markup may contain characters (e.g., #, ") that need to be escaped

    if (match) {
      var prefix = match[1],
          svg = match[2];
      var encodedSvg = encodeURIComponent(svg);
      return "" + prefix + encodedSvg;
    }
  }

  return uri;
}

var Image = /*#__PURE__*/React.forwardRef((props, ref) => {
  var accessibilityLabel = props.accessibilityLabel,
      blurRadius = props.blurRadius,
      defaultSource = props.defaultSource,
      draggable = props.draggable,
      onError = props.onError,
      onLayout = props.onLayout,
      onLoad = props.onLoad,
      onLoadEnd = props.onLoadEnd,
      onLoadStart = props.onLoadStart,
      pointerEvents = props.pointerEvents,
      source = props.source,
      style = props.style,
      rest = (0, _objectWithoutPropertiesLoose2.default)(props, _excluded);

  if (false) {}

  var _React$useState = React.useState(() => {
    var uri = resolveAssetUri(source);

    if (uri != null) {
      var isLoaded = _ImageLoader.default.has(uri);

      if (isLoaded) {
        return LOADED;
      }
    }

    return IDLE;
  }),
      state = _React$useState[0],
      updateState = _React$useState[1];

  var _React$useState2 = React.useState({}),
      layout = _React$useState2[0],
      updateLayout = _React$useState2[1];

  var hasTextAncestor = React.useContext(_TextAncestorContext.default);
  var hiddenImageRef = React.useRef(null);
  var filterRef = React.useRef(_filterId++);
  var requestRef = React.useRef(null);
  var shouldDisplaySource = state === LOADED || state === LOADING && defaultSource == null;

  var _getFlatStyle = getFlatStyle(style, blurRadius, filterRef.current),
      flatStyle = _getFlatStyle[0],
      _resizeMode = _getFlatStyle[1],
      filter = _getFlatStyle[2],
      tintColor = _getFlatStyle[3];

  var resizeMode = props.resizeMode || _resizeMode || 'cover';
  var selectedSource = shouldDisplaySource ? source : defaultSource;
  var displayImageUri = resolveAssetUri(selectedSource);
  var imageSizeStyle = resolveAssetDimensions(selectedSource);
  var backgroundImage = displayImageUri ? "url(\"" + displayImageUri + "\")" : null;
  var backgroundSize = getBackgroundSize(); // Accessibility image allows users to trigger the browser's image context menu

  var hiddenImage = displayImageUri ? (0, _createElement.default)('img', {
    alt: accessibilityLabel || '',
    style: styles.accessibilityImage$raw,
    draggable: draggable || false,
    ref: hiddenImageRef,
    src: displayImageUri
  }) : null;

  function getBackgroundSize() {
    if (hiddenImageRef.current != null && (resizeMode === 'center' || resizeMode === 'repeat')) {
      var _hiddenImageRef$curre = hiddenImageRef.current,
          naturalHeight = _hiddenImageRef$curre.naturalHeight,
          naturalWidth = _hiddenImageRef$curre.naturalWidth;
      var _height3 = layout.height,
          _width3 = layout.width;

      if (naturalHeight && naturalWidth && _height3 && _width3) {
        var scaleFactor = Math.min(1, _width3 / naturalWidth, _height3 / naturalHeight);
        var x = Math.ceil(scaleFactor * naturalWidth);
        var y = Math.ceil(scaleFactor * naturalHeight);
        return x + "px " + y + "px";
      }
    }
  }

  function handleLayout(e) {
    if (resizeMode === 'center' || resizeMode === 'repeat' || onLayout) {
      var _layout = e.nativeEvent.layout;
      onLayout && onLayout(e);
      updateLayout(_layout);
    }
  } // Image loading


  var uri = resolveAssetUri(source);
  React.useEffect(() => {
    abortPendingRequest();

    if (uri != null) {
      updateState(LOADING);

      if (onLoadStart) {
        onLoadStart();
      }

      requestRef.current = _ImageLoader.default.load(uri, function load(e) {
        updateState(LOADED);

        if (onLoad) {
          onLoad(e);
        }

        if (onLoadEnd) {
          onLoadEnd();
        }
      }, function error() {
        updateState(ERRORED);

        if (onError) {
          onError({
            nativeEvent: {
              error: "Failed to load resource " + uri + " (404)"
            }
          });
        }

        if (onLoadEnd) {
          onLoadEnd();
        }
      });
    }

    function abortPendingRequest() {
      if (requestRef.current != null) {
        _ImageLoader.default.abort(requestRef.current);

        requestRef.current = null;
      }
    }

    return abortPendingRequest;
  }, [uri, requestRef, updateState, onError, onLoad, onLoadEnd, onLoadStart]);
  return /*#__PURE__*/React.createElement(_View.default, (0, _extends2.default)({}, rest, {
    accessibilityLabel: accessibilityLabel,
    onLayout: handleLayout,
    pointerEvents: pointerEvents,
    ref: ref,
    style: [styles.root, hasTextAncestor && styles.inline, imageSizeStyle, flatStyle]
  }), /*#__PURE__*/React.createElement(_View.default, {
    style: [styles.image, resizeModeStyles[resizeMode], {
      backgroundImage,
      filter
    }, backgroundSize != null && {
      backgroundSize
    }],
    suppressHydrationWarning: true
  }), hiddenImage, createTintColorSVG(tintColor, filterRef.current));
});
Image.displayName = 'Image'; // $FlowIgnore: This is the correct type, but casting makes it unhappy since the variables aren't defined yet

var ImageWithStatics = Image;

ImageWithStatics.getSize = function (uri, success, failure) {
  _ImageLoader.default.getSize(uri, success, failure);
};

ImageWithStatics.prefetch = function (uri) {
  return _ImageLoader.default.prefetch(uri);
};

ImageWithStatics.queryCache = function (uris) {
  return _ImageLoader.default.queryCache(uris);
};

var styles = _StyleSheet.default.create({
  root: {
    flexBasis: 'auto',
    overflow: 'hidden',
    zIndex: 0
  },
  inline: {
    display: 'inline-flex'
  },
  image: (0, _objectSpread2.default)((0, _objectSpread2.default)({}, _StyleSheet.default.absoluteFillObject), {}, {
    backgroundColor: 'transparent',
    backgroundPosition: 'center',
    backgroundRepeat: 'no-repeat',
    backgroundSize: 'cover',
    height: '100%',
    width: '100%',
    zIndex: -1
  }),
  accessibilityImage$raw: (0, _objectSpread2.default)((0, _objectSpread2.default)({}, _StyleSheet.default.absoluteFillObject), {}, {
    height: '100%',
    opacity: 0,
    width: '100%',
    zIndex: -1
  })
});

var resizeModeStyles = _StyleSheet.default.create({
  center: {
    backgroundSize: 'auto'
  },
  contain: {
    backgroundSize: 'contain'
  },
  cover: {
    backgroundSize: 'cover'
  },
  none: {
    backgroundPosition: '0',
    backgroundSize: 'auto'
  },
  repeat: {
    backgroundPosition: '0',
    backgroundRepeat: 'repeat',
    backgroundSize: 'auto'
  },
  stretch: {
    backgroundSize: '100% 100%'
  }
});

var _default = ImageWithStatics;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),

/***/ 8116:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(64836)["default"]);

exports.__esModule = true;
exports["default"] = void 0;

var _UnimplementedView = _interopRequireDefault(__webpack_require__(85261));

var _default = _UnimplementedView.default;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),

/***/ 91195:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireWildcard = (__webpack_require__(75263)["default"]);

var _interopRequireDefault = (__webpack_require__(64836)["default"]);

exports.__esModule = true;
exports["default"] = void 0;

var _invariant = _interopRequireDefault(__webpack_require__(44505));

var _requestIdleCallback = _interopRequireWildcard(__webpack_require__(74357));

/**
 * Copyright (c) Nicolas Gallagher.
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
var InteractionManager = {
  Events: {
    interactionStart: 'interactionStart',
    interactionComplete: 'interactionComplete'
  },

  /**
   * Schedule a function to run after all interactions have completed.
   */
  runAfterInteractions(task) {
    var handle;
    var promise = new Promise(resolve => {
      handle = (0, _requestIdleCallback.default)(() => {
        if (task) {
          resolve(task());
        } else {
          resolve();
        }
      });
    });
    return {
      then: promise.then.bind(promise),
      done: promise.then.bind(promise),
      cancel: () => {
        (0, _requestIdleCallback.cancelIdleCallback)(handle);
      }
    };
  },

  /**
   * Notify manager that an interaction has started.
   */
  createInteractionHandle() {
    return 1;
  },

  /**
   * Notify manager that an interaction has completed.
   */
  clearInteractionHandle(handle) {
    (0, _invariant.default)(!!handle, 'Must provide a handle to clear.');
  },

  addListener: () => {}
};
var _default = InteractionManager;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),

/***/ 15869:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(64836)["default"]);

var _interopRequireWildcard = (__webpack_require__(75263)["default"]);

exports.__esModule = true;
exports["default"] = void 0;

var _extends2 = _interopRequireDefault(__webpack_require__(10434));

var _objectWithoutPropertiesLoose2 = _interopRequireDefault(__webpack_require__(7071));

var React = _interopRequireWildcard(__webpack_require__(16689));

var _View = _interopRequireDefault(__webpack_require__(79057));

var _excluded = ["behavior", "contentContainerStyle", "keyboardVerticalOffset"];

class KeyboardAvoidingView extends React.Component {
  constructor() {
    super(...arguments);
    this.frame = null;

    this.onLayout = event => {
      this.frame = event.nativeEvent.layout;
    };
  }

  relativeKeyboardHeight(keyboardFrame) {
    var frame = this.frame;

    if (!frame || !keyboardFrame) {
      return 0;
    }

    var keyboardY = keyboardFrame.screenY - (this.props.keyboardVerticalOffset || 0);
    return Math.max(frame.y + frame.height - keyboardY, 0);
  }

  onKeyboardChange(event) {}

  render() {
    var _this$props = this.props,
        behavior = _this$props.behavior,
        contentContainerStyle = _this$props.contentContainerStyle,
        keyboardVerticalOffset = _this$props.keyboardVerticalOffset,
        rest = (0, _objectWithoutPropertiesLoose2.default)(_this$props, _excluded);
    return /*#__PURE__*/React.createElement(_View.default, (0, _extends2.default)({
      onLayout: this.onLayout
    }, rest));
  }

}

var _default = KeyboardAvoidingView;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),

/***/ 95031:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(64836)["default"]);

exports.__esModule = true;
exports["default"] = void 0;

var _dismissKeyboard = _interopRequireDefault(__webpack_require__(69835));

/**
 * Copyright (c) Nicolas Gallagher.
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
var Keyboard = {
  addListener() {
    return {
      remove: () => {}
    };
  },

  dismiss() {
    (0, _dismissKeyboard.default)();
  },

  removeAllListeners() {},

  removeListener() {}

};
var _default = Keyboard;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),

/***/ 91194:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(64836)["default"]);

exports.__esModule = true;
exports["default"] = void 0;

var _LayoutAnimation = _interopRequireDefault(__webpack_require__(82626));

/**
 * Copyright (c) Nicolas Gallagher.
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
var _default = _LayoutAnimation.default;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),

/***/ 98346:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(64836)["default"]);

exports.__esModule = true;
exports["default"] = void 0;

var _invariant = _interopRequireDefault(__webpack_require__(44505));

var _canUseDom = _interopRequireDefault(__webpack_require__(24019));

/**
 * Copyright (c) Nicolas Gallagher.
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
var initialURL = _canUseDom.default ? window.location.href : '';

class Linking {
  constructor() {
    this._eventCallbacks = {};

    this.addEventListener = (event, callback) => {
      if (!this._eventCallbacks[event]) {
        this._eventCallbacks[event] = [callback];
        return;
      }

      this._eventCallbacks[event].push(callback);
    };

    this.removeEventListener = (event, callback) => {
      var callbacks = this._eventCallbacks[event];
      var filteredCallbacks = callbacks.filter(c => c.toString() !== callback.toString());
      this._eventCallbacks[event] = filteredCallbacks;
    };
  }

  _dispatchEvent(event) {
    for (var _len = arguments.length, data = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      data[_key - 1] = arguments[_key];
    }

    var listeners = this._eventCallbacks[event];

    if (listeners != null && Array.isArray(listeners)) {
      listeners.map(listener => {
        listener(...data);
      });
    }
  }
  /**
   * Adds a event listener for the specified event. The callback will be called when the
   * said event is dispatched.
   */


  canOpenURL() {
    return Promise.resolve(true);
  }

  getInitialURL() {
    return Promise.resolve(initialURL);
  }
  /**
   * Try to open the given url in a secure fashion. The method returns a Promise object.
   * If a target is passed (including undefined) that target will be used, otherwise '_blank'.
   * If the url opens, the promise is resolved. If not, the promise is rejected.
   * Dispatches the `onOpen` event if `url` is opened successfully.
   */


  openURL(url, target) {
    if (arguments.length === 1) {
      target = '_blank';
    }

    try {
      open(url, target);

      this._dispatchEvent('onOpen', url);

      return Promise.resolve();
    } catch (e) {
      return Promise.reject(e);
    }
  }

  _validateURL(url) {
    (0, _invariant.default)(typeof url === 'string', 'Invalid URL: should be a string. Was: ' + url);
    (0, _invariant.default)(url, 'Invalid URL: cannot be empty');
  }

}

var open = (url, target) => {
  if (_canUseDom.default) {
    var urlToOpen = new URL(url, window.location).toString();

    if (urlToOpen.indexOf('tel:') === 0) {
      window.location = urlToOpen;
    } else {
      window.open(urlToOpen, target, 'noopener');
    }
  }
};

var _default = new Linking();

exports["default"] = _default;
module.exports = exports.default;

/***/ }),

/***/ 14111:
/***/ ((module, exports) => {

"use strict";


exports.__esModule = true;
exports["default"] = void 0;

/**
 * Copyright (c) 2016-present, Nicolas Gallagher.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
var LogBox = {
  ignoreLogs() {},

  ignoreAllLogs() {},

  uninstall() {},

  install() {}

};
var _default = LogBox;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),

/***/ 45509:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(64836)["default"]);

var _interopRequireWildcard = (__webpack_require__(75263)["default"]);

exports.__esModule = true;
exports["default"] = void 0;

var React = _interopRequireWildcard(__webpack_require__(16689));

var _StyleSheet = _interopRequireDefault(__webpack_require__(84099));

var _createElement = _interopRequireDefault(__webpack_require__(63820));

/**
 * Copyright (c) Nicolas Gallagher.
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
var ANIMATION_DURATION = 300;

function getAnimationStyle(animationType, visible) {
  if (animationType === 'slide') {
    return visible ? animatedSlideInStyles : animatedSlideOutStyles;
  }

  if (animationType === 'fade') {
    return visible ? animatedFadeInStyles : animatedFadeOutStyles;
  }

  return visible ? styles.container : styles.hidden;
}

function ModalAnimation(props) {
  var animationType = props.animationType,
      children = props.children,
      onDismiss = props.onDismiss,
      onShow = props.onShow,
      visible = props.visible;

  var _React$useState = React.useState(false),
      isRendering = _React$useState[0],
      setIsRendering = _React$useState[1];

  var wasVisible = React.useRef(false);
  var isAnimated = animationType && animationType !== 'none';
  var animationEndCallback = React.useCallback(e => {
    if (e && e.currentTarget !== e.target) {
      // If the event was generated for something NOT this element we
      // should ignore it as it's not relevant to us
      return;
    }

    if (visible) {
      if (onShow) {
        onShow();
      }
    } else {
      setIsRendering(false);

      if (onDismiss) {
        onDismiss();
      }
    }
  }, [onDismiss, onShow, visible]);
  React.useEffect(() => {
    if (visible) {
      setIsRendering(true);
    }

    if (visible !== wasVisible.current && !isAnimated) {
      // Manually call `animationEndCallback` if no animation is used
      animationEndCallback();
    }

    wasVisible.current = visible;
  }, [isAnimated, visible, animationEndCallback]);
  return isRendering || visible ? (0, _createElement.default)('div', {
    style: isRendering ? getAnimationStyle(animationType, visible) : styles.hidden,
    onAnimationEnd: animationEndCallback,
    children
  }) : null;
}

var styles = _StyleSheet.default.create({
  container: {
    position: 'fixed',
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    zIndex: 9999
  },
  animatedIn: {
    animationDuration: ANIMATION_DURATION + "ms",
    animationTimingFunction: 'ease-in'
  },
  animatedOut: {
    pointerEvents: 'none',
    animationDuration: ANIMATION_DURATION + "ms",
    animationTimingFunction: 'ease-out'
  },
  fadeIn: {
    opacity: 1,
    animationKeyframes: {
      '0%': {
        opacity: 0
      },
      '100%': {
        opacity: 1
      }
    }
  },
  fadeOut: {
    opacity: 0,
    animationKeyframes: {
      '0%': {
        opacity: 1
      },
      '100%': {
        opacity: 0
      }
    }
  },
  slideIn: {
    transform: [{
      translateY: '0%'
    }],
    animationKeyframes: {
      '0%': {
        transform: [{
          translateY: '100%'
        }]
      },
      '100%': {
        transform: [{
          translateY: '0%'
        }]
      }
    }
  },
  slideOut: {
    transform: [{
      translateY: '100%'
    }],
    animationKeyframes: {
      '0%': {
        transform: [{
          translateY: '0%'
        }]
      },
      '100%': {
        transform: [{
          translateY: '100%'
        }]
      }
    }
  },
  hidden: {
    opacity: 0
  }
});

var animatedSlideInStyles = [styles.container, styles.animatedIn, styles.slideIn];
var animatedSlideOutStyles = [styles.container, styles.animatedOut, styles.slideOut];
var animatedFadeInStyles = [styles.container, styles.animatedIn, styles.fadeIn];
var animatedFadeOutStyles = [styles.container, styles.animatedOut, styles.fadeOut];
var _default = ModalAnimation;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),

/***/ 94133:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(64836)["default"]);

var _interopRequireWildcard = (__webpack_require__(75263)["default"]);

exports.__esModule = true;
exports["default"] = void 0;

var _extends2 = _interopRequireDefault(__webpack_require__(10434));

var _objectWithoutPropertiesLoose2 = _interopRequireDefault(__webpack_require__(7071));

var React = _interopRequireWildcard(__webpack_require__(16689));

var _View = _interopRequireDefault(__webpack_require__(79057));

var _StyleSheet = _interopRequireDefault(__webpack_require__(84099));

var _canUseDom = _interopRequireDefault(__webpack_require__(24019));

var _excluded = ["active", "children", "onRequestClose", "transparent"];
var ModalContent = /*#__PURE__*/React.forwardRef((props, forwardedRef) => {
  var active = props.active,
      children = props.children,
      onRequestClose = props.onRequestClose,
      transparent = props.transparent,
      rest = (0, _objectWithoutPropertiesLoose2.default)(props, _excluded);
  React.useEffect(() => {
    if (_canUseDom.default) {
      var closeOnEscape = e => {
        if (active && e.key === 'Escape') {
          e.stopPropagation();

          if (onRequestClose) {
            onRequestClose();
          }
        }
      };

      document.addEventListener('keyup', closeOnEscape, false);
      return () => document.removeEventListener('keyup', closeOnEscape, false);
    }
  }, [active, onRequestClose]);
  var style = React.useMemo(() => {
    return [styles.modal, transparent ? styles.modalTransparent : styles.modalOpaque];
  }, [transparent]);
  return /*#__PURE__*/React.createElement(_View.default, (0, _extends2.default)({}, rest, {
    accessibilityModal: true,
    accessibilityRole: active ? 'dialog' : null,
    ref: forwardedRef,
    style: style
  }), /*#__PURE__*/React.createElement(_View.default, {
    style: styles.container
  }, children));
});

var styles = _StyleSheet.default.create({
  modal: {
    position: 'fixed',
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  },
  modalTransparent: {
    backgroundColor: 'transparent'
  },
  modalOpaque: {
    backgroundColor: 'white'
  },
  container: {
    top: 0,
    flex: 1
  }
});

var _default = ModalContent;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),

/***/ 68601:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(64836)["default"]);

var _interopRequireWildcard = (__webpack_require__(75263)["default"]);

exports.__esModule = true;
exports["default"] = void 0;

var React = _interopRequireWildcard(__webpack_require__(16689));

var _View = _interopRequireDefault(__webpack_require__(79057));

var _createElement = _interopRequireDefault(__webpack_require__(63820));

var _StyleSheet = _interopRequireDefault(__webpack_require__(84099));

var _UIManager = _interopRequireDefault(__webpack_require__(56629));

var _canUseDom = _interopRequireDefault(__webpack_require__(24019));

/**
 * Copyright (c) Nicolas Gallagher.
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

/**
 * This Component is used to "wrap" the modal we're opening
 * so that changing focus via tab will never leave the document.
 *
 * This allows us to properly trap the focus within a modal
 * even if the modal is at the start or end of a document.
 */
var FocusBracket = () => {
  return (0, _createElement.default)('div', {
    accessibilityRole: 'none',
    tabIndex: 0,
    style: styles.focusBracket
  });
};

function attemptFocus(element) {
  if (!_canUseDom.default) {
    return false;
  }

  try {
    element.focus();
  } catch (e) {// Do nothing
  }

  return document.activeElement === element;
}

function focusFirstDescendant(element) {
  for (var i = 0; i < element.childNodes.length; i++) {
    var child = element.childNodes[i];

    if (attemptFocus(child) || focusFirstDescendant(child)) {
      return true;
    }
  }

  return false;
}

function focusLastDescendant(element) {
  for (var i = element.childNodes.length - 1; i >= 0; i--) {
    var child = element.childNodes[i];

    if (attemptFocus(child) || focusLastDescendant(child)) {
      return true;
    }
  }

  return false;
}

var ModalFocusTrap = _ref => {
  var active = _ref.active,
      children = _ref.children;
  var trapElementRef = React.useRef();
  var focusRef = React.useRef({
    trapFocusInProgress: false,
    lastFocusedElement: null
  });
  React.useEffect(() => {
    if (_canUseDom.default) {
      var trapFocus = () => {
        // We should not trap focus if:
        // - The modal hasn't fully initialized with an HTMLElement ref
        // - Focus is already in the process of being trapped (e.g., we're refocusing)
        // - isTrapActive prop being falsey tells us to do nothing
        if (trapElementRef.current == null || focusRef.current.trapFocusInProgress || !active) {
          return;
        }

        try {
          focusRef.current.trapFocusInProgress = true;

          if (document.activeElement instanceof Node && !trapElementRef.current.contains(document.activeElement)) {
            // To handle keyboard focusing we can make an assumption here.
            // If you're tabbing through the focusable elements, the previously
            // active element will either be the first or the last.
            // If the previously selected element is the "first" descendant
            // and we're leaving it - this means that we should be looping
            // around to the other side of the modal.
            var hasFocused = focusFirstDescendant(trapElementRef.current);

            if (focusRef.current.lastFocusedElement === document.activeElement) {
              hasFocused = focusLastDescendant(trapElementRef.current);
            } // If we couldn't focus a new element then we need to focus onto the trap target


            if (!hasFocused && trapElementRef.current != null && document.activeElement) {
              _UIManager.default.focus(trapElementRef.current);
            }
          }
        } finally {
          focusRef.current.trapFocusInProgress = false;
        }

        focusRef.current.lastFocusedElement = document.activeElement;
      }; // Call the trapFocus callback at least once when this modal has been activated.


      trapFocus();
      document.addEventListener('focus', trapFocus, true);
      return () => document.removeEventListener('focus', trapFocus, true);
    }
  }, [active]); // To be fully compliant with WCAG we need to refocus element that triggered opening modal
  // after closing it

  React.useEffect(function () {
    if (_canUseDom.default) {
      var lastFocusedElementOutsideTrap = document.activeElement;
      return function () {
        if (lastFocusedElementOutsideTrap && document.contains(lastFocusedElementOutsideTrap)) {
          _UIManager.default.focus(lastFocusedElementOutsideTrap);
        }
      };
    }
  }, []);
  return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(FocusBracket, null), /*#__PURE__*/React.createElement(_View.default, {
    ref: trapElementRef
  }, children), /*#__PURE__*/React.createElement(FocusBracket, null));
};

var _default = ModalFocusTrap;
exports["default"] = _default;

var styles = _StyleSheet.default.create({
  focusBracket: {
    outlineStyle: 'none'
  }
});

module.exports = exports.default;

/***/ }),

/***/ 19061:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(64836)["default"]);

var _interopRequireWildcard = (__webpack_require__(75263)["default"]);

exports.__esModule = true;
exports["default"] = void 0;

var React = _interopRequireWildcard(__webpack_require__(16689));

var _reactDom = _interopRequireDefault(__webpack_require__(66405));

var _canUseDom = _interopRequireDefault(__webpack_require__(24019));

/**
 * Copyright (c) Nicolas Gallagher.
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
function ModalPortal(props) {
  var children = props.children;
  var elementRef = React.useRef(null);

  if (_canUseDom.default && !elementRef.current) {
    var element = document.createElement('div');

    if (element && document.body) {
      document.body.appendChild(element);
      elementRef.current = element;
    }
  }

  React.useEffect(() => {
    if (_canUseDom.default) {
      return () => {
        if (document.body && elementRef.current) {
          document.body.removeChild(elementRef.current);
          elementRef.current = null;
        }
      };
    }
  }, []);
  return elementRef.current && _canUseDom.default ? /*#__PURE__*/_reactDom.default.createPortal(children, elementRef.current) : null;
}

var _default = ModalPortal;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),

/***/ 17666:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(64836)["default"]);

var _interopRequireWildcard = (__webpack_require__(75263)["default"]);

exports.__esModule = true;
exports["default"] = void 0;

var _extends2 = _interopRequireDefault(__webpack_require__(10434));

var _objectWithoutPropertiesLoose2 = _interopRequireDefault(__webpack_require__(7071));

var React = _interopRequireWildcard(__webpack_require__(16689));

var _ModalPortal = _interopRequireDefault(__webpack_require__(19061));

var _ModalAnimation = _interopRequireDefault(__webpack_require__(45509));

var _ModalContent = _interopRequireDefault(__webpack_require__(94133));

var _ModalFocusTrap = _interopRequireDefault(__webpack_require__(68601));

var _excluded = ["animationType", "children", "onDismiss", "onRequestClose", "onShow", "transparent", "visible"];
var uniqueModalIdentifier = 0;
var activeModalStack = [];
var activeModalListeners = {};

function notifyActiveModalListeners() {
  if (activeModalStack.length === 0) {
    return;
  }

  var activeModalId = activeModalStack[activeModalStack.length - 1];
  activeModalStack.forEach(modalId => {
    if (modalId in activeModalListeners) {
      activeModalListeners[modalId](modalId === activeModalId);
    }
  });
}

function removeActiveModal(modalId) {
  if (modalId in activeModalListeners) {
    // Before removing this listener we should probably tell it
    // that it's no longer the active modal for sure.
    activeModalListeners[modalId](false);
    delete activeModalListeners[modalId];
  }

  var index = activeModalStack.indexOf(modalId);

  if (index !== -1) {
    activeModalStack.splice(index, 1);
    notifyActiveModalListeners();
  }
}

function addActiveModal(modalId, listener) {
  removeActiveModal(modalId);
  activeModalStack.push(modalId);
  activeModalListeners[modalId] = listener;
  notifyActiveModalListeners();
}

var Modal = /*#__PURE__*/React.forwardRef((props, forwardedRef) => {
  var animationType = props.animationType,
      children = props.children,
      onDismiss = props.onDismiss,
      onRequestClose = props.onRequestClose,
      onShow = props.onShow,
      transparent = props.transparent,
      _props$visible = props.visible,
      visible = _props$visible === void 0 ? true : _props$visible,
      rest = (0, _objectWithoutPropertiesLoose2.default)(props, _excluded); // Set a unique model identifier so we can correctly route
  // dismissals and check the layering of modals.

  var modalId = React.useMemo(() => uniqueModalIdentifier++, []);

  var _React$useState = React.useState(false),
      isActive = _React$useState[0],
      setIsActive = _React$useState[1];

  var onDismissCallback = React.useCallback(() => {
    removeActiveModal(modalId);

    if (onDismiss) {
      onDismiss();
    }
  }, [modalId, onDismiss]);
  var onShowCallback = React.useCallback(() => {
    addActiveModal(modalId, setIsActive);

    if (onShow) {
      onShow();
    }
  }, [modalId, onShow]);
  React.useEffect(() => {
    return () => removeActiveModal(modalId);
  }, [modalId]);
  return /*#__PURE__*/React.createElement(_ModalPortal.default, null, /*#__PURE__*/React.createElement(_ModalAnimation.default, {
    animationType: animationType,
    onDismiss: onDismissCallback,
    onShow: onShowCallback,
    visible: visible
  }, /*#__PURE__*/React.createElement(_ModalFocusTrap.default, {
    active: isActive
  }, /*#__PURE__*/React.createElement(_ModalContent.default, (0, _extends2.default)({}, rest, {
    active: isActive,
    onRequestClose: onRequestClose,
    ref: forwardedRef,
    transparent: transparent
  }), children))));
});
var _default = Modal;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),

/***/ 98278:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(64836)["default"]);

exports.__esModule = true;
exports["default"] = void 0;

var _NativeEventEmitter = _interopRequireDefault(__webpack_require__(83394));

/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
var _default = _NativeEventEmitter.default;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),

/***/ 97389:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(64836)["default"]);

exports.__esModule = true;
exports["default"] = void 0;

var _UIManager = _interopRequireDefault(__webpack_require__(56629));

/**
 * Copyright (c) Nicolas Gallagher.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
// NativeModules shim
var NativeModules = {
  UIManager: _UIManager.default
};
var _default = NativeModules;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),

/***/ 44090:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(64836)["default"]);

exports.__esModule = true;
exports["default"] = void 0;

var _PanResponder = _interopRequireDefault(__webpack_require__(77145));

var _default = _PanResponder.default;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),

/***/ 33532:
/***/ ((module, exports) => {

"use strict";


exports.__esModule = true;
exports["default"] = void 0;

var promiseMock = () => Promise.resolve(false);

var _default = {
  PERMISSIONS: {},
  RESULTS: {},
  checkPermission: promiseMock,
  check: promiseMock,
  requestPermission: promiseMock,
  request: promiseMock,
  requestMultiple: promiseMock
};
exports["default"] = _default;
module.exports = exports.default;

/***/ }),

/***/ 93239:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(64836)["default"]);

exports.__esModule = true;
exports["default"] = PickerItem;

var _createElement = _interopRequireDefault(__webpack_require__(63820));

/**
 * Copyright (c) Nicolas Gallagher.
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
function PickerItem(props) {
  var color = props.color,
      label = props.label,
      testID = props.testID,
      value = props.value;
  var style = {
    color
  };
  return (0, _createElement.default)('option', {
    children: label,
    style,
    testID,
    value
  });
}

module.exports = exports.default;

/***/ }),

/***/ 88053:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(64836)["default"]);

var _interopRequireWildcard = (__webpack_require__(75263)["default"]);

exports.__esModule = true;
exports["default"] = void 0;

var _objectSpread2 = _interopRequireDefault(__webpack_require__(42122));

var _objectWithoutPropertiesLoose2 = _interopRequireDefault(__webpack_require__(7071));

var React = _interopRequireWildcard(__webpack_require__(16689));

var _createElement = _interopRequireDefault(__webpack_require__(63820));

var _useMergeRefs = _interopRequireDefault(__webpack_require__(88391));

var _usePlatformMethods = _interopRequireDefault(__webpack_require__(92187));

var _PickerItem = _interopRequireDefault(__webpack_require__(93239));

var _StyleSheet = _interopRequireDefault(__webpack_require__(84099));

var _excluded = ["children", "enabled", "onValueChange", "selectedValue", "style", "testID", "itemStyle", "mode", "prompt"];
var Picker = /*#__PURE__*/React.forwardRef((props, forwardedRef) => {
  var children = props.children,
      enabled = props.enabled,
      onValueChange = props.onValueChange,
      selectedValue = props.selectedValue,
      style = props.style,
      testID = props.testID,
      itemStyle = props.itemStyle,
      mode = props.mode,
      prompt = props.prompt,
      other = (0, _objectWithoutPropertiesLoose2.default)(props, _excluded);
  var hostRef = React.useRef(null);

  function handleChange(e) {
    var _e$target = e.target,
        selectedIndex = _e$target.selectedIndex,
        value = _e$target.value;

    if (onValueChange) {
      onValueChange(value, selectedIndex);
    }
  } // $FlowFixMe


  var supportedProps = (0, _objectSpread2.default)({
    children,
    disabled: enabled === false ? true : undefined,
    onChange: handleChange,
    style: [styles.initial, style],
    testID,
    value: selectedValue
  }, other);
  var platformMethodsRef = (0, _usePlatformMethods.default)(supportedProps);
  var setRef = (0, _useMergeRefs.default)(hostRef, platformMethodsRef, forwardedRef);
  supportedProps.ref = setRef;
  return (0, _createElement.default)('select', supportedProps);
}); // $FlowFixMe

Picker.Item = _PickerItem.default;

var styles = _StyleSheet.default.create({
  initial: {
    fontFamily: 'System',
    fontSize: 'inherit',
    margin: 0
  }
});

var _default = Picker;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),

/***/ 5238:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(64836)["default"]);

exports.__esModule = true;
exports["default"] = void 0;

var _Dimensions = _interopRequireDefault(__webpack_require__(13256));

/**
 * Copyright (c) Nicolas Gallagher.
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

/**
 * PixelRatio gives access to the device pixel density.
 */
class PixelRatio {
  /**
   * Returns the device pixel density.
   */
  static get() {
    return _Dimensions.default.get('window').scale;
  }
  /**
   * No equivalent for Web
   */


  static getFontScale() {
    return _Dimensions.default.get('window').fontScale || PixelRatio.get();
  }
  /**
   * Converts a layout size (dp) to pixel size (px).
   * Guaranteed to return an integer number.
   */


  static getPixelSizeForLayoutSize(layoutSize) {
    return Math.round(layoutSize * PixelRatio.get());
  }
  /**
   * Rounds a layout size (dp) to the nearest layout size that corresponds to
   * an integer number of pixels. For example, on a device with a PixelRatio
   * of 3, `PixelRatio.roundToNearestPixel(8.4) = 8.33`, which corresponds to
   * exactly (8.33 * 3) = 25 pixels.
   */


  static roundToNearestPixel(layoutSize) {
    var ratio = PixelRatio.get();
    return Math.round(layoutSize * ratio) / ratio;
  }

}

exports["default"] = PixelRatio;
module.exports = exports.default;

/***/ }),

/***/ 98842:
/***/ ((module, exports) => {

"use strict";


exports.__esModule = true;
exports["default"] = void 0;

/**
 * Copyright (c) Nicolas Gallagher.
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
var Platform = {
  OS: 'web',
  select: obj => 'web' in obj ? obj.web : obj.default,

  get isTesting() {
    if (false) {}

    return false;
  }

};
var _default = Platform;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),

/***/ 60696:
/***/ ((module, exports, __webpack_require__) => {

"use strict";
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */


var _interopRequireDefault = (__webpack_require__(64836)["default"]);

var _interopRequireWildcard = (__webpack_require__(75263)["default"]);

exports.__esModule = true;
exports["default"] = void 0;

var _extends2 = _interopRequireDefault(__webpack_require__(10434));

var _objectWithoutPropertiesLoose2 = _interopRequireDefault(__webpack_require__(7071));

var React = _interopRequireWildcard(__webpack_require__(16689));

var _useMergeRefs = _interopRequireDefault(__webpack_require__(88391));

var _useHover = _interopRequireDefault(__webpack_require__(63711));

var _usePressEvents = _interopRequireDefault(__webpack_require__(24982));

var _StyleSheet = _interopRequireDefault(__webpack_require__(84099));

var _View = _interopRequireDefault(__webpack_require__(79057));

var _excluded = ["children", "delayLongPress", "delayPressIn", "delayPressOut", "disabled", "focusable", "onBlur", "onContextMenu", "onFocus", "onHoverIn", "onHoverOut", "onKeyDown", "onLongPress", "onPress", "onPressMove", "onPressIn", "onPressOut", "style", "testOnly_hovered", "testOnly_pressed"];

/**
 * Component used to build display components that should respond to whether the
 * component is currently pressed or not.
 */
function Pressable(props, forwardedRef) {
  var children = props.children,
      delayLongPress = props.delayLongPress,
      delayPressIn = props.delayPressIn,
      delayPressOut = props.delayPressOut,
      disabled = props.disabled,
      focusable = props.focusable,
      onBlur = props.onBlur,
      onContextMenu = props.onContextMenu,
      onFocus = props.onFocus,
      onHoverIn = props.onHoverIn,
      onHoverOut = props.onHoverOut,
      onKeyDown = props.onKeyDown,
      onLongPress = props.onLongPress,
      onPress = props.onPress,
      onPressMove = props.onPressMove,
      onPressIn = props.onPressIn,
      onPressOut = props.onPressOut,
      style = props.style,
      testOnly_hovered = props.testOnly_hovered,
      testOnly_pressed = props.testOnly_pressed,
      rest = (0, _objectWithoutPropertiesLoose2.default)(props, _excluded);

  var _useForceableState = useForceableState(testOnly_hovered === true),
      hovered = _useForceableState[0],
      setHovered = _useForceableState[1];

  var _useForceableState2 = useForceableState(false),
      focused = _useForceableState2[0],
      setFocused = _useForceableState2[1];

  var _useForceableState3 = useForceableState(testOnly_pressed === true),
      pressed = _useForceableState3[0],
      setPressed = _useForceableState3[1];

  var hostRef = (0, React.useRef)(null);
  var setRef = (0, _useMergeRefs.default)(forwardedRef, hostRef);
  var pressConfig = (0, React.useMemo)(() => ({
    delayLongPress,
    delayPressStart: delayPressIn,
    delayPressEnd: delayPressOut,
    disabled,
    onLongPress,
    onPress,
    onPressChange: setPressed,
    onPressStart: onPressIn,
    onPressMove,
    onPressEnd: onPressOut
  }), [delayLongPress, delayPressIn, delayPressOut, disabled, onLongPress, onPress, onPressIn, onPressMove, onPressOut, setPressed]);
  var pressEventHandlers = (0, _usePressEvents.default)(hostRef, pressConfig);
  var onContextMenuPress = pressEventHandlers.onContextMenu,
      onKeyDownPress = pressEventHandlers.onKeyDown;
  (0, _useHover.default)(hostRef, {
    contain: true,
    disabled,
    onHoverChange: setHovered,
    onHoverStart: onHoverIn,
    onHoverEnd: onHoverOut
  });
  var interactionState = {
    hovered,
    focused,
    pressed
  };
  var blurHandler = React.useCallback(e => {
    if (e.nativeEvent.target === hostRef.current) {
      setFocused(false);

      if (onBlur != null) {
        onBlur(e);
      }
    }
  }, [hostRef, setFocused, onBlur]);
  var focusHandler = React.useCallback(e => {
    if (e.nativeEvent.target === hostRef.current) {
      setFocused(true);

      if (onFocus != null) {
        onFocus(e);
      }
    }
  }, [hostRef, setFocused, onFocus]);
  var contextMenuHandler = React.useCallback(e => {
    if (onContextMenuPress != null) {
      onContextMenuPress(e);
    }

    if (onContextMenu != null) {
      onContextMenu(e);
    }
  }, [onContextMenu, onContextMenuPress]);
  var keyDownHandler = React.useCallback(e => {
    if (onKeyDownPress != null) {
      onKeyDownPress(e);
    }

    if (onKeyDown != null) {
      onKeyDown(e);
    }
  }, [onKeyDown, onKeyDownPress]);
  return /*#__PURE__*/React.createElement(_View.default, (0, _extends2.default)({}, rest, pressEventHandlers, {
    accessibilityDisabled: disabled,
    focusable: !disabled && focusable !== false,
    onBlur: blurHandler,
    onContextMenu: contextMenuHandler,
    onFocus: focusHandler,
    onKeyDown: keyDownHandler,
    pointerEvents: disabled ? 'none' : rest.pointerEvents,
    ref: setRef,
    style: [!disabled && styles.root, typeof style === 'function' ? style(interactionState) : style]
  }), typeof children === 'function' ? children(interactionState) : children);
}

function useForceableState(forced) {
  var _useState = (0, React.useState)(false),
      bool = _useState[0],
      setBool = _useState[1];

  return [bool || forced, setBool];
}

var styles = _StyleSheet.default.create({
  root: {
    cursor: 'pointer',
    touchAction: 'manipulation'
  }
});

var MemoedPressable = /*#__PURE__*/(0, React.memo)( /*#__PURE__*/(0, React.forwardRef)(Pressable));
MemoedPressable.displayName = 'Pressable';
var _default = MemoedPressable;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),

/***/ 33157:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(64836)["default"]);

var _interopRequireWildcard = (__webpack_require__(75263)["default"]);

exports.__esModule = true;
exports["default"] = void 0;

var _extends2 = _interopRequireDefault(__webpack_require__(10434));

var _objectWithoutPropertiesLoose2 = _interopRequireDefault(__webpack_require__(7071));

var React = _interopRequireWildcard(__webpack_require__(16689));

var _StyleSheet = _interopRequireDefault(__webpack_require__(84099));

var _View = _interopRequireDefault(__webpack_require__(79057));

var _excluded = ["color", "indeterminate", "progress", "trackColor", "style"];
var ProgressBar = /*#__PURE__*/React.forwardRef((props, ref) => {
  var _props$color = props.color,
      color = _props$color === void 0 ? '#1976D2' : _props$color,
      _props$indeterminate = props.indeterminate,
      indeterminate = _props$indeterminate === void 0 ? false : _props$indeterminate,
      _props$progress = props.progress,
      progress = _props$progress === void 0 ? 0 : _props$progress,
      _props$trackColor = props.trackColor,
      trackColor = _props$trackColor === void 0 ? 'transparent' : _props$trackColor,
      style = props.style,
      other = (0, _objectWithoutPropertiesLoose2.default)(props, _excluded);
  var percentageProgress = progress * 100;
  var width = indeterminate ? '25%' : percentageProgress + "%";
  return /*#__PURE__*/React.createElement(_View.default, (0, _extends2.default)({}, other, {
    accessibilityRole: "progressbar",
    accessibilityValueMax: 100,
    accessibilityValueMin: 0,
    accessibilityValueNow: indeterminate ? null : percentageProgress,
    ref: ref,
    style: [styles.track, style, {
      backgroundColor: trackColor
    }]
  }), /*#__PURE__*/React.createElement(_View.default, {
    style: [{
      backgroundColor: color,
      width
    }, styles.progress, indeterminate && styles.animation]
  }));
});
ProgressBar.displayName = 'ProgressBar';

var styles = _StyleSheet.default.create({
  track: {
    forcedColorAdjust: 'none',
    height: 5,
    overflow: 'hidden',
    userSelect: 'none',
    zIndex: 0
  },
  progress: {
    forcedColorAdjust: 'none',
    height: '100%',
    zIndex: -1
  },
  animation: {
    animationDuration: '1s',
    animationKeyframes: [{
      '0%': {
        transform: [{
          translateX: '-100%'
        }]
      },
      '100%': {
        transform: [{
          translateX: '400%'
        }]
      }
    }],
    animationTimingFunction: 'linear',
    animationIterationCount: 'infinite'
  }
});

var _default = ProgressBar;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),

/***/ 77818:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(64836)["default"]);

exports.__esModule = true;
exports["default"] = void 0;

var _objectWithoutPropertiesLoose2 = _interopRequireDefault(__webpack_require__(7071));

var _View = _interopRequireDefault(__webpack_require__(79057));

var _react = _interopRequireDefault(__webpack_require__(16689));

var _excluded = ["colors", "enabled", "onRefresh", "progressBackgroundColor", "progressViewOffset", "refreshing", "size", "tintColor", "title", "titleColor"];

function RefreshControl(props) {
  var colors = props.colors,
      enabled = props.enabled,
      onRefresh = props.onRefresh,
      progressBackgroundColor = props.progressBackgroundColor,
      progressViewOffset = props.progressViewOffset,
      refreshing = props.refreshing,
      size = props.size,
      tintColor = props.tintColor,
      title = props.title,
      titleColor = props.titleColor,
      rest = (0, _objectWithoutPropertiesLoose2.default)(props, _excluded);
  return /*#__PURE__*/_react.default.createElement(_View.default, rest);
}

var _default = RefreshControl;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),

/***/ 79517:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(64836)["default"]);

var _interopRequireWildcard = (__webpack_require__(75263)["default"]);

exports.__esModule = true;
exports["default"] = void 0;

var _extends2 = _interopRequireDefault(__webpack_require__(10434));

var _objectWithoutPropertiesLoose2 = _interopRequireDefault(__webpack_require__(7071));

var React = _interopRequireWildcard(__webpack_require__(16689));

var _StyleSheet = _interopRequireDefault(__webpack_require__(84099));

var _View = _interopRequireDefault(__webpack_require__(79057));

var _canUseDom = _interopRequireDefault(__webpack_require__(24019));

var _excluded = ["style"];

var cssFunction = function () {
  if (_canUseDom.default && window.CSS && window.CSS.supports && window.CSS.supports('top: constant(safe-area-inset-top)')) {
    return 'constant';
  }

  return 'env';
}();

var SafeAreaView = /*#__PURE__*/React.forwardRef((props, ref) => {
  var style = props.style,
      rest = (0, _objectWithoutPropertiesLoose2.default)(props, _excluded);
  return /*#__PURE__*/React.createElement(_View.default, (0, _extends2.default)({}, rest, {
    ref: ref,
    style: _StyleSheet.default.compose(styles.root, style)
  }));
});
SafeAreaView.displayName = 'SafeAreaView';

var styles = _StyleSheet.default.create({
  root: {
    paddingTop: cssFunction + "(safe-area-inset-top)",
    paddingRight: cssFunction + "(safe-area-inset-right)",
    paddingBottom: cssFunction + "(safe-area-inset-bottom)",
    paddingLeft: cssFunction + "(safe-area-inset-left)"
  }
});

var _default = SafeAreaView;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),

/***/ 22947:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(64836)["default"]);

var _interopRequireWildcard = (__webpack_require__(75263)["default"]);

exports.__esModule = true;
exports["default"] = void 0;

var _extends2 = _interopRequireDefault(__webpack_require__(10434));

var _objectWithoutPropertiesLoose2 = _interopRequireDefault(__webpack_require__(7071));

var React = _interopRequireWildcard(__webpack_require__(16689));

var _StyleSheet = _interopRequireDefault(__webpack_require__(84099));

var _View = _interopRequireDefault(__webpack_require__(79057));

var _useMergeRefs = _interopRequireDefault(__webpack_require__(88391));

var _excluded = ["onScroll", "onTouchMove", "onWheel", "scrollEnabled", "scrollEventThrottle", "showsHorizontalScrollIndicator", "showsVerticalScrollIndicator", "style"];

function normalizeScrollEvent(e) {
  return {
    nativeEvent: {
      contentOffset: {
        get x() {
          return e.target.scrollLeft;
        },

        get y() {
          return e.target.scrollTop;
        }

      },
      contentSize: {
        get height() {
          return e.target.scrollHeight;
        },

        get width() {
          return e.target.scrollWidth;
        }

      },
      layoutMeasurement: {
        get height() {
          return e.target.offsetHeight;
        },

        get width() {
          return e.target.offsetWidth;
        }

      }
    },
    timeStamp: Date.now()
  };
}

function shouldEmitScrollEvent(lastTick, eventThrottle) {
  var timeSinceLastTick = Date.now() - lastTick;
  return eventThrottle > 0 && timeSinceLastTick >= eventThrottle;
}
/**
 * Encapsulates the Web-specific scroll throttling and disabling logic
 */


var ScrollViewBase = /*#__PURE__*/React.forwardRef((props, forwardedRef) => {
  var onScroll = props.onScroll,
      onTouchMove = props.onTouchMove,
      onWheel = props.onWheel,
      _props$scrollEnabled = props.scrollEnabled,
      scrollEnabled = _props$scrollEnabled === void 0 ? true : _props$scrollEnabled,
      _props$scrollEventThr = props.scrollEventThrottle,
      scrollEventThrottle = _props$scrollEventThr === void 0 ? 0 : _props$scrollEventThr,
      showsHorizontalScrollIndicator = props.showsHorizontalScrollIndicator,
      showsVerticalScrollIndicator = props.showsVerticalScrollIndicator,
      style = props.style,
      rest = (0, _objectWithoutPropertiesLoose2.default)(props, _excluded);
  var scrollState = React.useRef({
    isScrolling: false,
    scrollLastTick: 0
  });
  var scrollTimeout = React.useRef(null);
  var scrollRef = React.useRef(null);

  function createPreventableScrollHandler(handler) {
    return e => {
      if (scrollEnabled) {
        if (handler) {
          handler(e);
        }
      }
    };
  }

  function handleScroll(e) {
    e.stopPropagation();

    if (e.target === scrollRef.current) {
      e.persist(); // A scroll happened, so the scroll resets the scrollend timeout.

      if (scrollTimeout.current != null) {
        clearTimeout(scrollTimeout.current);
      }

      scrollTimeout.current = setTimeout(() => {
        handleScrollEnd(e);
      }, 100);

      if (scrollState.current.isScrolling) {
        // Scroll last tick may have changed, check if we need to notify
        if (shouldEmitScrollEvent(scrollState.current.scrollLastTick, scrollEventThrottle)) {
          handleScrollTick(e);
        }
      } else {
        // Weren't scrolling, so we must have just started
        handleScrollStart(e);
      }
    }
  }

  function handleScrollStart(e) {
    scrollState.current.isScrolling = true;
    handleScrollTick(e);
  }

  function handleScrollTick(e) {
    scrollState.current.scrollLastTick = Date.now();

    if (onScroll) {
      onScroll(normalizeScrollEvent(e));
    }
  }

  function handleScrollEnd(e) {
    scrollState.current.isScrolling = false;

    if (onScroll) {
      onScroll(normalizeScrollEvent(e));
    }
  }

  var hideScrollbar = showsHorizontalScrollIndicator === false || showsVerticalScrollIndicator === false;
  return /*#__PURE__*/React.createElement(_View.default, (0, _extends2.default)({}, rest, {
    onScroll: handleScroll,
    onTouchMove: createPreventableScrollHandler(onTouchMove),
    onWheel: createPreventableScrollHandler(onWheel),
    ref: (0, _useMergeRefs.default)(scrollRef, forwardedRef),
    style: [style, !scrollEnabled && styles.scrollDisabled, hideScrollbar && styles.hideScrollbar]
  }));
}); // Chrome doesn't support e.preventDefault in this case; touch-action must be
// used to disable scrolling.
// https://developers.google.com/web/updates/2017/01/scrolling-intervention

var styles = _StyleSheet.default.create({
  scrollDisabled: {
    overflowX: 'hidden',
    overflowY: 'hidden',
    touchAction: 'none'
  },
  hideScrollbar: {
    scrollbarWidth: 'none'
  }
});

var _default = ScrollViewBase;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),

/***/ 38174:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(64836)["default"]);

exports.__esModule = true;
exports["default"] = void 0;

var _objectSpread2 = _interopRequireDefault(__webpack_require__(42122));

var _extends2 = _interopRequireDefault(__webpack_require__(10434));

var _objectWithoutPropertiesLoose2 = _interopRequireDefault(__webpack_require__(7071));

var _createReactClass = _interopRequireDefault(__webpack_require__(28566));

var _dismissKeyboard = _interopRequireDefault(__webpack_require__(69835));

var _invariant = _interopRequireDefault(__webpack_require__(44505));

var _mergeRefs = _interopRequireDefault(__webpack_require__(88370));

var _ScrollResponder = _interopRequireDefault(__webpack_require__(65164));

var _ScrollViewBase = _interopRequireDefault(__webpack_require__(22947));

var _StyleSheet = _interopRequireDefault(__webpack_require__(84099));

var _View = _interopRequireDefault(__webpack_require__(79057));

var _react = _interopRequireDefault(__webpack_require__(16689));

var _excluded = ["contentContainerStyle", "horizontal", "onContentSizeChange", "refreshControl", "stickyHeaderIndices", "pagingEnabled", "forwardedRef", "keyboardDismissMode", "onScroll", "centerContent"];
var emptyObject = {};
/* eslint-disable react/prefer-es6-class */

var ScrollView = (0, _createReactClass.default)({
  displayName: "ScrollView",
  mixins: [_ScrollResponder.default.Mixin],

  getInitialState() {
    return this.scrollResponderMixinGetInitialState();
  },

  flashScrollIndicators() {
    this.scrollResponderFlashScrollIndicators();
  },

  /**
   * Returns a reference to the underlying scroll responder, which supports
   * operations like `scrollTo`. All ScrollView-like components should
   * implement this method so that they can be composed while providing access
   * to the underlying scroll responder's methods.
   */
  getScrollResponder() {
    return this;
  },

  getScrollableNode() {
    return this._scrollNodeRef;
  },

  getInnerViewRef() {
    return this._innerViewRef;
  },

  getInnerViewNode() {
    return this._innerViewRef;
  },

  getNativeScrollRef() {
    return this._scrollNodeRef;
  },

  /**
   * Scrolls to a given x, y offset, either immediately or with a smooth animation.
   * Syntax:
   *
   * scrollTo(options: {x: number = 0; y: number = 0; animated: boolean = true})
   *
   * Note: The weird argument signature is due to the fact that, for historical reasons,
   * the function also accepts separate arguments as as alternative to the options object.
   * This is deprecated due to ambiguity (y before x), and SHOULD NOT BE USED.
   */
  scrollTo(y, x, animated) {
    if (typeof y === 'number') {
      console.warn('`scrollTo(y, x, animated)` is deprecated. Use `scrollTo({x: 5, y: 5, animated: true})` instead.');
    } else {
      var _ref = y || emptyObject;

      x = _ref.x;
      y = _ref.y;
      animated = _ref.animated;
    }

    this.getScrollResponder().scrollResponderScrollTo({
      x: x || 0,
      y: y || 0,
      animated: animated !== false
    });
  },

  /**
   * If this is a vertical ScrollView scrolls to the bottom.
   * If this is a horizontal ScrollView scrolls to the right.
   *
   * Use `scrollToEnd({ animated: true })` for smooth animated scrolling,
   * `scrollToEnd({ animated: false })` for immediate scrolling.
   * If no options are passed, `animated` defaults to true.
   */
  scrollToEnd(options) {
    // Default to true
    var animated = (options && options.animated) !== false;
    var horizontal = this.props.horizontal;
    var scrollResponder = this.getScrollResponder();
    var scrollResponderNode = scrollResponder.scrollResponderGetScrollableNode();
    var x = horizontal ? scrollResponderNode.scrollWidth : 0;
    var y = horizontal ? 0 : scrollResponderNode.scrollHeight;
    scrollResponder.scrollResponderScrollTo({
      x,
      y,
      animated
    });
  },

  render() {
    var _this$props = this.props,
        contentContainerStyle = _this$props.contentContainerStyle,
        horizontal = _this$props.horizontal,
        onContentSizeChange = _this$props.onContentSizeChange,
        refreshControl = _this$props.refreshControl,
        stickyHeaderIndices = _this$props.stickyHeaderIndices,
        pagingEnabled = _this$props.pagingEnabled,
        forwardedRef = _this$props.forwardedRef,
        keyboardDismissMode = _this$props.keyboardDismissMode,
        onScroll = _this$props.onScroll,
        centerContent = _this$props.centerContent,
        other = (0, _objectWithoutPropertiesLoose2.default)(_this$props, _excluded);

    if (false) { var childLayoutProps, style; }

    var contentSizeChangeProps = {};

    if (onContentSizeChange) {
      contentSizeChangeProps = {
        onLayout: this._handleContentOnLayout
      };
    }

    var hasStickyHeaderIndices = !horizontal && Array.isArray(stickyHeaderIndices);
    var children = hasStickyHeaderIndices || pagingEnabled ? _react.default.Children.map(this.props.children, (child, i) => {
      var isSticky = hasStickyHeaderIndices && stickyHeaderIndices.indexOf(i) > -1;

      if (child != null && (isSticky || pagingEnabled)) {
        return /*#__PURE__*/_react.default.createElement(_View.default, {
          style: _StyleSheet.default.compose(isSticky && styles.stickyHeader, pagingEnabled && styles.pagingEnabledChild)
        }, child);
      } else {
        return child;
      }
    }) : this.props.children;

    var contentContainer = /*#__PURE__*/_react.default.createElement(_View.default, (0, _extends2.default)({}, contentSizeChangeProps, {
      children: children,
      collapsable: false,
      ref: this._setInnerViewRef,
      style: [horizontal && styles.contentContainerHorizontal, centerContent && styles.contentContainerCenterContent, contentContainerStyle]
    }));

    var baseStyle = horizontal ? styles.baseHorizontal : styles.baseVertical;
    var pagingEnabledStyle = horizontal ? styles.pagingEnabledHorizontal : styles.pagingEnabledVertical;
    var props = (0, _objectSpread2.default)((0, _objectSpread2.default)({}, other), {}, {
      style: [baseStyle, pagingEnabled && pagingEnabledStyle, this.props.style],
      onTouchStart: this.scrollResponderHandleTouchStart,
      onTouchMove: this.scrollResponderHandleTouchMove,
      onTouchEnd: this.scrollResponderHandleTouchEnd,
      onScrollBeginDrag: this.scrollResponderHandleScrollBeginDrag,
      onScrollEndDrag: this.scrollResponderHandleScrollEndDrag,
      onMomentumScrollBegin: this.scrollResponderHandleMomentumScrollBegin,
      onMomentumScrollEnd: this.scrollResponderHandleMomentumScrollEnd,
      onStartShouldSetResponder: this.scrollResponderHandleStartShouldSetResponder,
      onStartShouldSetResponderCapture: this.scrollResponderHandleStartShouldSetResponderCapture,
      onScrollShouldSetResponder: this.scrollResponderHandleScrollShouldSetResponder,
      onScroll: this._handleScroll,
      onResponderGrant: this.scrollResponderHandleResponderGrant,
      onResponderTerminationRequest: this.scrollResponderHandleTerminationRequest,
      onResponderTerminate: this.scrollResponderHandleTerminate,
      onResponderRelease: this.scrollResponderHandleResponderRelease,
      onResponderReject: this.scrollResponderHandleResponderReject
    });
    var ScrollViewClass = _ScrollViewBase.default;
    (0, _invariant.default)(ScrollViewClass !== undefined, 'ScrollViewClass must not be undefined');

    var scrollView = /*#__PURE__*/_react.default.createElement(ScrollViewClass, (0, _extends2.default)({}, props, {
      ref: this._setScrollNodeRef
    }), contentContainer);

    if (refreshControl) {
      return /*#__PURE__*/_react.default.cloneElement(refreshControl, {
        style: props.style
      }, scrollView);
    }

    return scrollView;
  },

  _handleContentOnLayout(e) {
    var _e$nativeEvent$layout = e.nativeEvent.layout,
        width = _e$nativeEvent$layout.width,
        height = _e$nativeEvent$layout.height;
    this.props.onContentSizeChange(width, height);
  },

  _handleScroll(e) {
    if (false) {}

    if (this.props.keyboardDismissMode === 'on-drag') {
      (0, _dismissKeyboard.default)();
    }

    this.scrollResponderHandleScroll(e);
  },

  _setInnerViewRef(node) {
    this._innerViewRef = node;
  },

  _setScrollNodeRef(node) {
    this._scrollNodeRef = node; // ScrollView needs to add more methods to the hostNode in addition to those
    // added by `usePlatformMethods`. This is temporarily until an API like
    // `ScrollView.scrollTo(hostNode, { x, y })` is added to React Native.

    if (node != null) {
      node.getScrollResponder = this.getScrollResponder;
      node.getInnerViewNode = this.getInnerViewNode;
      node.getInnerViewRef = this.getInnerViewRef;
      node.getNativeScrollRef = this.getNativeScrollRef;
      node.getScrollableNode = this.getScrollableNode;
      node.scrollTo = this.scrollTo;
      node.scrollToEnd = this.scrollToEnd;
      node.flashScrollIndicators = this.flashScrollIndicators;
      node.scrollResponderZoomTo = this.scrollResponderZoomTo;
      node.scrollResponderScrollNativeHandleToKeyboard = this.scrollResponderScrollNativeHandleToKeyboard;
    }

    var ref = (0, _mergeRefs.default)(this.props.forwardedRef);
    ref(node);
  }

});
var commonStyle = {
  flexGrow: 1,
  flexShrink: 1,
  // Enable hardware compositing in modern browsers.
  // Creates a new layer with its own backing surface that can significantly
  // improve scroll performance.
  transform: [{
    translateZ: 0
  }],
  // iOS native scrolling
  WebkitOverflowScrolling: 'touch'
};

var styles = _StyleSheet.default.create({
  baseVertical: (0, _objectSpread2.default)((0, _objectSpread2.default)({}, commonStyle), {}, {
    flexDirection: 'column',
    overflowX: 'hidden',
    overflowY: 'auto'
  }),
  baseHorizontal: (0, _objectSpread2.default)((0, _objectSpread2.default)({}, commonStyle), {}, {
    flexDirection: 'row',
    overflowX: 'auto',
    overflowY: 'hidden'
  }),
  contentContainerHorizontal: {
    flexDirection: 'row'
  },
  contentContainerCenterContent: {
    justifyContent: 'center',
    flexGrow: 1
  },
  stickyHeader: {
    position: 'sticky',
    top: 0,
    zIndex: 10
  },
  pagingEnabledHorizontal: {
    scrollSnapType: 'x mandatory'
  },
  pagingEnabledVertical: {
    scrollSnapType: 'y mandatory'
  },
  pagingEnabledChild: {
    scrollSnapAlign: 'start'
  }
});

var ForwardedScrollView = /*#__PURE__*/_react.default.forwardRef((props, forwardedRef) => {
  return /*#__PURE__*/_react.default.createElement(ScrollView, (0, _extends2.default)({}, props, {
    forwardedRef: forwardedRef
  }));
});

ForwardedScrollView.displayName = 'ScrollView';
var _default = ForwardedScrollView;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),

/***/ 87355:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(64836)["default"]);

exports.__esModule = true;
exports["default"] = void 0;

var _SectionList = _interopRequireDefault(__webpack_require__(33316));

/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
var _default = _SectionList.default;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),

/***/ 25975:
/***/ ((module, exports) => {

"use strict";


exports.__esModule = true;
exports["default"] = void 0;
var _default = {};
exports["default"] = _default;
module.exports = exports.default;

/***/ }),

/***/ 89239:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(64836)["default"]);

exports.__esModule = true;
exports["default"] = void 0;

var _invariant = _interopRequireDefault(__webpack_require__(44505));

/**
 * Copyright (c) Nicolas Gallagher.
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
class Share {
  static share(content, options) {
    if (options === void 0) {
      options = {};
    }

    (0, _invariant.default)(typeof content === 'object' && content !== null, 'Content to share must be a valid object');
    (0, _invariant.default)(typeof content.url === 'string' || typeof content.message === 'string', 'At least one of URL and message is required');
    (0, _invariant.default)(typeof options === 'object' && options !== null, 'Options must be a valid object');
    (0, _invariant.default)(!content.title || typeof content.title === 'string', 'Invalid title: title should be a string.');

    if (window.navigator.share !== undefined) {
      return window.navigator.share({
        title: content.title,
        text: content.message,
        url: content.url
      });
    } else {
      return Promise.reject(new Error('Share is not supported in this browser'));
    }
  }
  /**
   * The content was successfully shared.
   */


  static get sharedAction() {
    return 'sharedAction';
  }
  /**
   * The dialog has been dismissed.
   * @platform ios
   */


  static get dismissedAction() {
    return 'dismissedAction';
  }

}

var _default = Share;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),

/***/ 68704:
/***/ ((module, exports) => {

"use strict";


exports.__esModule = true;
exports["default"] = void 0;

/**
 * Copyright (c) Nicolas Gallagher.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
var emptyFunction = () => {};

function StatusBar() {
  return null;
}

StatusBar.setBackgroundColor = emptyFunction;
StatusBar.setBarStyle = emptyFunction;
StatusBar.setHidden = emptyFunction;
StatusBar.setNetworkActivityIndicatorVisible = emptyFunction;
StatusBar.setTranslucent = emptyFunction;
var _default = StatusBar;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),

/***/ 5803:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(64836)["default"]);

exports.__esModule = true;
exports["default"] = exports.createTransformValue = void 0;

var _normalizeValueWithProperty = _interopRequireDefault(__webpack_require__(65858));

var _canUseDom = _interopRequireDefault(__webpack_require__(24019));

/**
 * Copyright (c) Nicolas Gallagher.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

/**
 * The browser implements the CSS cascade, where the order of properties is a
 * factor in determining which styles to paint. React Native is different. It
 * gives giving precedence to the more specific style property. For example,
 * the value of `paddingTop` takes precedence over that of `padding`.
 *
 * This module creates mutally exclusive style declarations by expanding all of
 * React Native's supported shortform properties (e.g. `padding`) to their
 * longfrom equivalents.
 */
var emptyObject = {};
var supportsCSS3TextDecoration = !_canUseDom.default || window.CSS != null && window.CSS.supports != null && (window.CSS.supports('text-decoration-line', 'none') || window.CSS.supports('-webkit-text-decoration-line', 'none'));
var ignoredProps = {
  elevation: true,
  overlayColor: true,
  resizeMode: true,
  tintColor: true
};
var MONOSPACE_FONT_STACK = 'monospace,monospace';
var SYSTEM_FONT_STACK = '-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Helvetica,Arial,sans-serif';
var STYLE_SHORT_FORM_EXPANSIONS = {
  borderColor: ['borderTopColor', 'borderRightColor', 'borderBottomColor', 'borderLeftColor'],
  borderRadius: ['borderTopLeftRadius', 'borderTopRightRadius', 'borderBottomRightRadius', 'borderBottomLeftRadius'],
  borderStyle: ['borderTopStyle', 'borderRightStyle', 'borderBottomStyle', 'borderLeftStyle'],
  borderWidth: ['borderTopWidth', 'borderRightWidth', 'borderBottomWidth', 'borderLeftWidth'],
  marginHorizontal: ['marginRight', 'marginLeft'],
  marginVertical: ['marginTop', 'marginBottom'],
  overflow: ['overflowX', 'overflowY'],
  overscrollBehavior: ['overscrollBehaviorX', 'overscrollBehaviorY'],
  paddingHorizontal: ['paddingRight', 'paddingLeft'],
  paddingVertical: ['paddingTop', 'paddingBottom']
};
/**
 * Transform
 */
// { scale: 2 } => 'scale(2)'
// { translateX: 20 } => 'translateX(20px)'
// { matrix: [1,2,3,4,5,6] } => 'matrix(1,2,3,4,5,6)'

var mapTransform = transform => {
  var type = Object.keys(transform)[0];
  var value = transform[type];

  if (type === 'matrix' || type === 'matrix3d') {
    return type + "(" + value.join(',') + ")";
  } else {
    var normalizedValue = (0, _normalizeValueWithProperty.default)(value, type);
    return type + "(" + normalizedValue + ")";
  }
};

var createTransformValue = style => {
  var transform = style.transform;

  if (Array.isArray(style.transform)) {
    transform = style.transform.map(mapTransform).join(' ');
  }

  return transform;
};
/**
 * Reducer
 */


exports.createTransformValue = createTransformValue;

var createReactDOMStyle = (style, isInline) => {
  if (!style) {
    return emptyObject;
  }

  var resolvedStyle = {};

  for (var prop in style) {
    var value = style[prop];

    if ( // Ignore everything with a null value
    value == null || // Ignore some React Native styles
    ignoredProps[prop]) {
      continue;
    }

    if (prop === 'aspectRatio') {
      resolvedStyle[prop] = value.toString();
    } else if (prop === 'backgroundClip') {
      // TODO: remove once this issue is fixed
      // https://github.com/rofrischmann/inline-style-prefixer/issues/159
      if (value === 'text') {
        resolvedStyle.backgroundClip = value;
        resolvedStyle.WebkitBackgroundClip = value;
      }
    } else if (prop === 'flex') {
      if (value === -1) {
        resolvedStyle.flexGrow = 0;
        resolvedStyle.flexShrink = 1;
        resolvedStyle.flexBasis = 'auto';
      } else {
        resolvedStyle.flex = value;
      }
    } else if (prop === 'font') {
      resolvedStyle[prop] = value.replace('System', SYSTEM_FONT_STACK);
    } else if (prop === 'fontFamily') {
      if (value.indexOf('System') > -1) {
        var stack = value.split(/,\s*/);
        stack[stack.indexOf('System')] = SYSTEM_FONT_STACK;
        resolvedStyle[prop] = stack.join(',');
      } else if (value === 'monospace') {
        resolvedStyle[prop] = MONOSPACE_FONT_STACK;
      } else {
        resolvedStyle[prop] = value;
      }
    } else if (prop === 'fontVariant') {
      if (Array.isArray(value) && value.length > 0) {
        resolvedStyle.fontVariant = value.join(' ');
      }
    } else if (prop === 'textAlignVertical') {
      resolvedStyle.verticalAlign = value === 'center' ? 'middle' : value;
    } else if (prop === 'textDecorationLine') {
      // use 'text-decoration' for browsers that only support CSS2
      // text-decoration (e.g., IE, Edge)
      if (!supportsCSS3TextDecoration) {
        resolvedStyle.textDecoration = value;
      } else {
        resolvedStyle.textDecorationLine = value;
      }
    } else if (prop === 'transform' || prop === 'transformMatrix') {
      resolvedStyle.transform = createTransformValue(style);
    } else if (prop === 'writingDirection') {
      resolvedStyle.direction = value;
    } else {
      (function () {
        var value = (0, _normalizeValueWithProperty.default)(style[prop], prop);
        var longFormProperties = STYLE_SHORT_FORM_EXPANSIONS[prop];

        if (isInline && prop === 'margin') {
          if (style.marginHorizontal == null) {
            resolvedStyle.marginLeft = value;
            resolvedStyle.marginRight = value;
          }

          if (style.marginVertical == null) {
            resolvedStyle.marginTop = value;
            resolvedStyle.marginBottom = value;
          }
        } else if (isInline && prop === 'padding') {
          if (style.paddingHorizontal == null) {
            resolvedStyle.paddingLeft = value;
            resolvedStyle.paddingRight = value;
          }

          if (style.paddingVertical == null) {
            resolvedStyle.paddingTop = value;
            resolvedStyle.paddingBottom = value;
          }
        } else if (longFormProperties) {
          longFormProperties.forEach((longForm, i) => {
            // The value of any longform property in the original styles takes
            // precedence over the shortform's value.
            if (style[longForm] == null) {
              resolvedStyle[longForm] = value;
            }
          });
        } else {
          resolvedStyle[prop] = Array.isArray(value) ? value.join(',') : value;
        }
      })();
    }
  }

  return resolvedStyle;
};

var _default = createReactDOMStyle;
exports["default"] = _default;

/***/ }),

/***/ 11227:
/***/ ((module, exports) => {

"use strict";


exports.__esModule = true;
exports["default"] = void 0;

/* eslint-disable */

/**
 * JS Implementation of MurmurHash2
 *
 * @author <a href="mailto:gary.court@gmail.com">Gary Court</a>
 * @see http://github.com/garycourt/murmurhash-js
 * @author <a href="mailto:aappleby@gmail.com">Austin Appleby</a>
 * @see http://sites.google.com/site/murmurhash/
 *
 * @param {string} str ASCII only
 * @param {number} seed Positive integer only
 * @return {number} 32-bit positive integer hash
 *
 * 
 */
function murmurhash2_32_gc(str, seed) {
  var l = str.length,
      h = seed ^ l,
      i = 0,
      k;

  while (l >= 4) {
    k = str.charCodeAt(i) & 0xff | (str.charCodeAt(++i) & 0xff) << 8 | (str.charCodeAt(++i) & 0xff) << 16 | (str.charCodeAt(++i) & 0xff) << 24;
    k = (k & 0xffff) * 0x5bd1e995 + (((k >>> 16) * 0x5bd1e995 & 0xffff) << 16);
    k ^= k >>> 24;
    k = (k & 0xffff) * 0x5bd1e995 + (((k >>> 16) * 0x5bd1e995 & 0xffff) << 16);
    h = (h & 0xffff) * 0x5bd1e995 + (((h >>> 16) * 0x5bd1e995 & 0xffff) << 16) ^ k;
    l -= 4;
    ++i;
  }

  switch (l) {
    case 3:
      h ^= (str.charCodeAt(i + 2) & 0xff) << 16;

    case 2:
      h ^= (str.charCodeAt(i + 1) & 0xff) << 8;

    case 1:
      h ^= str.charCodeAt(i) & 0xff;
      h = (h & 0xffff) * 0x5bd1e995 + (((h >>> 16) * 0x5bd1e995 & 0xffff) << 16);
  }

  h ^= h >>> 13;
  h = (h & 0xffff) * 0x5bd1e995 + (((h >>> 16) * 0x5bd1e995 & 0xffff) << 16);
  h ^= h >>> 15;
  return h >>> 0;
}

var hash = str => murmurhash2_32_gc(str, 1).toString(36);

var _default = hash;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),

/***/ 10623:
/***/ ((module, exports) => {

"use strict";


exports.__esModule = true;
exports["default"] = void 0;

/**
 * Copyright (c) Nicolas Gallagher.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
var uppercasePattern = /[A-Z]/g;
var msPattern = /^ms-/;
var cache = {};

function toHyphenLower(match) {
  return '-' + match.toLowerCase();
}

function hyphenateStyleName(name) {
  if (name in cache) {
    return cache[name];
  }

  var hName = name.replace(uppercasePattern, toHyphenLower);
  return cache[name] = msPattern.test(hName) ? '-' + hName : hName;
}

var _default = hyphenateStyleName;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),

/***/ 61618:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(64836)["default"]);

exports.__esModule = true;
exports.atomic = atomic;
exports.classic = classic;
exports.inline = inline;
exports.stringifyValueWithProperty = stringifyValueWithProperty;

var _objectSpread2 = _interopRequireDefault(__webpack_require__(42122));

var _objectWithoutPropertiesLoose2 = _interopRequireDefault(__webpack_require__(7071));

var _createReactDOMStyle = _interopRequireDefault(__webpack_require__(5803));

var _hash = _interopRequireDefault(__webpack_require__(11227));

var _hyphenateStyleName = _interopRequireDefault(__webpack_require__(10623));

var _normalizeValueWithProperty = _interopRequireDefault(__webpack_require__(65858));

var _prefixStyles = _interopRequireDefault(__webpack_require__(82637));

var _excluded = ["animationKeyframes"];
var cache = new Map();
var emptyObject = {};
var classicGroup = 1;
var atomicGroup = 2.2;
var customGroup = {
  borderColor: 2,
  borderRadius: 2,
  borderStyle: 2,
  borderWidth: 2,
  display: 2,
  flex: 2,
  margin: 2,
  overflow: 2,
  overscrollBehavior: 2,
  padding: 2,
  marginHorizontal: 2.1,
  marginVertical: 2.1,
  paddingHorizontal: 2.1,
  paddingVertical: 2.1
};
var borderTopLeftRadius = 'borderTopLeftRadius';
var borderTopRightRadius = 'borderTopRightRadius';
var borderBottomLeftRadius = 'borderBottomLeftRadius';
var borderBottomRightRadius = 'borderBottomRightRadius';
var borderLeftColor = 'borderLeftColor';
var borderLeftStyle = 'borderLeftStyle';
var borderLeftWidth = 'borderLeftWidth';
var borderRightColor = 'borderRightColor';
var borderRightStyle = 'borderRightStyle';
var borderRightWidth = 'borderRightWidth';
var right = 'right';
var marginLeft = 'marginLeft';
var marginRight = 'marginRight';
var paddingLeft = 'paddingLeft';
var paddingRight = 'paddingRight';
var left = 'left'; // Map of LTR property names to their BiDi equivalent.

var PROPERTIES_FLIP = {
  [borderTopLeftRadius]: borderTopRightRadius,
  [borderTopRightRadius]: borderTopLeftRadius,
  [borderBottomLeftRadius]: borderBottomRightRadius,
  [borderBottomRightRadius]: borderBottomLeftRadius,
  [borderLeftColor]: borderRightColor,
  [borderLeftStyle]: borderRightStyle,
  [borderLeftWidth]: borderRightWidth,
  [borderRightColor]: borderLeftColor,
  [borderRightStyle]: borderLeftStyle,
  [borderRightWidth]: borderLeftWidth,
  [left]: right,
  [marginLeft]: marginRight,
  [marginRight]: marginLeft,
  [paddingLeft]: paddingRight,
  [paddingRight]: paddingLeft,
  [right]: left
}; // Map of I18N property names to their LTR equivalent.

var PROPERTIES_I18N = {
  borderTopStartRadius: borderTopLeftRadius,
  borderTopEndRadius: borderTopRightRadius,
  borderBottomStartRadius: borderBottomLeftRadius,
  borderBottomEndRadius: borderBottomRightRadius,
  borderStartColor: borderLeftColor,
  borderStartStyle: borderLeftStyle,
  borderStartWidth: borderLeftWidth,
  borderEndColor: borderRightColor,
  borderEndStyle: borderRightStyle,
  borderEndWidth: borderRightWidth,
  end: right,
  marginStart: marginLeft,
  marginEnd: marginRight,
  paddingStart: paddingLeft,
  paddingEnd: paddingRight,
  start: left
};
var PROPERTIES_VALUE = ['clear', 'float', 'textAlign'];

function atomic(style) {
  var compiledStyle = {
    $$css: true
  };
  var compiledRules = [];

  function atomicCompile(prop, value) {
    var valueString = stringifyValueWithProperty(value, prop);
    var cacheKey = prop + valueString;
    var cachedResult = cache.get(cacheKey);
    var identifier;

    if (cachedResult != null) {
      identifier = cachedResult[0];
      compiledRules.push(cachedResult[1]);
    } else {
      identifier = createIdentifier('r', prop, value);
      var order = customGroup[prop] || atomicGroup;
      var rules = createAtomicRules(identifier, prop, value);
      var orderedRules = [rules, order];
      compiledRules.push(orderedRules);
      cache.set(cacheKey, [identifier, orderedRules]);
    }

    return identifier;
  }

  Object.keys(style).sort().forEach(prop => {
    var value = style[prop];

    if (value != null) {
      var localizeableValue; // BiDi flip values

      if (PROPERTIES_VALUE.indexOf(prop) > -1) {
        var _left = atomicCompile(prop, 'left');

        var _right = atomicCompile(prop, 'right');

        if (value === 'start') {
          localizeableValue = [_left, _right];
        } else if (value === 'end') {
          localizeableValue = [_right, _left];
        }
      } // BiDi flip properties


      var propPolyfill = PROPERTIES_I18N[prop];

      if (propPolyfill != null) {
        var ltr = atomicCompile(propPolyfill, value);
        var rtl = atomicCompile(PROPERTIES_FLIP[propPolyfill], value);
        localizeableValue = [ltr, rtl];
      } // BiDi flip transitionProperty value


      if (prop === 'transitionProperty') {
        var values = Array.isArray(value) ? value : [value];
        var polyfillIndices = [];

        for (var i = 0; i < values.length; i++) {
          var val = values[i];

          if (typeof val === 'string' && PROPERTIES_I18N[val] != null) {
            polyfillIndices.push(i);
          }
        }

        if (polyfillIndices.length > 0) {
          var ltrPolyfillValues = [...values];
          var rtlPolyfillValues = [...values];
          polyfillIndices.forEach(i => {
            var ltrVal = ltrPolyfillValues[i];

            if (typeof ltrVal === 'string') {
              var ltrPolyfill = PROPERTIES_I18N[ltrVal];
              var rtlPolyfill = PROPERTIES_FLIP[ltrPolyfill];
              ltrPolyfillValues[i] = ltrPolyfill;
              rtlPolyfillValues[i] = rtlPolyfill;

              var _ltr = atomicCompile(prop, ltrPolyfillValues);

              var _rtl = atomicCompile(prop, rtlPolyfillValues);

              localizeableValue = [_ltr, _rtl];
            }
          });
        }
      }

      if (localizeableValue == null) {
        localizeableValue = atomicCompile(prop, value);
      } else {
        compiledStyle['$$css$localize'] = true;
      }

      compiledStyle[prop] = localizeableValue;
    }
  });
  return [compiledStyle, compiledRules];
}
/**
 * Compile simple style object to classic CSS rules.
 * No support for 'placeholderTextColor', 'scrollbarWidth', or 'pointerEvents'.
 */


function classic(style, name) {
  var compiledStyle = {
    $$css: true
  };
  var compiledRules = [];
  var animationKeyframes = style.animationKeyframes,
      rest = (0, _objectWithoutPropertiesLoose2.default)(style, _excluded);
  var identifier = createIdentifier('css', name, style);
  var selector = "." + identifier;
  var animationName;

  if (animationKeyframes != null) {
    var _processKeyframesValu = processKeyframesValue(animationKeyframes),
        animationNames = _processKeyframesValu[0],
        keyframesRules = _processKeyframesValu[1];

    animationName = animationNames.join(',');
    compiledRules.push(...keyframesRules);
  }

  var block = createDeclarationBlock((0, _objectSpread2.default)((0, _objectSpread2.default)({}, rest), {}, {
    animationName
  }));
  compiledRules.push("" + selector + block);
  compiledStyle[identifier] = identifier;
  return [compiledStyle, [[compiledRules, classicGroup]]];
}
/**
 * Compile simple style object to inline DOM styles.
 * No support for 'animationKeyframes', 'placeholderTextColor', 'scrollbarWidth', or 'pointerEvents'.
 */


function inline(originalStyle, isRTL) {
  var style = originalStyle || emptyObject;
  var frozenProps = {};
  var nextStyle = {};

  for (var originalProp in style) {
    var originalValue = style[originalProp];
    var prop = originalProp;
    var value = originalValue;

    if (!Object.prototype.hasOwnProperty.call(style, originalProp) || originalValue == null) {
      continue;
    } // BiDi flip values


    if (PROPERTIES_VALUE.indexOf(originalProp) > -1) {
      if (originalValue === 'start') {
        value = isRTL ? 'right' : 'left';
      } else if (originalValue === 'end') {
        value = isRTL ? 'left' : 'right';
      }
    } // BiDi flip properties


    var propPolyfill = PROPERTIES_I18N[originalProp];

    if (propPolyfill != null) {
      prop = isRTL ? PROPERTIES_FLIP[propPolyfill] : propPolyfill;
    } // BiDi flip transitionProperty value


    if (originalProp === 'transitionProperty') {
      (function () {
        // $FlowFixMe
        var originalValues = Array.isArray(originalValue) ? originalValue : [originalValue];
        originalValues.forEach((val, i) => {
          if (typeof val === 'string') {
            var valuePolyfill = PROPERTIES_I18N[val];

            if (valuePolyfill != null) {
              originalValues[i] = isRTL ? PROPERTIES_FLIP[valuePolyfill] : valuePolyfill;
            }
          }
        });
      })();
    } // Create finalized style


    if (!frozenProps[prop]) {
      nextStyle[prop] = value;
    }

    if (PROPERTIES_I18N.hasOwnProperty(originalProp)) {
      frozenProps[prop] = true;
    }
  }

  return (0, _createReactDOMStyle.default)(nextStyle, true);
}
/**
 * Create a value string that normalizes different input values with a common
 * output.
 */


function stringifyValueWithProperty(value, property) {
  // e.g., 0 => '0px', 'black' => 'rgba(0,0,0,1)'
  var normalizedValue = (0, _normalizeValueWithProperty.default)(value, property);
  return typeof normalizedValue !== 'string' ? JSON.stringify(normalizedValue || '') : normalizedValue;
}
/**
 * Create the Atomic CSS rules needed for a given StyleSheet rule.
 * Translates StyleSheet declarations to CSS.
 */


function createAtomicRules(identifier, property, value) {
  var rules = [];
  var selector = "." + identifier; // Handle non-standard properties and object values that require multiple
  // CSS rules to be created.

  switch (property) {
    case 'animationKeyframes':
      {
        var _processKeyframesValu2 = processKeyframesValue(value),
            animationNames = _processKeyframesValu2[0],
            keyframesRules = _processKeyframesValu2[1];

        var block = createDeclarationBlock({
          animationName: animationNames.join(',')
        });
        rules.push("" + selector + block, ...keyframesRules);
        break;
      }
    // Equivalent to using '::placeholder'

    case 'placeholderTextColor':
      {
        var _block = createDeclarationBlock({
          color: value,
          opacity: 1
        });

        rules.push(selector + "::-webkit-input-placeholder" + _block, selector + "::-moz-placeholder" + _block, selector + ":-ms-input-placeholder" + _block, selector + "::placeholder" + _block);
        break;
      }
    // Polyfill for additional 'pointer-events' values
    // See d13f78622b233a0afc0c7a200c0a0792c8ca9e58

    case 'pointerEvents':
      {
        var finalValue = value;

        if (value === 'auto' || value === 'box-only') {
          finalValue = 'auto!important';

          if (value === 'box-only') {
            var _block3 = createDeclarationBlock({
              pointerEvents: 'none'
            });

            rules.push(selector + ">*" + _block3);
          }
        } else if (value === 'none' || value === 'box-none') {
          finalValue = 'none!important';

          if (value === 'box-none') {
            var _block4 = createDeclarationBlock({
              pointerEvents: 'auto'
            });

            rules.push(selector + ">*" + _block4);
          }
        }

        var _block2 = createDeclarationBlock({
          pointerEvents: finalValue
        });

        rules.push("" + selector + _block2);
        break;
      }
    // Polyfill for draft spec
    // https://drafts.csswg.org/css-scrollbars-1/

    case 'scrollbarWidth':
      {
        if (value === 'none') {
          rules.push(selector + "::-webkit-scrollbar{display:none}");
        }

        var _block5 = createDeclarationBlock({
          scrollbarWidth: value
        });

        rules.push("" + selector + _block5);
        break;
      }

    default:
      {
        var _block6 = createDeclarationBlock({
          [property]: value
        });

        rules.push("" + selector + _block6);
        break;
      }
  }

  return rules;
}
/**
 * Creates a CSS declaration block from a StyleSheet object.
 */


function createDeclarationBlock(style) {
  var domStyle = (0, _prefixStyles.default)((0, _createReactDOMStyle.default)(style));
  var declarationsString = Object.keys(domStyle).map(property => {
    var value = domStyle[property];
    var prop = (0, _hyphenateStyleName.default)(property); // The prefixer may return an array of values:
    // { display: [ '-webkit-flex', 'flex' ] }
    // to represent "fallback" declarations
    // { display: -webkit-flex; display: flex; }

    if (Array.isArray(value)) {
      return value.map(v => prop + ":" + v).join(';');
    } else {
      return prop + ":" + value;
    }
  }) // Once properties are hyphenated, this will put the vendor
  // prefixed and short-form properties first in the list.
  .sort().join(';');
  return "{" + declarationsString + ";}";
}
/**
 * An identifier is associated with a unique set of styles.
 */


function createIdentifier(prefix, name, value) {
  var hashedString = (0, _hash.default)(name + stringifyValueWithProperty(value, name));
  return  false ? 0 : prefix + "-" + hashedString;
}
/**
 * Create individual CSS keyframes rules.
 */


function createKeyframes(keyframes) {
  var prefixes = ['-webkit-', ''];
  var identifier = createIdentifier('r', 'animation', keyframes);
  var steps = '{' + Object.keys(keyframes).map(stepName => {
    var rule = keyframes[stepName];
    var block = createDeclarationBlock(rule);
    return "" + stepName + block;
  }).join('') + '}';
  var rules = prefixes.map(prefix => {
    return "@" + prefix + "keyframes " + identifier + steps;
  });
  return [identifier, rules];
}
/**
 * Create CSS keyframes rules and names from a StyleSheet keyframes object.
 */


function processKeyframesValue(keyframesValue) {
  if (typeof keyframesValue === 'number') {
    throw new Error("Invalid CSS keyframes type: " + typeof keyframesValue);
  }

  var animationNames = [];
  var rules = [];
  var value = Array.isArray(keyframesValue) ? keyframesValue : [keyframesValue];
  value.forEach(keyframes => {
    if (typeof keyframes === 'string') {
      // Support external animation libraries (identifiers only)
      animationNames.push(keyframes);
    } else {
      // Create rules for each of the keyframes
      var _createKeyframes = createKeyframes(keyframes),
          identifier = _createKeyframes[0],
          keyframesRules = _createKeyframes[1];

      animationNames.push(identifier);
      rules.push(...keyframesRules);
    }
  });
  return [animationNames, rules];
}

/***/ }),

/***/ 66470:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(64836)["default"]);

exports.__esModule = true;
exports["default"] = void 0;

var _isWebColor = _interopRequireDefault(__webpack_require__(47391));

var _processColor = _interopRequireDefault(__webpack_require__(64385));

/**
 * Copyright (c) Nicolas Gallagher.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
var normalizeColor = function normalizeColor(color, opacity) {
  if (opacity === void 0) {
    opacity = 1;
  }

  if (color == null) return;

  if (typeof color === 'string' && (0, _isWebColor.default)(color)) {
    return color;
  }

  var colorInt = (0, _processColor.default)(color);

  if (colorInt != null) {
    var r = colorInt >> 16 & 255;
    var g = colorInt >> 8 & 255;
    var b = colorInt & 255;
    var a = (colorInt >> 24 & 255) / 255;
    var alpha = (a * opacity).toFixed(2);
    return "rgba(" + r + "," + g + "," + b + "," + alpha + ")";
  }
};

var _default = normalizeColor;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),

/***/ 65858:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(64836)["default"]);

exports.__esModule = true;
exports["default"] = normalizeValueWithProperty;

var _unitlessNumbers = _interopRequireDefault(__webpack_require__(62773));

var _normalizeColor = _interopRequireDefault(__webpack_require__(66470));

/**
 * Copyright (c) Nicolas Gallagher.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
var colorProps = {
  backgroundColor: true,
  borderColor: true,
  borderTopColor: true,
  borderRightColor: true,
  borderBottomColor: true,
  borderLeftColor: true,
  color: true,
  shadowColor: true,
  textDecorationColor: true,
  textShadowColor: true
};

function normalizeValueWithProperty(value, property) {
  var returnValue = value;

  if ((property == null || !_unitlessNumbers.default[property]) && typeof value === 'number') {
    returnValue = value + "px";
  } else if (property != null && colorProps[property]) {
    returnValue = (0, _normalizeColor.default)(value);
  }

  return returnValue;
}

module.exports = exports.default;

/***/ }),

/***/ 62773:
/***/ ((module, exports) => {

"use strict";


exports.__esModule = true;
exports["default"] = void 0;

/**
 * Copyright (c) Nicolas Gallagher.
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
var unitlessNumbers = {
  animationIterationCount: true,
  aspectRatio: true,
  borderImageOutset: true,
  borderImageSlice: true,
  borderImageWidth: true,
  boxFlex: true,
  boxFlexGroup: true,
  boxOrdinalGroup: true,
  columnCount: true,
  flex: true,
  flexGrow: true,
  flexOrder: true,
  flexPositive: true,
  flexShrink: true,
  flexNegative: true,
  fontWeight: true,
  gridRow: true,
  gridRowEnd: true,
  gridRowGap: true,
  gridRowStart: true,
  gridColumn: true,
  gridColumnEnd: true,
  gridColumnGap: true,
  gridColumnStart: true,
  lineClamp: true,
  opacity: true,
  order: true,
  orphans: true,
  tabSize: true,
  widows: true,
  zIndex: true,
  zoom: true,
  // SVG-related
  fillOpacity: true,
  floodOpacity: true,
  stopOpacity: true,
  strokeDasharray: true,
  strokeDashoffset: true,
  strokeMiterlimit: true,
  strokeOpacity: true,
  strokeWidth: true,
  // transform types
  scale: true,
  scaleX: true,
  scaleY: true,
  scaleZ: true,
  // RN properties
  shadowOpacity: true
};
/**
 * Support style names that may come passed in prefixed by adding permutations
 * of vendor prefixes.
 */

var prefixes = ['ms', 'Moz', 'O', 'Webkit'];

var prefixKey = (prefix, key) => {
  return prefix + key.charAt(0).toUpperCase() + key.substring(1);
};

Object.keys(unitlessNumbers).forEach(prop => {
  prefixes.forEach(prefix => {
    unitlessNumbers[prefixKey(prefix, prop)] = unitlessNumbers[prop];
  });
});
var _default = unitlessNumbers;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),

/***/ 43396:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(64836)["default"]);

exports.__esModule = true;
exports["default"] = createCSSStyleSheet;

var _canUseDom = _interopRequireDefault(__webpack_require__(24019));

/**
 * Copyright (c) Nicolas Gallagher.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
// $FlowFixMe: HTMLStyleElement is incorrectly typed - https://github.com/facebook/flow/issues/2696
function createCSSStyleSheet(id, rootNode, textContent) {
  if (_canUseDom.default) {
    var root = rootNode != null ? rootNode : document;
    var element = root.getElementById(id);

    if (element == null) {
      element = document.createElement('style');
      element.setAttribute('id', id);

      if (typeof textContent === 'string') {
        element.appendChild(document.createTextNode(textContent));
      }

      if (root instanceof ShadowRoot) {
        root.insertBefore(element, root.firstChild);
      } else {
        var head = root.head;

        if (head) {
          head.insertBefore(element, head.firstChild);
        }
      }
    } // $FlowFixMe: HTMLElement is incorrectly typed


    return element.sheet;
  } else {
    return null;
  }
}

module.exports = exports.default;

/***/ }),

/***/ 74192:
/***/ ((module, exports) => {

"use strict";


exports.__esModule = true;
exports["default"] = createOrderedCSSStyleSheet;

/**
 * Copyright (c) Nicolas Gallagher.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
var slice = Array.prototype.slice;
/**
 * Order-based insertion of CSS.
 *
 * Each rule is associated with a numerically defined group.
 * Groups are ordered within the style sheet according to their number, with the
 * lowest first.
 *
 * Groups are implemented using marker rules. The selector of the first rule of
 * each group is used only to encode the group number for hydration. An
 * alternative implementation could rely on CSSMediaRule, allowing groups to be
 * treated as a sub-sheet, but the Edge implementation of CSSMediaRule is
 * broken.
 * https://developer.mozilla.org/en-US/docs/Web/API/CSSMediaRule
 * https://gist.github.com/necolas/aa0c37846ad6bd3b05b727b959e82674
 */

function createOrderedCSSStyleSheet(sheet) {
  var groups = {};
  var selectors = {};
  /**
   * Hydrate approximate record from any existing rules in the sheet.
   */

  if (sheet != null) {
    var group;
    slice.call(sheet.cssRules).forEach((cssRule, i) => {
      var cssText = cssRule.cssText; // Create record of existing selectors and rules

      if (cssText.indexOf('stylesheet-group') > -1) {
        group = decodeGroupRule(cssRule);
        groups[group] = {
          start: i,
          rules: [cssText]
        };
      } else {
        var selectorText = getSelectorText(cssText);

        if (selectorText != null) {
          selectors[selectorText] = true;
          groups[group].rules.push(cssText);
        }
      }
    });
  }

  function sheetInsert(sheet, group, text) {
    var orderedGroups = getOrderedGroups(groups);
    var groupIndex = orderedGroups.indexOf(group);
    var nextGroupIndex = groupIndex + 1;
    var nextGroup = orderedGroups[nextGroupIndex]; // Insert rule before the next group, or at the end of the stylesheet

    var position = nextGroup != null && groups[nextGroup].start != null ? groups[nextGroup].start : sheet.cssRules.length;
    var isInserted = insertRuleAt(sheet, text, position);

    if (isInserted) {
      // Set the starting index of the new group
      if (groups[group].start == null) {
        groups[group].start = position;
      } // Increment the starting index of all subsequent groups


      for (var i = nextGroupIndex; i < orderedGroups.length; i += 1) {
        var groupNumber = orderedGroups[i];
        var previousStart = groups[groupNumber].start || 0;
        groups[groupNumber].start = previousStart + 1;
      }
    }

    return isInserted;
  }

  var OrderedCSSStyleSheet = {
    /**
     * The textContent of the style sheet.
     */
    getTextContent() {
      return getOrderedGroups(groups).map(group => {
        var rules = groups[group].rules; // Sorting provides deterministic order of styles in group for
        // build-time extraction of the style sheet.

        var marker = rules.shift();
        rules.sort();
        rules.unshift(marker);
        return rules.join('\n');
      }).join('\n');
    },

    /**
     * Insert a rule into the style sheet
     */
    insert(cssText, groupValue) {
      var group = Number(groupValue); // Create a new group.

      if (groups[group] == null) {
        var markerRule = encodeGroupRule(group); // Create the internal record.

        groups[group] = {
          start: null,
          rules: [markerRule]
        }; // Update CSSOM.

        if (sheet != null) {
          sheetInsert(sheet, group, markerRule);
        }
      } // selectorText is more reliable than cssText for insertion checks. The
      // browser excludes vendor-prefixed properties and rewrites certain values
      // making cssText more likely to be different from what was inserted.


      var selectorText = getSelectorText(cssText);

      if (selectorText != null && selectors[selectorText] == null) {
        // Update the internal records.
        selectors[selectorText] = true;
        groups[group].rules.push(cssText); // Update CSSOM.

        if (sheet != null) {
          var isInserted = sheetInsert(sheet, group, cssText);

          if (!isInserted) {
            // Revert internal record change if a rule was rejected (e.g.,
            // unrecognized pseudo-selector)
            groups[group].rules.pop();
          }
        }
      }
    }

  };
  return OrderedCSSStyleSheet;
}
/**
 * Helper functions
 */


function encodeGroupRule(group) {
  return "[stylesheet-group=\"" + group + "\"]{}";
}

var groupPattern = /["']/g;

function decodeGroupRule(cssRule) {
  return Number(cssRule.selectorText.split(groupPattern)[1]);
}

function getOrderedGroups(obj) {
  return Object.keys(obj).map(Number).sort((a, b) => a > b ? 1 : -1);
}

var selectorPattern = /\s*([,])\s*/g;

function getSelectorText(cssText) {
  var selector = cssText.split('{')[0].trim();
  return selector !== '' ? selector.replace(selectorPattern, '$1') : null;
}

function insertRuleAt(root, cssText, position) {
  try {
    // $FlowFixMe: Flow is missing CSSOM types needed to type 'root'.
    root.insertRule(cssText, position);
    return true;
  } catch (e) {
    // JSDOM doesn't support `CSSSMediaRule#insertRule`.
    // Also ignore errors that occur from attempting to insert vendor-prefixed selectors.
    return false;
  }
}

module.exports = exports.default;

/***/ }),

/***/ 79352:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(64836)["default"]);

exports.__esModule = true;
exports.createSheet = createSheet;

var _canUseDom = _interopRequireDefault(__webpack_require__(24019));

var _createCSSStyleSheet = _interopRequireDefault(__webpack_require__(43396));

var _createOrderedCSSStyleSheet = _interopRequireDefault(__webpack_require__(74192));

/**
 * Copyright (c) Nicolas Gallagher.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
var defaultId = 'react-native-stylesheet';
var roots = new WeakMap();
var sheets = [];
var initialRules = [// minimal top-level reset
'html{-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%;-webkit-tap-highlight-color:rgba(0,0,0,0);}', 'body{margin:0;}', // minimal form pseudo-element reset
'button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0;}', 'input::-webkit-search-cancel-button,input::-webkit-search-decoration,input::-webkit-search-results-button,input::-webkit-search-results-decoration{display:none;}'];

function createSheet(root, id) {
  if (id === void 0) {
    id = defaultId;
  }

  var sheet;

  if (_canUseDom.default) {
    var rootNode = root != null ? root.getRootNode() : document; // Create the initial style sheet

    if (sheets.length === 0) {
      sheet = (0, _createOrderedCSSStyleSheet.default)((0, _createCSSStyleSheet.default)(id));
      initialRules.forEach(rule => {
        sheet.insert(rule, 0);
      });
      roots.set(rootNode, sheets.length);
      sheets.push(sheet);
    } else {
      var index = roots.get(rootNode);

      if (index == null) {
        var initialSheet = sheets[0]; // If we're creating a new sheet, populate it with existing styles

        var textContent = initialSheet != null ? initialSheet.getTextContent() : ''; // Cast rootNode to 'any' because Flow types for getRootNode are wrong

        sheet = (0, _createOrderedCSSStyleSheet.default)((0, _createCSSStyleSheet.default)(id, rootNode, textContent));
        roots.set(rootNode, sheets.length);
        sheets.push(sheet);
      } else {
        sheet = sheets[index];
      }
    }
  } else {
    // Create the initial style sheet
    if (sheets.length === 0) {
      sheet = (0, _createOrderedCSSStyleSheet.default)((0, _createCSSStyleSheet.default)(id));
      initialRules.forEach(rule => {
        sheet.insert(rule, 0);
      });
      sheets.push(sheet);
    } else {
      sheet = sheets[0];
    }
  }

  return {
    getTextContent() {
      return sheet.getTextContent();
    },

    id,

    insert(cssText, groupValue) {
      sheets.forEach(s => {
        s.insert(cssText, groupValue);
      });
    }

  };
}

/***/ }),

/***/ 84099:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(64836)["default"]);

exports.__esModule = true;
exports["default"] = void 0;

var _objectSpread2 = _interopRequireDefault(__webpack_require__(42122));

var _compiler = __webpack_require__(61618);

var _dom = __webpack_require__(79352);

var _transformLocalizeStyle = __webpack_require__(58688);

var _preprocess = __webpack_require__(27874);

var _styleq = __webpack_require__(78616);

var _validate = __webpack_require__(46054);

var _canUseDom = _interopRequireDefault(__webpack_require__(24019));

/**
 * Copyright (c) Nicolas Gallagher.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
var staticStyleMap = new WeakMap();
var sheet = (0, _dom.createSheet)();

function customStyleq(styles, isRTL) {
  return _styleq.styleq.factory({
    transform(style) {
      var compiledStyle = staticStyleMap.get(style);

      if (compiledStyle != null) {
        return (0, _transformLocalizeStyle.localizeStyle)(compiledStyle, isRTL);
      }

      return style;
    }

  })(styles);
}

function insertRules(compiledOrderedRules) {
  compiledOrderedRules.forEach(_ref => {
    var rules = _ref[0],
        order = _ref[1];

    if (sheet != null) {
      rules.forEach(rule => {
        sheet.insert(rule, order);
      });
    }
  });
}

function compileAndInsertAtomic(style) {
  var _atomic = (0, _compiler.atomic)((0, _preprocess.preprocess)(style)),
      compiledStyle = _atomic[0],
      compiledOrderedRules = _atomic[1];

  insertRules(compiledOrderedRules);
  return compiledStyle;
}

function compileAndInsertReset(style, key) {
  var _classic = (0, _compiler.classic)(style, key),
      compiledStyle = _classic[0],
      compiledOrderedRules = _classic[1];

  insertRules(compiledOrderedRules);
  return compiledStyle;
}
/* ----- API ----- */


var absoluteFillObject = {
  position: 'absolute',
  left: 0,
  right: 0,
  top: 0,
  bottom: 0
};
var absoluteFill = create({
  x: (0, _objectSpread2.default)({}, absoluteFillObject)
}).x;
/**
 * create
 */

function create(styles) {
  Object.keys(styles).forEach(key => {
    var styleObj = styles[key]; // Only compile at runtime if the style is not already compiled

    if (styleObj != null && styleObj.$$css !== true) {
      var compiledStyles;

      if (key.indexOf('$raw') > -1) {
        compiledStyles = compileAndInsertReset(styleObj, key.split('$raw')[0]);
      } else {
        if (false) {}

        compiledStyles = compileAndInsertAtomic(styleObj);
      }

      staticStyleMap.set(styleObj, compiledStyles);
    }
  });
  return styles;
}
/**
 * compose
 */


function compose(style1, style2) {
  if (false) { var readableStyles, len; }

  if (style1 && style2) {
    return [style1, style2];
  } else {
    return style1 || style2;
  }
}
/**
 * flatten
 */


function flatten() {
  for (var _len = arguments.length, styles = new Array(_len), _key = 0; _key < _len; _key++) {
    styles[_key] = arguments[_key];
  }

  var flatArray = styles.flat(Infinity);
  var result = {};

  for (var i = 0; i < flatArray.length; i++) {
    var style = flatArray[i];

    if (style != null && typeof style === 'object') {
      // $FlowFixMe
      Object.assign(result, style);
    }
  }

  return result;
}
/**
 * getSheet
 */


function getSheet() {
  return {
    id: sheet.id,
    textContent: sheet.getTextContent()
  };
}
/**
 * resolve
 */


function StyleSheet(styles, options) {
  var isRTL = options != null && options.writingDirection === 'rtl';
  var styleProps = customStyleq(styles, isRTL);

  if (Array.isArray(styleProps) && styleProps[1] != null) {
    styleProps[1] = (0, _compiler.inline)((0, _preprocess.preprocess)(styleProps[1]), isRTL);
  }

  return styleProps;
}

StyleSheet.absoluteFill = absoluteFill;
StyleSheet.absoluteFillObject = absoluteFillObject;
StyleSheet.create = create;
StyleSheet.compose = compose;
StyleSheet.flatten = flatten;
StyleSheet.getSheet = getSheet; // `hairlineWidth` is not implemented using screen density as browsers may
// round sub-pixel values down to `0`, causing the line not to be rendered.

StyleSheet.hairlineWidth = 1;

if (_canUseDom.default && window.__REACT_DEVTOOLS_GLOBAL_HOOK__) {
  window.__REACT_DEVTOOLS_GLOBAL_HOOK__.resolveRNStyle = StyleSheet.flatten;
}

var stylesheet = StyleSheet;
var _default = stylesheet;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),

/***/ 27874:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(64836)["default"]);

exports.__esModule = true;
exports.preprocess = exports["default"] = exports.createTextShadowValue = exports.createBoxShadowValue = void 0;

var _normalizeColor = _interopRequireDefault(__webpack_require__(66470));

var _normalizeValueWithProperty = _interopRequireDefault(__webpack_require__(65858));

/**
 * Copyright (c) Nicolas Gallagher.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
var emptyObject = {};
/**
 * Shadows
 */

var defaultOffset = {
  height: 0,
  width: 0
};

var createBoxShadowValue = style => {
  var shadowColor = style.shadowColor,
      shadowOffset = style.shadowOffset,
      shadowOpacity = style.shadowOpacity,
      shadowRadius = style.shadowRadius;

  var _ref = shadowOffset || defaultOffset,
      height = _ref.height,
      width = _ref.width;

  var offsetX = (0, _normalizeValueWithProperty.default)(width);
  var offsetY = (0, _normalizeValueWithProperty.default)(height);
  var blurRadius = (0, _normalizeValueWithProperty.default)(shadowRadius || 0);
  var color = (0, _normalizeColor.default)(shadowColor || 'black', shadowOpacity);

  if (color != null && offsetX != null && offsetY != null && blurRadius != null) {
    return offsetX + " " + offsetY + " " + blurRadius + " " + color;
  }
};

exports.createBoxShadowValue = createBoxShadowValue;

var createTextShadowValue = style => {
  var textShadowColor = style.textShadowColor,
      textShadowOffset = style.textShadowOffset,
      textShadowRadius = style.textShadowRadius;

  var _ref2 = textShadowOffset || defaultOffset,
      height = _ref2.height,
      width = _ref2.width;

  var radius = textShadowRadius || 0;
  var offsetX = (0, _normalizeValueWithProperty.default)(width);
  var offsetY = (0, _normalizeValueWithProperty.default)(height);
  var blurRadius = (0, _normalizeValueWithProperty.default)(radius);
  var color = (0, _normalizeValueWithProperty.default)(textShadowColor, 'textShadowColor');

  if (color && (height !== 0 || width !== 0 || radius !== 0) && offsetX != null && offsetY != null && blurRadius != null) {
    return offsetX + " " + offsetY + " " + blurRadius + " " + color;
  }
};
/**
 * Preprocess styles
 */


exports.createTextShadowValue = createTextShadowValue;

var preprocess = originalStyle => {
  var style = originalStyle || emptyObject;
  var nextStyle = {};

  for (var originalProp in style) {
    var originalValue = style[originalProp];
    var prop = originalProp;
    var value = originalValue;

    if (!Object.prototype.hasOwnProperty.call(style, originalProp) || originalValue == null) {
      continue;
    } // Convert shadow styles


    if (prop === 'shadowColor' || prop === 'shadowOffset' || prop === 'shadowOpacity' || prop === 'shadowRadius') {
      var boxShadowValue = createBoxShadowValue(style);

      if (boxShadowValue != null && nextStyle.boxShadow == null) {
        var boxShadow = style.boxShadow;
        prop = 'boxShadow';
        value = boxShadow ? boxShadow + ", " + boxShadowValue : boxShadowValue;
      } else {
        continue;
      }
    } // Convert text shadow styles


    if (prop === 'textShadowColor' || prop === 'textShadowOffset' || prop === 'textShadowRadius') {
      var textShadowValue = createTextShadowValue(style);

      if (textShadowValue != null && nextStyle.textShadow == null) {
        var textShadow = style.textShadow;
        prop = 'textShadow';
        value = textShadow ? textShadow + ", " + textShadowValue : textShadowValue;
      } else {
        continue;
      }
    }

    nextStyle[prop] = value;
  } // $FlowIgnore


  return nextStyle;
};

exports.preprocess = preprocess;
var _default = preprocess;
exports["default"] = _default;

/***/ }),

/***/ 46054:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(64836)["default"]);

exports.__esModule = true;
exports.validate = validate;

var _postcssValueParser = _interopRequireDefault(__webpack_require__(460));

/**
 * Copyright (c) Nicolas Gallagher.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
var invalidShortforms = {
  background: true,
  borderBottom: true,
  borderLeft: true,
  borderRight: true,
  borderTop: true,
  font: true,
  grid: true,
  outline: true,
  textDecoration: true
};
var invalidMultiValueShortforms = {
  flex: true,
  margin: true,
  padding: true,
  borderColor: true,
  borderRadius: true,
  borderStyle: true,
  borderWidth: true,
  marginHorizontal: true,
  marginVertical: true,
  paddingHorizontal: true,
  paddingVertical: true,
  overflow: true,
  overscrollBehavior: true,
  backgroundPosition: true
};

function error(message) {
  console.error(message);
}

function validate(obj) {
  for (var k in obj) {
    var prop = k.trim();
    var value = obj[prop];
    var isInvalid = false;

    if (value === null) {
      continue;
    }

    if (typeof value === 'string' && value.indexOf('!important') > -1) {
      error("Invalid style declaration \"" + prop + ":" + value + "\". Values cannot include \"!important\"");
      isInvalid = true;
    } else {
      var suggestion = '';

      if (prop === 'animation' || prop === 'animationName') {
        suggestion = 'Did you mean "animationKeyframes"?'; // } else if (prop === 'boxShadow') {
        //  suggestion = 'Did you mean "shadow{Color,Offset,Opacity,Radius}"?';

        isInvalid = true;
      } else if (prop === 'direction') {
        suggestion = 'Did you mean "writingDirection"?';
        isInvalid = true;
      } else if (prop === 'verticalAlign') {
        suggestion = 'Did you mean "textAlignVertical"?';
        isInvalid = true;
      } else if (invalidShortforms[prop]) {
        suggestion = 'Please use long-form properties.';
        isInvalid = true;
      } else if (invalidMultiValueShortforms[prop]) {
        if (typeof value === 'string' && (0, _postcssValueParser.default)(value).nodes.length > 1) {
          suggestion = "Value is \"" + value + "\" but only single values are supported.";
          isInvalid = true;
        }
      }

      if (suggestion !== '') {
        error("Invalid style property of \"" + prop + "\". " + suggestion);
      }
    }

    if (isInvalid) {
      delete obj[k];
    }
  }
}

/***/ }),

/***/ 96138:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(64836)["default"]);

var _interopRequireWildcard = (__webpack_require__(75263)["default"]);

exports.__esModule = true;
exports["default"] = void 0;

var _objectSpread2 = _interopRequireDefault(__webpack_require__(42122));

var _extends2 = _interopRequireDefault(__webpack_require__(10434));

var _objectWithoutPropertiesLoose2 = _interopRequireDefault(__webpack_require__(7071));

var React = _interopRequireWildcard(__webpack_require__(16689));

var _createElement = _interopRequireDefault(__webpack_require__(63820));

var _multiplyStyleLengthValue = _interopRequireDefault(__webpack_require__(29720));

var _StyleSheet = _interopRequireDefault(__webpack_require__(84099));

var _View = _interopRequireDefault(__webpack_require__(79057));

var _excluded = ["accessibilityLabel", "activeThumbColor", "activeTrackColor", "disabled", "onValueChange", "style", "thumbColor", "trackColor", "value"];
var emptyObject = {};
var thumbDefaultBoxShadow = '0px 1px 3px rgba(0,0,0,0.5)';
var thumbFocusedBoxShadow = thumbDefaultBoxShadow + ", 0 0 0 10px rgba(0,0,0,0.1)";
var defaultActiveTrackColor = '#A3D3CF';
var defaultTrackColor = '#939393';
var defaultDisabledTrackColor = '#D5D5D5';
var defaultActiveThumbColor = '#009688';
var defaultThumbColor = '#FAFAFA';
var defaultDisabledThumbColor = '#BDBDBD';
var Switch = /*#__PURE__*/React.forwardRef((props, forwardedRef) => {
  var accessibilityLabel = props.accessibilityLabel,
      activeThumbColor = props.activeThumbColor,
      activeTrackColor = props.activeTrackColor,
      _props$disabled = props.disabled,
      disabled = _props$disabled === void 0 ? false : _props$disabled,
      onValueChange = props.onValueChange,
      _props$style = props.style,
      style = _props$style === void 0 ? emptyObject : _props$style,
      thumbColor = props.thumbColor,
      trackColor = props.trackColor,
      _props$value = props.value,
      value = _props$value === void 0 ? false : _props$value,
      other = (0, _objectWithoutPropertiesLoose2.default)(props, _excluded);
  var thumbRef = React.useRef(null);

  function handleChange(event) {
    if (onValueChange != null) {
      onValueChange(event.nativeEvent.target.checked);
    }
  }

  function handleFocusState(event) {
    var isFocused = event.nativeEvent.type === 'focus';
    var boxShadow = isFocused ? thumbFocusedBoxShadow : thumbDefaultBoxShadow;

    if (thumbRef.current != null) {
      thumbRef.current.style.boxShadow = boxShadow;
    }
  }

  var _StyleSheet$flatten = _StyleSheet.default.flatten(style),
      styleHeight = _StyleSheet$flatten.height,
      styleWidth = _StyleSheet$flatten.width;

  var height = styleHeight || '20px';
  var minWidth = (0, _multiplyStyleLengthValue.default)(height, 2);
  var width = styleWidth > minWidth ? styleWidth : minWidth;
  var trackBorderRadius = (0, _multiplyStyleLengthValue.default)(height, 0.5);

  var trackCurrentColor = function () {
    if (value === true) {
      if (trackColor != null && typeof trackColor === 'object') {
        return trackColor.true;
      } else {
        return activeTrackColor !== null && activeTrackColor !== void 0 ? activeTrackColor : defaultActiveTrackColor;
      }
    } else {
      if (trackColor != null && typeof trackColor === 'object') {
        return trackColor.false;
      } else {
        return trackColor !== null && trackColor !== void 0 ? trackColor : defaultTrackColor;
      }
    }
  }();

  var thumbCurrentColor = value ? activeThumbColor !== null && activeThumbColor !== void 0 ? activeThumbColor : defaultActiveThumbColor : thumbColor !== null && thumbColor !== void 0 ? thumbColor : defaultThumbColor;
  var thumbHeight = height;
  var thumbWidth = thumbHeight;
  var rootStyle = [styles.root, style, disabled && styles.cursorDefault, {
    height,
    width
  }];

  var disabledTrackColor = function () {
    if (value === true) {
      if (typeof activeTrackColor === 'string' && activeTrackColor != null || typeof trackColor === 'object' && trackColor != null && trackColor.true) {
        return trackCurrentColor;
      } else {
        return defaultDisabledTrackColor;
      }
    } else {
      if (typeof trackColor === 'string' && trackColor != null || typeof trackColor === 'object' && trackColor != null && trackColor.false) {
        return trackCurrentColor;
      } else {
        return defaultDisabledTrackColor;
      }
    }
  }();

  var disabledThumbColor = function () {
    if (value === true) {
      if (activeThumbColor == null) {
        return defaultDisabledThumbColor;
      } else {
        return thumbCurrentColor;
      }
    } else {
      if (thumbColor == null) {
        return defaultDisabledThumbColor;
      } else {
        return thumbCurrentColor;
      }
    }
  }();

  var trackStyle = [styles.track, {
    backgroundColor: disabled ? disabledTrackColor : trackCurrentColor,
    borderRadius: trackBorderRadius
  }];
  var thumbStyle = [styles.thumb, value && styles.thumbActive, {
    backgroundColor: disabled ? disabledThumbColor : thumbCurrentColor,
    height: thumbHeight,
    marginStart: value ? (0, _multiplyStyleLengthValue.default)(thumbWidth, -1) : 0,
    width: thumbWidth
  }];
  var nativeControl = (0, _createElement.default)('input', {
    accessibilityLabel,
    checked: value,
    disabled: disabled,
    onBlur: handleFocusState,
    onChange: handleChange,
    onFocus: handleFocusState,
    ref: forwardedRef,
    style: [styles.nativeControl, styles.cursorInherit],
    type: 'checkbox',
    role: 'switch'
  });
  return /*#__PURE__*/React.createElement(_View.default, (0, _extends2.default)({}, other, {
    style: rootStyle
  }), /*#__PURE__*/React.createElement(_View.default, {
    style: trackStyle
  }), /*#__PURE__*/React.createElement(_View.default, {
    ref: thumbRef,
    style: thumbStyle
  }), nativeControl);
});
Switch.displayName = 'Switch';

var styles = _StyleSheet.default.create({
  root: {
    cursor: 'pointer',
    userSelect: 'none'
  },
  cursorDefault: {
    cursor: 'default'
  },
  cursorInherit: {
    cursor: 'inherit'
  },
  track: (0, _objectSpread2.default)((0, _objectSpread2.default)({
    forcedColorAdjust: 'none'
  }, _StyleSheet.default.absoluteFillObject), {}, {
    height: '70%',
    margin: 'auto',
    transitionDuration: '0.1s',
    width: '100%'
  }),
  thumb: {
    forcedColorAdjust: 'none',
    alignSelf: 'flex-start',
    borderRadius: '100%',
    boxShadow: thumbDefaultBoxShadow,
    start: '0%',
    transform: [{
      translateZ: 0
    }],
    transitionDuration: '0.1s'
  },
  thumbActive: {
    start: '100%'
  },
  nativeControl: (0, _objectSpread2.default)((0, _objectSpread2.default)({}, _StyleSheet.default.absoluteFillObject), {}, {
    height: '100%',
    margin: 0,
    appearance: 'none',
    padding: 0,
    width: '100%'
  })
});

var _default = Switch;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),

/***/ 84242:
/***/ ((module, exports) => {

"use strict";


exports.__esModule = true;
exports["default"] = void 0;
var _default = {};
exports["default"] = _default;
module.exports = exports.default;

/***/ }),

/***/ 4385:
/***/ ((module, exports) => {

"use strict";


exports.__esModule = true;
exports["default"] = void 0;
var _default = {};
exports["default"] = _default;
module.exports = exports.default;

/***/ }),

/***/ 64941:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(64836)["default"]);

var _interopRequireWildcard = (__webpack_require__(75263)["default"]);

exports.__esModule = true;
exports["default"] = void 0;

var React = _interopRequireWildcard(__webpack_require__(16689));

var _createElement = _interopRequireDefault(__webpack_require__(63820));

var forwardedProps = _interopRequireWildcard(__webpack_require__(24475));

var _pick = _interopRequireDefault(__webpack_require__(27447));

var _useElementLayout = _interopRequireDefault(__webpack_require__(98954));

var _useLayoutEffect = _interopRequireDefault(__webpack_require__(63320));

var _useMergeRefs = _interopRequireDefault(__webpack_require__(88391));

var _usePlatformMethods = _interopRequireDefault(__webpack_require__(92187));

var _useResponderEvents = _interopRequireDefault(__webpack_require__(36758));

var _useLocale = __webpack_require__(82901);

var _StyleSheet = _interopRequireDefault(__webpack_require__(84099));

var _TextInputState = _interopRequireDefault(__webpack_require__(20551));

/**
 * Copyright (c) Nicolas Gallagher.
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

/**
 * Determines whether a 'selection' prop differs from a node's existing
 * selection state.
 */
var isSelectionStale = (node, selection) => {
  var selectionEnd = node.selectionEnd,
      selectionStart = node.selectionStart;
  var start = selection.start,
      end = selection.end;
  return start !== selectionStart || end !== selectionEnd;
};
/**
 * Certain input types do no support 'selectSelectionRange' and will throw an
 * error.
 */


var setSelection = (node, selection) => {
  if (isSelectionStale(node, selection)) {
    var start = selection.start,
        end = selection.end;

    try {
      node.setSelectionRange(start, end || start);
    } catch (e) {}
  }
};

var forwardPropsList = Object.assign({}, forwardedProps.defaultProps, forwardedProps.accessibilityProps, forwardedProps.clickProps, forwardedProps.focusProps, forwardedProps.keyboardProps, forwardedProps.mouseProps, forwardedProps.touchProps, forwardedProps.styleProps, {
  autoCapitalize: true,
  autoComplete: true,
  autoCorrect: true,
  autoFocus: true,
  defaultValue: true,
  disabled: true,
  lang: true,
  maxLength: true,
  onChange: true,
  onScroll: true,
  placeholder: true,
  pointerEvents: true,
  readOnly: true,
  rows: true,
  spellCheck: true,
  value: true,
  type: true
});

var pickProps = props => (0, _pick.default)(props, forwardPropsList); // If an Input Method Editor is processing key input, the 'keyCode' is 229.
// https://www.w3.org/TR/uievents/#determine-keydown-keyup-keyCode


function isEventComposing(nativeEvent) {
  return nativeEvent.isComposing || nativeEvent.keyCode === 229;
}

var focusTimeout = null;
var TextInput = /*#__PURE__*/React.forwardRef((props, forwardedRef) => {
  var _props$autoCapitalize = props.autoCapitalize,
      autoCapitalize = _props$autoCapitalize === void 0 ? 'sentences' : _props$autoCapitalize,
      autoComplete = props.autoComplete,
      autoCompleteType = props.autoCompleteType,
      _props$autoCorrect = props.autoCorrect,
      autoCorrect = _props$autoCorrect === void 0 ? true : _props$autoCorrect,
      blurOnSubmit = props.blurOnSubmit,
      clearTextOnFocus = props.clearTextOnFocus,
      dir = props.dir,
      _props$editable = props.editable,
      editable = _props$editable === void 0 ? true : _props$editable,
      _props$keyboardType = props.keyboardType,
      keyboardType = _props$keyboardType === void 0 ? 'default' : _props$keyboardType,
      _props$multiline = props.multiline,
      multiline = _props$multiline === void 0 ? false : _props$multiline,
      _props$numberOfLines = props.numberOfLines,
      numberOfLines = _props$numberOfLines === void 0 ? 1 : _props$numberOfLines,
      onBlur = props.onBlur,
      onChange = props.onChange,
      onChangeText = props.onChangeText,
      onContentSizeChange = props.onContentSizeChange,
      onFocus = props.onFocus,
      onKeyPress = props.onKeyPress,
      onLayout = props.onLayout,
      onMoveShouldSetResponder = props.onMoveShouldSetResponder,
      onMoveShouldSetResponderCapture = props.onMoveShouldSetResponderCapture,
      onResponderEnd = props.onResponderEnd,
      onResponderGrant = props.onResponderGrant,
      onResponderMove = props.onResponderMove,
      onResponderReject = props.onResponderReject,
      onResponderRelease = props.onResponderRelease,
      onResponderStart = props.onResponderStart,
      onResponderTerminate = props.onResponderTerminate,
      onResponderTerminationRequest = props.onResponderTerminationRequest,
      onScrollShouldSetResponder = props.onScrollShouldSetResponder,
      onScrollShouldSetResponderCapture = props.onScrollShouldSetResponderCapture,
      onSelectionChange = props.onSelectionChange,
      onSelectionChangeShouldSetResponder = props.onSelectionChangeShouldSetResponder,
      onSelectionChangeShouldSetResponderCapture = props.onSelectionChangeShouldSetResponderCapture,
      onStartShouldSetResponder = props.onStartShouldSetResponder,
      onStartShouldSetResponderCapture = props.onStartShouldSetResponderCapture,
      onSubmitEditing = props.onSubmitEditing,
      placeholderTextColor = props.placeholderTextColor,
      returnKeyType = props.returnKeyType,
      _props$secureTextEntr = props.secureTextEntry,
      secureTextEntry = _props$secureTextEntr === void 0 ? false : _props$secureTextEntr,
      selection = props.selection,
      selectTextOnFocus = props.selectTextOnFocus,
      spellCheck = props.spellCheck;
  var type;
  var inputMode;

  switch (keyboardType) {
    case 'email-address':
      type = 'email';
      break;

    case 'number-pad':
    case 'numeric':
      inputMode = 'numeric';
      break;

    case 'decimal-pad':
      inputMode = 'decimal';
      break;

    case 'phone-pad':
      type = 'tel';
      break;

    case 'search':
    case 'web-search':
      type = 'search';
      break;

    case 'url':
      type = 'url';
      break;

    default:
      type = 'text';
  }

  if (secureTextEntry) {
    type = 'password';
  }

  var dimensions = React.useRef({
    height: null,
    width: null
  });
  var hostRef = React.useRef(null);
  var handleContentSizeChange = React.useCallback(hostNode => {
    if (multiline && onContentSizeChange && hostNode != null) {
      var newHeight = hostNode.scrollHeight;
      var newWidth = hostNode.scrollWidth;

      if (newHeight !== dimensions.current.height || newWidth !== dimensions.current.width) {
        dimensions.current.height = newHeight;
        dimensions.current.width = newWidth;
        onContentSizeChange({
          nativeEvent: {
            contentSize: {
              height: dimensions.current.height,
              width: dimensions.current.width
            }
          }
        });
      }
    }
  }, [multiline, onContentSizeChange]);
  var imperativeRef = React.useMemo(() => hostNode => {
    // TextInput needs to add more methods to the hostNode in addition to those
    // added by `usePlatformMethods`. This is temporarily until an API like
    // `TextInput.clear(hostRef)` is added to React Native.
    if (hostNode != null) {
      hostNode.clear = function () {
        if (hostNode != null) {
          hostNode.value = '';
        }
      };

      hostNode.isFocused = function () {
        return hostNode != null && _TextInputState.default.currentlyFocusedField() === hostNode;
      };

      handleContentSizeChange(hostNode);
    }
  }, [handleContentSizeChange]);

  function handleBlur(e) {
    _TextInputState.default._currentlyFocusedNode = null;

    if (onBlur) {
      e.nativeEvent.text = e.target.value;
      onBlur(e);
    }
  }

  function handleChange(e) {
    var hostNode = e.target;
    var text = hostNode.value;
    e.nativeEvent.text = text;
    handleContentSizeChange(hostNode);

    if (onChange) {
      onChange(e);
    }

    if (onChangeText) {
      onChangeText(text);
    }
  }

  function handleFocus(e) {
    var hostNode = e.target;

    if (onFocus) {
      e.nativeEvent.text = hostNode.value;
      onFocus(e);
    }

    if (hostNode != null) {
      _TextInputState.default._currentlyFocusedNode = hostNode;

      if (clearTextOnFocus) {
        hostNode.value = '';
      }

      if (selectTextOnFocus) {
        // Safari requires selection to occur in a setTimeout
        if (focusTimeout != null) {
          clearTimeout(focusTimeout);
        }

        focusTimeout = setTimeout(() => {
          if (hostNode != null) {
            hostNode.select();
          }
        }, 0);
      }
    }
  }

  function handleKeyDown(e) {
    var hostNode = e.target; // Prevent key events bubbling (see #612)

    e.stopPropagation();
    var blurOnSubmitDefault = !multiline;
    var shouldBlurOnSubmit = blurOnSubmit == null ? blurOnSubmitDefault : blurOnSubmit;
    var nativeEvent = e.nativeEvent;
    var isComposing = isEventComposing(nativeEvent);

    if (onKeyPress) {
      onKeyPress(e);
    }

    if (e.key === 'Enter' && !e.shiftKey && // Do not call submit if composition is occuring.
    !isComposing && !e.isDefaultPrevented()) {
      if ((blurOnSubmit || !multiline) && onSubmitEditing) {
        // prevent "Enter" from inserting a newline or submitting a form
        e.preventDefault();
        nativeEvent.text = e.target.value;
        onSubmitEditing(e);
      }

      if (shouldBlurOnSubmit && hostNode != null) {
        setTimeout(() => hostNode.blur(), 0);
      }
    }
  }

  function handleSelectionChange(e) {
    if (onSelectionChange) {
      try {
        var node = e.target;
        var selectionStart = node.selectionStart,
            selectionEnd = node.selectionEnd;
        e.nativeEvent.selection = {
          start: selectionStart,
          end: selectionEnd
        };
        e.nativeEvent.text = e.target.value;
        onSelectionChange(e);
      } catch (e) {}
    }
  }

  (0, _useLayoutEffect.default)(() => {
    var node = hostRef.current;

    if (node != null && selection != null) {
      setSelection(node, selection);
    }

    if (document.activeElement === node) {
      _TextInputState.default._currentlyFocusedNode = node;
    }
  }, [hostRef, selection]);
  var component = multiline ? 'textarea' : 'input';
  (0, _useElementLayout.default)(hostRef, onLayout);
  (0, _useResponderEvents.default)(hostRef, {
    onMoveShouldSetResponder,
    onMoveShouldSetResponderCapture,
    onResponderEnd,
    onResponderGrant,
    onResponderMove,
    onResponderReject,
    onResponderRelease,
    onResponderStart,
    onResponderTerminate,
    onResponderTerminationRequest,
    onScrollShouldSetResponder,
    onScrollShouldSetResponderCapture,
    onSelectionChangeShouldSetResponder,
    onSelectionChangeShouldSetResponderCapture,
    onStartShouldSetResponder,
    onStartShouldSetResponderCapture
  });

  var _useLocaleContext = (0, _useLocale.useLocaleContext)(),
      contextDirection = _useLocaleContext.direction;

  var supportedProps = pickProps(props);
  supportedProps.autoCapitalize = autoCapitalize;
  supportedProps.autoComplete = autoComplete || autoCompleteType || 'on';
  supportedProps.autoCorrect = autoCorrect ? 'on' : 'off'; // 'auto' by default allows browsers to infer writing direction

  supportedProps.dir = dir !== undefined ? dir : 'auto';
  supportedProps.enterKeyHint = returnKeyType;
  supportedProps.inputMode = inputMode;
  supportedProps.onBlur = handleBlur;
  supportedProps.onChange = handleChange;
  supportedProps.onFocus = handleFocus;
  supportedProps.onKeyDown = handleKeyDown;
  supportedProps.onSelect = handleSelectionChange;
  supportedProps.readOnly = !editable;
  supportedProps.rows = multiline ? numberOfLines : undefined;
  supportedProps.spellCheck = spellCheck != null ? spellCheck : autoCorrect;
  supportedProps.style = [{
    '--placeholderTextColor': placeholderTextColor
  }, styles.textinput$raw, styles.placeholder, props.style];
  supportedProps.type = multiline ? undefined : type;
  var platformMethodsRef = (0, _usePlatformMethods.default)(supportedProps);
  var setRef = (0, _useMergeRefs.default)(hostRef, platformMethodsRef, imperativeRef, forwardedRef);
  supportedProps.ref = setRef;
  var langDirection = props.lang != null ? (0, _useLocale.getLocaleDirection)(props.lang) : null;
  var componentDirection = props.dir || langDirection;
  var writingDirection = componentDirection || contextDirection;
  var element = (0, _createElement.default)(component, supportedProps, {
    writingDirection
  });
  return element;
});
TextInput.displayName = 'TextInput'; // $FlowFixMe

TextInput.State = _TextInputState.default;

var styles = _StyleSheet.default.create({
  textinput$raw: {
    MozAppearance: 'textfield',
    WebkitAppearance: 'none',
    backgroundColor: 'transparent',
    border: '0 solid black',
    borderRadius: 0,
    boxSizing: 'border-box',
    font: '14px System',
    margin: 0,
    padding: 0,
    resize: 'none'
  },
  placeholder: {
    placeholderTextColor: 'var(--placeholderTextColor)'
  }
});

var _default = TextInput;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),

/***/ 47905:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


exports.__esModule = true;
exports["default"] = void 0;

var _react = __webpack_require__(16689);

/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
var TextAncestorContext = /*#__PURE__*/(0, _react.createContext)(false);
var _default = TextAncestorContext;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),

/***/ 48409:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(64836)["default"]);

var _interopRequireWildcard = (__webpack_require__(75263)["default"]);

exports.__esModule = true;
exports["default"] = void 0;

var _objectSpread2 = _interopRequireDefault(__webpack_require__(42122));

var _objectWithoutPropertiesLoose2 = _interopRequireDefault(__webpack_require__(7071));

var React = _interopRequireWildcard(__webpack_require__(16689));

var _createElement = _interopRequireDefault(__webpack_require__(63820));

var forwardedProps = _interopRequireWildcard(__webpack_require__(24475));

var _pick = _interopRequireDefault(__webpack_require__(27447));

var _useElementLayout = _interopRequireDefault(__webpack_require__(98954));

var _useMergeRefs = _interopRequireDefault(__webpack_require__(88391));

var _usePlatformMethods = _interopRequireDefault(__webpack_require__(92187));

var _useResponderEvents = _interopRequireDefault(__webpack_require__(36758));

var _StyleSheet = _interopRequireDefault(__webpack_require__(84099));

var _TextAncestorContext = _interopRequireDefault(__webpack_require__(47905));

var _useLocale = __webpack_require__(82901);

var _excluded = ["hrefAttrs", "numberOfLines", "onClick", "onLayout", "onPress", "onMoveShouldSetResponder", "onMoveShouldSetResponderCapture", "onResponderEnd", "onResponderGrant", "onResponderMove", "onResponderReject", "onResponderRelease", "onResponderStart", "onResponderTerminate", "onResponderTerminationRequest", "onScrollShouldSetResponder", "onScrollShouldSetResponderCapture", "onSelectionChangeShouldSetResponder", "onSelectionChangeShouldSetResponderCapture", "onStartShouldSetResponder", "onStartShouldSetResponderCapture", "selectable"];
var forwardPropsList = Object.assign({}, forwardedProps.defaultProps, forwardedProps.accessibilityProps, forwardedProps.clickProps, forwardedProps.focusProps, forwardedProps.keyboardProps, forwardedProps.mouseProps, forwardedProps.touchProps, forwardedProps.styleProps, {
  href: true,
  lang: true,
  pointerEvents: true
});

var pickProps = props => (0, _pick.default)(props, forwardPropsList);

var Text = /*#__PURE__*/React.forwardRef((props, forwardedRef) => {
  var hrefAttrs = props.hrefAttrs,
      numberOfLines = props.numberOfLines,
      onClick = props.onClick,
      onLayout = props.onLayout,
      onPress = props.onPress,
      onMoveShouldSetResponder = props.onMoveShouldSetResponder,
      onMoveShouldSetResponderCapture = props.onMoveShouldSetResponderCapture,
      onResponderEnd = props.onResponderEnd,
      onResponderGrant = props.onResponderGrant,
      onResponderMove = props.onResponderMove,
      onResponderReject = props.onResponderReject,
      onResponderRelease = props.onResponderRelease,
      onResponderStart = props.onResponderStart,
      onResponderTerminate = props.onResponderTerminate,
      onResponderTerminationRequest = props.onResponderTerminationRequest,
      onScrollShouldSetResponder = props.onScrollShouldSetResponder,
      onScrollShouldSetResponderCapture = props.onScrollShouldSetResponderCapture,
      onSelectionChangeShouldSetResponder = props.onSelectionChangeShouldSetResponder,
      onSelectionChangeShouldSetResponderCapture = props.onSelectionChangeShouldSetResponderCapture,
      onStartShouldSetResponder = props.onStartShouldSetResponder,
      onStartShouldSetResponderCapture = props.onStartShouldSetResponderCapture,
      selectable = props.selectable,
      rest = (0, _objectWithoutPropertiesLoose2.default)(props, _excluded);
  var hasTextAncestor = React.useContext(_TextAncestorContext.default);
  var hostRef = React.useRef(null);

  var _useLocaleContext = (0, _useLocale.useLocaleContext)(),
      contextDirection = _useLocaleContext.direction;

  (0, _useElementLayout.default)(hostRef, onLayout);
  (0, _useResponderEvents.default)(hostRef, {
    onMoveShouldSetResponder,
    onMoveShouldSetResponderCapture,
    onResponderEnd,
    onResponderGrant,
    onResponderMove,
    onResponderReject,
    onResponderRelease,
    onResponderStart,
    onResponderTerminate,
    onResponderTerminationRequest,
    onScrollShouldSetResponder,
    onScrollShouldSetResponderCapture,
    onSelectionChangeShouldSetResponder,
    onSelectionChangeShouldSetResponderCapture,
    onStartShouldSetResponder,
    onStartShouldSetResponderCapture
  });
  var handleClick = React.useCallback(e => {
    if (onClick != null) {
      onClick(e);
    } else if (onPress != null) {
      e.stopPropagation();
      onPress(e);
    }
  }, [onClick, onPress]);
  var component = hasTextAncestor ? 'span' : 'div';
  var langDirection = props.lang != null ? (0, _useLocale.getLocaleDirection)(props.lang) : null;
  var componentDirection = props.dir || langDirection;
  var writingDirection = componentDirection || contextDirection;
  var supportedProps = pickProps(rest);
  supportedProps.dir = componentDirection; // 'auto' by default allows browsers to infer writing direction (root elements only)

  if (!hasTextAncestor) {
    supportedProps.dir = componentDirection != null ? componentDirection : 'auto';
  }

  if (onClick || onPress) {
    supportedProps.onClick = handleClick;
  }

  supportedProps.style = [numberOfLines != null && numberOfLines > 1 && {
    WebkitLineClamp: numberOfLines
  }, hasTextAncestor === true ? styles.textHasAncestor$raw : styles.text$raw, numberOfLines === 1 && styles.textOneLine, numberOfLines != null && numberOfLines > 1 && styles.textMultiLine, props.style, selectable === true && styles.selectable, selectable === false && styles.notSelectable, onPress && styles.pressable];

  if (props.href != null) {
    component = 'a';

    if (hrefAttrs != null) {
      var download = hrefAttrs.download,
          rel = hrefAttrs.rel,
          target = hrefAttrs.target;

      if (download != null) {
        supportedProps.download = download;
      }

      if (rel != null) {
        supportedProps.rel = rel;
      }

      if (typeof target === 'string') {
        supportedProps.target = target.charAt(0) !== '_' ? '_' + target : target;
      }
    }
  }

  var platformMethodsRef = (0, _usePlatformMethods.default)(supportedProps);
  var setRef = (0, _useMergeRefs.default)(hostRef, platformMethodsRef, forwardedRef);
  supportedProps.ref = setRef;
  var element = (0, _createElement.default)(component, supportedProps, {
    writingDirection
  });
  return hasTextAncestor ? element : /*#__PURE__*/React.createElement(_TextAncestorContext.default.Provider, {
    value: true
  }, element);
});
Text.displayName = 'Text';
var textStyle = {
  backgroundColor: 'transparent',
  border: '0 solid black',
  boxSizing: 'border-box',
  color: 'black',
  display: 'inline',
  font: '14px System',
  listStyle: 'none',
  margin: 0,
  padding: 0,
  textAlign: 'inherit',
  textDecoration: 'none',
  whiteSpace: 'pre-wrap',
  wordWrap: 'break-word'
};

var styles = _StyleSheet.default.create({
  text$raw: textStyle,
  textHasAncestor$raw: (0, _objectSpread2.default)((0, _objectSpread2.default)({}, textStyle), {}, {
    color: 'inherit',
    font: 'inherit',
    whiteSpace: 'inherit'
  }),
  textOneLine: {
    maxWidth: '100%',
    overflow: 'hidden',
    textOverflow: 'ellipsis',
    whiteSpace: 'nowrap',
    wordWrap: 'normal'
  },
  // See #13
  textMultiLine: {
    display: '-webkit-box',
    maxWidth: '100%',
    overflow: 'hidden',
    textOverflow: 'ellipsis',
    WebkitBoxOrient: 'vertical'
  },
  notSelectable: {
    userSelect: 'none'
  },
  selectable: {
    userSelect: 'text'
  },
  pressable: {
    cursor: 'pointer'
  }
});

var _default = Text;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),

/***/ 7131:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(64836)["default"]);

exports.__esModule = true;
exports["default"] = void 0;

var _UnimplementedView = _interopRequireDefault(__webpack_require__(85261));

var _default = _UnimplementedView.default;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),

/***/ 28865:
/***/ ((module, exports, __webpack_require__) => {

"use strict";
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 */


var _interopRequireDefault = (__webpack_require__(64836)["default"]);

var _interopRequireWildcard = (__webpack_require__(75263)["default"]);

exports.__esModule = true;
exports["default"] = void 0;

var _extends2 = _interopRequireDefault(__webpack_require__(10434));

var _objectWithoutPropertiesLoose2 = _interopRequireDefault(__webpack_require__(7071));

var React = _interopRequireWildcard(__webpack_require__(16689));

var _useMergeRefs = _interopRequireDefault(__webpack_require__(88391));

var _usePressEvents = _interopRequireDefault(__webpack_require__(24982));

var _StyleSheet = _interopRequireDefault(__webpack_require__(84099));

var _View = _interopRequireDefault(__webpack_require__(79057));

var _excluded = ["activeOpacity", "children", "delayPressIn", "delayPressOut", "delayLongPress", "disabled", "focusable", "onHideUnderlay", "onLongPress", "onPress", "onPressIn", "onPressOut", "onShowUnderlay", "rejectResponderTermination", "style", "testOnly_pressed", "underlayColor"];

function createExtraStyles(activeOpacity, underlayColor) {
  return {
    child: {
      opacity: activeOpacity !== null && activeOpacity !== void 0 ? activeOpacity : 0.85
    },
    underlay: {
      backgroundColor: underlayColor === undefined ? 'black' : underlayColor
    }
  };
}

function hasPressHandler(props) {
  return props.onPress != null || props.onPressIn != null || props.onPressOut != null || props.onLongPress != null;
}
/**
 * A wrapper for making views respond properly to touches.
 * On press down, the opacity of the wrapped view is decreased, which allows
 * the underlay color to show through, darkening or tinting the view.
 *
 * The underlay comes from wrapping the child in a new View, which can affect
 * layout, and sometimes cause unwanted visual artifacts if not used correctly,
 * for example if the backgroundColor of the wrapped view isn't explicitly set
 * to an opaque color.
 *
 * TouchableHighlight must have one child (not zero or more than one).
 * If you wish to have several child components, wrap them in a View.
 */


function TouchableHighlight(props, forwardedRef) {
  var activeOpacity = props.activeOpacity,
      children = props.children,
      delayPressIn = props.delayPressIn,
      delayPressOut = props.delayPressOut,
      delayLongPress = props.delayLongPress,
      disabled = props.disabled,
      focusable = props.focusable,
      onHideUnderlay = props.onHideUnderlay,
      onLongPress = props.onLongPress,
      onPress = props.onPress,
      onPressIn = props.onPressIn,
      onPressOut = props.onPressOut,
      onShowUnderlay = props.onShowUnderlay,
      rejectResponderTermination = props.rejectResponderTermination,
      style = props.style,
      testOnly_pressed = props.testOnly_pressed,
      underlayColor = props.underlayColor,
      rest = (0, _objectWithoutPropertiesLoose2.default)(props, _excluded);
  var hostRef = (0, React.useRef)(null);
  var setRef = (0, _useMergeRefs.default)(forwardedRef, hostRef);

  var _useState = (0, React.useState)(testOnly_pressed === true ? createExtraStyles(activeOpacity, underlayColor) : null),
      extraStyles = _useState[0],
      setExtraStyles = _useState[1];

  var showUnderlay = (0, React.useCallback)(() => {
    if (!hasPressHandler(props)) {
      return;
    }

    setExtraStyles(createExtraStyles(activeOpacity, underlayColor));

    if (onShowUnderlay != null) {
      onShowUnderlay();
    }
  }, [activeOpacity, onShowUnderlay, props, underlayColor]);
  var hideUnderlay = (0, React.useCallback)(() => {
    if (testOnly_pressed === true) {
      return;
    }

    if (hasPressHandler(props)) {
      setExtraStyles(null);

      if (onHideUnderlay != null) {
        onHideUnderlay();
      }
    }
  }, [onHideUnderlay, props, testOnly_pressed]);
  var pressConfig = (0, React.useMemo)(() => ({
    cancelable: !rejectResponderTermination,
    disabled,
    delayLongPress,
    delayPressStart: delayPressIn,
    delayPressEnd: delayPressOut,
    onLongPress,
    onPress,

    onPressStart(event) {
      showUnderlay();

      if (onPressIn != null) {
        onPressIn(event);
      }
    },

    onPressEnd(event) {
      hideUnderlay();

      if (onPressOut != null) {
        onPressOut(event);
      }
    }

  }), [delayLongPress, delayPressIn, delayPressOut, disabled, onLongPress, onPress, onPressIn, onPressOut, rejectResponderTermination, showUnderlay, hideUnderlay]);
  var pressEventHandlers = (0, _usePressEvents.default)(hostRef, pressConfig);
  var child = React.Children.only(children);
  return /*#__PURE__*/React.createElement(_View.default, (0, _extends2.default)({}, rest, pressEventHandlers, {
    accessibilityDisabled: disabled,
    focusable: !disabled && focusable !== false,
    pointerEvents: disabled ? 'none' : undefined,
    ref: setRef,
    style: [styles.root, style, !disabled && styles.actionable, extraStyles && extraStyles.underlay]
  }), /*#__PURE__*/React.cloneElement(child, {
    style: _StyleSheet.default.compose(child.props.style, extraStyles && extraStyles.child)
  }));
}

var styles = _StyleSheet.default.create({
  root: {
    userSelect: 'none'
  },
  actionable: {
    cursor: 'pointer',
    touchAction: 'manipulation'
  }
});

var MemoedTouchableHighlight = /*#__PURE__*/React.memo( /*#__PURE__*/React.forwardRef(TouchableHighlight));
MemoedTouchableHighlight.displayName = 'TouchableHighlight';
var _default = MemoedTouchableHighlight;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),

/***/ 762:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(64836)["default"]);

exports.__esModule = true;
exports["default"] = void 0;

var _UnimplementedView = _interopRequireDefault(__webpack_require__(85261));

/**
 * Copyright (c) Nicolas Gallagher.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
var _default = _UnimplementedView.default;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),

/***/ 28908:
/***/ ((module, exports, __webpack_require__) => {

"use strict";
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 */


var _interopRequireDefault = (__webpack_require__(64836)["default"]);

var _interopRequireWildcard = (__webpack_require__(75263)["default"]);

exports.__esModule = true;
exports["default"] = void 0;

var _extends2 = _interopRequireDefault(__webpack_require__(10434));

var _objectWithoutPropertiesLoose2 = _interopRequireDefault(__webpack_require__(7071));

var React = _interopRequireWildcard(__webpack_require__(16689));

var _useMergeRefs = _interopRequireDefault(__webpack_require__(88391));

var _usePressEvents = _interopRequireDefault(__webpack_require__(24982));

var _StyleSheet = _interopRequireDefault(__webpack_require__(84099));

var _View = _interopRequireDefault(__webpack_require__(79057));

var _excluded = ["activeOpacity", "delayPressIn", "delayPressOut", "delayLongPress", "disabled", "focusable", "onLongPress", "onPress", "onPressIn", "onPressOut", "rejectResponderTermination", "style"];

/**
 * A wrapper for making views respond properly to touches.
 * On press down, the opacity of the wrapped view is decreased, dimming it.
 */
function TouchableOpacity(props, forwardedRef) {
  var activeOpacity = props.activeOpacity,
      delayPressIn = props.delayPressIn,
      delayPressOut = props.delayPressOut,
      delayLongPress = props.delayLongPress,
      disabled = props.disabled,
      focusable = props.focusable,
      onLongPress = props.onLongPress,
      onPress = props.onPress,
      onPressIn = props.onPressIn,
      onPressOut = props.onPressOut,
      rejectResponderTermination = props.rejectResponderTermination,
      style = props.style,
      rest = (0, _objectWithoutPropertiesLoose2.default)(props, _excluded);
  var hostRef = (0, React.useRef)(null);
  var setRef = (0, _useMergeRefs.default)(forwardedRef, hostRef);

  var _useState = (0, React.useState)('0s'),
      duration = _useState[0],
      setDuration = _useState[1];

  var _useState2 = (0, React.useState)(null),
      opacityOverride = _useState2[0],
      setOpacityOverride = _useState2[1];

  var setOpacityTo = (0, React.useCallback)((value, duration) => {
    setOpacityOverride(value);
    setDuration(duration ? duration / 1000 + "s" : '0s');
  }, [setOpacityOverride, setDuration]);
  var setOpacityActive = (0, React.useCallback)(duration => {
    setOpacityTo(activeOpacity !== null && activeOpacity !== void 0 ? activeOpacity : 0.2, duration);
  }, [activeOpacity, setOpacityTo]);
  var setOpacityInactive = (0, React.useCallback)(duration => {
    setOpacityTo(null, duration);
  }, [setOpacityTo]);
  var pressConfig = (0, React.useMemo)(() => ({
    cancelable: !rejectResponderTermination,
    disabled,
    delayLongPress,
    delayPressStart: delayPressIn,
    delayPressEnd: delayPressOut,
    onLongPress,
    onPress,

    onPressStart(event) {
      var isGrant = event.dispatchConfig != null ? event.dispatchConfig.registrationName === 'onResponderGrant' : event.type === 'keydown';
      setOpacityActive(isGrant ? 0 : 150);

      if (onPressIn != null) {
        onPressIn(event);
      }
    },

    onPressEnd(event) {
      setOpacityInactive(250);

      if (onPressOut != null) {
        onPressOut(event);
      }
    }

  }), [delayLongPress, delayPressIn, delayPressOut, disabled, onLongPress, onPress, onPressIn, onPressOut, rejectResponderTermination, setOpacityActive, setOpacityInactive]);
  var pressEventHandlers = (0, _usePressEvents.default)(hostRef, pressConfig);
  return /*#__PURE__*/React.createElement(_View.default, (0, _extends2.default)({}, rest, pressEventHandlers, {
    accessibilityDisabled: disabled,
    focusable: !disabled && focusable !== false,
    pointerEvents: disabled ? 'none' : undefined,
    ref: setRef,
    style: [styles.root, !disabled && styles.actionable, style, opacityOverride != null && {
      opacity: opacityOverride
    }, {
      transitionDuration: duration
    }]
  }));
}

var styles = _StyleSheet.default.create({
  root: {
    transitionProperty: 'opacity',
    transitionDuration: '0.15s',
    userSelect: 'none'
  },
  actionable: {
    cursor: 'pointer',
    touchAction: 'manipulation'
  }
});

var MemoedTouchableOpacity = /*#__PURE__*/React.memo( /*#__PURE__*/React.forwardRef(TouchableOpacity));
MemoedTouchableOpacity.displayName = 'TouchableOpacity';
var _default = MemoedTouchableOpacity;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),

/***/ 15248:
/***/ ((module, exports, __webpack_require__) => {

"use strict";
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 */


var _interopRequireDefault = (__webpack_require__(64836)["default"]);

var _interopRequireWildcard = (__webpack_require__(75263)["default"]);

exports.__esModule = true;
exports["default"] = void 0;

var React = _interopRequireWildcard(__webpack_require__(16689));

var _pick = _interopRequireDefault(__webpack_require__(27447));

var _useMergeRefs = _interopRequireDefault(__webpack_require__(88391));

var _usePressEvents = _interopRequireDefault(__webpack_require__(24982));

var forwardPropsList = {
  accessibilityDisabled: true,
  accessibilityLabel: true,
  accessibilityLiveRegion: true,
  accessibilityRole: true,
  accessibilityState: true,
  accessibilityValue: true,
  children: true,
  disabled: true,
  focusable: true,
  nativeID: true,
  onBlur: true,
  onFocus: true,
  onLayout: true,
  testID: true
};

var pickProps = props => (0, _pick.default)(props, forwardPropsList);

function TouchableWithoutFeedback(props, forwardedRef) {
  var delayPressIn = props.delayPressIn,
      delayPressOut = props.delayPressOut,
      delayLongPress = props.delayLongPress,
      disabled = props.disabled,
      focusable = props.focusable,
      onLongPress = props.onLongPress,
      onPress = props.onPress,
      onPressIn = props.onPressIn,
      onPressOut = props.onPressOut,
      rejectResponderTermination = props.rejectResponderTermination;
  var hostRef = (0, React.useRef)(null);
  var pressConfig = (0, React.useMemo)(() => ({
    cancelable: !rejectResponderTermination,
    disabled,
    delayLongPress,
    delayPressStart: delayPressIn,
    delayPressEnd: delayPressOut,
    onLongPress,
    onPress,
    onPressStart: onPressIn,
    onPressEnd: onPressOut
  }), [disabled, delayPressIn, delayPressOut, delayLongPress, onLongPress, onPress, onPressIn, onPressOut, rejectResponderTermination]);
  var pressEventHandlers = (0, _usePressEvents.default)(hostRef, pressConfig);
  var element = React.Children.only(props.children);
  var children = [element.props.children];
  var supportedProps = pickProps(props);
  supportedProps.accessibilityDisabled = disabled;
  supportedProps.focusable = !disabled && focusable !== false;
  supportedProps.ref = (0, _useMergeRefs.default)(forwardedRef, hostRef, element.ref);
  var elementProps = Object.assign(supportedProps, pressEventHandlers);
  return /*#__PURE__*/React.cloneElement(element, elementProps, ...children);
}

var MemoedTouchableWithoutFeedback = /*#__PURE__*/React.memo( /*#__PURE__*/React.forwardRef(TouchableWithoutFeedback));
MemoedTouchableWithoutFeedback.displayName = 'TouchableWithoutFeedback';
var _default = MemoedTouchableWithoutFeedback;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),

/***/ 61158:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(64836)["default"]);

exports.__esModule = true;
exports["default"] = void 0;

var _PooledClass = _interopRequireDefault(__webpack_require__(25919));

/**
 * Copyright (c) Nicolas Gallagher.
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
var twoArgumentPooler = _PooledClass.default.twoArgumentPooler;
/**
 * PooledClass representing the bounding rectangle of a region.
 */

function BoundingDimensions(width, height) {
  this.width = width;
  this.height = height;
}

BoundingDimensions.prototype.destructor = function () {
  this.width = null;
  this.height = null;
};

BoundingDimensions.getPooledFromElement = function (element) {
  return BoundingDimensions.getPooled(element.offsetWidth, element.offsetHeight);
};

_PooledClass.default.addPoolingTo(BoundingDimensions, twoArgumentPooler);

var _default = BoundingDimensions;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),

/***/ 64180:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(64836)["default"]);

exports.__esModule = true;
exports["default"] = void 0;

var _PooledClass = _interopRequireDefault(__webpack_require__(25919));

/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
var twoArgumentPooler = _PooledClass.default.twoArgumentPooler;

function Position(left, top) {
  this.left = left;
  this.top = top;
}

Position.prototype.destructor = function () {
  this.left = null;
  this.top = null;
};

_PooledClass.default.addPoolingTo(Position, twoArgumentPooler);

var _default = Position;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),

/***/ 77254:
/***/ ((module, exports, __webpack_require__) => {

"use strict";
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 */


var _interopRequireDefault = (__webpack_require__(64836)["default"]);

exports.__esModule = true;
exports["default"] = void 0;

var _objectWithoutPropertiesLoose2 = _interopRequireDefault(__webpack_require__(7071));

var _objectSpread2 = _interopRequireDefault(__webpack_require__(42122));

var _AccessibilityUtil = _interopRequireDefault(__webpack_require__(65082));

var _BoundingDimensions = _interopRequireDefault(__webpack_require__(61158));

var _findNodeHandle = _interopRequireDefault(__webpack_require__(10530));

var _normalizeCssColor = _interopRequireDefault(__webpack_require__(15002));

var _Position = _interopRequireDefault(__webpack_require__(64180));

var _react = _interopRequireDefault(__webpack_require__(16689));

var _UIManager = _interopRequireDefault(__webpack_require__(56629));

var _View = _interopRequireDefault(__webpack_require__(79057));

var extractSingleTouch = nativeEvent => {
  var touches = nativeEvent.touches;
  var changedTouches = nativeEvent.changedTouches;
  var hasTouches = touches && touches.length > 0;
  var hasChangedTouches = changedTouches && changedTouches.length > 0;
  return !hasTouches && hasChangedTouches ? changedTouches[0] : hasTouches ? touches[0] : nativeEvent;
};
/**
 * `Touchable`: Taps done right.
 *
 * You hook your `ResponderEventPlugin` events into `Touchable`. `Touchable`
 * will measure time/geometry and tells you when to give feedback to the user.
 *
 * ====================== Touchable Tutorial ===============================
 * The `Touchable` mixin helps you handle the "press" interaction. It analyzes
 * the geometry of elements, and observes when another responder (scroll view
 * etc) has stolen the touch lock. It notifies your component when it should
 * give feedback to the user. (bouncing/highlighting/unhighlighting).
 *
 * - When a touch was activated (typically you highlight)
 * - When a touch was deactivated (typically you unhighlight)
 * - When a touch was "pressed" - a touch ended while still within the geometry
 *   of the element, and no other element (like scroller) has "stolen" touch
 *   lock ("responder") (Typically you bounce the element).
 *
 * A good tap interaction isn't as simple as you might think. There should be a
 * slight delay before showing a highlight when starting a touch. If a
 * subsequent touch move exceeds the boundary of the element, it should
 * unhighlight, but if that same touch is brought back within the boundary, it
 * should rehighlight again. A touch can move in and out of that boundary
 * several times, each time toggling highlighting, but a "press" is only
 * triggered if that touch ends while within the element's boundary and no
 * scroller (or anything else) has stolen the lock on touches.
 *
 * To create a new type of component that handles interaction using the
 * `Touchable` mixin, do the following:
 *
 * - Initialize the `Touchable` state.
 *
 *   getInitialState: function() {
 *     return merge(this.touchableGetInitialState(), yourComponentState);
 *   }
 *
 * - Choose the rendered component who's touches should start the interactive
 *   sequence. On that rendered node, forward all `Touchable` responder
 *   handlers. You can choose any rendered node you like. Choose a node whose
 *   hit target you'd like to instigate the interaction sequence:
 *
 *   // In render function:
 *   return (
 *     <View
 *       onStartShouldSetResponder={this.touchableHandleStartShouldSetResponder}
 *       onResponderTerminationRequest={this.touchableHandleResponderTerminationRequest}
 *       onResponderGrant={this.touchableHandleResponderGrant}
 *       onResponderMove={this.touchableHandleResponderMove}
 *       onResponderRelease={this.touchableHandleResponderRelease}
 *       onResponderTerminate={this.touchableHandleResponderTerminate}>
 *       <View>
 *         Even though the hit detection/interactions are triggered by the
 *         wrapping (typically larger) node, we usually end up implementing
 *         custom logic that highlights this inner one.
 *       </View>
 *     </View>
 *   );
 *
 * - You may set up your own handlers for each of these events, so long as you
 *   also invoke the `touchable*` handlers inside of your custom handler.
 *
 * - Implement the handlers on your component class in order to provide
 *   feedback to the user. See documentation for each of these class methods
 *   that you should implement.
 *
 *   touchableHandlePress: function() {
 *      this.performBounceAnimation();  // or whatever you want to do.
 *   },
 *   touchableHandleActivePressIn: function() {
 *     this.beginHighlighting(...);  // Whatever you like to convey activation
 *   },
 *   touchableHandleActivePressOut: function() {
 *     this.endHighlighting(...);  // Whatever you like to convey deactivation
 *   },
 *
 * - There are more advanced methods you can implement (see documentation below):
 *   touchableGetHighlightDelayMS: function() {
 *     return 20;
 *   }
 *   // In practice, *always* use a predeclared constant (conserve memory).
 *   touchableGetPressRectOffset: function() {
 *     return {top: 20, left: 20, right: 20, bottom: 100};
 *   }
 */

/**
 * Touchable states.
 */


var States = {
  NOT_RESPONDER: 'NOT_RESPONDER',
  // Not the responder
  RESPONDER_INACTIVE_PRESS_IN: 'RESPONDER_INACTIVE_PRESS_IN',
  // Responder, inactive, in the `PressRect`
  RESPONDER_INACTIVE_PRESS_OUT: 'RESPONDER_INACTIVE_PRESS_OUT',
  // Responder, inactive, out of `PressRect`
  RESPONDER_ACTIVE_PRESS_IN: 'RESPONDER_ACTIVE_PRESS_IN',
  // Responder, active, in the `PressRect`
  RESPONDER_ACTIVE_PRESS_OUT: 'RESPONDER_ACTIVE_PRESS_OUT',
  // Responder, active, out of `PressRect`
  RESPONDER_ACTIVE_LONG_PRESS_IN: 'RESPONDER_ACTIVE_LONG_PRESS_IN',
  // Responder, active, in the `PressRect`, after long press threshold
  RESPONDER_ACTIVE_LONG_PRESS_OUT: 'RESPONDER_ACTIVE_LONG_PRESS_OUT',
  // Responder, active, out of `PressRect`, after long press threshold
  ERROR: 'ERROR'
};

/*
 * Quick lookup map for states that are considered to be "active"
 */
var baseStatesConditions = {
  NOT_RESPONDER: false,
  RESPONDER_INACTIVE_PRESS_IN: false,
  RESPONDER_INACTIVE_PRESS_OUT: false,
  RESPONDER_ACTIVE_PRESS_IN: false,
  RESPONDER_ACTIVE_PRESS_OUT: false,
  RESPONDER_ACTIVE_LONG_PRESS_IN: false,
  RESPONDER_ACTIVE_LONG_PRESS_OUT: false,
  ERROR: false
};
var IsActive = (0, _objectSpread2.default)((0, _objectSpread2.default)({}, baseStatesConditions), {}, {
  RESPONDER_ACTIVE_PRESS_OUT: true,
  RESPONDER_ACTIVE_PRESS_IN: true
});
/**
 * Quick lookup for states that are considered to be "pressing" and are
 * therefore eligible to result in a "selection" if the press stops.
 */

var IsPressingIn = (0, _objectSpread2.default)((0, _objectSpread2.default)({}, baseStatesConditions), {}, {
  RESPONDER_INACTIVE_PRESS_IN: true,
  RESPONDER_ACTIVE_PRESS_IN: true,
  RESPONDER_ACTIVE_LONG_PRESS_IN: true
});
var IsLongPressingIn = (0, _objectSpread2.default)((0, _objectSpread2.default)({}, baseStatesConditions), {}, {
  RESPONDER_ACTIVE_LONG_PRESS_IN: true
});
/**
 * Inputs to the state machine.
 */

var Signals = {
  DELAY: 'DELAY',
  RESPONDER_GRANT: 'RESPONDER_GRANT',
  RESPONDER_RELEASE: 'RESPONDER_RELEASE',
  RESPONDER_TERMINATED: 'RESPONDER_TERMINATED',
  ENTER_PRESS_RECT: 'ENTER_PRESS_RECT',
  LEAVE_PRESS_RECT: 'LEAVE_PRESS_RECT',
  LONG_PRESS_DETECTED: 'LONG_PRESS_DETECTED'
};

/**
 * Mapping from States x Signals => States
 */
var Transitions = {
  NOT_RESPONDER: {
    DELAY: States.ERROR,
    RESPONDER_GRANT: States.RESPONDER_INACTIVE_PRESS_IN,
    RESPONDER_RELEASE: States.ERROR,
    RESPONDER_TERMINATED: States.ERROR,
    ENTER_PRESS_RECT: States.ERROR,
    LEAVE_PRESS_RECT: States.ERROR,
    LONG_PRESS_DETECTED: States.ERROR
  },
  RESPONDER_INACTIVE_PRESS_IN: {
    DELAY: States.RESPONDER_ACTIVE_PRESS_IN,
    RESPONDER_GRANT: States.ERROR,
    RESPONDER_RELEASE: States.NOT_RESPONDER,
    RESPONDER_TERMINATED: States.NOT_RESPONDER,
    ENTER_PRESS_RECT: States.RESPONDER_INACTIVE_PRESS_IN,
    LEAVE_PRESS_RECT: States.RESPONDER_INACTIVE_PRESS_OUT,
    LONG_PRESS_DETECTED: States.ERROR
  },
  RESPONDER_INACTIVE_PRESS_OUT: {
    DELAY: States.RESPONDER_ACTIVE_PRESS_OUT,
    RESPONDER_GRANT: States.ERROR,
    RESPONDER_RELEASE: States.NOT_RESPONDER,
    RESPONDER_TERMINATED: States.NOT_RESPONDER,
    ENTER_PRESS_RECT: States.RESPONDER_INACTIVE_PRESS_IN,
    LEAVE_PRESS_RECT: States.RESPONDER_INACTIVE_PRESS_OUT,
    LONG_PRESS_DETECTED: States.ERROR
  },
  RESPONDER_ACTIVE_PRESS_IN: {
    DELAY: States.ERROR,
    RESPONDER_GRANT: States.ERROR,
    RESPONDER_RELEASE: States.NOT_RESPONDER,
    RESPONDER_TERMINATED: States.NOT_RESPONDER,
    ENTER_PRESS_RECT: States.RESPONDER_ACTIVE_PRESS_IN,
    LEAVE_PRESS_RECT: States.RESPONDER_ACTIVE_PRESS_OUT,
    LONG_PRESS_DETECTED: States.RESPONDER_ACTIVE_LONG_PRESS_IN
  },
  RESPONDER_ACTIVE_PRESS_OUT: {
    DELAY: States.ERROR,
    RESPONDER_GRANT: States.ERROR,
    RESPONDER_RELEASE: States.NOT_RESPONDER,
    RESPONDER_TERMINATED: States.NOT_RESPONDER,
    ENTER_PRESS_RECT: States.RESPONDER_ACTIVE_PRESS_IN,
    LEAVE_PRESS_RECT: States.RESPONDER_ACTIVE_PRESS_OUT,
    LONG_PRESS_DETECTED: States.ERROR
  },
  RESPONDER_ACTIVE_LONG_PRESS_IN: {
    DELAY: States.ERROR,
    RESPONDER_GRANT: States.ERROR,
    RESPONDER_RELEASE: States.NOT_RESPONDER,
    RESPONDER_TERMINATED: States.NOT_RESPONDER,
    ENTER_PRESS_RECT: States.RESPONDER_ACTIVE_LONG_PRESS_IN,
    LEAVE_PRESS_RECT: States.RESPONDER_ACTIVE_LONG_PRESS_OUT,
    LONG_PRESS_DETECTED: States.RESPONDER_ACTIVE_LONG_PRESS_IN
  },
  RESPONDER_ACTIVE_LONG_PRESS_OUT: {
    DELAY: States.ERROR,
    RESPONDER_GRANT: States.ERROR,
    RESPONDER_RELEASE: States.NOT_RESPONDER,
    RESPONDER_TERMINATED: States.NOT_RESPONDER,
    ENTER_PRESS_RECT: States.RESPONDER_ACTIVE_LONG_PRESS_IN,
    LEAVE_PRESS_RECT: States.RESPONDER_ACTIVE_LONG_PRESS_OUT,
    LONG_PRESS_DETECTED: States.ERROR
  },
  error: {
    DELAY: States.NOT_RESPONDER,
    RESPONDER_GRANT: States.RESPONDER_INACTIVE_PRESS_IN,
    RESPONDER_RELEASE: States.NOT_RESPONDER,
    RESPONDER_TERMINATED: States.NOT_RESPONDER,
    ENTER_PRESS_RECT: States.NOT_RESPONDER,
    LEAVE_PRESS_RECT: States.NOT_RESPONDER,
    LONG_PRESS_DETECTED: States.NOT_RESPONDER
  }
}; // ==== Typical Constants for integrating into UI components ====
// var HIT_EXPAND_PX = 20;
// var HIT_VERT_OFFSET_PX = 10;

var HIGHLIGHT_DELAY_MS = 130;
var PRESS_EXPAND_PX = 20;
var LONG_PRESS_THRESHOLD = 500;
var LONG_PRESS_DELAY_MS = LONG_PRESS_THRESHOLD - HIGHLIGHT_DELAY_MS;
var LONG_PRESS_ALLOWED_MOVEMENT = 10; // Default amount "active" region protrudes beyond box

/**
 * By convention, methods prefixed with underscores are meant to be @private,
 * and not @protected. Mixers shouldn't access them - not even to provide them
 * as callback handlers.
 *
 *
 * ========== Geometry =========
 * `Touchable` only assumes that there exists a `HitRect` node. The `PressRect`
 * is an abstract box that is extended beyond the `HitRect`.
 *
 *  +--------------------------+
 *  |                          | - "Start" events in `HitRect` cause `HitRect`
 *  |  +--------------------+  |   to become the responder.
 *  |  |  +--------------+  |  | - `HitRect` is typically expanded around
 *  |  |  |              |  |  |   the `VisualRect`, but shifted downward.
 *  |  |  |  VisualRect  |  |  | - After pressing down, after some delay,
 *  |  |  |              |  |  |   and before letting up, the Visual React
 *  |  |  +--------------+  |  |   will become "active". This makes it eligible
 *  |  |     HitRect        |  |   for being highlighted (so long as the
 *  |  +--------------------+  |   press remains in the `PressRect`).
 *  |        PressRect     o   |
 *  +----------------------|---+
 *           Out Region    |
 *                         +-----+ This gap between the `HitRect` and
 *                                 `PressRect` allows a touch to move far away
 *                                 from the original hit rect, and remain
 *                                 highlighted, and eligible for a "Press".
 *                                 Customize this via
 *                                 `touchableGetPressRectOffset()`.
 *
 *
 *
 * ======= State Machine =======
 *
 * +-------------+ <---+ RESPONDER_RELEASE
 * |NOT_RESPONDER|
 * +-------------+ <---+ RESPONDER_TERMINATED
 *     +
 *     | RESPONDER_GRANT (HitRect)
 *     v
 * +---------------------------+  DELAY   +-------------------------+  T + DELAY     +------------------------------+
 * |RESPONDER_INACTIVE_PRESS_IN|+-------->|RESPONDER_ACTIVE_PRESS_IN| +------------> |RESPONDER_ACTIVE_LONG_PRESS_IN|
 * +---------------------------+          +-------------------------+                +------------------------------+
 *     +            ^                         +           ^                                 +           ^
 *     |LEAVE_      |ENTER_                   |LEAVE_     |ENTER_                           |LEAVE_     |ENTER_
 *     |PRESS_RECT  |PRESS_RECT               |PRESS_RECT |PRESS_RECT                       |PRESS_RECT |PRESS_RECT
 *     |            |                         |           |                                 |           |
 *     v            +                         v           +                                 v           +
 * +----------------------------+  DELAY  +--------------------------+               +-------------------------------+
 * |RESPONDER_INACTIVE_PRESS_OUT|+------->|RESPONDER_ACTIVE_PRESS_OUT|               |RESPONDER_ACTIVE_LONG_PRESS_OUT|
 * +----------------------------+         +--------------------------+               +-------------------------------+
 *
 * T + DELAY => LONG_PRESS_DELAY_MS + DELAY
 *
 * Not drawn are the side effects of each transition. The most important side
 * effect is the `touchableHandlePress` abstract method invocation that occurs
 * when a responder is released while in either of the "Press" states.
 *
 * The other important side effects are the highlight abstract method
 * invocations (internal callbacks) to be implemented by the mixer.
 *
 *
 * @lends Touchable.prototype
 */

var TouchableMixin = {
  // HACK (part 1): basic support for touchable interactions using a keyboard
  componentDidMount: function componentDidMount() {
    this._touchableNode = (0, _findNodeHandle.default)(this);

    if (this._touchableNode && this._touchableNode.addEventListener) {
      this._touchableBlurListener = e => {
        if (this._isTouchableKeyboardActive) {
          if (this.state.touchable.touchState && this.state.touchable.touchState !== States.NOT_RESPONDER) {
            this.touchableHandleResponderTerminate({
              nativeEvent: e
            });
          }

          this._isTouchableKeyboardActive = false;
        }
      };

      this._touchableNode.addEventListener('blur', this._touchableBlurListener);
    }
  },

  /**
   * Clear all timeouts on unmount
   */
  componentWillUnmount: function componentWillUnmount() {
    if (this._touchableNode && this._touchableNode.addEventListener) {
      this._touchableNode.removeEventListener('blur', this._touchableBlurListener);
    }

    this.touchableDelayTimeout && clearTimeout(this.touchableDelayTimeout);
    this.longPressDelayTimeout && clearTimeout(this.longPressDelayTimeout);
    this.pressOutDelayTimeout && clearTimeout(this.pressOutDelayTimeout); // Clear DOM nodes

    this.pressInLocation = null;
    this.state.touchable.responderID = null;
    this._touchableNode = null;
  },

  /**
   * It's prefer that mixins determine state in this way, having the class
   * explicitly mix the state in the one and only `getInitialState` method.
   *
   * @return {object} State object to be placed inside of
   * `this.state.touchable`.
   */
  touchableGetInitialState: function touchableGetInitialState() {
    return {
      touchable: {
        touchState: undefined,
        responderID: null
      }
    };
  },
  // ==== Hooks to Gesture Responder system ====

  /**
   * Must return true if embedded in a native platform scroll view.
   */
  touchableHandleResponderTerminationRequest: function touchableHandleResponderTerminationRequest() {
    return !this.props.rejectResponderTermination;
  },

  /**
   * Must return true to start the process of `Touchable`.
   */
  touchableHandleStartShouldSetResponder: function touchableHandleStartShouldSetResponder() {
    return !this.props.disabled;
  },

  /**
   * Return true to cancel press on long press.
   */
  touchableLongPressCancelsPress: function touchableLongPressCancelsPress() {
    return true;
  },

  /**
   * Place as callback for a DOM element's `onResponderGrant` event.
   * @param {SyntheticEvent} e Synthetic event from event system.
   *
   */
  touchableHandleResponderGrant: function touchableHandleResponderGrant(e) {
    var dispatchID = e.currentTarget; // Since e is used in a callback invoked on another event loop
    // (as in setTimeout etc), we need to call e.persist() on the
    // event to make sure it doesn't get reused in the event object pool.

    e.persist();
    this.pressOutDelayTimeout && clearTimeout(this.pressOutDelayTimeout);
    this.pressOutDelayTimeout = null;
    this.state.touchable.touchState = States.NOT_RESPONDER;
    this.state.touchable.responderID = dispatchID;

    this._receiveSignal(Signals.RESPONDER_GRANT, e);

    var delayMS = this.touchableGetHighlightDelayMS !== undefined ? Math.max(this.touchableGetHighlightDelayMS(), 0) : HIGHLIGHT_DELAY_MS;
    delayMS = isNaN(delayMS) ? HIGHLIGHT_DELAY_MS : delayMS;

    if (delayMS !== 0) {
      this.touchableDelayTimeout = setTimeout(this._handleDelay.bind(this, e), delayMS);
    } else {
      this._handleDelay(e);
    }

    var longDelayMS = this.touchableGetLongPressDelayMS !== undefined ? Math.max(this.touchableGetLongPressDelayMS(), 10) : LONG_PRESS_DELAY_MS;
    longDelayMS = isNaN(longDelayMS) ? LONG_PRESS_DELAY_MS : longDelayMS;
    this.longPressDelayTimeout = setTimeout(this._handleLongDelay.bind(this, e), longDelayMS + delayMS);
  },

  /**
   * Place as callback for a DOM element's `onResponderRelease` event.
   */
  touchableHandleResponderRelease: function touchableHandleResponderRelease(e) {
    this.pressInLocation = null;

    this._receiveSignal(Signals.RESPONDER_RELEASE, e);
  },

  /**
   * Place as callback for a DOM element's `onResponderTerminate` event.
   */
  touchableHandleResponderTerminate: function touchableHandleResponderTerminate(e) {
    this.pressInLocation = null;

    this._receiveSignal(Signals.RESPONDER_TERMINATED, e);
  },

  /**
   * Place as callback for a DOM element's `onResponderMove` event.
   */
  touchableHandleResponderMove: function touchableHandleResponderMove(e) {
    // Measurement may not have returned yet.
    if (!this.state.touchable.positionOnActivate) {
      return;
    }

    var positionOnActivate = this.state.touchable.positionOnActivate;
    var dimensionsOnActivate = this.state.touchable.dimensionsOnActivate;
    var pressRectOffset = this.touchableGetPressRectOffset ? this.touchableGetPressRectOffset() : {
      left: PRESS_EXPAND_PX,
      right: PRESS_EXPAND_PX,
      top: PRESS_EXPAND_PX,
      bottom: PRESS_EXPAND_PX
    };
    var pressExpandLeft = pressRectOffset.left;
    var pressExpandTop = pressRectOffset.top;
    var pressExpandRight = pressRectOffset.right;
    var pressExpandBottom = pressRectOffset.bottom;
    var hitSlop = this.touchableGetHitSlop ? this.touchableGetHitSlop() : null;

    if (hitSlop) {
      pressExpandLeft += hitSlop.left || 0;
      pressExpandTop += hitSlop.top || 0;
      pressExpandRight += hitSlop.right || 0;
      pressExpandBottom += hitSlop.bottom || 0;
    }

    var touch = extractSingleTouch(e.nativeEvent);
    var pageX = touch && touch.pageX;
    var pageY = touch && touch.pageY;

    if (this.pressInLocation) {
      var movedDistance = this._getDistanceBetweenPoints(pageX, pageY, this.pressInLocation.pageX, this.pressInLocation.pageY);

      if (movedDistance > LONG_PRESS_ALLOWED_MOVEMENT) {
        this._cancelLongPressDelayTimeout();
      }
    }

    var isTouchWithinActive = pageX > positionOnActivate.left - pressExpandLeft && pageY > positionOnActivate.top - pressExpandTop && pageX < positionOnActivate.left + dimensionsOnActivate.width + pressExpandRight && pageY < positionOnActivate.top + dimensionsOnActivate.height + pressExpandBottom;

    if (isTouchWithinActive) {
      var prevState = this.state.touchable.touchState;

      this._receiveSignal(Signals.ENTER_PRESS_RECT, e);

      var curState = this.state.touchable.touchState;

      if (curState === States.RESPONDER_INACTIVE_PRESS_IN && prevState !== States.RESPONDER_INACTIVE_PRESS_IN) {
        // fix for t7967420
        this._cancelLongPressDelayTimeout();
      }
    } else {
      this._cancelLongPressDelayTimeout();

      this._receiveSignal(Signals.LEAVE_PRESS_RECT, e);
    }
  },

  /**
   * Invoked when the item receives focus. Mixers might override this to
   * visually distinguish the `VisualRect` so that the user knows that it
   * currently has the focus. Most platforms only support a single element being
   * focused at a time, in which case there may have been a previously focused
   * element that was blurred just prior to this. This can be overridden when
   * using `Touchable.Mixin.withoutDefaultFocusAndBlur`.
   */
  touchableHandleFocus: function touchableHandleFocus(e) {
    this.props.onFocus && this.props.onFocus(e);
  },

  /**
   * Invoked when the item loses focus. Mixers might override this to
   * visually distinguish the `VisualRect` so that the user knows that it
   * no longer has focus. Most platforms only support a single element being
   * focused at a time, in which case the focus may have moved to another.
   * This can be overridden when using
   * `Touchable.Mixin.withoutDefaultFocusAndBlur`.
   */
  touchableHandleBlur: function touchableHandleBlur(e) {
    this.props.onBlur && this.props.onBlur(e);
  },
  // ==== Abstract Application Callbacks ====

  /**
   * Invoked when the item should be highlighted. Mixers should implement this
   * to visually distinguish the `VisualRect` so that the user knows that
   * releasing a touch will result in a "selection" (analog to click).
   *
   * @abstract
   * touchableHandleActivePressIn: function,
   */

  /**
   * Invoked when the item is "active" (in that it is still eligible to become
   * a "select") but the touch has left the `PressRect`. Usually the mixer will
   * want to unhighlight the `VisualRect`. If the user (while pressing) moves
   * back into the `PressRect` `touchableHandleActivePressIn` will be invoked
   * again and the mixer should probably highlight the `VisualRect` again. This
   * event will not fire on an `touchEnd/mouseUp` event, only move events while
   * the user is depressing the mouse/touch.
   *
   * @abstract
   * touchableHandleActivePressOut: function
   */

  /**
   * Invoked when the item is "selected" - meaning the interaction ended by
   * letting up while the item was either in the state
   * `RESPONDER_ACTIVE_PRESS_IN` or `RESPONDER_INACTIVE_PRESS_IN`.
   *
   * @abstract
   * touchableHandlePress: function
   */

  /**
   * Invoked when the item is long pressed - meaning the interaction ended by
   * letting up while the item was in `RESPONDER_ACTIVE_LONG_PRESS_IN`. If
   * `touchableHandleLongPress` is *not* provided, `touchableHandlePress` will
   * be called as it normally is. If `touchableHandleLongPress` is provided, by
   * default any `touchableHandlePress` callback will not be invoked. To
   * override this default behavior, override `touchableLongPressCancelsPress`
   * to return false. As a result, `touchableHandlePress` will be called when
   * lifting up, even if `touchableHandleLongPress` has also been called.
   *
   * @abstract
   * touchableHandleLongPress: function
   */

  /**
   * Returns the number of millis to wait before triggering a highlight.
   *
   * @abstract
   * touchableGetHighlightDelayMS: function
   */

  /**
   * Returns the amount to extend the `HitRect` into the `PressRect`. Positive
   * numbers mean the size expands outwards.
   *
   * @abstract
   * touchableGetPressRectOffset: function
   */
  // ==== Internal Logic ====

  /**
   * Measures the `HitRect` node on activation. The Bounding rectangle is with
   * respect to viewport - not page, so adding the `pageXOffset/pageYOffset`
   * should result in points that are in the same coordinate system as an
   * event's `globalX/globalY` data values.
   *
   * - Consider caching this for the lifetime of the component, or possibly
   *   being able to share this cache between any `ScrollMap` view.
   *
   * @sideeffects
   * @private
   */
  _remeasureMetricsOnActivation: function _remeasureMetricsOnActivation() {
    var tag = this.state.touchable.responderID;

    if (tag == null) {
      return;
    }

    _UIManager.default.measure(tag, this._handleQueryLayout);
  },
  _handleQueryLayout: function _handleQueryLayout(l, t, w, h, globalX, globalY) {
    //don't do anything UIManager failed to measure node
    if (!l && !t && !w && !h && !globalX && !globalY) {
      return;
    }

    this.state.touchable.positionOnActivate && _Position.default.release(this.state.touchable.positionOnActivate);
    this.state.touchable.dimensionsOnActivate && // $FlowFixMe
    _BoundingDimensions.default.release(this.state.touchable.dimensionsOnActivate);
    this.state.touchable.positionOnActivate = _Position.default.getPooled(globalX, globalY); // $FlowFixMe

    this.state.touchable.dimensionsOnActivate = _BoundingDimensions.default.getPooled(w, h);
  },
  _handleDelay: function _handleDelay(e) {
    this.touchableDelayTimeout = null;

    this._receiveSignal(Signals.DELAY, e);
  },
  _handleLongDelay: function _handleLongDelay(e) {
    this.longPressDelayTimeout = null;
    var curState = this.state.touchable.touchState;

    if (curState !== States.RESPONDER_ACTIVE_PRESS_IN && curState !== States.RESPONDER_ACTIVE_LONG_PRESS_IN) {
      console.error('Attempted to transition from state `' + curState + '` to `' + States.RESPONDER_ACTIVE_LONG_PRESS_IN + '`, which is not supported. This is ' + 'most likely due to `Touchable.longPressDelayTimeout` not being cancelled.');
    } else {
      this._receiveSignal(Signals.LONG_PRESS_DETECTED, e);
    }
  },

  /**
   * Receives a state machine signal, performs side effects of the transition
   * and stores the new state. Validates the transition as well.
   *
   * @param {Signals} signal State machine signal.
   * @throws Error if invalid state transition or unrecognized signal.
   * @sideeffects
   */
  _receiveSignal: function _receiveSignal(signal, e) {
    var responderID = this.state.touchable.responderID;
    var curState = this.state.touchable.touchState;
    var nextState = Transitions[curState] && Transitions[curState][signal];

    if (!responderID && signal === Signals.RESPONDER_RELEASE) {
      return;
    }

    if (!nextState) {
      throw new Error('Unrecognized signal `' + signal + '` or state `' + curState + '` for Touchable responder `' + responderID + '`');
    }

    if (nextState === States.ERROR) {
      throw new Error('Touchable cannot transition from `' + curState + '` to `' + signal + '` for responder `' + responderID + '`');
    }

    if (curState !== nextState) {
      this._performSideEffectsForTransition(curState, nextState, signal, e);

      this.state.touchable.touchState = nextState;
    }
  },
  _cancelLongPressDelayTimeout: function _cancelLongPressDelayTimeout() {
    this.longPressDelayTimeout && clearTimeout(this.longPressDelayTimeout);
    this.longPressDelayTimeout = null;
  },
  _isHighlight: function _isHighlight(state) {
    return state === States.RESPONDER_ACTIVE_PRESS_IN || state === States.RESPONDER_ACTIVE_LONG_PRESS_IN;
  },
  _savePressInLocation: function _savePressInLocation(e) {
    var touch = extractSingleTouch(e.nativeEvent);
    var pageX = touch && touch.pageX;
    var pageY = touch && touch.pageY;
    var locationX = touch && touch.locationX;
    var locationY = touch && touch.locationY;
    this.pressInLocation = {
      pageX,
      pageY,
      locationX,
      locationY
    };
  },
  _getDistanceBetweenPoints: function _getDistanceBetweenPoints(aX, aY, bX, bY) {
    var deltaX = aX - bX;
    var deltaY = aY - bY;
    return Math.sqrt(deltaX * deltaX + deltaY * deltaY);
  },

  /**
   * Will perform a transition between touchable states, and identify any
   * highlighting or unhighlighting that must be performed for this particular
   * transition.
   *
   * @param {States} curState Current Touchable state.
   * @param {States} nextState Next Touchable state.
   * @param {Signal} signal Signal that triggered the transition.
   * @param {Event} e Native event.
   * @sideeffects
   */
  _performSideEffectsForTransition: function _performSideEffectsForTransition(curState, nextState, signal, e) {
    var curIsHighlight = this._isHighlight(curState);

    var newIsHighlight = this._isHighlight(nextState);

    var isFinalSignal = signal === Signals.RESPONDER_TERMINATED || signal === Signals.RESPONDER_RELEASE;

    if (isFinalSignal) {
      this._cancelLongPressDelayTimeout();
    }

    var isInitialTransition = curState === States.NOT_RESPONDER && nextState === States.RESPONDER_INACTIVE_PRESS_IN;
    var isActiveTransition = !IsActive[curState] && IsActive[nextState];

    if (isInitialTransition || isActiveTransition) {
      this._remeasureMetricsOnActivation();
    }

    if (IsPressingIn[curState] && signal === Signals.LONG_PRESS_DETECTED) {
      this.touchableHandleLongPress && this.touchableHandleLongPress(e);
    }

    if (newIsHighlight && !curIsHighlight) {
      this._startHighlight(e);
    } else if (!newIsHighlight && curIsHighlight) {
      this._endHighlight(e);
    }

    if (IsPressingIn[curState] && signal === Signals.RESPONDER_RELEASE) {
      var hasLongPressHandler = !!this.props.onLongPress;
      var pressIsLongButStillCallOnPress = IsLongPressingIn[curState] && ( // We *are* long pressing.. // But either has no long handler
      !hasLongPressHandler || !this.touchableLongPressCancelsPress()); // or we're told to ignore it.

      var shouldInvokePress = !IsLongPressingIn[curState] || pressIsLongButStillCallOnPress;

      if (shouldInvokePress && this.touchableHandlePress) {
        if (!newIsHighlight && !curIsHighlight) {
          // we never highlighted because of delay, but we should highlight now
          this._startHighlight(e);

          this._endHighlight(e);
        }

        this.touchableHandlePress(e);
      }
    }

    this.touchableDelayTimeout && clearTimeout(this.touchableDelayTimeout);
    this.touchableDelayTimeout = null;
  },
  _playTouchSound: function _playTouchSound() {
    _UIManager.default.playTouchSound();
  },
  _startHighlight: function _startHighlight(e) {
    this._savePressInLocation(e);

    this.touchableHandleActivePressIn && this.touchableHandleActivePressIn(e);
  },
  _endHighlight: function _endHighlight(e) {
    if (this.touchableHandleActivePressOut) {
      if (this.touchableGetPressOutDelayMS && this.touchableGetPressOutDelayMS()) {
        this.pressOutDelayTimeout = setTimeout(() => {
          this.touchableHandleActivePressOut(e);
        }, this.touchableGetPressOutDelayMS());
      } else {
        this.touchableHandleActivePressOut(e);
      }
    }
  },
  // HACK (part 2): basic support for touchable interactions using a keyboard (including
  // delays and longPress)
  touchableHandleKeyEvent: function touchableHandleKeyEvent(e) {
    var type = e.type,
        key = e.key;

    if (key === 'Enter' || key === ' ') {
      if (type === 'keydown') {
        if (!this._isTouchableKeyboardActive) {
          if (!this.state.touchable.touchState || this.state.touchable.touchState === States.NOT_RESPONDER) {
            this.touchableHandleResponderGrant(e);
            this._isTouchableKeyboardActive = true;
          }
        }
      } else if (type === 'keyup') {
        if (this._isTouchableKeyboardActive) {
          if (this.state.touchable.touchState && this.state.touchable.touchState !== States.NOT_RESPONDER) {
            this.touchableHandleResponderRelease(e);
            this._isTouchableKeyboardActive = false;
          }
        }
      }

      e.stopPropagation(); // prevent the default behaviour unless the Touchable functions as a link
      // and Enter is pressed

      if (!(key === 'Enter' && _AccessibilityUtil.default.propsToAriaRole(this.props) === 'link')) {
        e.preventDefault();
      }
    }
  },
  withoutDefaultFocusAndBlur: {}
};
/**
 * Provide an optional version of the mixin where `touchableHandleFocus` and
 * `touchableHandleBlur` can be overridden. This allows appropriate defaults to
 * be set on TV platforms, without breaking existing implementations of
 * `Touchable`.
 */

var touchableHandleFocus = TouchableMixin.touchableHandleFocus,
    touchableHandleBlur = TouchableMixin.touchableHandleBlur,
    TouchableMixinWithoutDefaultFocusAndBlur = (0, _objectWithoutPropertiesLoose2.default)(TouchableMixin, ["touchableHandleFocus", "touchableHandleBlur"]);
TouchableMixin.withoutDefaultFocusAndBlur = TouchableMixinWithoutDefaultFocusAndBlur;
var Touchable = {
  Mixin: TouchableMixin,
  TOUCH_TARGET_DEBUG: false,
  // Highlights all touchable targets. Toggle with Inspector.

  /**
   * Renders a debugging overlay to visualize touch target with hitSlop (might not work on Android).
   */
  renderDebugView: _ref => {
    var color = _ref.color,
        hitSlop = _ref.hitSlop;

    if (!Touchable.TOUCH_TARGET_DEBUG) {
      return null;
    }

    if (false) {}

    var debugHitSlopStyle = {};
    hitSlop = hitSlop || {
      top: 0,
      bottom: 0,
      left: 0,
      right: 0
    };

    for (var key in hitSlop) {
      debugHitSlopStyle[key] = -hitSlop[key];
    }

    var normalizedColor = (0, _normalizeCssColor.default)(color);

    if (typeof normalizedColor !== 'number') {
      return null;
    }

    var hexColor = '#' + ('00000000' + normalizedColor.toString(16)).substr(-8);
    return /*#__PURE__*/_react.default.createElement(_View.default, {
      pointerEvents: "none",
      style: (0, _objectSpread2.default)({
        position: 'absolute',
        borderColor: hexColor.slice(0, -2) + '55',
        // More opaque
        borderWidth: 1,
        borderStyle: 'dashed',
        backgroundColor: hexColor.slice(0, -2) + '0F'
      }, debugHitSlopStyle)
    });
  }
};
var _default = Touchable;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),

/***/ 56629:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(64836)["default"]);

exports.__esModule = true;
exports["default"] = void 0;

var _getBoundingClientRect = _interopRequireDefault(__webpack_require__(71826));

var _setValueForStyles = _interopRequireDefault(__webpack_require__(75736));

/**
 * Copyright (c) Nicolas Gallagher.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
var getRect = node => {
  // Unlike the DOM's getBoundingClientRect, React Native layout measurements
  // for "height" and "width" ignore scale transforms.
  // https://developer.mozilla.org/en-US/docs/Web/API/CSS_Object_Model/Determining_the_dimensions_of_elements
  var _getBoundingClientRec = (0, _getBoundingClientRect.default)(node),
      x = _getBoundingClientRec.x,
      y = _getBoundingClientRec.y,
      top = _getBoundingClientRec.top,
      left = _getBoundingClientRec.left;

  var width = node.offsetWidth;
  var height = node.offsetHeight;
  return {
    x,
    y,
    width,
    height,
    top,
    left
  };
};

var measureLayout = (node, relativeToNativeNode, callback) => {
  var relativeNode = relativeToNativeNode || node && node.parentNode;

  if (node && relativeNode) {
    setTimeout(() => {
      var relativeRect = (0, _getBoundingClientRect.default)(relativeNode);

      var _getRect = getRect(node),
          height = _getRect.height,
          left = _getRect.left,
          top = _getRect.top,
          width = _getRect.width;

      var x = left - relativeRect.left;
      var y = top - relativeRect.top;
      callback(x, y, width, height, left, top);
    }, 0);
  }
};

var elementsToIgnore = {
  A: true,
  BODY: true,
  INPUT: true,
  SELECT: true,
  TEXTAREA: true
};
var UIManager = {
  blur(node) {
    try {
      node.blur();
    } catch (err) {}
  },

  focus(node) {
    try {
      var name = node.nodeName; // A tabIndex of -1 allows element to be programmatically focused but
      // prevents keyboard focus. We don't want to set the tabindex value on
      // elements that should not prevent keyboard focus.

      if (node.getAttribute('tabIndex') == null && node.isContentEditable !== true && elementsToIgnore[name] == null) {
        node.setAttribute('tabIndex', '-1');
      }

      node.focus();
    } catch (err) {}
  },

  measure(node, callback) {
    measureLayout(node, null, callback);
  },

  measureInWindow(node, callback) {
    if (node) {
      setTimeout(() => {
        var _getRect2 = getRect(node),
            height = _getRect2.height,
            left = _getRect2.left,
            top = _getRect2.top,
            width = _getRect2.width;

        callback(left, top, width, height);
      }, 0);
    }
  },

  measureLayout(node, relativeToNativeNode, onFail, onSuccess) {
    measureLayout(node, relativeToNativeNode, onSuccess);
  },

  updateView(node, props) {
    for (var prop in props) {
      if (!Object.prototype.hasOwnProperty.call(props, prop)) {
        continue;
      }

      var value = props[prop];

      switch (prop) {
        case 'style':
          {
            (0, _setValueForStyles.default)(node, value);
            break;
          }

        case 'class':
        case 'className':
          {
            node.setAttribute('class', value);
            break;
          }

        case 'text':
        case 'value':
          // native platforms use `text` prop to replace text input value
          node.value = value;
          break;

        default:
          node.setAttribute(prop, value);
      }
    }
  },

  configureNextLayoutAnimation(config, onAnimationDidEnd) {
    onAnimationDidEnd();
  },

  // mocks
  setLayoutAnimationEnabledExperimental() {}

};
var _default = UIManager;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),

/***/ 22256:
/***/ ((module, exports) => {

"use strict";


exports.__esModule = true;
exports["default"] = void 0;

/**
 * Copyright (c) Nicolas Gallagher.
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
var vibrate = pattern => {
  if ('vibrate' in window.navigator) {
    window.navigator.vibrate(pattern);
  }
};

var Vibration = {
  cancel() {
    vibrate(0);
  },

  vibrate(pattern) {
    if (pattern === void 0) {
      pattern = 400;
    }

    vibrate(pattern);
  }

};
var _default = Vibration;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),

/***/ 79057:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(64836)["default"]);

var _interopRequireWildcard = (__webpack_require__(75263)["default"]);

exports.__esModule = true;
exports["default"] = void 0;

var _objectWithoutPropertiesLoose2 = _interopRequireDefault(__webpack_require__(7071));

var React = _interopRequireWildcard(__webpack_require__(16689));

var _createElement = _interopRequireDefault(__webpack_require__(63820));

var forwardedProps = _interopRequireWildcard(__webpack_require__(24475));

var _pick = _interopRequireDefault(__webpack_require__(27447));

var _useElementLayout = _interopRequireDefault(__webpack_require__(98954));

var _useMergeRefs = _interopRequireDefault(__webpack_require__(88391));

var _usePlatformMethods = _interopRequireDefault(__webpack_require__(92187));

var _useResponderEvents = _interopRequireDefault(__webpack_require__(36758));

var _StyleSheet = _interopRequireDefault(__webpack_require__(84099));

var _TextAncestorContext = _interopRequireDefault(__webpack_require__(47905));

var _useLocale = __webpack_require__(82901);

var _excluded = ["hrefAttrs", "onLayout", "onMoveShouldSetResponder", "onMoveShouldSetResponderCapture", "onResponderEnd", "onResponderGrant", "onResponderMove", "onResponderReject", "onResponderRelease", "onResponderStart", "onResponderTerminate", "onResponderTerminationRequest", "onScrollShouldSetResponder", "onScrollShouldSetResponderCapture", "onSelectionChangeShouldSetResponder", "onSelectionChangeShouldSetResponderCapture", "onStartShouldSetResponder", "onStartShouldSetResponderCapture"];
var forwardPropsList = Object.assign({}, forwardedProps.defaultProps, forwardedProps.accessibilityProps, forwardedProps.clickProps, forwardedProps.defaultProps, forwardedProps.accessibilityProps, forwardedProps.clickProps, forwardedProps.focusProps, forwardedProps.keyboardProps, forwardedProps.mouseProps, forwardedProps.touchProps, forwardedProps.styleProps, {
  href: true,
  lang: true,
  onScroll: true,
  onWheel: true,
  pointerEvents: true
});

var pickProps = props => (0, _pick.default)(props, forwardPropsList);

var View = /*#__PURE__*/React.forwardRef((props, forwardedRef) => {
  var hrefAttrs = props.hrefAttrs,
      onLayout = props.onLayout,
      onMoveShouldSetResponder = props.onMoveShouldSetResponder,
      onMoveShouldSetResponderCapture = props.onMoveShouldSetResponderCapture,
      onResponderEnd = props.onResponderEnd,
      onResponderGrant = props.onResponderGrant,
      onResponderMove = props.onResponderMove,
      onResponderReject = props.onResponderReject,
      onResponderRelease = props.onResponderRelease,
      onResponderStart = props.onResponderStart,
      onResponderTerminate = props.onResponderTerminate,
      onResponderTerminationRequest = props.onResponderTerminationRequest,
      onScrollShouldSetResponder = props.onScrollShouldSetResponder,
      onScrollShouldSetResponderCapture = props.onScrollShouldSetResponderCapture,
      onSelectionChangeShouldSetResponder = props.onSelectionChangeShouldSetResponder,
      onSelectionChangeShouldSetResponderCapture = props.onSelectionChangeShouldSetResponderCapture,
      onStartShouldSetResponder = props.onStartShouldSetResponder,
      onStartShouldSetResponderCapture = props.onStartShouldSetResponderCapture,
      rest = (0, _objectWithoutPropertiesLoose2.default)(props, _excluded);

  if (false) {}

  var hasTextAncestor = React.useContext(_TextAncestorContext.default);
  var hostRef = React.useRef(null);

  var _useLocaleContext = (0, _useLocale.useLocaleContext)(),
      contextDirection = _useLocaleContext.direction;

  (0, _useElementLayout.default)(hostRef, onLayout);
  (0, _useResponderEvents.default)(hostRef, {
    onMoveShouldSetResponder,
    onMoveShouldSetResponderCapture,
    onResponderEnd,
    onResponderGrant,
    onResponderMove,
    onResponderReject,
    onResponderRelease,
    onResponderStart,
    onResponderTerminate,
    onResponderTerminationRequest,
    onScrollShouldSetResponder,
    onScrollShouldSetResponderCapture,
    onSelectionChangeShouldSetResponder,
    onSelectionChangeShouldSetResponderCapture,
    onStartShouldSetResponder,
    onStartShouldSetResponderCapture
  });
  var component = 'div';
  var langDirection = props.lang != null ? (0, _useLocale.getLocaleDirection)(props.lang) : null;
  var componentDirection = props.dir || langDirection;
  var writingDirection = componentDirection || contextDirection;
  var supportedProps = pickProps(rest);
  supportedProps.dir = componentDirection;
  supportedProps.style = [styles.view$raw, hasTextAncestor && styles.inline, props.style];

  if (props.href != null) {
    component = 'a';

    if (hrefAttrs != null) {
      var download = hrefAttrs.download,
          rel = hrefAttrs.rel,
          target = hrefAttrs.target;

      if (download != null) {
        supportedProps.download = download;
      }

      if (rel != null) {
        supportedProps.rel = rel;
      }

      if (typeof target === 'string') {
        supportedProps.target = target.charAt(0) !== '_' ? '_' + target : target;
      }
    }
  }

  var platformMethodsRef = (0, _usePlatformMethods.default)(supportedProps);
  var setRef = (0, _useMergeRefs.default)(hostRef, platformMethodsRef, forwardedRef);
  supportedProps.ref = setRef;
  return (0, _createElement.default)(component, supportedProps, {
    writingDirection
  });
});
View.displayName = 'View';

var styles = _StyleSheet.default.create({
  view$raw: {
    alignItems: 'stretch',
    backgroundColor: 'transparent',
    border: '0 solid black',
    boxSizing: 'border-box',
    display: 'flex',
    flexBasis: 'auto',
    flexDirection: 'column',
    flexShrink: 0,
    listStyle: 'none',
    margin: 0,
    minHeight: 0,
    minWidth: 0,
    padding: 0,
    position: 'relative',
    textDecoration: 'none',
    zIndex: 0
  },
  inline: {
    display: 'inline-flex'
  }
});

var _default = View;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),

/***/ 16608:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(64836)["default"]);

exports.__esModule = true;
exports["default"] = void 0;

var _VirtualizedList = _interopRequireDefault(__webpack_require__(71655));

/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
var _default = _VirtualizedList.default;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),

/***/ 38506:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(64836)["default"]);

exports.__esModule = true;
exports["default"] = void 0;

var _react = _interopRequireDefault(__webpack_require__(16689));

var _UnimplementedView = _interopRequireDefault(__webpack_require__(85261));

/**
 * Copyright (c) Nicolas Gallagher.
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
function YellowBox(props) {
  return /*#__PURE__*/_react.default.createElement(_UnimplementedView.default, props);
}

YellowBox.ignoreWarnings = () => {};

var _default = YellowBox;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),

/***/ 63820:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(64836)["default"]);

exports.__esModule = true;
exports["default"] = void 0;

var _AccessibilityUtil = _interopRequireDefault(__webpack_require__(65082));

var _createDOMProps = _interopRequireDefault(__webpack_require__(18083));

var _react = _interopRequireDefault(__webpack_require__(16689));

var _useLocale = __webpack_require__(82901);

/**
 * Copyright (c) Nicolas Gallagher.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
var createElement = (component, props, options) => {
  // Use equivalent platform elements where possible.
  var accessibilityComponent;

  if (component && component.constructor === String) {
    accessibilityComponent = _AccessibilityUtil.default.propsToAccessibilityComponent(props);
  }

  var Component = accessibilityComponent || component;
  var domProps = (0, _createDOMProps.default)(Component, props, options);

  var element = /*#__PURE__*/_react.default.createElement(Component, domProps); // Update locale context if element's writing direction prop changes


  var elementWithLocaleProvider = domProps.dir ? /*#__PURE__*/_react.default.createElement(_useLocale.LocaleProvider, {
    children: element,
    direction: domProps.dir,
    locale: domProps.lang
  }) : element;
  return elementWithLocaleProvider;
};

var _default = createElement;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),

/***/ 10530:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


exports.__esModule = true;
exports["default"] = void 0;

var _reactDom = __webpack_require__(66405);

/**
 * Copyright (c) Nicolas Gallagher.
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
var findNodeHandle = component => {
  var node;

  try {
    node = (0, _reactDom.findDOMNode)(component);
  } catch (e) {}

  return node;
};

var _default = findNodeHandle;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),

/***/ 64385:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(64836)["default"]);

exports.__esModule = true;
exports["default"] = void 0;

var _normalizeCssColor = _interopRequireDefault(__webpack_require__(15002));

/**
 * Copyright (c) Nicolas Gallagher.
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
var processColor = color => {
  if (color === undefined || color === null) {
    return color;
  } // convert number and hex


  var int32Color = (0, _normalizeCssColor.default)(color);

  if (int32Color === undefined || int32Color === null) {
    return undefined;
  }

  int32Color = (int32Color << 24 | int32Color >>> 8) >>> 0;
  return int32Color;
};

var _default = processColor;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),

/***/ 53291:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


exports.__esModule = true;
exports["default"] = render;
exports.hydrate = hydrate;

var _reactDom = __webpack_require__(66405);

var _dom = __webpack_require__(79352);

/**
 * Copyright (c) Nicolas Gallagher.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
function hydrate(element, root, callback) {
  (0, _dom.createSheet)(root);
  return (0, _reactDom.hydrate)(element, root, callback);
}

function render(element, root, callback) {
  (0, _dom.createSheet)(root);
  return (0, _reactDom.render)(element, root, callback);
}

/***/ }),

/***/ 90993:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


exports.__esModule = true;
exports["default"] = void 0;

var _reactDom = __webpack_require__(66405);

/**
 * Copyright (c) Nicolas Gallagher.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
var _default = _reactDom.unmountComponentAtNode;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),

/***/ 55962:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(64836)["default"]);

var _interopRequireWildcard = (__webpack_require__(75263)["default"]);

exports.__esModule = true;
exports["default"] = useColorScheme;

var React = _interopRequireWildcard(__webpack_require__(16689));

var _Appearance = _interopRequireDefault(__webpack_require__(43433));

/**
 * Copyright (c) Nicolas Gallagher.
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
function useColorScheme() {
  var _React$useState = React.useState(_Appearance.default.getColorScheme()),
      colorScheme = _React$useState[0],
      setColorScheme = _React$useState[1];

  React.useEffect(() => {
    function listener(appearance) {
      setColorScheme(appearance.colorScheme);
    }

    var _Appearance$addChange = _Appearance.default.addChangeListener(listener),
        remove = _Appearance$addChange.remove;

    return remove;
  });
  return colorScheme;
}

module.exports = exports.default;

/***/ }),

/***/ 49091:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


exports.__esModule = true;
exports["default"] = void 0;

var _useLocale = __webpack_require__(82901);

/**
 * Copyright (c) Nicolas Gallagher.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
var _default = _useLocale.useLocaleContext;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),

/***/ 25390:
/***/ ((module, exports, __webpack_require__) => {

"use strict";
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @format
 * 
 */


var _interopRequireDefault = (__webpack_require__(64836)["default"]);

exports.__esModule = true;
exports["default"] = useWindowDimensions;

var _Dimensions = _interopRequireDefault(__webpack_require__(13256));

var _react = __webpack_require__(16689);

function useWindowDimensions() {
  var _useState = (0, _react.useState)(() => _Dimensions.default.get('window')),
      dims = _useState[0],
      setDims = _useState[1];

  (0, _react.useEffect)(() => {
    function handleChange(_ref) {
      var window = _ref.window;

      if (window != null) {
        setDims(window);
      }
    }

    _Dimensions.default.addEventListener('change', handleChange); // We might have missed an update between calling `get` in render and
    // `addEventListener` in this handler, so we set it here. If there was
    // no change, React will filter out this update as a no-op.


    setDims(_Dimensions.default.get('window'));
    return () => {
      _Dimensions.default.removeEventListener('change', handleChange);
    };
  }, []);
  return dims;
}

module.exports = exports.default;

/***/ }),

/***/ 83849:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(64836)["default"]);

exports.__esModule = true;
exports.useWindowDimensions = exports.useLocaleContext = exports.useColorScheme = exports.unstable_createElement = exports.unmountComponentAtNode = exports.render = exports.processColor = exports.findNodeHandle = exports.YellowBox = exports.VirtualizedList = exports.View = exports.Vibration = exports.UIManager = exports.TouchableWithoutFeedback = exports.TouchableOpacity = exports.TouchableNativeFeedback = exports.TouchableHighlight = exports.Touchable = exports.ToastAndroid = exports.TextInput = exports.Text = exports.TVEventHandler = exports.Systrace = exports.Switch = exports.StyleSheet = exports.StatusBar = exports.Share = exports.Settings = exports.SectionList = exports.ScrollView = exports.SafeAreaView = exports.RefreshControl = exports.ProgressBar = exports.Pressable = exports.Platform = exports.PixelRatio = exports.Picker = exports.PermissionsAndroid = exports.PanResponder = exports.NativeModules = exports.NativeEventEmitter = exports.Modal = exports.LogBox = exports.Linking = exports.LayoutAnimation = exports.KeyboardAvoidingView = exports.Keyboard = exports.InteractionManager = exports.InputAccessoryView = exports.ImageBackground = exports.Image = exports.I18nManager = exports.FlatList = exports.Easing = exports.DrawerLayoutAndroid = exports.Dimensions = exports.DeviceInfo = exports.DeviceEventEmitter = exports.Clipboard = exports.CheckBox = exports.Button = exports.BackHandler = exports.Appearance = exports.AppState = exports.AppRegistry = exports.Animated = exports.Alert = exports.ActivityIndicator = exports.AccessibilityInfo = void 0;

var _createElement = _interopRequireDefault(__webpack_require__(63820));

exports.unstable_createElement = _createElement.default;

var _findNodeHandle = _interopRequireDefault(__webpack_require__(10530));

exports.findNodeHandle = _findNodeHandle.default;

var _processColor = _interopRequireDefault(__webpack_require__(64385));

exports.processColor = _processColor.default;

var _render = _interopRequireDefault(__webpack_require__(53291));

exports.render = _render.default;

var _unmountComponentAtNode = _interopRequireDefault(__webpack_require__(90993));

exports.unmountComponentAtNode = _unmountComponentAtNode.default;

var _NativeModules = _interopRequireDefault(__webpack_require__(97389));

exports.NativeModules = _NativeModules.default;

var _AccessibilityInfo = _interopRequireDefault(__webpack_require__(96329));

exports.AccessibilityInfo = _AccessibilityInfo.default;

var _Alert = _interopRequireDefault(__webpack_require__(7426));

exports.Alert = _Alert.default;

var _Animated = _interopRequireDefault(__webpack_require__(31529));

exports.Animated = _Animated.default;

var _Appearance = _interopRequireDefault(__webpack_require__(43433));

exports.Appearance = _Appearance.default;

var _AppRegistry = _interopRequireDefault(__webpack_require__(10269));

exports.AppRegistry = _AppRegistry.default;

var _AppState = _interopRequireDefault(__webpack_require__(42384));

exports.AppState = _AppState.default;

var _BackHandler = _interopRequireDefault(__webpack_require__(97531));

exports.BackHandler = _BackHandler.default;

var _Clipboard = _interopRequireDefault(__webpack_require__(31993));

exports.Clipboard = _Clipboard.default;

var _DeviceInfo = _interopRequireDefault(__webpack_require__(95072));

exports.DeviceInfo = _DeviceInfo.default;

var _Dimensions = _interopRequireDefault(__webpack_require__(13256));

exports.Dimensions = _Dimensions.default;

var _Easing = _interopRequireDefault(__webpack_require__(5717));

exports.Easing = _Easing.default;

var _I18nManager = _interopRequireDefault(__webpack_require__(4020));

exports.I18nManager = _I18nManager.default;

var _Keyboard = _interopRequireDefault(__webpack_require__(95031));

exports.Keyboard = _Keyboard.default;

var _InteractionManager = _interopRequireDefault(__webpack_require__(91195));

exports.InteractionManager = _InteractionManager.default;

var _LayoutAnimation = _interopRequireDefault(__webpack_require__(91194));

exports.LayoutAnimation = _LayoutAnimation.default;

var _Linking = _interopRequireDefault(__webpack_require__(98346));

exports.Linking = _Linking.default;

var _NativeEventEmitter = _interopRequireDefault(__webpack_require__(98278));

exports.NativeEventEmitter = _NativeEventEmitter.default;

var _PanResponder = _interopRequireDefault(__webpack_require__(44090));

exports.PanResponder = _PanResponder.default;

var _PixelRatio = _interopRequireDefault(__webpack_require__(5238));

exports.PixelRatio = _PixelRatio.default;

var _Platform = _interopRequireDefault(__webpack_require__(98842));

exports.Platform = _Platform.default;

var _Share = _interopRequireDefault(__webpack_require__(89239));

exports.Share = _Share.default;

var _StyleSheet = _interopRequireDefault(__webpack_require__(84099));

exports.StyleSheet = _StyleSheet.default;

var _UIManager = _interopRequireDefault(__webpack_require__(56629));

exports.UIManager = _UIManager.default;

var _Vibration = _interopRequireDefault(__webpack_require__(22256));

exports.Vibration = _Vibration.default;

var _ActivityIndicator = _interopRequireDefault(__webpack_require__(89009));

exports.ActivityIndicator = _ActivityIndicator.default;

var _Button = _interopRequireDefault(__webpack_require__(25959));

exports.Button = _Button.default;

var _CheckBox = _interopRequireDefault(__webpack_require__(4857));

exports.CheckBox = _CheckBox.default;

var _FlatList = _interopRequireDefault(__webpack_require__(70035));

exports.FlatList = _FlatList.default;

var _Image = _interopRequireDefault(__webpack_require__(94965));

exports.Image = _Image.default;

var _ImageBackground = _interopRequireDefault(__webpack_require__(75296));

exports.ImageBackground = _ImageBackground.default;

var _KeyboardAvoidingView = _interopRequireDefault(__webpack_require__(15869));

exports.KeyboardAvoidingView = _KeyboardAvoidingView.default;

var _Modal = _interopRequireDefault(__webpack_require__(17666));

exports.Modal = _Modal.default;

var _Picker = _interopRequireDefault(__webpack_require__(88053));

exports.Picker = _Picker.default;

var _Pressable = _interopRequireDefault(__webpack_require__(60696));

exports.Pressable = _Pressable.default;

var _ProgressBar = _interopRequireDefault(__webpack_require__(33157));

exports.ProgressBar = _ProgressBar.default;

var _RefreshControl = _interopRequireDefault(__webpack_require__(77818));

exports.RefreshControl = _RefreshControl.default;

var _SafeAreaView = _interopRequireDefault(__webpack_require__(79517));

exports.SafeAreaView = _SafeAreaView.default;

var _ScrollView = _interopRequireDefault(__webpack_require__(38174));

exports.ScrollView = _ScrollView.default;

var _SectionList = _interopRequireDefault(__webpack_require__(87355));

exports.SectionList = _SectionList.default;

var _StatusBar = _interopRequireDefault(__webpack_require__(68704));

exports.StatusBar = _StatusBar.default;

var _Switch = _interopRequireDefault(__webpack_require__(96138));

exports.Switch = _Switch.default;

var _Text = _interopRequireDefault(__webpack_require__(48409));

exports.Text = _Text.default;

var _TextInput = _interopRequireDefault(__webpack_require__(64941));

exports.TextInput = _TextInput.default;

var _Touchable = _interopRequireDefault(__webpack_require__(77254));

exports.Touchable = _Touchable.default;

var _TouchableHighlight = _interopRequireDefault(__webpack_require__(28865));

exports.TouchableHighlight = _TouchableHighlight.default;

var _TouchableNativeFeedback = _interopRequireDefault(__webpack_require__(762));

exports.TouchableNativeFeedback = _TouchableNativeFeedback.default;

var _TouchableOpacity = _interopRequireDefault(__webpack_require__(28908));

exports.TouchableOpacity = _TouchableOpacity.default;

var _TouchableWithoutFeedback = _interopRequireDefault(__webpack_require__(15248));

exports.TouchableWithoutFeedback = _TouchableWithoutFeedback.default;

var _View = _interopRequireDefault(__webpack_require__(79057));

exports.View = _View.default;

var _VirtualizedList = _interopRequireDefault(__webpack_require__(16608));

exports.VirtualizedList = _VirtualizedList.default;

var _YellowBox = _interopRequireDefault(__webpack_require__(38506));

exports.YellowBox = _YellowBox.default;

var _LogBox = _interopRequireDefault(__webpack_require__(14111));

exports.LogBox = _LogBox.default;

var _DrawerLayoutAndroid = _interopRequireDefault(__webpack_require__(75487));

exports.DrawerLayoutAndroid = _DrawerLayoutAndroid.default;

var _InputAccessoryView = _interopRequireDefault(__webpack_require__(8116));

exports.InputAccessoryView = _InputAccessoryView.default;

var _ToastAndroid = _interopRequireDefault(__webpack_require__(7131));

exports.ToastAndroid = _ToastAndroid.default;

var _PermissionsAndroid = _interopRequireDefault(__webpack_require__(33532));

exports.PermissionsAndroid = _PermissionsAndroid.default;

var _Settings = _interopRequireDefault(__webpack_require__(25975));

exports.Settings = _Settings.default;

var _Systrace = _interopRequireDefault(__webpack_require__(84242));

exports.Systrace = _Systrace.default;

var _TVEventHandler = _interopRequireDefault(__webpack_require__(4385));

exports.TVEventHandler = _TVEventHandler.default;

var _DeviceEventEmitter = _interopRequireDefault(__webpack_require__(84384));

exports.DeviceEventEmitter = _DeviceEventEmitter.default;

var _useColorScheme = _interopRequireDefault(__webpack_require__(55962));

exports.useColorScheme = _useColorScheme.default;

var _useLocaleContext = _interopRequireDefault(__webpack_require__(49091));

exports.useLocaleContext = _useLocaleContext.default;

var _useWindowDimensions = _interopRequireDefault(__webpack_require__(25390));

exports.useWindowDimensions = _useWindowDimensions.default;

/***/ }),

/***/ 65082:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(64836)["default"]);

exports.__esModule = true;
exports["default"] = void 0;

var _isDisabled = _interopRequireDefault(__webpack_require__(29902));

var _propsToAccessibilityComponent = _interopRequireDefault(__webpack_require__(52703));

var _propsToAriaRole = _interopRequireDefault(__webpack_require__(80144));

/**
 * Copyright (c) Nicolas Gallagher.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
var AccessibilityUtil = {
  isDisabled: _isDisabled.default,
  propsToAccessibilityComponent: _propsToAccessibilityComponent.default,
  propsToAriaRole: _propsToAriaRole.default
};
var _default = AccessibilityUtil;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),

/***/ 29902:
/***/ ((module, exports) => {

"use strict";


exports.__esModule = true;
exports["default"] = void 0;

/**
 * Copyright (c) Nicolas Gallagher.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
var isDisabled = props => props.disabled || Array.isArray(props.accessibilityStates) && props.accessibilityStates.indexOf('disabled') > -1;

var _default = isDisabled;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),

/***/ 52703:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(64836)["default"]);

exports.__esModule = true;
exports["default"] = void 0;

var _propsToAriaRole = _interopRequireDefault(__webpack_require__(80144));

/**
 * Copyright (c) Nicolas Gallagher.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
var roleComponents = {
  article: 'article',
  banner: 'header',
  blockquote: 'blockquote',
  code: 'code',
  complementary: 'aside',
  contentinfo: 'footer',
  deletion: 'del',
  emphasis: 'em',
  figure: 'figure',
  insertion: 'ins',
  form: 'form',
  list: 'ul',
  listitem: 'li',
  main: 'main',
  navigation: 'nav',
  region: 'section',
  strong: 'strong'
};
var emptyObject = {};

var propsToAccessibilityComponent = function propsToAccessibilityComponent(props) {
  if (props === void 0) {
    props = emptyObject;
  }

  // special-case for "label" role which doesn't map to an ARIA role
  if (props.accessibilityRole === 'label') {
    return 'label';
  }

  var role = (0, _propsToAriaRole.default)(props);

  if (role) {
    if (role === 'heading') {
      var level = props.accessibilityLevel || props['aria-level'];

      if (level != null) {
        return "h" + level;
      }

      return 'h1';
    }

    return roleComponents[role];
  }
};

var _default = propsToAccessibilityComponent;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),

/***/ 80144:
/***/ ((module, exports) => {

"use strict";


exports.__esModule = true;
exports["default"] = void 0;

/**
 * Copyright (c) Nicolas Gallagher.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
var accessibilityRoleToWebRole = {
  adjustable: 'slider',
  button: 'button',
  header: 'heading',
  image: 'img',
  imagebutton: null,
  keyboardkey: null,
  label: null,
  link: 'link',
  none: 'presentation',
  search: 'search',
  summary: 'region',
  text: null
};

var propsToAriaRole = _ref => {
  var accessibilityRole = _ref.accessibilityRole;

  if (accessibilityRole) {
    var inferredRole = accessibilityRoleToWebRole[accessibilityRole];

    if (inferredRole !== null) {
      // ignore roles that don't map to web
      return inferredRole || accessibilityRole;
    }
  }
};

var _default = propsToAriaRole;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),

/***/ 39025:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


exports.__esModule = true;
exports.getAssetByID = getAssetByID;
exports.registerAsset = registerAsset;

/**
 * Copyright (c) Nicolas Gallagher.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
var assets = [];

function registerAsset(asset) {
  // `push` returns new array length, so the first asset will
  // get id 1 (not 0) to make the value truthy
  return assets.push(asset);
}

function getAssetByID(assetId) {
  return assets[assetId - 1];
}

/***/ }),

/***/ 39096:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


exports.__esModule = true;
exports["default"] = exports.ImageUriCache = void 0;

/**
 * Copyright (c) Nicolas Gallagher.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
var dataUriPattern = /^data:/;

class ImageUriCache {
  static has(uri) {
    var entries = ImageUriCache._entries;
    var isDataUri = dataUriPattern.test(uri);
    return isDataUri || Boolean(entries[uri]);
  }

  static add(uri) {
    var entries = ImageUriCache._entries;
    var lastUsedTimestamp = Date.now();

    if (entries[uri]) {
      entries[uri].lastUsedTimestamp = lastUsedTimestamp;
      entries[uri].refCount += 1;
    } else {
      entries[uri] = {
        lastUsedTimestamp,
        refCount: 1
      };
    }
  }

  static remove(uri) {
    var entries = ImageUriCache._entries;

    if (entries[uri]) {
      entries[uri].refCount -= 1;
    } // Free up entries when the cache is "full"


    ImageUriCache._cleanUpIfNeeded();
  }

  static _cleanUpIfNeeded() {
    var entries = ImageUriCache._entries;
    var imageUris = Object.keys(entries);

    if (imageUris.length + 1 > ImageUriCache._maximumEntries) {
      var leastRecentlyUsedKey;
      var leastRecentlyUsedEntry;
      imageUris.forEach(uri => {
        var entry = entries[uri];

        if ((!leastRecentlyUsedEntry || entry.lastUsedTimestamp < leastRecentlyUsedEntry.lastUsedTimestamp) && entry.refCount === 0) {
          leastRecentlyUsedKey = uri;
          leastRecentlyUsedEntry = entry;
        }
      });

      if (leastRecentlyUsedKey) {
        delete entries[leastRecentlyUsedKey];
      }
    }
  }

}

exports.ImageUriCache = ImageUriCache;
ImageUriCache._maximumEntries = 256;
ImageUriCache._entries = {};
var id = 0;
var requests = {};
var ImageLoader = {
  abort(requestId) {
    var image = requests["" + requestId];

    if (image) {
      image.onerror = null;
      image.onload = null;
      image = null;
      delete requests["" + requestId];
    }
  },

  getSize(uri, success, failure) {
    var complete = false;
    var interval = setInterval(callback, 16);
    var requestId = ImageLoader.load(uri, callback, errorCallback);

    function callback() {
      var image = requests["" + requestId];

      if (image) {
        var naturalHeight = image.naturalHeight,
            naturalWidth = image.naturalWidth;

        if (naturalHeight && naturalWidth) {
          success(naturalWidth, naturalHeight);
          complete = true;
        }
      }

      if (complete) {
        ImageLoader.abort(requestId);
        clearInterval(interval);
      }
    }

    function errorCallback() {
      if (typeof failure === 'function') {
        failure();
      }

      ImageLoader.abort(requestId);
      clearInterval(interval);
    }
  },

  has(uri) {
    return ImageUriCache.has(uri);
  },

  load(uri, onLoad, onError) {
    id += 1;
    var image = new window.Image();
    image.onerror = onError;

    image.onload = e => {
      // avoid blocking the main thread
      var onDecode = () => onLoad({
        nativeEvent: e
      });

      if (typeof image.decode === 'function') {
        // Safari currently throws exceptions when decoding svgs.
        // We want to catch that error and allow the load handler
        // to be forwarded to the onLoad handler in this case
        image.decode().then(onDecode, onDecode);
      } else {
        setTimeout(onDecode, 0);
      }
    };

    image.src = uri;
    requests["" + id] = image;
    return id;
  },

  prefetch(uri) {
    return new Promise((resolve, reject) => {
      ImageLoader.load(uri, () => {
        // Add the uri to the cache so it can be immediately displayed when used
        // but also immediately remove it to correctly reflect that it has no active references
        ImageUriCache.add(uri);
        ImageUriCache.remove(uri);
        resolve();
      }, reject);
    });
  },

  queryCache(uris) {
    var result = {};
    uris.forEach(u => {
      if (ImageUriCache.has(u)) {
        result[u] = 'disk/memory';
      }
    });
    return Promise.resolve(result);
  }

};
var _default = ImageLoader;
exports["default"] = _default;

/***/ }),

/***/ 65164:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(64836)["default"]);

exports.__esModule = true;
exports["default"] = void 0;

var _Dimensions = _interopRequireDefault(__webpack_require__(13256));

var _findNodeHandle = _interopRequireDefault(__webpack_require__(10530));

var _invariant = _interopRequireDefault(__webpack_require__(44505));

var _Platform = _interopRequireDefault(__webpack_require__(98842));

var _TextInputState = _interopRequireDefault(__webpack_require__(20551));

var _UIManager = _interopRequireDefault(__webpack_require__(56629));

var _warning = _interopRequireDefault(__webpack_require__(99905));

/**
 * Copyright (c) Nicolas Gallagher.
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

/**
 * Mixin that can be integrated in order to handle scrolling that plays well
 * with `ResponderEventPlugin`. Integrate with your platform specific scroll
 * views, or even your custom built (every-frame animating) scroll views so that
 * all of these systems play well with the `ResponderEventPlugin`.
 *
 * iOS scroll event timing nuances:
 * ===============================
 *
 *
 * Scrolling without bouncing, if you touch down:
 * -------------------------------
 *
 * 1. `onMomentumScrollBegin` (when animation begins after letting up)
 *    ... physical touch starts ...
 * 2. `onTouchStartCapture`   (when you press down to stop the scroll)
 * 3. `onTouchStart`          (same, but bubble phase)
 * 4. `onResponderRelease`    (when lifting up - you could pause forever before * lifting)
 * 5. `onMomentumScrollEnd`
 *
 *
 * Scrolling with bouncing, if you touch down:
 * -------------------------------
 *
 * 1. `onMomentumScrollBegin` (when animation begins after letting up)
 *    ... bounce begins ...
 *    ... some time elapses ...
 *    ... physical touch during bounce ...
 * 2. `onMomentumScrollEnd`   (Makes no sense why this occurs first during bounce)
 * 3. `onTouchStartCapture`   (immediately after `onMomentumScrollEnd`)
 * 4. `onTouchStart`          (same, but bubble phase)
 * 5. `onTouchEnd`            (You could hold the touch start for a long time)
 * 6. `onMomentumScrollBegin` (When releasing the view starts bouncing back)
 *
 * So when we receive an `onTouchStart`, how can we tell if we are touching
 * *during* an animation (which then causes the animation to stop)? The only way
 * to tell is if the `touchStart` occurred immediately after the
 * `onMomentumScrollEnd`.
 *
 * This is abstracted out for you, so you can just call this.scrollResponderIsAnimating() if
 * necessary
 *
 * `ScrollResponder` also includes logic for blurring a currently focused input
 * if one is focused while scrolling. The `ScrollResponder` is a natural place
 * to put this logic since it can support not dismissing the keyboard while
 * scrolling, unless a recognized "tap"-like gesture has occurred.
 *
 * The public lifecycle API includes events for keyboard interaction, responder
 * interaction, and scrolling (among others). The keyboard callbacks
 * `onKeyboardWill/Did/*` are *global* events, but are invoked on scroll
 * responder's props so that you can guarantee that the scroll responder's
 * internal state has been updated accordingly (and deterministically) by
 * the time the props callbacks are invoke. Otherwise, you would always wonder
 * if the scroll responder is currently in a state where it recognizes new
 * keyboard positions etc. If coordinating scrolling with keyboard movement,
 * *always* use these hooks instead of listening to your own global keyboard
 * events.
 *
 * Public keyboard lifecycle API: (props callbacks)
 *
 * Standard Keyboard Appearance Sequence:
 *
 *   this.props.onKeyboardWillShow
 *   this.props.onKeyboardDidShow
 *
 * `onScrollResponderKeyboardDismissed` will be invoked if an appropriate
 * tap inside the scroll responder's scrollable region was responsible
 * for the dismissal of the keyboard. There are other reasons why the
 * keyboard could be dismissed.
 *
 *   this.props.onScrollResponderKeyboardDismissed
 *
 * Standard Keyboard Hide Sequence:
 *
 *   this.props.onKeyboardWillHide
 *   this.props.onKeyboardDidHide
 */
var emptyObject = {};
var IS_ANIMATING_TOUCH_START_THRESHOLD_MS = 16;
var ScrollResponderMixin = {
  // mixins: [Subscribable.Mixin],
  scrollResponderMixinGetInitialState: function scrollResponderMixinGetInitialState() {
    return {
      isTouching: false,
      lastMomentumScrollBeginTime: 0,
      lastMomentumScrollEndTime: 0,
      // Reset to false every time becomes responder. This is used to:
      // - Determine if the scroll view has been scrolled and therefore should
      // refuse to give up its responder lock.
      // - Determine if releasing should dismiss the keyboard when we are in
      // tap-to-dismiss mode (!this.props.keyboardShouldPersistTaps).
      observedScrollSinceBecomingResponder: false,
      becameResponderWhileAnimating: false
    };
  },

  /**
   * Invoke this from an `onScroll` event.
   */
  scrollResponderHandleScrollShouldSetResponder: function scrollResponderHandleScrollShouldSetResponder() {
    return this.state.isTouching;
  },

  /**
   * Merely touch starting is not sufficient for a scroll view to become the
   * responder. Being the "responder" means that the very next touch move/end
   * event will result in an action/movement.
   *
   * Invoke this from an `onStartShouldSetResponder` event.
   *
   * `onStartShouldSetResponder` is used when the next move/end will trigger
   * some UI movement/action, but when you want to yield priority to views
   * nested inside of the view.
   *
   * There may be some cases where scroll views actually should return `true`
   * from `onStartShouldSetResponder`: Any time we are detecting a standard tap
   * that gives priority to nested views.
   *
   * - If a single tap on the scroll view triggers an action such as
   *   recentering a map style view yet wants to give priority to interaction
   *   views inside (such as dropped pins or labels), then we would return true
   *   from this method when there is a single touch.
   *
   * - Similar to the previous case, if a two finger "tap" should trigger a
   *   zoom, we would check the `touches` count, and if `>= 2`, we would return
   *   true.
   *
   */
  scrollResponderHandleStartShouldSetResponder: function scrollResponderHandleStartShouldSetResponder() {
    return false;
  },

  /**
   * There are times when the scroll view wants to become the responder
   * (meaning respond to the next immediate `touchStart/touchEnd`), in a way
   * that *doesn't* give priority to nested views (hence the capture phase):
   *
   * - Currently animating.
   * - Tapping anywhere that is not the focused input, while the keyboard is
   *   up (which should dismiss the keyboard).
   *
   * Invoke this from an `onStartShouldSetResponderCapture` event.
   */
  scrollResponderHandleStartShouldSetResponderCapture: function scrollResponderHandleStartShouldSetResponderCapture(e) {
    // First see if we want to eat taps while the keyboard is up
    // var currentlyFocusedTextInput = TextInputState.currentlyFocusedField();
    // if (!this.props.keyboardShouldPersistTaps &&
    //   currentlyFocusedTextInput != null &&
    //   e.target !== currentlyFocusedTextInput) {
    //   return true;
    // }
    return this.scrollResponderIsAnimating();
  },

  /**
   * Invoke this from an `onResponderReject` event.
   *
   * Some other element is not yielding its role as responder. Normally, we'd
   * just disable the `UIScrollView`, but a touch has already began on it, the
   * `UIScrollView` will not accept being disabled after that. The easiest
   * solution for now is to accept the limitation of disallowing this
   * altogether. To improve this, find a way to disable the `UIScrollView` after
   * a touch has already started.
   */
  scrollResponderHandleResponderReject: function scrollResponderHandleResponderReject() {
    (0, _warning.default)(false, "ScrollView doesn't take rejection well - scrolls anyway");
  },

  /**
   * We will allow the scroll view to give up its lock iff it acquired the lock
   * during an animation. This is a very useful default that happens to satisfy
   * many common user experiences.
   *
   * - Stop a scroll on the left edge, then turn that into an outer view's
   *   backswipe.
   * - Stop a scroll mid-bounce at the top, continue pulling to have the outer
   *   view dismiss.
   * - However, without catching the scroll view mid-bounce (while it is
   *   motionless), if you drag far enough for the scroll view to become
   *   responder (and therefore drag the scroll view a bit), any backswipe
   *   navigation of a swipe gesture higher in the view hierarchy, should be
   *   rejected.
   */
  scrollResponderHandleTerminationRequest: function scrollResponderHandleTerminationRequest() {
    return !this.state.observedScrollSinceBecomingResponder;
  },

  /**
   * Invoke this from an `onTouchEnd` event.
   *
   * @param {SyntheticEvent} e Event.
   */
  scrollResponderHandleTouchEnd: function scrollResponderHandleTouchEnd(e) {
    var nativeEvent = e.nativeEvent;
    this.state.isTouching = nativeEvent.touches.length !== 0;
    this.props.onTouchEnd && this.props.onTouchEnd(e);
  },

  /**
   * Invoke this from an `onResponderRelease` event.
   */
  scrollResponderHandleResponderRelease: function scrollResponderHandleResponderRelease(e) {
    this.props.onResponderRelease && this.props.onResponderRelease(e); // By default scroll views will unfocus a textField
    // if another touch occurs outside of it

    var currentlyFocusedTextInput = _TextInputState.default.currentlyFocusedField();

    if (!this.props.keyboardShouldPersistTaps && currentlyFocusedTextInput != null && e.target !== currentlyFocusedTextInput && !this.state.observedScrollSinceBecomingResponder && !this.state.becameResponderWhileAnimating) {
      this.props.onScrollResponderKeyboardDismissed && this.props.onScrollResponderKeyboardDismissed(e);

      _TextInputState.default.blurTextInput(currentlyFocusedTextInput);
    }
  },
  scrollResponderHandleScroll: function scrollResponderHandleScroll(e) {
    this.state.observedScrollSinceBecomingResponder = true;
    this.props.onScroll && this.props.onScroll(e);
  },

  /**
   * Invoke this from an `onResponderGrant` event.
   */
  scrollResponderHandleResponderGrant: function scrollResponderHandleResponderGrant(e) {
    this.state.observedScrollSinceBecomingResponder = false;
    this.props.onResponderGrant && this.props.onResponderGrant(e);
    this.state.becameResponderWhileAnimating = this.scrollResponderIsAnimating();
  },

  /**
   * Unfortunately, `onScrollBeginDrag` also fires when *stopping* the scroll
   * animation, and there's not an easy way to distinguish a drag vs. stopping
   * momentum.
   *
   * Invoke this from an `onScrollBeginDrag` event.
   */
  scrollResponderHandleScrollBeginDrag: function scrollResponderHandleScrollBeginDrag(e) {
    this.props.onScrollBeginDrag && this.props.onScrollBeginDrag(e);
  },

  /**
   * Invoke this from an `onScrollEndDrag` event.
   */
  scrollResponderHandleScrollEndDrag: function scrollResponderHandleScrollEndDrag(e) {
    this.props.onScrollEndDrag && this.props.onScrollEndDrag(e);
  },

  /**
   * Invoke this from an `onMomentumScrollBegin` event.
   */
  scrollResponderHandleMomentumScrollBegin: function scrollResponderHandleMomentumScrollBegin(e) {
    this.state.lastMomentumScrollBeginTime = Date.now();
    this.props.onMomentumScrollBegin && this.props.onMomentumScrollBegin(e);
  },

  /**
   * Invoke this from an `onMomentumScrollEnd` event.
   */
  scrollResponderHandleMomentumScrollEnd: function scrollResponderHandleMomentumScrollEnd(e) {
    this.state.lastMomentumScrollEndTime = Date.now();
    this.props.onMomentumScrollEnd && this.props.onMomentumScrollEnd(e);
  },

  /**
   * Invoke this from an `onTouchStart` event.
   *
   * Since we know that the `SimpleEventPlugin` occurs later in the plugin
   * order, after `ResponderEventPlugin`, we can detect that we were *not*
   * permitted to be the responder (presumably because a contained view became
   * responder). The `onResponderReject` won't fire in that case - it only
   * fires when a *current* responder rejects our request.
   *
   * @param {SyntheticEvent} e Touch Start event.
   */
  scrollResponderHandleTouchStart: function scrollResponderHandleTouchStart(e) {
    this.state.isTouching = true;
    this.props.onTouchStart && this.props.onTouchStart(e);
  },

  /**
   * Invoke this from an `onTouchMove` event.
   *
   * Since we know that the `SimpleEventPlugin` occurs later in the plugin
   * order, after `ResponderEventPlugin`, we can detect that we were *not*
   * permitted to be the responder (presumably because a contained view became
   * responder). The `onResponderReject` won't fire in that case - it only
   * fires when a *current* responder rejects our request.
   *
   * @param {SyntheticEvent} e Touch Start event.
   */
  scrollResponderHandleTouchMove: function scrollResponderHandleTouchMove(e) {
    this.props.onTouchMove && this.props.onTouchMove(e);
  },

  /**
   * A helper function for this class that lets us quickly determine if the
   * view is currently animating. This is particularly useful to know when
   * a touch has just started or ended.
   */
  scrollResponderIsAnimating: function scrollResponderIsAnimating() {
    var now = Date.now();
    var timeSinceLastMomentumScrollEnd = now - this.state.lastMomentumScrollEndTime;
    var isAnimating = timeSinceLastMomentumScrollEnd < IS_ANIMATING_TOUCH_START_THRESHOLD_MS || this.state.lastMomentumScrollEndTime < this.state.lastMomentumScrollBeginTime;
    return isAnimating;
  },

  /**
   * Returns the node that represents native view that can be scrolled.
   * Components can pass what node to use by defining a `getScrollableNode`
   * function otherwise `this` is used.
   */
  scrollResponderGetScrollableNode: function scrollResponderGetScrollableNode() {
    return this.getScrollableNode ? this.getScrollableNode() : (0, _findNodeHandle.default)(this);
  },

  /**
   * A helper function to scroll to a specific point in the scrollview.
   * This is currently used to help focus on child textviews, but can also
   * be used to quickly scroll to any element we want to focus. Syntax:
   *
   * scrollResponderScrollTo(options: {x: number = 0; y: number = 0; animated: boolean = true})
   *
   * Note: The weird argument signature is due to the fact that, for historical reasons,
   * the function also accepts separate arguments as as alternative to the options object.
   * This is deprecated due to ambiguity (y before x), and SHOULD NOT BE USED.
   */
  scrollResponderScrollTo: function scrollResponderScrollTo(x, y, animated) {
    if (typeof x === 'number') {
      console.warn('`scrollResponderScrollTo(x, y, animated)` is deprecated. Use `scrollResponderScrollTo({x: 5, y: 5, animated: true})` instead.');
    } else {
      var _ref = x || emptyObject;

      x = _ref.x;
      y = _ref.y;
      animated = _ref.animated;
    }

    var node = this.scrollResponderGetScrollableNode();
    var left = x || 0;
    var top = y || 0;

    if (typeof node.scroll === 'function') {
      node.scroll({
        top,
        left,
        behavior: !animated ? 'auto' : 'smooth'
      });
    } else {
      node.scrollLeft = left;
      node.scrollTop = top;
    }
  },

  /**
   * A helper function to zoom to a specific rect in the scrollview. The argument has the shape
   * {x: number; y: number; width: number; height: number; animated: boolean = true}
   *
   * @platform ios
   */
  scrollResponderZoomTo: function scrollResponderZoomTo(rect, animated) {
    if (_Platform.default.OS !== 'ios') {
      (0, _invariant.default)('zoomToRect is not implemented');
    }
  },

  /**
   * Displays the scroll indicators momentarily.
   */
  scrollResponderFlashScrollIndicators: function scrollResponderFlashScrollIndicators() {},

  /**
   * This method should be used as the callback to onFocus in a TextInputs'
   * parent view. Note that any module using this mixin needs to return
   * the parent view's ref in getScrollViewRef() in order to use this method.
   * @param {any} nodeHandle The TextInput node handle
   * @param {number} additionalOffset The scroll view's top "contentInset".
   *        Default is 0.
   * @param {bool} preventNegativeScrolling Whether to allow pulling the content
   *        down to make it meet the keyboard's top. Default is false.
   */
  scrollResponderScrollNativeHandleToKeyboard: function scrollResponderScrollNativeHandleToKeyboard(nodeHandle, additionalOffset, preventNegativeScrollOffset) {
    this.additionalScrollOffset = additionalOffset || 0;
    this.preventNegativeScrollOffset = !!preventNegativeScrollOffset;

    _UIManager.default.measureLayout(nodeHandle, (0, _findNodeHandle.default)(this.getInnerViewNode()), this.scrollResponderTextInputFocusError, this.scrollResponderInputMeasureAndScrollToKeyboard);
  },

  /**
   * The calculations performed here assume the scroll view takes up the entire
   * screen - even if has some content inset. We then measure the offsets of the
   * keyboard, and compensate both for the scroll view's "contentInset".
   *
   * @param {number} left Position of input w.r.t. table view.
   * @param {number} top Position of input w.r.t. table view.
   * @param {number} width Width of the text input.
   * @param {number} height Height of the text input.
   */
  scrollResponderInputMeasureAndScrollToKeyboard: function scrollResponderInputMeasureAndScrollToKeyboard(left, top, width, height) {
    var keyboardScreenY = _Dimensions.default.get('window').height;

    if (this.keyboardWillOpenTo) {
      keyboardScreenY = this.keyboardWillOpenTo.endCoordinates.screenY;
    }

    var scrollOffsetY = top - keyboardScreenY + height + this.additionalScrollOffset; // By default, this can scroll with negative offset, pulling the content
    // down so that the target component's bottom meets the keyboard's top.
    // If requested otherwise, cap the offset at 0 minimum to avoid content
    // shifting down.

    if (this.preventNegativeScrollOffset) {
      scrollOffsetY = Math.max(0, scrollOffsetY);
    }

    this.scrollResponderScrollTo({
      x: 0,
      y: scrollOffsetY,
      animated: true
    });
    this.additionalOffset = 0;
    this.preventNegativeScrollOffset = false;
  },
  scrollResponderTextInputFocusError: function scrollResponderTextInputFocusError(e) {
    console.error('Error measuring text field: ', e);
  },

  /**
   * `componentWillMount` is the closest thing to a  standard "constructor" for
   * React components.
   *
   * The `keyboardWillShow` is called before input focus.
   */
  UNSAFE_componentWillMount: function UNSAFE_componentWillMount() {
    this.keyboardWillOpenTo = null;
    this.additionalScrollOffset = 0; // this.addListenerOn(RCTDeviceEventEmitter, 'keyboardWillShow', this.scrollResponderKeyboardWillShow);
    // this.addListenerOn(RCTDeviceEventEmitter, 'keyboardWillHide', this.scrollResponderKeyboardWillHide);
    // this.addListenerOn(RCTDeviceEventEmitter, 'keyboardDidShow', this.scrollResponderKeyboardDidShow);
    // this.addListenerOn(RCTDeviceEventEmitter, 'keyboardDidHide', this.scrollResponderKeyboardDidHide);
  },

  /**
   * Warning, this may be called several times for a single keyboard opening.
   * It's best to store the information in this method and then take any action
   * at a later point (either in `keyboardDidShow` or other).
   *
   * Here's the order that events occur in:
   * - focus
   * - willShow {startCoordinates, endCoordinates} several times
   * - didShow several times
   * - blur
   * - willHide {startCoordinates, endCoordinates} several times
   * - didHide several times
   *
   * The `ScrollResponder` providesModule callbacks for each of these events.
   * Even though any user could have easily listened to keyboard events
   * themselves, using these `props` callbacks ensures that ordering of events
   * is consistent - and not dependent on the order that the keyboard events are
   * subscribed to. This matters when telling the scroll view to scroll to where
   * the keyboard is headed - the scroll responder better have been notified of
   * the keyboard destination before being instructed to scroll to where the
   * keyboard will be. Stick to the `ScrollResponder` callbacks, and everything
   * will work.
   *
   * WARNING: These callbacks will fire even if a keyboard is displayed in a
   * different navigation pane. Filter out the events to determine if they are
   * relevant to you. (For example, only if you receive these callbacks after
   * you had explicitly focused a node etc).
   */
  scrollResponderKeyboardWillShow: function scrollResponderKeyboardWillShow(e) {
    this.keyboardWillOpenTo = e;
    this.props.onKeyboardWillShow && this.props.onKeyboardWillShow(e);
  },
  scrollResponderKeyboardWillHide: function scrollResponderKeyboardWillHide(e) {
    this.keyboardWillOpenTo = null;
    this.props.onKeyboardWillHide && this.props.onKeyboardWillHide(e);
  },
  scrollResponderKeyboardDidShow: function scrollResponderKeyboardDidShow(e) {
    // TODO(7693961): The event for DidShow is not available on iOS yet.
    // Use the one from WillShow and do not assign.
    if (e) {
      this.keyboardWillOpenTo = e;
    }

    this.props.onKeyboardDidShow && this.props.onKeyboardDidShow(e);
  },
  scrollResponderKeyboardDidHide: function scrollResponderKeyboardDidHide(e) {
    this.keyboardWillOpenTo = null;
    this.props.onKeyboardDidHide && this.props.onKeyboardDidHide(e);
  }
};
var ScrollResponder = {
  Mixin: ScrollResponderMixin
};
var _default = ScrollResponder;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),

/***/ 20551:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(64836)["default"]);

exports.__esModule = true;
exports["default"] = void 0;

var _UIManager = _interopRequireDefault(__webpack_require__(56629));

/**
 * Copyright (c) Nicolas Gallagher.
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

/**
 * This class is responsible for coordinating the "focused"
 * state for TextInputs. All calls relating to the keyboard
 * should be funneled through here
 */
var TextInputState = {
  /**
   * Internal state
   */
  _currentlyFocusedNode: null,

  /**
   * Returns the ID of the currently focused text field, if one exists
   * If no text field is focused it returns null
   */
  currentlyFocusedField() {
    if (document.activeElement !== this._currentlyFocusedNode) {
      this._currentlyFocusedNode = null;
    }

    return this._currentlyFocusedNode;
  },

  /**
   * @param {Object} TextInputID id of the text field to focus
   * Focuses the specified text field
   * noop if the text field was already focused
   */
  focusTextInput(textFieldNode) {
    if (textFieldNode !== null) {
      this._currentlyFocusedNode = textFieldNode;

      if (document.activeElement !== textFieldNode) {
        _UIManager.default.focus(textFieldNode);
      }
    }
  },

  /**
   * @param {Object} textFieldNode id of the text field to focus
   * Unfocuses the specified text field
   * noop if it wasn't focused
   */
  blurTextInput(textFieldNode) {
    if (textFieldNode !== null) {
      this._currentlyFocusedNode = null;

      if (document.activeElement === textFieldNode) {
        _UIManager.default.blur(textFieldNode);
      }
    }
  }

};
var _default = TextInputState;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),

/***/ 85261:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(64836)["default"]);

exports.__esModule = true;
exports["default"] = void 0;

var _View = _interopRequireDefault(__webpack_require__(79057));

var _react = _interopRequireDefault(__webpack_require__(16689));

/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

/**
 * Common implementation for a simple stubbed view.
 */
class UnimplementedView extends _react.default.Component {
  setNativeProps() {// Do nothing.
  }

  render() {
    return /*#__PURE__*/_react.default.createElement(_View.default, {
      style: [unimplementedViewStyles, this.props.style]
    }, this.props.children);
  }

}

var unimplementedViewStyles =  false ? 0 : {};
var _default = UnimplementedView;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),

/***/ 24019:
/***/ ((module, exports) => {

"use strict";


exports.__esModule = true;
exports["default"] = void 0;

/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
var canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);
var _default = canUseDOM;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),

/***/ 18083:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(64836)["default"]);

exports.__esModule = true;
exports["default"] = void 0;

var _objectWithoutPropertiesLoose2 = _interopRequireDefault(__webpack_require__(7071));

var _AccessibilityUtil = _interopRequireDefault(__webpack_require__(65082));

var _StyleSheet2 = _interopRequireDefault(__webpack_require__(84099));

var _excluded = ["accessibilityActiveDescendant", "accessibilityAtomic", "accessibilityAutoComplete", "accessibilityBusy", "accessibilityChecked", "accessibilityColumnCount", "accessibilityColumnIndex", "accessibilityColumnSpan", "accessibilityControls", "accessibilityCurrent", "accessibilityDescribedBy", "accessibilityDetails", "accessibilityDisabled", "accessibilityErrorMessage", "accessibilityExpanded", "accessibilityFlowTo", "accessibilityHasPopup", "accessibilityHidden", "accessibilityInvalid", "accessibilityKeyShortcuts", "accessibilityLabel", "accessibilityLabelledBy", "accessibilityLevel", "accessibilityLiveRegion", "accessibilityModal", "accessibilityMultiline", "accessibilityMultiSelectable", "accessibilityOrientation", "accessibilityOwns", "accessibilityPlaceholder", "accessibilityPosInSet", "accessibilityPressed", "accessibilityReadOnly", "accessibilityRequired", "accessibilityRole", "accessibilityRoleDescription", "accessibilityRowCount", "accessibilityRowIndex", "accessibilityRowSpan", "accessibilitySelected", "accessibilitySetSize", "accessibilitySort", "accessibilityValueMax", "accessibilityValueMin", "accessibilityValueNow", "accessibilityValueText", "dataSet", "focusable", "nativeID", "pointerEvents", "style", "testID"];
var emptyObject = {};
var hasOwnProperty = Object.prototype.hasOwnProperty;
var isArray = Array.isArray;
var uppercasePattern = /[A-Z]/g;

function toHyphenLower(match) {
  return '-' + match.toLowerCase();
}

function hyphenateString(str) {
  return str.replace(uppercasePattern, toHyphenLower);
}

function processIDRefList(idRefList) {
  return isArray(idRefList) ? idRefList.join(' ') : idRefList;
}

var pointerEventsStyles = _StyleSheet2.default.create({
  auto: {
    pointerEvents: 'auto'
  },
  'box-none': {
    pointerEvents: 'box-none'
  },
  'box-only': {
    pointerEvents: 'box-only'
  },
  none: {
    pointerEvents: 'none'
  }
});

var createDOMProps = (elementType, props, options) => {
  if (!props) {
    props = emptyObject;
  }

  var _props = props,
      accessibilityActiveDescendant = _props.accessibilityActiveDescendant,
      accessibilityAtomic = _props.accessibilityAtomic,
      accessibilityAutoComplete = _props.accessibilityAutoComplete,
      accessibilityBusy = _props.accessibilityBusy,
      accessibilityChecked = _props.accessibilityChecked,
      accessibilityColumnCount = _props.accessibilityColumnCount,
      accessibilityColumnIndex = _props.accessibilityColumnIndex,
      accessibilityColumnSpan = _props.accessibilityColumnSpan,
      accessibilityControls = _props.accessibilityControls,
      accessibilityCurrent = _props.accessibilityCurrent,
      accessibilityDescribedBy = _props.accessibilityDescribedBy,
      accessibilityDetails = _props.accessibilityDetails,
      accessibilityDisabled = _props.accessibilityDisabled,
      accessibilityErrorMessage = _props.accessibilityErrorMessage,
      accessibilityExpanded = _props.accessibilityExpanded,
      accessibilityFlowTo = _props.accessibilityFlowTo,
      accessibilityHasPopup = _props.accessibilityHasPopup,
      accessibilityHidden = _props.accessibilityHidden,
      accessibilityInvalid = _props.accessibilityInvalid,
      accessibilityKeyShortcuts = _props.accessibilityKeyShortcuts,
      accessibilityLabel = _props.accessibilityLabel,
      accessibilityLabelledBy = _props.accessibilityLabelledBy,
      accessibilityLevel = _props.accessibilityLevel,
      accessibilityLiveRegion = _props.accessibilityLiveRegion,
      accessibilityModal = _props.accessibilityModal,
      accessibilityMultiline = _props.accessibilityMultiline,
      accessibilityMultiSelectable = _props.accessibilityMultiSelectable,
      accessibilityOrientation = _props.accessibilityOrientation,
      accessibilityOwns = _props.accessibilityOwns,
      accessibilityPlaceholder = _props.accessibilityPlaceholder,
      accessibilityPosInSet = _props.accessibilityPosInSet,
      accessibilityPressed = _props.accessibilityPressed,
      accessibilityReadOnly = _props.accessibilityReadOnly,
      accessibilityRequired = _props.accessibilityRequired,
      accessibilityRole = _props.accessibilityRole,
      accessibilityRoleDescription = _props.accessibilityRoleDescription,
      accessibilityRowCount = _props.accessibilityRowCount,
      accessibilityRowIndex = _props.accessibilityRowIndex,
      accessibilityRowSpan = _props.accessibilityRowSpan,
      accessibilitySelected = _props.accessibilitySelected,
      accessibilitySetSize = _props.accessibilitySetSize,
      accessibilitySort = _props.accessibilitySort,
      accessibilityValueMax = _props.accessibilityValueMax,
      accessibilityValueMin = _props.accessibilityValueMin,
      accessibilityValueNow = _props.accessibilityValueNow,
      accessibilityValueText = _props.accessibilityValueText,
      dataSet = _props.dataSet,
      focusable = _props.focusable,
      nativeID = _props.nativeID,
      pointerEvents = _props.pointerEvents,
      style = _props.style,
      testID = _props.testID,
      domProps = (0, _objectWithoutPropertiesLoose2.default)(_props, _excluded);
  var disabled = accessibilityDisabled;

  var role = _AccessibilityUtil.default.propsToAriaRole(props); // ACCESSIBILITY


  if (accessibilityActiveDescendant != null) {
    domProps['aria-activedescendant'] = accessibilityActiveDescendant;
  }

  if (accessibilityAtomic != null) {
    domProps['aria-atomic'] = accessibilityAtomic;
  }

  if (accessibilityAutoComplete != null) {
    domProps['aria-autocomplete'] = accessibilityAutoComplete;
  }

  if (accessibilityBusy != null) {
    domProps['aria-busy'] = accessibilityBusy;
  }

  if (accessibilityChecked != null) {
    domProps['aria-checked'] = accessibilityChecked;
  }

  if (accessibilityColumnCount != null) {
    domProps['aria-colcount'] = accessibilityColumnCount;
  }

  if (accessibilityColumnIndex != null) {
    domProps['aria-colindex'] = accessibilityColumnIndex;
  }

  if (accessibilityColumnSpan != null) {
    domProps['aria-colspan'] = accessibilityColumnSpan;
  }

  if (accessibilityControls != null) {
    domProps['aria-controls'] = processIDRefList(accessibilityControls);
  }

  if (accessibilityCurrent != null) {
    domProps['aria-current'] = accessibilityCurrent;
  }

  if (accessibilityDescribedBy != null) {
    domProps['aria-describedby'] = processIDRefList(accessibilityDescribedBy);
  }

  if (accessibilityDetails != null) {
    domProps['aria-details'] = accessibilityDetails;
  }

  if (disabled === true) {
    domProps['aria-disabled'] = true; // Enhance with native semantics

    if (elementType === 'button' || elementType === 'form' || elementType === 'input' || elementType === 'select' || elementType === 'textarea') {
      domProps.disabled = true;
    }
  }

  if (accessibilityErrorMessage != null) {
    domProps['aria-errormessage'] = accessibilityErrorMessage;
  }

  if (accessibilityExpanded != null) {
    domProps['aria-expanded'] = accessibilityExpanded;
  }

  if (accessibilityFlowTo != null) {
    domProps['aria-flowto'] = processIDRefList(accessibilityFlowTo);
  }

  if (accessibilityHasPopup != null) {
    domProps['aria-haspopup'] = accessibilityHasPopup;
  }

  if (accessibilityHidden === true) {
    domProps['aria-hidden'] = accessibilityHidden;
  }

  if (accessibilityInvalid != null) {
    domProps['aria-invalid'] = accessibilityInvalid;
  }

  if (accessibilityKeyShortcuts != null && Array.isArray(accessibilityKeyShortcuts)) {
    domProps['aria-keyshortcuts'] = accessibilityKeyShortcuts.join(' ');
  }

  if (accessibilityLabel != null) {
    domProps['aria-label'] = accessibilityLabel;
  }

  if (accessibilityLabelledBy != null) {
    domProps['aria-labelledby'] = processIDRefList(accessibilityLabelledBy);
  }

  if (accessibilityLevel != null) {
    domProps['aria-level'] = accessibilityLevel;
  }

  if (accessibilityLiveRegion != null) {
    domProps['aria-live'] = accessibilityLiveRegion === 'none' ? 'off' : accessibilityLiveRegion;
  }

  if (accessibilityModal != null) {
    domProps['aria-modal'] = accessibilityModal;
  }

  if (accessibilityMultiline != null) {
    domProps['aria-multiline'] = accessibilityMultiline;
  }

  if (accessibilityMultiSelectable != null) {
    domProps['aria-multiselectable'] = accessibilityMultiSelectable;
  }

  if (accessibilityOrientation != null) {
    domProps['aria-orientation'] = accessibilityOrientation;
  }

  if (accessibilityOwns != null) {
    domProps['aria-owns'] = processIDRefList(accessibilityOwns);
  }

  if (accessibilityPlaceholder != null) {
    domProps['aria-placeholder'] = accessibilityPlaceholder;
  }

  if (accessibilityPosInSet != null) {
    domProps['aria-posinset'] = accessibilityPosInSet;
  }

  if (accessibilityPressed != null) {
    domProps['aria-pressed'] = accessibilityPressed;
  }

  if (accessibilityReadOnly != null) {
    domProps['aria-readonly'] = accessibilityReadOnly; // Enhance with native semantics

    if (elementType === 'input' || elementType === 'select' || elementType === 'textarea') {
      domProps.readOnly = true;
    }
  }

  if (accessibilityRequired != null) {
    domProps['aria-required'] = accessibilityRequired; // Enhance with native semantics

    if (elementType === 'input' || elementType === 'select' || elementType === 'textarea') {
      domProps.required = accessibilityRequired;
    }
  }

  if (role != null) {
    // 'presentation' synonym has wider browser support
    domProps['role'] = role === 'none' ? 'presentation' : role;
  }

  if (accessibilityRoleDescription != null) {
    domProps['aria-roledescription'] = accessibilityRoleDescription;
  }

  if (accessibilityRowCount != null) {
    domProps['aria-rowcount'] = accessibilityRowCount;
  }

  if (accessibilityRowIndex != null) {
    domProps['aria-rowindex'] = accessibilityRowIndex;
  }

  if (accessibilityRowSpan != null) {
    domProps['aria-rowspan'] = accessibilityRowSpan;
  }

  if (accessibilitySelected != null) {
    domProps['aria-selected'] = accessibilitySelected;
  }

  if (accessibilitySetSize != null) {
    domProps['aria-setsize'] = accessibilitySetSize;
  }

  if (accessibilitySort != null) {
    domProps['aria-sort'] = accessibilitySort;
  }

  if (accessibilityValueMax != null) {
    domProps['aria-valuemax'] = accessibilityValueMax;
  }

  if (accessibilityValueMin != null) {
    domProps['aria-valuemin'] = accessibilityValueMin;
  }

  if (accessibilityValueNow != null) {
    domProps['aria-valuenow'] = accessibilityValueNow;
  }

  if (accessibilityValueText != null) {
    domProps['aria-valuetext'] = accessibilityValueText;
  } // "dataSet" replaced with "data-*"


  if (dataSet != null) {
    for (var dataProp in dataSet) {
      if (hasOwnProperty.call(dataSet, dataProp)) {
        var dataName = hyphenateString(dataProp);
        var dataValue = dataSet[dataProp];

        if (dataValue != null) {
          domProps["data-" + dataName] = dataValue;
        }
      }
    }
  } // FOCUS
  // "focusable" indicates that an element may be a keyboard tab-stop.


  if (focusable === false) {
    domProps.tabIndex = '-1';
  }

  if ( // These native elements are keyboard focusable by default
  elementType === 'a' || elementType === 'button' || elementType === 'input' || elementType === 'select' || elementType === 'textarea') {
    if (focusable === false || accessibilityDisabled === true) {
      domProps.tabIndex = '-1';
    }
  } else if ( // These roles are made keyboard focusable by default
  role === 'button' || role === 'checkbox' || role === 'link' || role === 'radio' || role === 'textbox' || role === 'switch') {
    if (focusable !== false) {
      domProps.tabIndex = '0';
    }
  } else {
    // Everything else must explicitly set the prop
    if (focusable === true) {
      domProps.tabIndex = '0';
    }
  } // Resolve styles


  var _StyleSheet = (0, _StyleSheet2.default)([style, pointerEvents && pointerEventsStyles[pointerEvents]], {
    writingDirection: options ? options.writingDirection : 'ltr'
  }),
      className = _StyleSheet[0],
      inlineStyle = _StyleSheet[1];

  if (className) {
    domProps.className = className;
  }

  if (inlineStyle) {
    domProps.style = inlineStyle;
  } // OTHER
  // Native element ID


  if (nativeID != null) {
    domProps.id = nativeID;
  } // Automated test IDs


  if (testID != null) {
    domProps['data-testid'] = testID;
  }

  return domProps;
};

var _default = createDOMProps;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),

/***/ 54615:
/***/ ((module, exports, __webpack_require__) => {

"use strict";
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */


var _interopRequireDefault = (__webpack_require__(64836)["default"]);

exports.__esModule = true;
exports["default"] = createEventHandle;

var _canUseDom = _interopRequireDefault(__webpack_require__(24019));

var emptyFunction = () => {};

function supportsPassiveEvents() {
  var supported = false; // Check if browser supports event with passive listeners
  // https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Safely_detecting_option_support

  if (_canUseDom.default) {
    try {
      var options = {};
      Object.defineProperty(options, 'passive', {
        get() {
          supported = true;
          return false;
        }

      });
      window.addEventListener('test', null, options);
      window.removeEventListener('test', null, options);
    } catch (e) {}
  }

  return supported;
}

var canUsePassiveEvents = supportsPassiveEvents();

function getOptions(options) {
  if (options == null) {
    return false;
  }

  return canUsePassiveEvents ? options : Boolean(options.capture);
}
/**
 * Shim generic API compatibility with ReactDOM's synthetic events, without needing the
 * large amount of code ReactDOM uses to do this. Ideally we wouldn't use a synthetic
 * event wrapper at all.
 */


function isPropagationStopped() {
  return this.cancelBubble;
}

function isDefaultPrevented() {
  return this.defaultPrevented;
}

function normalizeEvent(event) {
  event.nativeEvent = event;
  event.persist = emptyFunction;
  event.isDefaultPrevented = isDefaultPrevented;
  event.isPropagationStopped = isPropagationStopped;
  return event;
}
/**
 *
 */


function createEventHandle(type, options) {
  var opts = getOptions(options);
  return function (target, listener) {
    if (target == null || typeof target.addEventListener !== 'function') {
      throw new Error('createEventHandle: called on an invalid target.');
    }

    var element = target;

    if (listener != null) {
      var compatListener = e => listener(normalizeEvent(e));

      element.addEventListener(type, compatListener, opts);
      return function removeListener() {
        if (element != null) {
          element.removeEventListener(type, compatListener, opts);
        }
      };
    } else {
      return emptyFunction;
    }
  };
}

module.exports = exports.default;

/***/ }),

/***/ 69835:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(64836)["default"]);

exports.__esModule = true;
exports["default"] = void 0;

var _TextInputState = _interopRequireDefault(__webpack_require__(20551));

/**
 * Copyright (c) Nicolas Gallagher.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
var dismissKeyboard = () => {
  _TextInputState.default.blurTextInput(_TextInputState.default.currentlyFocusedField());
};

var _default = dismissKeyboard;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),

/***/ 24475:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


exports.__esModule = true;
exports.touchProps = exports.styleProps = exports.mouseProps = exports.keyboardProps = exports.focusProps = exports.defaultProps = exports.clickProps = exports.accessibilityProps = void 0;

/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
var defaultProps = {
  children: true,
  dataSet: true,
  nativeID: true,
  ref: true,
  suppressHydrationWarning: true,
  testID: true
};
exports.defaultProps = defaultProps;
var accessibilityProps = {
  accessibilityActiveDescendant: true,
  accessibilityAtomic: true,
  accessibilityAutoComplete: true,
  accessibilityBusy: true,
  accessibilityChecked: true,
  accessibilityColumnCount: true,
  accessibilityColumnIndex: true,
  accessibilityColumnSpan: true,
  accessibilityControls: true,
  accessibilityCurrent: true,
  accessibilityDescribedBy: true,
  accessibilityDetails: true,
  accessibilityDisabled: true,
  accessibilityErrorMessage: true,
  accessibilityExpanded: true,
  accessibilityFlowTo: true,
  accessibilityHasPopup: true,
  accessibilityHidden: true,
  accessibilityInvalid: true,
  accessibilityKeyShortcuts: true,
  accessibilityLabel: true,
  accessibilityLabelledBy: true,
  accessibilityLevel: true,
  accessibilityLiveRegion: true,
  accessibilityModal: true,
  accessibilityMultiline: true,
  accessibilityMultiSelectable: true,
  accessibilityOrientation: true,
  accessibilityOwns: true,
  accessibilityPlaceholder: true,
  accessibilityPosInSet: true,
  accessibilityPressed: true,
  accessibilityReadOnly: true,
  accessibilityRequired: true,
  accessibilityRole: true,
  accessibilityRoleDescription: true,
  accessibilityRowCount: true,
  accessibilityRowIndex: true,
  accessibilityRowSpan: true,
  accessibilitySelected: true,
  accessibilitySetSize: true,
  accessibilitySort: true,
  accessibilityValueMax: true,
  accessibilityValueMin: true,
  accessibilityValueNow: true,
  accessibilityValueText: true,
  dir: true,
  focusable: true
};
exports.accessibilityProps = accessibilityProps;
var clickProps = {
  onClick: true,
  onClickCapture: true,
  onContextMenu: true
};
exports.clickProps = clickProps;
var focusProps = {
  onBlur: true,
  onFocus: true
};
exports.focusProps = focusProps;
var keyboardProps = {
  onKeyDown: true,
  onKeyDownCapture: true,
  onKeyUp: true,
  onKeyUpCapture: true
};
exports.keyboardProps = keyboardProps;
var mouseProps = {
  onMouseDown: true,
  onMouseEnter: true,
  onMouseLeave: true,
  onMouseMove: true,
  onMouseOver: true,
  onMouseOut: true,
  onMouseUp: true
};
exports.mouseProps = mouseProps;
var touchProps = {
  onTouchCancel: true,
  onTouchCancelCapture: true,
  onTouchEnd: true,
  onTouchEndCapture: true,
  onTouchMove: true,
  onTouchMoveCapture: true,
  onTouchStart: true,
  onTouchStartCapture: true
};
exports.touchProps = touchProps;
var styleProps = {
  classList: true,
  style: true
};
exports.styleProps = styleProps;

/***/ }),

/***/ 71826:
/***/ ((module, exports) => {

"use strict";


exports.__esModule = true;
exports["default"] = void 0;

/**
 * Copyright (c) Nicolas Gallagher.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
var getBoundingClientRect = node => {
  if (node != null) {
    var isElement = node.nodeType === 1;
    /* Node.ELEMENT_NODE */

    if (isElement && typeof node.getBoundingClientRect === 'function') {
      return node.getBoundingClientRect();
    }
  }
};

var _default = getBoundingClientRect;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),

/***/ 72031:
/***/ ((module, exports) => {

"use strict";


exports.__esModule = true;
exports["default"] = isSelectionValid;

/**
 * Copyright (c) Nicolas Gallagher
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
function isSelectionValid() {
  var selection = window.getSelection();
  var string = selection.toString();
  var anchorNode = selection.anchorNode;
  var focusNode = selection.focusNode;
  var isTextNode = anchorNode && anchorNode.nodeType === window.Node.TEXT_NODE || focusNode && focusNode.nodeType === window.Node.TEXT_NODE;
  return string.length >= 1 && string !== '\n' && isTextNode;
}

module.exports = exports.default;

/***/ }),

/***/ 47391:
/***/ ((module, exports) => {

"use strict";


exports.__esModule = true;
exports["default"] = void 0;

/**
 * Copyright (c) Nicolas Gallagher.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
var isWebColor = color => color === 'currentcolor' || color === 'currentColor' || color === 'inherit' || color.indexOf('var(') === 0;

var _default = isWebColor;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),

/***/ 88370:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireWildcard = (__webpack_require__(75263)["default"]);

exports.__esModule = true;
exports["default"] = mergeRefs;

var React = _interopRequireWildcard(__webpack_require__(16689));

/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
function mergeRefs() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  return function forwardRef(node) {
    args.forEach(ref => {
      if (ref == null) {
        return;
      }

      if (typeof ref === 'function') {
        ref(node);
        return;
      }

      if (typeof ref === 'object') {
        ref.current = node;
        return;
      }

      console.error("mergeRefs cannot handle Refs of type boolean, number or string, received ref " + String(ref));
    });
  };
}

module.exports = exports.default;

/***/ }),

/***/ 38661:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(64836)["default"]);

exports.__esModule = true;
exports.addModalityListener = addModalityListener;
exports.getActiveModality = getActiveModality;
exports.getModality = getModality;
exports.testOnly_resetActiveModality = testOnly_resetActiveModality;

var _createEventHandle = _interopRequireDefault(__webpack_require__(54615));

var _canUseDom = _interopRequireDefault(__webpack_require__(24019));

/**
 * Copyright (c) Nicolas Gallagher.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
var supportsPointerEvent = () => !!(typeof window !== 'undefined' && window.PointerEvent != null);

var activeModality = 'keyboard';
var modality = 'keyboard';
var previousModality;
var previousActiveModality;
var isEmulatingMouseEvents = false;
var listeners = new Set();
var KEYBOARD = 'keyboard';
var MOUSE = 'mouse';
var TOUCH = 'touch';
var BLUR = 'blur';
var CONTEXTMENU = 'contextmenu';
var FOCUS = 'focus';
var KEYDOWN = 'keydown';
var MOUSEDOWN = 'mousedown';
var MOUSEMOVE = 'mousemove';
var MOUSEUP = 'mouseup';
var POINTERDOWN = 'pointerdown';
var POINTERMOVE = 'pointermove';
var SCROLL = 'scroll';
var SELECTIONCHANGE = 'selectionchange';
var TOUCHCANCEL = 'touchcancel';
var TOUCHMOVE = 'touchmove';
var TOUCHSTART = 'touchstart';
var VISIBILITYCHANGE = 'visibilitychange';
var bubbleOptions = {
  passive: true
};
var captureOptions = {
  capture: true,
  passive: true
}; // Window events

var addBlurListener = (0, _createEventHandle.default)(BLUR, bubbleOptions);
var addFocusListener = (0, _createEventHandle.default)(FOCUS, bubbleOptions); // Must be capture phase because 'stopPropagation' might prevent these
// events bubbling to the document.

var addVisibilityChangeListener = (0, _createEventHandle.default)(VISIBILITYCHANGE, captureOptions);
var addKeyDownListener = (0, _createEventHandle.default)(KEYDOWN, captureOptions);
var addPointerDownListener = (0, _createEventHandle.default)(POINTERDOWN, captureOptions);
var addPointerMoveListener = (0, _createEventHandle.default)(POINTERMOVE, captureOptions); // Fallback events

var addContextMenuListener = (0, _createEventHandle.default)(CONTEXTMENU, captureOptions);
var addMouseDownListener = (0, _createEventHandle.default)(MOUSEDOWN, captureOptions);
var addMouseMoveListener = (0, _createEventHandle.default)(MOUSEMOVE, captureOptions);
var addMouseUpListener = (0, _createEventHandle.default)(MOUSEUP, captureOptions);
var addScrollListener = (0, _createEventHandle.default)(SCROLL, captureOptions);
var addSelectiomChangeListener = (0, _createEventHandle.default)(SELECTIONCHANGE, captureOptions);
var addTouchCancelListener = (0, _createEventHandle.default)(TOUCHCANCEL, captureOptions);
var addTouchMoveListener = (0, _createEventHandle.default)(TOUCHMOVE, captureOptions);
var addTouchStartListener = (0, _createEventHandle.default)(TOUCHSTART, captureOptions);

function restoreModality() {
  if (previousModality != null || previousActiveModality != null) {
    if (previousModality != null) {
      modality = previousModality;
      previousModality = null;
    }

    if (previousActiveModality != null) {
      activeModality = previousActiveModality;
      previousActiveModality = null;
    }

    callListeners();
  }
}

function onBlurWindow() {
  previousModality = modality;
  previousActiveModality = activeModality;
  activeModality = KEYBOARD;
  modality = KEYBOARD;
  callListeners(); // for fallback events

  isEmulatingMouseEvents = false;
}

function onFocusWindow() {
  restoreModality();
}

function onKeyDown(event) {
  if (event.metaKey || event.altKey || event.ctrlKey) {
    return;
  }

  if (modality !== KEYBOARD) {
    modality = KEYBOARD;
    activeModality = KEYBOARD;
    callListeners();
  }
}

function onVisibilityChange() {
  if (document.visibilityState !== 'hidden') {
    restoreModality();
  }
}

function onPointerish(event) {
  var eventType = event.type;

  if (supportsPointerEvent()) {
    if (eventType === POINTERDOWN) {
      if (activeModality !== event.pointerType) {
        modality = event.pointerType;
        activeModality = event.pointerType;
        callListeners();
      }

      return;
    }

    if (eventType === POINTERMOVE) {
      if (modality !== event.pointerType) {
        modality = event.pointerType;
        callListeners();
      }

      return;
    }
  } // Fallback for non-PointerEvent environment
  else {
    if (!isEmulatingMouseEvents) {
      if (eventType === MOUSEDOWN) {
        if (activeModality !== MOUSE) {
          modality = MOUSE;
          activeModality = MOUSE;
          callListeners();
        }
      }

      if (eventType === MOUSEMOVE) {
        if (modality !== MOUSE) {
          modality = MOUSE;
          callListeners();
        }
      }
    } // Flag when browser may produce emulated events


    if (eventType === TOUCHSTART) {
      isEmulatingMouseEvents = true;

      if (event.touches && event.touches.length > 1) {
        isEmulatingMouseEvents = false;
      }

      if (activeModality !== TOUCH) {
        modality = TOUCH;
        activeModality = TOUCH;
        callListeners();
      }

      return;
    } // Remove flag after emulated events are finished or cancelled, and if an
    // event occurs that cuts short a touch event sequence.


    if (eventType === CONTEXTMENU || eventType === MOUSEUP || eventType === SELECTIONCHANGE || eventType === SCROLL || eventType === TOUCHCANCEL || eventType === TOUCHMOVE) {
      isEmulatingMouseEvents = false;
    }
  }
}

if (_canUseDom.default) {
  addBlurListener(window, onBlurWindow);
  addFocusListener(window, onFocusWindow);
  addKeyDownListener(document, onKeyDown);
  addPointerDownListener(document, onPointerish);
  addPointerMoveListener(document, onPointerish);
  addVisibilityChangeListener(document, onVisibilityChange); // fallbacks

  addContextMenuListener(document, onPointerish);
  addMouseDownListener(document, onPointerish);
  addMouseMoveListener(document, onPointerish);
  addMouseUpListener(document, onPointerish);
  addTouchCancelListener(document, onPointerish);
  addTouchMoveListener(document, onPointerish);
  addTouchStartListener(document, onPointerish);
  addSelectiomChangeListener(document, onPointerish);
  addScrollListener(document, onPointerish);
}

function callListeners() {
  var value = {
    activeModality,
    modality
  };
  listeners.forEach(listener => {
    listener(value);
  });
}

function getActiveModality() {
  return activeModality;
}

function getModality() {
  return modality;
}

function addModalityListener(listener) {
  listeners.add(listener);
  return () => {
    listeners.delete(listener);
  };
}

function testOnly_resetActiveModality() {
  isEmulatingMouseEvents = false;
  activeModality = KEYBOARD;
  modality = KEYBOARD;
}

/***/ }),

/***/ 29720:
/***/ ((module, exports) => {

"use strict";


exports.__esModule = true;
exports["default"] = void 0;

/**
 * Copyright (c) Nicolas Gallagher.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
var CSS_UNIT_RE = /^[+-]?\d*(?:\.\d+)?(?:[Ee][+-]?\d+)?(%|\w*)/;

var getUnit = str => str.match(CSS_UNIT_RE)[1];

var isNumeric = n => {
  return !isNaN(parseFloat(n)) && isFinite(n);
};

var multiplyStyleLengthValue = (value, multiple) => {
  if (typeof value === 'string') {
    var number = parseFloat(value) * multiple;
    var unit = getUnit(value);
    return "" + number + unit;
  } else if (isNumeric(value)) {
    return value * multiple;
  }
};

var _default = multiplyStyleLengthValue;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),

/***/ 27447:
/***/ ((module, exports) => {

"use strict";


exports.__esModule = true;
exports["default"] = pick;

/**
 * Copyright (c) Nicolas Gallagher.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
function pick(obj, list) {
  var nextObj = {};

  for (var key in obj) {
    if (obj.hasOwnProperty(key)) {
      if (list[key] === true) {
        nextObj[key] = obj[key];
      }
    }
  }

  return nextObj;
}

module.exports = exports.default;

/***/ }),

/***/ 82637:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(64836)["default"]);

exports.__esModule = true;
exports["default"] = void 0;

var _createPrefixer = _interopRequireDefault(__webpack_require__(12150));

var _static = _interopRequireDefault(__webpack_require__(47195));

/**
 * Copyright (c) Nicolas Gallagher.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
var prefixAll = (0, _createPrefixer.default)(_static.default);
var _default = prefixAll;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),

/***/ 47195:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(64836)["default"]);

exports.__esModule = true;
exports["default"] = void 0;

var _backgroundClip = _interopRequireDefault(__webpack_require__(60998));

var _crossFade = _interopRequireDefault(__webpack_require__(45539));

var _cursor = _interopRequireDefault(__webpack_require__(49308));

var _filter = _interopRequireDefault(__webpack_require__(38739));

var _imageSet = _interopRequireDefault(__webpack_require__(34845));

var _logical = _interopRequireDefault(__webpack_require__(21764));

var _position = _interopRequireDefault(__webpack_require__(43358));

var _sizing = _interopRequireDefault(__webpack_require__(12196));

var _transition = _interopRequireDefault(__webpack_require__(73763));

var w = ['Webkit'];
var m = ['Moz'];
var wm = ['Webkit', 'Moz'];
var wms = ['Webkit', 'ms'];
var wmms = ['Webkit', 'Moz', 'ms'];
var _default = {
  plugins: [_backgroundClip.default, _crossFade.default, _cursor.default, _filter.default, _imageSet.default, _logical.default, _position.default, _sizing.default, _transition.default],
  prefixMap: {
    appearance: wmms,
    userSelect: wm,
    textEmphasisPosition: wms,
    textEmphasis: wms,
    textEmphasisStyle: wms,
    textEmphasisColor: wms,
    boxDecorationBreak: wms,
    clipPath: w,
    maskImage: wms,
    maskMode: wms,
    maskRepeat: wms,
    maskPosition: wms,
    maskClip: wms,
    maskOrigin: wms,
    maskSize: wms,
    maskComposite: wms,
    mask: wms,
    maskBorderSource: wms,
    maskBorderMode: wms,
    maskBorderSlice: wms,
    maskBorderWidth: wms,
    maskBorderOutset: wms,
    maskBorderRepeat: wms,
    maskBorder: wms,
    maskType: wms,
    textDecorationStyle: w,
    textDecorationSkip: w,
    textDecorationLine: w,
    textDecorationColor: w,
    filter: w,
    breakAfter: w,
    breakBefore: w,
    breakInside: w,
    columnCount: w,
    columnFill: w,
    columnGap: w,
    columnRule: w,
    columnRuleColor: w,
    columnRuleStyle: w,
    columnRuleWidth: w,
    columns: w,
    columnSpan: w,
    columnWidth: w,
    backdropFilter: w,
    hyphens: w,
    flowInto: w,
    flowFrom: w,
    regionFragment: w,
    textOrientation: w,
    tabSize: m,
    fontKerning: w,
    textSizeAdjust: w
  }
};
exports["default"] = _default;
module.exports = exports.default;

/***/ }),

/***/ 74357:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(64836)["default"]);

exports.__esModule = true;
exports["default"] = exports.cancelIdleCallback = void 0;

var _canUseDom = _interopRequireDefault(__webpack_require__(24019));

/**
 * Copyright (c) Nicolas Gallagher.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
var _requestIdleCallback = function _requestIdleCallback(cb, options) {
  return setTimeout(() => {
    var start = Date.now();
    cb({
      didTimeout: false,

      timeRemaining() {
        return Math.max(0, 50 - (Date.now() - start));
      }

    });
  }, 1);
};

var _cancelIdleCallback = function _cancelIdleCallback(id) {
  clearTimeout(id);
};

var isSupported = _canUseDom.default && typeof window.requestIdleCallback !== 'undefined';
var requestIdleCallback = isSupported ? window.requestIdleCallback : _requestIdleCallback;
var cancelIdleCallback = isSupported ? window.cancelIdleCallback : _cancelIdleCallback;
exports.cancelIdleCallback = cancelIdleCallback;
var _default = requestIdleCallback;
exports["default"] = _default;

/***/ }),

/***/ 52916:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(64836)["default"]);

exports.__esModule = true;
exports["default"] = void 0;

var _unitlessNumbers = _interopRequireDefault(__webpack_require__(95836));

/* eslint-disable */

/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * From React 16.0.0
 * 
 */

/**
 * Convert a value into the proper css writable value. The style name `name`
 * should be logical (no hyphens), as specified
 * in `CSSProperty.isUnitlessNumber`.
 *
 * @param {string} name CSS property name such as `topMargin`.
 * @param {*} value CSS property value such as `10px`.
 * @return {string} Normalized style value with dimensions applied.
 */
function dangerousStyleValue(name, value, isCustomProperty) {
  // Note that we've removed escapeTextForBrowser() calls here since the
  // whole string will be escaped when the attribute is injected into
  // the markup. If you provide unsafe user data here they can inject
  // arbitrary CSS which may be problematic (I couldn't repro this):
  // https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet
  // http://www.thespanner.co.uk/2007/11/26/ultimate-xss-css-injection/
  // This is not an XSS hole but instead a potential CSS injection issue
  // which has lead to a greater discussion about how we're going to
  // trust URLs moving forward. See #2115901
  var isEmpty = value == null || typeof value === 'boolean' || value === '';

  if (isEmpty) {
    return '';
  }

  if (!isCustomProperty && typeof value === 'number' && value !== 0 && !(_unitlessNumbers.default.hasOwnProperty(name) && _unitlessNumbers.default[name])) {
    return value + 'px'; // Presumes implicit 'px' suffix for unitless numbers
  }

  return ('' + value).trim();
}

var _default = dangerousStyleValue;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),

/***/ 75736:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(64836)["default"]);

exports.__esModule = true;
exports["default"] = void 0;

var _dangerousStyleValue = _interopRequireDefault(__webpack_require__(52916));

/* eslint-disable */

/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * From React 16.3.0
 * 
 */

/**
 * Sets the value for multiple styles on a node.  If a value is specified as
 * '' (empty string), the corresponding style property will be unset.
 *
 * @param {DOMElement} node
 * @param {object} styles
 */
function setValueForStyles(node, styles) {
  var style = node.style;

  for (var styleName in styles) {
    if (!styles.hasOwnProperty(styleName)) {
      continue;
    }

    var isCustomProperty = styleName.indexOf('--') === 0;
    var styleValue = (0, _dangerousStyleValue.default)(styleName, styles[styleName], isCustomProperty);

    if (styleName === 'float') {
      styleName = 'cssFloat';
    }

    if (isCustomProperty) {
      style.setProperty(styleName, styleValue);
    } else {
      style[styleName] = styleValue;
    }
  }
}

var _default = setValueForStyles;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),

/***/ 95836:
/***/ ((module, exports) => {

"use strict";


exports.__esModule = true;
exports["default"] = void 0;

/**
 * Copyright (c) Nicolas Gallagher.
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
var unitlessNumbers = {
  animationIterationCount: true,
  aspectRatio: true,
  borderImageOutset: true,
  borderImageSlice: true,
  borderImageWidth: true,
  boxFlex: true,
  boxFlexGroup: true,
  boxOrdinalGroup: true,
  columnCount: true,
  flex: true,
  flexGrow: true,
  flexOrder: true,
  flexPositive: true,
  flexShrink: true,
  flexNegative: true,
  fontWeight: true,
  gridRow: true,
  gridRowEnd: true,
  gridRowGap: true,
  gridRowStart: true,
  gridColumn: true,
  gridColumnEnd: true,
  gridColumnGap: true,
  gridColumnStart: true,
  lineClamp: true,
  opacity: true,
  order: true,
  orphans: true,
  tabSize: true,
  widows: true,
  zIndex: true,
  zoom: true,
  // SVG-related
  fillOpacity: true,
  floodOpacity: true,
  stopOpacity: true,
  strokeDasharray: true,
  strokeDashoffset: true,
  strokeMiterlimit: true,
  strokeOpacity: true,
  strokeWidth: true,
  // transform types
  scale: true,
  scaleX: true,
  scaleY: true,
  scaleZ: true,
  // RN properties
  shadowOpacity: true
};
/**
 * Support style names that may come passed in prefixed by adding permutations
 * of vendor prefixes.
 */

var prefixes = ['ms', 'Moz', 'O', 'Webkit'];

var prefixKey = (prefix, key) => {
  return prefix + key.charAt(0).toUpperCase() + key.substring(1);
};

Object.keys(unitlessNumbers).forEach(prop => {
  prefixes.forEach(prefix => {
    unitlessNumbers[prefixKey(prefix, prop)] = unitlessNumbers[prop];
  });
});
var _default = unitlessNumbers;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),

/***/ 98954:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(64836)["default"]);

exports.__esModule = true;
exports["default"] = useElementLayout;

var _useLayoutEffect = _interopRequireDefault(__webpack_require__(63320));

var _UIManager = _interopRequireDefault(__webpack_require__(56629));

var _canUseDom = _interopRequireDefault(__webpack_require__(24019));

/**
 * Copyright (c) Nicolas Gallagher.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
var DOM_LAYOUT_HANDLER_NAME = '__reactLayoutHandler';
var didWarn = !_canUseDom.default;
var resizeObserver = null;

function getResizeObserver() {
  if (_canUseDom.default && typeof window.ResizeObserver !== 'undefined') {
    if (resizeObserver == null) {
      resizeObserver = new window.ResizeObserver(function (entries) {
        entries.forEach(entry => {
          var node = entry.target;
          var onLayout = node[DOM_LAYOUT_HANDLER_NAME];

          if (typeof onLayout === 'function') {
            // We still need to measure the view because browsers don't yet provide
            // border-box dimensions in the entry
            _UIManager.default.measure(node, (x, y, width, height, left, top) => {
              var event = {
                // $FlowFixMe
                nativeEvent: {
                  layout: {
                    x,
                    y,
                    width,
                    height,
                    left,
                    top
                  }
                },
                timeStamp: Date.now()
              };
              Object.defineProperty(event.nativeEvent, 'target', {
                enumerable: true,
                get: () => entry.target
              });
              onLayout(event);
            });
          }
        });
      });
    }
  } else if (!didWarn) {
    if (false) {}
  }

  return resizeObserver;
}

function useElementLayout(ref, onLayout) {
  var observer = getResizeObserver();
  (0, _useLayoutEffect.default)(() => {
    var node = ref.current;

    if (node != null) {
      node[DOM_LAYOUT_HANDLER_NAME] = onLayout;
    }
  }, [ref, onLayout]); // Observing is done in a separate effect to avoid this effect running
  // when 'onLayout' changes.

  (0, _useLayoutEffect.default)(() => {
    var node = ref.current;

    if (node != null && observer != null) {
      if (typeof node[DOM_LAYOUT_HANDLER_NAME] === 'function') {
        observer.observe(node);
      } else {
        observer.unobserve(node);
      }
    }

    return () => {
      if (node != null && observer != null) {
        observer.unobserve(node);
      }
    };
  }, [ref, observer]);
}

module.exports = exports.default;

/***/ }),

/***/ 87866:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(64836)["default"]);

exports.__esModule = true;
exports["default"] = useEvent;

var _createEventHandle = _interopRequireDefault(__webpack_require__(54615));

var _useLayoutEffect = _interopRequireDefault(__webpack_require__(63320));

var _useStable = _interopRequireDefault(__webpack_require__(96492));

/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

/**
 * This can be used with any event type include custom events.
 *
 * const click = useEvent('click', options);
 * useEffect(() => {
 *   click.setListener(target, onClick);
 *   return () => click.clear();
 * }).
 */
function useEvent(event, options) {
  var targetListeners = (0, _useStable.default)(() => new Map());
  var addListener = (0, _useStable.default)(() => {
    var addEventListener = (0, _createEventHandle.default)(event, options);
    return (target, callback) => {
      var removeTargetListener = targetListeners.get(target);

      if (removeTargetListener != null) {
        removeTargetListener();
      }

      if (callback == null) {
        targetListeners.delete(target);
      }

      var removeEventListener = addEventListener(target, callback);
      targetListeners.set(target, removeEventListener);
      return removeEventListener;
    };
  });
  (0, _useLayoutEffect.default)(() => {
    return () => {
      targetListeners.forEach(removeListener => {
        removeListener();
      });
      targetListeners.clear();
    };
  }, [targetListeners]);
  return addListener;
}

module.exports = exports.default;

/***/ }),

/***/ 63711:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(64836)["default"]);

exports.__esModule = true;
exports["default"] = useHover;

var _modality = __webpack_require__(38661);

var _useEvent = _interopRequireDefault(__webpack_require__(87866));

var _useLayoutEffect = _interopRequireDefault(__webpack_require__(63320));

/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

/**
 * Implementation
 */
var emptyObject = {};
var opts = {
  passive: true
};
var lockEventType = 'react-gui:hover:lock';
var unlockEventType = 'react-gui:hover:unlock';

var supportsPointerEvent = () => !!(typeof window !== 'undefined' && window.PointerEvent != null);

function dispatchCustomEvent(target, type, payload) {
  var event = document.createEvent('CustomEvent');

  var _ref = payload || emptyObject,
      _ref$bubbles = _ref.bubbles,
      bubbles = _ref$bubbles === void 0 ? true : _ref$bubbles,
      _ref$cancelable = _ref.cancelable,
      cancelable = _ref$cancelable === void 0 ? true : _ref$cancelable,
      detail = _ref.detail;

  event.initCustomEvent(type, bubbles, cancelable, detail);
  target.dispatchEvent(event);
} // This accounts for the non-PointerEvent fallback events.


function getPointerType(event) {
  var pointerType = event.pointerType;
  return pointerType != null ? pointerType : (0, _modality.getModality)();
}

function useHover(targetRef, config) {
  var contain = config.contain,
      disabled = config.disabled,
      onHoverStart = config.onHoverStart,
      onHoverChange = config.onHoverChange,
      onHoverUpdate = config.onHoverUpdate,
      onHoverEnd = config.onHoverEnd;
  var canUsePE = supportsPointerEvent();
  var addMoveListener = (0, _useEvent.default)(canUsePE ? 'pointermove' : 'mousemove', opts);
  var addEnterListener = (0, _useEvent.default)(canUsePE ? 'pointerenter' : 'mouseenter', opts);
  var addLeaveListener = (0, _useEvent.default)(canUsePE ? 'pointerleave' : 'mouseleave', opts); // These custom events are used to implement the "contain" prop.

  var addLockListener = (0, _useEvent.default)(lockEventType, opts);
  var addUnlockListener = (0, _useEvent.default)(unlockEventType, opts);
  (0, _useLayoutEffect.default)(() => {
    var target = targetRef.current;

    if (target !== null) {
      /**
       * End the hover gesture
       */
      var hoverEnd = function hoverEnd(e) {
        if (onHoverEnd != null) {
          onHoverEnd(e);
        }

        if (onHoverChange != null) {
          onHoverChange(false);
        } // Remove the listeners once finished.


        addMoveListener(target, null);
        addLeaveListener(target, null);
      };
      /**
       * Leave element
       */


      var leaveListener = function leaveListener(e) {
        var target = targetRef.current;

        if (target != null && getPointerType(e) !== 'touch') {
          if (contain) {
            dispatchCustomEvent(target, unlockEventType);
          }

          hoverEnd(e);
        }
      };
      /**
       * Move within element
       */


      var moveListener = function moveListener(e) {
        if (getPointerType(e) !== 'touch') {
          if (onHoverUpdate != null) {
            // Not all browsers have these properties
            if (e.x == null) {
              e.x = e.clientX;
            }

            if (e.y == null) {
              e.y = e.clientY;
            }

            onHoverUpdate(e);
          }
        }
      };
      /**
       * Start the hover gesture
       */


      var hoverStart = function hoverStart(e) {
        if (onHoverStart != null) {
          onHoverStart(e);
        }

        if (onHoverChange != null) {
          onHoverChange(true);
        } // Set the listeners needed for the rest of the hover gesture.


        if (onHoverUpdate != null) {
          addMoveListener(target, !disabled ? moveListener : null);
        }

        addLeaveListener(target, !disabled ? leaveListener : null);
      };
      /**
       * Enter element
       */


      var enterListener = function enterListener(e) {
        var target = targetRef.current;

        if (target != null && getPointerType(e) !== 'touch') {
          if (contain) {
            dispatchCustomEvent(target, lockEventType);
          }

          hoverStart(e);

          var lockListener = function lockListener(lockEvent) {
            if (lockEvent.target !== target) {
              hoverEnd(e);
            }
          };

          var unlockListener = function unlockListener(lockEvent) {
            if (lockEvent.target !== target) {
              hoverStart(e);
            }
          };

          addLockListener(target, !disabled ? lockListener : null);
          addUnlockListener(target, !disabled ? unlockListener : null);
        }
      };

      addEnterListener(target, !disabled ? enterListener : null);
    }
  }, [addEnterListener, addMoveListener, addLeaveListener, addLockListener, addUnlockListener, contain, disabled, onHoverStart, onHoverChange, onHoverUpdate, onHoverEnd, targetRef]);
}

module.exports = exports.default;

/***/ }),

/***/ 63320:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(64836)["default"]);

exports.__esModule = true;
exports["default"] = void 0;

var _react = __webpack_require__(16689);

var _canUseDom = _interopRequireDefault(__webpack_require__(24019));

/**
 * Copyright (c) Nicolas Gallagher.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * useLayoutEffect throws an error on the server. On the few occasions where is
 * problematic, use this hook.
 *
 * 
 */
var useLayoutEffectImpl = _canUseDom.default ? _react.useLayoutEffect : _react.useEffect;
var _default = useLayoutEffectImpl;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),

/***/ 82901:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var _interopRequireWildcard = (__webpack_require__(75263)["default"]);

exports.__esModule = true;
exports.LocaleProvider = LocaleProvider;
exports.getLocaleDirection = getLocaleDirection;
exports.useLocaleContext = useLocaleContext;

var _react = _interopRequireWildcard(__webpack_require__(16689));

var _isLocaleRTL = __webpack_require__(46928);

/**
 * Copyright (c) Nicolas Gallagher.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
var defaultLocale = {
  direction: 'ltr',
  locale: 'en-US'
};
var LocaleContext = /*#__PURE__*/(0, _react.createContext)(defaultLocale);

function getLocaleDirection(locale) {
  return (0, _isLocaleRTL.isLocaleRTL)(locale) ? 'rtl' : 'ltr';
}

function LocaleProvider(props) {
  var direction = props.direction,
      locale = props.locale,
      children = props.children;
  var needsContext = direction || locale;
  return needsContext ? /*#__PURE__*/_react.default.createElement(LocaleContext.Provider, {
    children: children,
    value: {
      direction: locale ? getLocaleDirection(locale) : direction,
      locale
    }
  }) : children;
}

function useLocaleContext() {
  return (0, _react.useContext)(LocaleContext);
}

/***/ }),

/***/ 46928:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


exports.__esModule = true;
exports.isLocaleRTL = isLocaleRTL;

/**
 * Copyright (c) Nicolas Gallagher.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
var rtlScripts = new Set(['Arab', 'Syrc', 'Samr', 'Mand', 'Thaa', 'Mend', 'Nkoo', 'Adlm', 'Rohg', 'Hebr']);
var rtlLangs = new Set(['ae', // Avestan
'ar', // Arabic
'arc', // Aramaic
'bcc', // Southern Balochi
'bqi', // Bakthiari
'ckb', // Sorani
'dv', // Dhivehi
'fa', 'far', // Persian
'glk', // Gilaki
'he', 'iw', // Hebrew
'khw', // Khowar
'ks', // Kashmiri
'ku', // Kurdish
'mzn', // Mazanderani
'nqo', // N'Ko
'pnb', // Western Punjabi
'ps', // Pashto
'sd', // Sindhi
'ug', // Uyghur
'ur', // Urdu
'yi' // Yiddish
]);
var cache = new Map();
/**
 * Determine the writing direction of a locale
 */

function isLocaleRTL(locale) {
  var cachedRTL = cache.get(locale);

  if (cachedRTL) {
    return cachedRTL;
  }

  var isRTL = false; // $FlowFixMe

  if (Intl.Locale) {
    // $FlowFixMe
    var script = new Intl.Locale(locale).maximize().script;
    isRTL = rtlScripts.has(script);
  } else {
    // Fallback to inferring from language
    var lang = locale.split('-')[0];
    isRTL = rtlLangs.has(lang);
  }

  cache.set(locale, isRTL);
  return isRTL;
}

/***/ }),

/***/ 88391:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(64836)["default"]);

var _interopRequireWildcard = (__webpack_require__(75263)["default"]);

exports.__esModule = true;
exports["default"] = useMergeRefs;

var React = _interopRequireWildcard(__webpack_require__(16689));

var _mergeRefs = _interopRequireDefault(__webpack_require__(88370));

/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
function useMergeRefs() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  return React.useMemo(() => (0, _mergeRefs.default)(...args), // eslint-disable-next-line
  [...args]);
}

module.exports = exports.default;

/***/ }),

/***/ 92187:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(64836)["default"]);

exports.__esModule = true;
exports["default"] = usePlatformMethods;

var _objectSpread2 = _interopRequireDefault(__webpack_require__(42122));

var _UIManager = _interopRequireDefault(__webpack_require__(56629));

var _createDOMProps = _interopRequireDefault(__webpack_require__(18083));

var _useStable = _interopRequireDefault(__webpack_require__(96492));

var _react = __webpack_require__(16689);

/**
 * Copyright (c) Nicolas Gallagher.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
var didWarn = false;
var emptyObject = {};

function setNativeProps(node, nativeProps, pointerEvents, style, previousStyleRef) {
  if (!didWarn) {
    console.warn('setNativeProps is deprecated. Please update props using React state instead.');
    didWarn = true;
  }

  if (node != null && nativeProps) {
    var domProps = (0, _createDOMProps.default)(null, (0, _objectSpread2.default)((0, _objectSpread2.default)({
      pointerEvents
    }, nativeProps), {}, {
      style: [style, nativeProps.style]
    }));
    var nextDomStyle = domProps.style;

    if (previousStyleRef.current != null) {
      if (domProps.style == null) {
        domProps.style = {};
      }

      for (var styleName in previousStyleRef.current) {
        if (domProps.style[styleName] == null) {
          domProps.style[styleName] = '';
        }
      }
    }

    previousStyleRef.current = nextDomStyle;

    _UIManager.default.updateView(node, domProps);
  }
}
/**
 * Adds non-standard methods to the hode element. This is temporarily until an
 * API like `ReactNative.measure(hostRef, callback)` is added to React Native.
 */


function usePlatformMethods(_ref) {
  var pointerEvents = _ref.pointerEvents,
      style = _ref.style;
  var previousStyleRef = (0, _react.useRef)(null);
  var setNativePropsArgsRef = (0, _react.useRef)(null);
  setNativePropsArgsRef.current = {
    pointerEvents,
    style
  }; // Avoid creating a new ref on every render. The props only need to be
  // available to 'setNativeProps' when it is called.

  var ref = (0, _useStable.default)(() => hostNode => {
    if (hostNode != null) {
      hostNode.measure = callback => _UIManager.default.measure(hostNode, callback);

      hostNode.measureLayout = (relativeToNode, success, failure) => _UIManager.default.measureLayout(hostNode, relativeToNode, failure, success);

      hostNode.measureInWindow = callback => _UIManager.default.measureInWindow(hostNode, callback);

      hostNode.setNativeProps = nativeProps => {
        var _ref2 = setNativePropsArgsRef.current || emptyObject,
            style = _ref2.style,
            pointerEvents = _ref2.pointerEvents;

        setNativeProps(hostNode, nativeProps, pointerEvents, style, previousStyleRef);
      };
    }
  });
  return ref;
}

module.exports = exports.default;

/***/ }),

/***/ 10271:
/***/ ((module, exports) => {

"use strict";
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 */


exports.__esModule = true;
exports["default"] = void 0;
var DELAY = 'DELAY';
var ERROR = 'ERROR';
var LONG_PRESS_DETECTED = 'LONG_PRESS_DETECTED';
var NOT_RESPONDER = 'NOT_RESPONDER';
var RESPONDER_ACTIVE_LONG_PRESS_START = 'RESPONDER_ACTIVE_LONG_PRESS_START';
var RESPONDER_ACTIVE_PRESS_START = 'RESPONDER_ACTIVE_PRESS_START';
var RESPONDER_INACTIVE_PRESS_START = 'RESPONDER_INACTIVE_PRESS_START';
var RESPONDER_GRANT = 'RESPONDER_GRANT';
var RESPONDER_RELEASE = 'RESPONDER_RELEASE';
var RESPONDER_TERMINATED = 'RESPONDER_TERMINATED';
var Transitions = Object.freeze({
  NOT_RESPONDER: {
    DELAY: ERROR,
    RESPONDER_GRANT: RESPONDER_INACTIVE_PRESS_START,
    RESPONDER_RELEASE: ERROR,
    RESPONDER_TERMINATED: ERROR,
    LONG_PRESS_DETECTED: ERROR
  },
  RESPONDER_INACTIVE_PRESS_START: {
    DELAY: RESPONDER_ACTIVE_PRESS_START,
    RESPONDER_GRANT: ERROR,
    RESPONDER_RELEASE: NOT_RESPONDER,
    RESPONDER_TERMINATED: NOT_RESPONDER,
    LONG_PRESS_DETECTED: ERROR
  },
  RESPONDER_ACTIVE_PRESS_START: {
    DELAY: ERROR,
    RESPONDER_GRANT: ERROR,
    RESPONDER_RELEASE: NOT_RESPONDER,
    RESPONDER_TERMINATED: NOT_RESPONDER,
    LONG_PRESS_DETECTED: RESPONDER_ACTIVE_LONG_PRESS_START
  },
  RESPONDER_ACTIVE_LONG_PRESS_START: {
    DELAY: ERROR,
    RESPONDER_GRANT: ERROR,
    RESPONDER_RELEASE: NOT_RESPONDER,
    RESPONDER_TERMINATED: NOT_RESPONDER,
    LONG_PRESS_DETECTED: RESPONDER_ACTIVE_LONG_PRESS_START
  },
  ERROR: {
    DELAY: NOT_RESPONDER,
    RESPONDER_GRANT: RESPONDER_INACTIVE_PRESS_START,
    RESPONDER_RELEASE: NOT_RESPONDER,
    RESPONDER_TERMINATED: NOT_RESPONDER,
    LONG_PRESS_DETECTED: NOT_RESPONDER
  }
});

var isActiveSignal = signal => signal === RESPONDER_ACTIVE_PRESS_START || signal === RESPONDER_ACTIVE_LONG_PRESS_START;

var isButtonRole = element => element.getAttribute('role') === 'button';

var isPressStartSignal = signal => signal === RESPONDER_INACTIVE_PRESS_START || signal === RESPONDER_ACTIVE_PRESS_START || signal === RESPONDER_ACTIVE_LONG_PRESS_START;

var isTerminalSignal = signal => signal === RESPONDER_TERMINATED || signal === RESPONDER_RELEASE;

var isValidKeyPress = event => {
  var key = event.key,
      target = event.target;
  var role = target.getAttribute('role');
  var isSpacebar = key === ' ' || key === 'Spacebar';
  return key === 'Enter' || isSpacebar && role === 'button';
};

var DEFAULT_LONG_PRESS_DELAY_MS = 450; // 500 - 50

var DEFAULT_PRESS_DELAY_MS = 50;
/**
 * =========================== PressResponder Tutorial ===========================
 *
 * The `PressResponder` class helps you create press interactions by analyzing the
 * geometry of elements and observing when another responder (e.g. ScrollView)
 * has stolen the touch lock. It offers hooks for your component to provide
 * interaction feedback to the user:
 *
 * - When a press has activated (e.g. highlight an element)
 * - When a press has deactivated (e.g. un-highlight an element)
 * - When a press sould trigger an action, meaning it activated and deactivated
 *   while within the geometry of the element without the lock being stolen.
 *
 * A high quality interaction isn't as simple as you might think. There should
 * be a slight delay before activation. Moving your finger beyond an element's
 * bounds should trigger deactivation, but moving the same finger back within an
 * element's bounds should trigger reactivation.
 *
 * In order to use `PressResponder`, do the following:
 *
 *     const pressResponder = new PressResponder(config);
 *
 * 2. Choose the rendered component who should collect the press events. On that
 *    element, spread `pressability.getEventHandlers()` into its props.
 *
 *    return (
 *      <View {...this.state.pressResponder.getEventHandlers()} />
 *    );
 *
 * 3. Reset `PressResponder` when your component unmounts.
 *
 *    componentWillUnmount() {
 *      this.state.pressResponder.reset();
 *    }
 *
 * ==================== Implementation Details ====================
 *
 * `PressResponder` only assumes that there exists a `HitRect` node. The `PressRect`
 * is an abstract box that is extended beyond the `HitRect`.
 *
 * # Geometry
 *
 *  
 *       - Presses start anywhere within `HitRect`.
 *          
 *       VisualRect     
 *           - When pressed down for sufficient amount of time
 *        HitRect            before letting up, `VisualRect` activates.
 *      
 *         Out Region   o   
 *  
 *                        When the press is released outside the `HitRect`,
 *                               the responder is NOT eligible for a "press".
 *
 * # State Machine
 *
 *   RESPONDER_RELEASE
 *  NOT_RESPONDER 
 *   RESPONDER_TERMINATED
 *     
 *      RESPONDER_GRANT (HitRect)
 *     
 *     
 *                         
 *  RESPONDER_INACTIVE_   DELAY    RESPONDER_ACTIVE_   T + DELAY    RESPONDER_ACTIVE_ 
 *  PRESS_START           PRESS_START         LONG_PRESS_START  
 *                         
 *
 * T + DELAY => LONG_PRESS_DELAY + DELAY
 *
 * Not drawn are the side effects of each transition. The most important side
 * effect is the invocation of `onLongPress`. Only when the browser produces a
 * `click` event is `onPress` invoked.
 */

class PressResponder {
  constructor(config) {
    this._eventHandlers = null;
    this._isPointerTouch = false;
    this._longPressDelayTimeout = null;
    this._longPressDispatched = false;
    this._pressDelayTimeout = null;
    this._pressOutDelayTimeout = null;
    this._touchState = NOT_RESPONDER;
    this.configure(config);
  }

  configure(config) {
    this._config = config;
  }
  /**
   * Resets any pending timers. This should be called on unmount.
   */


  reset() {
    this._cancelLongPressDelayTimeout();

    this._cancelPressDelayTimeout();

    this._cancelPressOutDelayTimeout();
  }
  /**
   * Returns a set of props to spread into the interactive element.
   */


  getEventHandlers() {
    if (this._eventHandlers == null) {
      this._eventHandlers = this._createEventHandlers();
    }

    return this._eventHandlers;
  }

  _createEventHandlers() {
    var start = (event, shouldDelay) => {
      event.persist();

      this._cancelPressOutDelayTimeout();

      this._longPressDispatched = false;
      this._selectionTerminated = false;
      this._touchState = NOT_RESPONDER;
      this._isPointerTouch = event.nativeEvent.type === 'touchstart';

      this._receiveSignal(RESPONDER_GRANT, event);

      var delayPressStart = normalizeDelay(this._config.delayPressStart, 0, DEFAULT_PRESS_DELAY_MS);

      if (shouldDelay !== false && delayPressStart > 0) {
        this._pressDelayTimeout = setTimeout(() => {
          this._receiveSignal(DELAY, event);
        }, delayPressStart);
      } else {
        this._receiveSignal(DELAY, event);
      }

      var delayLongPress = normalizeDelay(this._config.delayLongPress, 10, DEFAULT_LONG_PRESS_DELAY_MS);
      this._longPressDelayTimeout = setTimeout(() => {
        this._handleLongPress(event);
      }, delayLongPress + delayPressStart);
    };

    var end = event => {
      this._receiveSignal(RESPONDER_RELEASE, event);
    };

    var keyupHandler = event => {
      var onPress = this._config.onPress;
      var target = event.target;

      if (this._touchState !== NOT_RESPONDER && isValidKeyPress(event)) {
        end(event);
        document.removeEventListener('keyup', keyupHandler);
        var role = target.getAttribute('role');
        var elementType = target.tagName.toLowerCase();
        var isNativeInteractiveElement = role === 'link' || elementType === 'a' || elementType === 'button' || elementType === 'input' || elementType === 'select' || elementType === 'textarea';

        if (onPress != null && !isNativeInteractiveElement) {
          onPress(event);
        }
      }
    };

    return {
      onStartShouldSetResponder: event => {
        var disabled = this._config.disabled;

        if (disabled && isButtonRole(event.currentTarget)) {
          event.stopPropagation();
        }

        if (disabled == null) {
          return true;
        }

        return !disabled;
      },
      onKeyDown: event => {
        var disabled = this._config.disabled;
        var key = event.key,
            target = event.target;

        if (!disabled && isValidKeyPress(event)) {
          if (this._touchState === NOT_RESPONDER) {
            start(event, false); // Listen to 'keyup' on document to account for situations where
            // focus is moved to another element during 'keydown'.

            document.addEventListener('keyup', keyupHandler);
          }

          var role = target.getAttribute('role');
          var isSpacebarKey = key === ' ' || key === 'Spacebar';

          var _isButtonRole = role === 'button' || role === 'menuitem';

          if (isSpacebarKey && _isButtonRole) {
            // Prevent spacebar scrolling the window
            event.preventDefault();
          }

          event.stopPropagation();
        }
      },
      onResponderGrant: event => start(event),
      onResponderMove: event => {
        if (this._config.onPressMove != null) {
          this._config.onPressMove(event);
        }

        var touch = getTouchFromResponderEvent(event);

        if (this._touchActivatePosition != null) {
          var deltaX = this._touchActivatePosition.pageX - touch.pageX;
          var deltaY = this._touchActivatePosition.pageY - touch.pageY;

          if (Math.hypot(deltaX, deltaY) > 10) {
            this._cancelLongPressDelayTimeout();
          }
        }
      },
      onResponderRelease: event => end(event),
      onResponderTerminate: event => {
        if (event.nativeEvent.type === 'selectionchange') {
          this._selectionTerminated = true;
        }

        this._receiveSignal(RESPONDER_TERMINATED, event);
      },
      onResponderTerminationRequest: event => {
        var _this$_config = this._config,
            cancelable = _this$_config.cancelable,
            disabled = _this$_config.disabled,
            onLongPress = _this$_config.onLongPress; // If `onLongPress` is provided, don't terminate on `contextmenu` as default
        // behavior will be prevented for non-mouse pointers.

        if (!disabled && onLongPress != null && this._isPointerTouch && event.nativeEvent.type === 'contextmenu') {
          return false;
        }

        if (cancelable == null) {
          return true;
        }

        return cancelable;
      },
      // NOTE: this diverges from react-native in 3 significant ways:
      // * The `onPress` callback is not connected to the responder system (the native
      //  `click` event must be used but is dispatched in many scenarios where no pointers
      //   are on the screen.) Therefore, it's possible for `onPress` to be called without
      //   `onPress{Start,End}` being called first.
      // * The `onPress` callback is only be called on the first ancestor of the native
      //   `click` target that is using the PressResponder.
      // * The event's `nativeEvent` is a `MouseEvent` not a `TouchEvent`.
      onClick: event => {
        var _this$_config2 = this._config,
            disabled = _this$_config2.disabled,
            onPress = _this$_config2.onPress;

        if (!disabled) {
          // If long press dispatched, cancel default click behavior.
          // If the responder terminated because text was selected during the gesture,
          // cancel the default click behavior.
          event.stopPropagation();

          if (this._longPressDispatched || this._selectionTerminated) {
            event.preventDefault();
          } else if (onPress != null && event.altKey === false) {
            onPress(event);
          }
        } else {
          if (isButtonRole(event.currentTarget)) {
            event.stopPropagation();
          }
        }
      },
      // If `onLongPress` is provided and a touch pointer is being used, prevent the
      // default context menu from opening.
      onContextMenu: event => {
        var _this$_config3 = this._config,
            disabled = _this$_config3.disabled,
            onLongPress = _this$_config3.onLongPress;

        if (!disabled) {
          if (onLongPress != null && this._isPointerTouch && !event.defaultPrevented) {
            event.preventDefault();
            event.stopPropagation();
          }
        } else {
          if (isButtonRole(event.currentTarget)) {
            event.stopPropagation();
          }
        }
      }
    };
  }
  /**
   * Receives a state machine signal, performs side effects of the transition
   * and stores the new state. Validates the transition as well.
   */


  _receiveSignal(signal, event) {
    var prevState = this._touchState;
    var nextState = null;

    if (Transitions[prevState] != null) {
      nextState = Transitions[prevState][signal];
    }

    if (this._touchState === NOT_RESPONDER && signal === RESPONDER_RELEASE) {
      return;
    }

    if (nextState == null || nextState === ERROR) {
      console.error("PressResponder: Invalid signal " + signal + " for state " + prevState + " on responder");
    } else if (prevState !== nextState) {
      this._performTransitionSideEffects(prevState, nextState, signal, event);

      this._touchState = nextState;
    }
  }
  /**
   * Performs a transition between touchable states and identify any activations
   * or deactivations (and callback invocations).
   */


  _performTransitionSideEffects(prevState, nextState, signal, event) {
    if (isTerminalSignal(signal)) {
      // Pressable suppression of contextmenu on windows.
      // On Windows, the contextmenu is displayed after pointerup.
      // https://github.com/necolas/react-native-web/issues/2296
      setTimeout(() => {
        this._isPointerTouch = false;
      }, 0);
      this._touchActivatePosition = null;

      this._cancelLongPressDelayTimeout();
    }

    if (isPressStartSignal(prevState) && signal === LONG_PRESS_DETECTED) {
      var onLongPress = this._config.onLongPress; // Long press is not supported for keyboards because 'click' can be dispatched
      // immediately (and multiple times) after 'keydown'.

      if (onLongPress != null && event.nativeEvent.key == null) {
        onLongPress(event);
        this._longPressDispatched = true;
      }
    }

    var isPrevActive = isActiveSignal(prevState);
    var isNextActive = isActiveSignal(nextState);

    if (!isPrevActive && isNextActive) {
      this._activate(event);
    } else if (isPrevActive && !isNextActive) {
      this._deactivate(event);
    }

    if (isPressStartSignal(prevState) && signal === RESPONDER_RELEASE) {
      var _this$_config4 = this._config,
          _onLongPress = _this$_config4.onLongPress,
          onPress = _this$_config4.onPress;

      if (onPress != null) {
        var isPressCanceledByLongPress = _onLongPress != null && prevState === RESPONDER_ACTIVE_LONG_PRESS_START;

        if (!isPressCanceledByLongPress) {
          // If we never activated (due to delays), activate and deactivate now.
          if (!isNextActive && !isPrevActive) {
            this._activate(event);

            this._deactivate(event);
          }
        }
      }
    }

    this._cancelPressDelayTimeout();
  }

  _activate(event) {
    var _this$_config5 = this._config,
        onPressChange = _this$_config5.onPressChange,
        onPressStart = _this$_config5.onPressStart;
    var touch = getTouchFromResponderEvent(event);
    this._touchActivatePosition = {
      pageX: touch.pageX,
      pageY: touch.pageY
    };

    if (onPressStart != null) {
      onPressStart(event);
    }

    if (onPressChange != null) {
      onPressChange(true);
    }
  }

  _deactivate(event) {
    var _this$_config6 = this._config,
        onPressChange = _this$_config6.onPressChange,
        onPressEnd = _this$_config6.onPressEnd;

    function end() {
      if (onPressEnd != null) {
        onPressEnd(event);
      }

      if (onPressChange != null) {
        onPressChange(false);
      }
    }

    var delayPressEnd = normalizeDelay(this._config.delayPressEnd);

    if (delayPressEnd > 0) {
      this._pressOutDelayTimeout = setTimeout(() => {
        end();
      }, delayPressEnd);
    } else {
      end();
    }
  }

  _handleLongPress(event) {
    if (this._touchState === RESPONDER_ACTIVE_PRESS_START || this._touchState === RESPONDER_ACTIVE_LONG_PRESS_START) {
      this._receiveSignal(LONG_PRESS_DETECTED, event);
    }
  }

  _cancelLongPressDelayTimeout() {
    if (this._longPressDelayTimeout != null) {
      clearTimeout(this._longPressDelayTimeout);
      this._longPressDelayTimeout = null;
    }
  }

  _cancelPressDelayTimeout() {
    if (this._pressDelayTimeout != null) {
      clearTimeout(this._pressDelayTimeout);
      this._pressDelayTimeout = null;
    }
  }

  _cancelPressOutDelayTimeout() {
    if (this._pressOutDelayTimeout != null) {
      clearTimeout(this._pressOutDelayTimeout);
      this._pressOutDelayTimeout = null;
    }
  }

}

exports["default"] = PressResponder;

function normalizeDelay(delay, min, fallback) {
  if (min === void 0) {
    min = 0;
  }

  if (fallback === void 0) {
    fallback = 0;
  }

  return Math.max(min, delay !== null && delay !== void 0 ? delay : fallback);
}

function getTouchFromResponderEvent(event) {
  var _event$nativeEvent = event.nativeEvent,
      changedTouches = _event$nativeEvent.changedTouches,
      touches = _event$nativeEvent.touches;

  if (touches != null && touches.length > 0) {
    return touches[0];
  }

  if (changedTouches != null && changedTouches.length > 0) {
    return changedTouches[0];
  }

  return event.nativeEvent;
}

module.exports = exports.default;

/***/ }),

/***/ 24982:
/***/ ((module, exports, __webpack_require__) => {

"use strict";
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 */


var _interopRequireDefault = (__webpack_require__(64836)["default"]);

exports.__esModule = true;
exports["default"] = usePressEvents;

var _PressResponder = _interopRequireDefault(__webpack_require__(10271));

var _react = __webpack_require__(16689);

function usePressEvents(hostRef, config) {
  var pressResponderRef = (0, _react.useRef)(null);

  if (pressResponderRef.current == null) {
    pressResponderRef.current = new _PressResponder.default(config);
  }

  var pressResponder = pressResponderRef.current; // Re-configure to use the current node and configuration.

  (0, _react.useEffect)(() => {
    pressResponder.configure(config);
  }, [config, pressResponder]); // Reset the `pressResponder` when cleanup needs to occur. This is
  // a separate effect because we do not want to rest the responder when `config` changes.

  (0, _react.useEffect)(() => {
    return () => {
      pressResponder.reset();
    };
  }, [pressResponder]);
  (0, _react.useDebugValue)(config);
  return pressResponder.getEventHandlers();
}

module.exports = exports.default;

/***/ }),

/***/ 42170:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


exports.__esModule = true;
exports.TOUCH_START = exports.TOUCH_MOVE = exports.TOUCH_END = exports.TOUCH_CANCEL = exports.SELECTION_CHANGE = exports.SELECT = exports.SCROLL = exports.MOUSE_UP = exports.MOUSE_MOVE = exports.MOUSE_DOWN = exports.MOUSE_CANCEL = exports.FOCUS_OUT = exports.CONTEXT_MENU = exports.BLUR = void 0;
exports.isCancelish = isCancelish;
exports.isEndish = isEndish;
exports.isMoveish = isMoveish;
exports.isScroll = isScroll;
exports.isSelectionChange = isSelectionChange;
exports.isStartish = isStartish;

/**
 * Copyright (c) Nicolas Gallagher
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
var BLUR = 'blur';
exports.BLUR = BLUR;
var CONTEXT_MENU = 'contextmenu';
exports.CONTEXT_MENU = CONTEXT_MENU;
var FOCUS_OUT = 'focusout';
exports.FOCUS_OUT = FOCUS_OUT;
var MOUSE_DOWN = 'mousedown';
exports.MOUSE_DOWN = MOUSE_DOWN;
var MOUSE_MOVE = 'mousemove';
exports.MOUSE_MOVE = MOUSE_MOVE;
var MOUSE_UP = 'mouseup';
exports.MOUSE_UP = MOUSE_UP;
var MOUSE_CANCEL = 'dragstart';
exports.MOUSE_CANCEL = MOUSE_CANCEL;
var TOUCH_START = 'touchstart';
exports.TOUCH_START = TOUCH_START;
var TOUCH_MOVE = 'touchmove';
exports.TOUCH_MOVE = TOUCH_MOVE;
var TOUCH_END = 'touchend';
exports.TOUCH_END = TOUCH_END;
var TOUCH_CANCEL = 'touchcancel';
exports.TOUCH_CANCEL = TOUCH_CANCEL;
var SCROLL = 'scroll';
exports.SCROLL = SCROLL;
var SELECT = 'select';
exports.SELECT = SELECT;
var SELECTION_CHANGE = 'selectionchange';
exports.SELECTION_CHANGE = SELECTION_CHANGE;

function isStartish(eventType) {
  return eventType === TOUCH_START || eventType === MOUSE_DOWN;
}

function isMoveish(eventType) {
  return eventType === TOUCH_MOVE || eventType === MOUSE_MOVE;
}

function isEndish(eventType) {
  return eventType === TOUCH_END || eventType === MOUSE_UP || isCancelish(eventType);
}

function isCancelish(eventType) {
  return eventType === TOUCH_CANCEL || eventType === MOUSE_CANCEL;
}

function isScroll(eventType) {
  return eventType === SCROLL;
}

function isSelectionChange(eventType) {
  return eventType === SELECT || eventType === SELECTION_CHANGE;
}

/***/ }),

/***/ 82528:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(64836)["default"]);

exports.__esModule = true;
exports.addNode = addNode;
exports.attachListeners = attachListeners;
exports.getResponderNode = getResponderNode;
exports.removeNode = removeNode;
exports.terminateResponder = terminateResponder;

var _createResponderEvent = _interopRequireDefault(__webpack_require__(15999));

var _ResponderEventTypes = __webpack_require__(42170);

var _utils = __webpack_require__(13128);

var _ResponderTouchHistoryStore = __webpack_require__(2522);

var _canUseDom = _interopRequireDefault(__webpack_require__(24019));

/**
 * Copyright (c) Nicolas Gallagher
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

/**
 * RESPONDER EVENT SYSTEM
 *
 * A single, global "interaction lock" on views. For a view to be the "responder" means
 * that pointer interactions are exclusive to that view and none other. The "interaction
 * lock" can be transferred (only) to ancestors of the current "responder" as long as
 * pointers continue to be active.
 *
 * Responder being granted:
 *
 * A view can become the "responder" after the following events:
 *  * "pointerdown" (implemented using "touchstart", "mousedown")
 *  * "pointermove" (implemented using "touchmove", "mousemove")
 *  * "scroll" (while a pointer is down)
 *  * "selectionchange" (while a pointer is down)
 *
 * If nothing is already the "responder", the event propagates to (capture) and from
 * (bubble) the event target until a view returns `true` for
 * `on*ShouldSetResponder(Capture)`.
 *
 * If something is already the responder, the event propagates to (capture) and from
 * (bubble) the lowest common ancestor of the event target and the current "responder".
 * Then negotiation happens between the current "responder" and a view that wants to
 * become the "responder": see the timing diagram below.
 *
 * (NOTE: Scrolled views either automatically become the "responder" or release the
 * "interaction lock". A native scroll view that isn't built on top of the responder
 * system must result in the current "responder" being notified that it no longer has
 * the "interaction lock" - the native system has taken over.
 *
 * Responder being released:
 *
 * As soon as there are no more active pointers that *started* inside descendants
 * of the *current* "responder", an `onResponderRelease` event is dispatched to the
 * current "responder", and the responder lock is released.
 *
 * Typical sequence of events:
 *  * startShouldSetResponder
 *  * responderGrant/Reject
 *  * responderStart
 *  * responderMove
 *  * responderEnd
 *  * responderRelease
 */

/*                                             Negotiation Performed
                                             +-----------------------+
                                            /                         \
Process low level events to    +     Current Responder      +   wantsResponderID
determine who to perform negot-|   (if any exists at all)   |
iation/transition              | Otherwise just pass through|
-------------------------------+----------------------------+------------------+
Bubble to find first ID        |                            |
to return true:wantsResponderID|                            |
                               |                            |
     +--------------+          |                            |
     | onTouchStart |          |                            |
     +------+-------+    none  |                            |
            |            return|                            |
+-----------v-------------+true| +------------------------+ |
|onStartShouldSetResponder|----->| onResponderStart (cur) |<-----------+
+-----------+-------------+    | +------------------------+ |          |
            |                  |                            | +--------+-------+
            | returned true for|       false:REJECT +-------->|onResponderReject
            | wantsResponderID |                    |       | +----------------+
            | (now attempt     | +------------------+-----+ |
            |  handoff)        | | onResponder            | |
            +------------------->|    TerminationRequest  | |
                               | +------------------+-----+ |
                               |                    |       | +----------------+
                               |         true:GRANT +-------->|onResponderGrant|
                               |                            | +--------+-------+
                               | +------------------------+ |          |
                               | | onResponderTerminate   |<-----------+
                               | +------------------+-----+ |
                               |                    |       | +----------------+
                               |                    +-------->|onResponderStart|
                               |                            | +----------------+
Bubble to find first ID        |                            |
to return true:wantsResponderID|                            |
                               |                            |
     +-------------+           |                            |
     | onTouchMove |           |                            |
     +------+------+     none  |                            |
            |            return|                            |
+-----------v-------------+true| +------------------------+ |
|onMoveShouldSetResponder |----->| onResponderMove (cur)  |<-----------+
+-----------+-------------+    | +------------------------+ |          |
            |                  |                            | +--------+-------+
            | returned true for|       false:REJECT +-------->|onResponderReject
            | wantsResponderID |                    |       | +----------------+
            | (now attempt     | +------------------+-----+ |
            |  handoff)        | |   onResponder          | |
            +------------------->|      TerminationRequest| |
                               | +------------------+-----+ |
                               |                    |       | +----------------+
                               |         true:GRANT +-------->|onResponderGrant|
                               |                            | +--------+-------+
                               | +------------------------+ |          |
                               | |   onResponderTerminate |<-----------+
                               | +------------------+-----+ |
                               |                    |       | +----------------+
                               |                    +-------->|onResponderMove |
                               |                            | +----------------+
                               |                            |
                               |                            |
      Some active touch started|                            |
      inside current responder | +------------------------+ |
      +------------------------->|      onResponderEnd    | |
      |                        | +------------------------+ |
  +---+---------+              |                            |
  | onTouchEnd  |              |                            |
  +---+---------+              |                            |
      |                        | +------------------------+ |
      +------------------------->|     onResponderEnd     | |
      No active touches started| +-----------+------------+ |
      inside current responder |             |              |
                               |             v              |
                               | +------------------------+ |
                               | |    onResponderRelease  | |
                               | +------------------------+ |
                               |                            |
                               +                            + */
var emptyObject = {};
/* ------------ IMPLEMENTATION ------------ */

var startRegistration = ['onStartShouldSetResponderCapture', 'onStartShouldSetResponder', {
  bubbles: true
}];
var moveRegistration = ['onMoveShouldSetResponderCapture', 'onMoveShouldSetResponder', {
  bubbles: true
}];
var scrollRegistration = ['onScrollShouldSetResponderCapture', 'onScrollShouldSetResponder', {
  bubbles: false
}];
var shouldSetResponderEvents = {
  touchstart: startRegistration,
  mousedown: startRegistration,
  touchmove: moveRegistration,
  mousemove: moveRegistration,
  scroll: scrollRegistration
};
var emptyResponder = {
  id: null,
  idPath: null,
  node: null
};
var responderListenersMap = new Map();
var isEmulatingMouseEvents = false;
var trackedTouchCount = 0;
var currentResponder = {
  id: null,
  node: null,
  idPath: null
};
var responderTouchHistoryStore = new _ResponderTouchHistoryStore.ResponderTouchHistoryStore();

function changeCurrentResponder(responder) {
  currentResponder = responder;
}

function getResponderConfig(id) {
  var config = responderListenersMap.get(id);
  return config != null ? config : emptyObject;
}
/**
 * Process native events
 *
 * A single event listener is used to manage the responder system.
 * All pointers are tracked in the ResponderTouchHistoryStore. Native events
 * are interpreted in terms of the Responder System and checked to see if
 * the responder should be transferred. Each host node that is attached to
 * the Responder System has an ID, which is used to look up its associated
 * callbacks.
 */


function eventListener(domEvent) {
  var eventType = domEvent.type;
  var eventTarget = domEvent.target;
  /**
   * Manage emulated events and early bailout.
   * Since PointerEvent is not used yet (lack of support in older Safari), it's
   * necessary to manually manage the mess of browser touch/mouse events.
   * And bailout early for termination events when there is no active responder.
   */
  // Flag when browser may produce emulated events

  if (eventType === 'touchstart') {
    isEmulatingMouseEvents = true;
  } // Remove flag when browser will not produce emulated events


  if (eventType === 'touchmove' || trackedTouchCount > 1) {
    isEmulatingMouseEvents = false;
  } // Ignore various events in particular circumstances


  if ( // Ignore browser emulated mouse events
  eventType === 'mousedown' && isEmulatingMouseEvents || eventType === 'mousemove' && isEmulatingMouseEvents || // Ignore mousemove if a mousedown didn't occur first
  eventType === 'mousemove' && trackedTouchCount < 1) {
    return;
  } // Remove flag after emulated events are finished


  if (isEmulatingMouseEvents && eventType === 'mouseup') {
    if (trackedTouchCount === 0) {
      isEmulatingMouseEvents = false;
    }

    return;
  }

  var isStartEvent = (0, _ResponderEventTypes.isStartish)(eventType) && (0, _utils.isPrimaryPointerDown)(domEvent);
  var isMoveEvent = (0, _ResponderEventTypes.isMoveish)(eventType);
  var isEndEvent = (0, _ResponderEventTypes.isEndish)(eventType);
  var isScrollEvent = (0, _ResponderEventTypes.isScroll)(eventType);
  var isSelectionChangeEvent = (0, _ResponderEventTypes.isSelectionChange)(eventType);
  var responderEvent = (0, _createResponderEvent.default)(domEvent, responderTouchHistoryStore);
  /**
   * Record the state of active pointers
   */

  if (isStartEvent || isMoveEvent || isEndEvent) {
    if (domEvent.touches) {
      trackedTouchCount = domEvent.touches.length;
    } else {
      if (isStartEvent) {
        trackedTouchCount = 1;
      } else if (isEndEvent) {
        trackedTouchCount = 0;
      }
    }

    responderTouchHistoryStore.recordTouchTrack(eventType, responderEvent.nativeEvent);
  }
  /**
   * Responder System logic
   */


  var eventPaths = (0, _utils.getResponderPaths)(domEvent);
  var wasNegotiated = false;
  var wantsResponder; // If an event occured that might change the current responder...

  if (isStartEvent || isMoveEvent || isScrollEvent && trackedTouchCount > 0) {
    // If there is already a responder, prune the event paths to the lowest common ancestor
    // of the existing responder and deepest target of the event.
    var currentResponderIdPath = currentResponder.idPath;
    var eventIdPath = eventPaths.idPath;

    if (currentResponderIdPath != null && eventIdPath != null) {
      var lowestCommonAncestor = (0, _utils.getLowestCommonAncestor)(currentResponderIdPath, eventIdPath);

      if (lowestCommonAncestor != null) {
        var indexOfLowestCommonAncestor = eventIdPath.indexOf(lowestCommonAncestor); // Skip the current responder so it doesn't receive unexpected "shouldSet" events.

        var index = indexOfLowestCommonAncestor + (lowestCommonAncestor === currentResponder.id ? 1 : 0);
        eventPaths = {
          idPath: eventIdPath.slice(index),
          nodePath: eventPaths.nodePath.slice(index)
        };
      } else {
        eventPaths = null;
      }
    }

    if (eventPaths != null) {
      // If a node wants to become the responder, attempt to transfer.
      wantsResponder = findWantsResponder(eventPaths, domEvent, responderEvent);

      if (wantsResponder != null) {
        // Sets responder if none exists, or negotates with existing responder.
        attemptTransfer(responderEvent, wantsResponder);
        wasNegotiated = true;
      }
    }
  } // If there is now a responder, invoke its callbacks for the lifecycle of the gesture.


  if (currentResponder.id != null && currentResponder.node != null) {
    var _currentResponder = currentResponder,
        id = _currentResponder.id,
        node = _currentResponder.node;

    var _getResponderConfig = getResponderConfig(id),
        onResponderStart = _getResponderConfig.onResponderStart,
        onResponderMove = _getResponderConfig.onResponderMove,
        onResponderEnd = _getResponderConfig.onResponderEnd,
        onResponderRelease = _getResponderConfig.onResponderRelease,
        onResponderTerminate = _getResponderConfig.onResponderTerminate,
        onResponderTerminationRequest = _getResponderConfig.onResponderTerminationRequest;

    responderEvent.bubbles = false;
    responderEvent.cancelable = false;
    responderEvent.currentTarget = node; // Start

    if (isStartEvent) {
      if (onResponderStart != null) {
        responderEvent.dispatchConfig.registrationName = 'onResponderStart';
        onResponderStart(responderEvent);
      }
    } // Move
    else if (isMoveEvent) {
      if (onResponderMove != null) {
        responderEvent.dispatchConfig.registrationName = 'onResponderMove';
        onResponderMove(responderEvent);
      }
    } else {
      var isTerminateEvent = (0, _ResponderEventTypes.isCancelish)(eventType) || // native context menu
      eventType === 'contextmenu' || // window blur
      eventType === 'blur' && eventTarget === window || // responder (or ancestors) blur
      eventType === 'blur' && eventTarget.contains(node) && domEvent.relatedTarget !== node || // native scroll without using a pointer
      isScrollEvent && trackedTouchCount === 0 || // native scroll on node that is parent of the responder (allow siblings to scroll)
      isScrollEvent && eventTarget.contains(node) && eventTarget !== node || // native select/selectionchange on node
      isSelectionChangeEvent && (0, _utils.hasValidSelection)(domEvent);
      var isReleaseEvent = isEndEvent && !isTerminateEvent && !(0, _utils.hasTargetTouches)(node, domEvent.touches); // End

      if (isEndEvent) {
        if (onResponderEnd != null) {
          responderEvent.dispatchConfig.registrationName = 'onResponderEnd';
          onResponderEnd(responderEvent);
        }
      } // Release


      if (isReleaseEvent) {
        if (onResponderRelease != null) {
          responderEvent.dispatchConfig.registrationName = 'onResponderRelease';
          onResponderRelease(responderEvent);
        }

        changeCurrentResponder(emptyResponder);
      } // Terminate


      if (isTerminateEvent) {
        var shouldTerminate = true; // Responders can still avoid termination but only for these events.

        if (eventType === 'contextmenu' || eventType === 'scroll' || eventType === 'selectionchange') {
          // Only call this function is it wasn't already called during negotiation.
          if (wasNegotiated) {
            shouldTerminate = false;
          } else if (onResponderTerminationRequest != null) {
            responderEvent.dispatchConfig.registrationName = 'onResponderTerminationRequest';

            if (onResponderTerminationRequest(responderEvent) === false) {
              shouldTerminate = false;
            }
          }
        }

        if (shouldTerminate) {
          if (onResponderTerminate != null) {
            responderEvent.dispatchConfig.registrationName = 'onResponderTerminate';
            onResponderTerminate(responderEvent);
          }

          changeCurrentResponder(emptyResponder);
          isEmulatingMouseEvents = false;
          trackedTouchCount = 0;
        }
      }
    }
  }
}
/**
 * Walk the event path to/from the target node. At each node, stop and call the
 * relevant "shouldSet" functions for the given event type. If any of those functions
 * call "stopPropagation" on the event, stop searching for a responder.
 */


function findWantsResponder(eventPaths, domEvent, responderEvent) {
  var shouldSetCallbacks = shouldSetResponderEvents[domEvent.type]; // for Flow

  if (shouldSetCallbacks != null) {
    var idPath = eventPaths.idPath,
        nodePath = eventPaths.nodePath;
    var shouldSetCallbackCaptureName = shouldSetCallbacks[0];
    var shouldSetCallbackBubbleName = shouldSetCallbacks[1];
    var bubbles = shouldSetCallbacks[2].bubbles;

    var check = function check(id, node, callbackName) {
      var config = getResponderConfig(id);
      var shouldSetCallback = config[callbackName];

      if (shouldSetCallback != null) {
        responderEvent.currentTarget = node;

        if (shouldSetCallback(responderEvent) === true) {
          // Start the path from the potential responder
          var prunedIdPath = idPath.slice(idPath.indexOf(id));
          return {
            id,
            node,
            idPath: prunedIdPath
          };
        }
      }
    }; // capture


    for (var i = idPath.length - 1; i >= 0; i--) {
      var id = idPath[i];
      var node = nodePath[i];
      var result = check(id, node, shouldSetCallbackCaptureName);

      if (result != null) {
        return result;
      }

      if (responderEvent.isPropagationStopped() === true) {
        return;
      }
    } // bubble


    if (bubbles) {
      for (var _i = 0; _i < idPath.length; _i++) {
        var _id = idPath[_i];
        var _node = nodePath[_i];

        var _result = check(_id, _node, shouldSetCallbackBubbleName);

        if (_result != null) {
          return _result;
        }

        if (responderEvent.isPropagationStopped() === true) {
          return;
        }
      }
    } else {
      var _id2 = idPath[0];
      var _node2 = nodePath[0];
      var target = domEvent.target;

      if (target === _node2) {
        return check(_id2, _node2, shouldSetCallbackBubbleName);
      }
    }
  }
}
/**
 * Attempt to transfer the responder.
 */


function attemptTransfer(responderEvent, wantsResponder) {
  var _currentResponder2 = currentResponder,
      currentId = _currentResponder2.id,
      currentNode = _currentResponder2.node;
  var id = wantsResponder.id,
      node = wantsResponder.node;

  var _getResponderConfig2 = getResponderConfig(id),
      onResponderGrant = _getResponderConfig2.onResponderGrant,
      onResponderReject = _getResponderConfig2.onResponderReject;

  responderEvent.bubbles = false;
  responderEvent.cancelable = false;
  responderEvent.currentTarget = node; // Set responder

  if (currentId == null) {
    if (onResponderGrant != null) {
      responderEvent.currentTarget = node;
      responderEvent.dispatchConfig.registrationName = 'onResponderGrant';
      onResponderGrant(responderEvent);
    }

    changeCurrentResponder(wantsResponder);
  } // Negotiate with current responder
  else {
    var _getResponderConfig3 = getResponderConfig(currentId),
        onResponderTerminate = _getResponderConfig3.onResponderTerminate,
        onResponderTerminationRequest = _getResponderConfig3.onResponderTerminationRequest;

    var allowTransfer = true;

    if (onResponderTerminationRequest != null) {
      responderEvent.currentTarget = currentNode;
      responderEvent.dispatchConfig.registrationName = 'onResponderTerminationRequest';

      if (onResponderTerminationRequest(responderEvent) === false) {
        allowTransfer = false;
      }
    }

    if (allowTransfer) {
      // Terminate existing responder
      if (onResponderTerminate != null) {
        responderEvent.currentTarget = currentNode;
        responderEvent.dispatchConfig.registrationName = 'onResponderTerminate';
        onResponderTerminate(responderEvent);
      } // Grant next responder


      if (onResponderGrant != null) {
        responderEvent.currentTarget = node;
        responderEvent.dispatchConfig.registrationName = 'onResponderGrant';
        onResponderGrant(responderEvent);
      }

      changeCurrentResponder(wantsResponder);
    } else {
      // Reject responder request
      if (onResponderReject != null) {
        responderEvent.currentTarget = node;
        responderEvent.dispatchConfig.registrationName = 'onResponderReject';
        onResponderReject(responderEvent);
      }
    }
  }
}
/* ------------ PUBLIC API ------------ */

/**
 * Attach Listeners
 *
 * Use native events as ReactDOM doesn't have a non-plugin API to implement
 * this system.
 */


var documentEventsCapturePhase = ['blur', 'scroll'];
var documentEventsBubblePhase = [// mouse
'mousedown', 'mousemove', 'mouseup', 'dragstart', // touch
'touchstart', 'touchmove', 'touchend', 'touchcancel', // other
'contextmenu', 'select', 'selectionchange'];

function attachListeners() {
  if (_canUseDom.default && window.__reactResponderSystemActive == null) {
    window.addEventListener('blur', eventListener);
    documentEventsBubblePhase.forEach(eventType => {
      document.addEventListener(eventType, eventListener);
    });
    documentEventsCapturePhase.forEach(eventType => {
      document.addEventListener(eventType, eventListener, true);
    });
    window.__reactResponderSystemActive = true;
  }
}
/**
 * Register a node with the ResponderSystem.
 */


function addNode(id, node, config) {
  (0, _utils.setResponderId)(node, id);
  responderListenersMap.set(id, config);
}
/**
 * Unregister a node with the ResponderSystem.
 */


function removeNode(id) {
  if (currentResponder.id === id) {
    terminateResponder();
  }

  if (responderListenersMap.has(id)) {
    responderListenersMap.delete(id);
  }
}
/**
 * Allow the current responder to be terminated from within components to support
 * more complex requirements, such as use with other React libraries for working
 * with scroll views, input views, etc.
 */


function terminateResponder() {
  var _currentResponder3 = currentResponder,
      id = _currentResponder3.id,
      node = _currentResponder3.node;

  if (id != null && node != null) {
    var _getResponderConfig4 = getResponderConfig(id),
        onResponderTerminate = _getResponderConfig4.onResponderTerminate;

    if (onResponderTerminate != null) {
      var event = (0, _createResponderEvent.default)({}, responderTouchHistoryStore);
      event.currentTarget = node;
      onResponderTerminate(event);
    }

    changeCurrentResponder(emptyResponder);
  }

  isEmulatingMouseEvents = false;
  trackedTouchCount = 0;
}
/**
 * Allow unit tests to inspect the current responder in the system.
 * FOR TESTING ONLY.
 */


function getResponderNode() {
  return currentResponder.node;
}

/***/ }),

/***/ 2522:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


exports.__esModule = true;
exports.ResponderTouchHistoryStore = void 0;

var _ResponderEventTypes = __webpack_require__(42170);

/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

/**
 * Tracks the position and time of each active touch by `touch.identifier`. We
 * should typically only see IDs in the range of 1-20 because IDs get recycled
 * when touches end and start again.
 */
var __DEV__ = "production" !== 'production';

var MAX_TOUCH_BANK = 20;

function timestampForTouch(touch) {
  // The legacy internal implementation provides "timeStamp", which has been
  // renamed to "timestamp".
  return touch.timeStamp || touch.timestamp;
}
/**
 * TODO: Instead of making gestures recompute filtered velocity, we could
 * include a built in velocity computation that can be reused globally.
 */


function createTouchRecord(touch) {
  return {
    touchActive: true,
    startPageX: touch.pageX,
    startPageY: touch.pageY,
    startTimeStamp: timestampForTouch(touch),
    currentPageX: touch.pageX,
    currentPageY: touch.pageY,
    currentTimeStamp: timestampForTouch(touch),
    previousPageX: touch.pageX,
    previousPageY: touch.pageY,
    previousTimeStamp: timestampForTouch(touch)
  };
}

function resetTouchRecord(touchRecord, touch) {
  touchRecord.touchActive = true;
  touchRecord.startPageX = touch.pageX;
  touchRecord.startPageY = touch.pageY;
  touchRecord.startTimeStamp = timestampForTouch(touch);
  touchRecord.currentPageX = touch.pageX;
  touchRecord.currentPageY = touch.pageY;
  touchRecord.currentTimeStamp = timestampForTouch(touch);
  touchRecord.previousPageX = touch.pageX;
  touchRecord.previousPageY = touch.pageY;
  touchRecord.previousTimeStamp = timestampForTouch(touch);
}

function getTouchIdentifier(_ref) {
  var identifier = _ref.identifier;

  if (identifier == null) {
    console.error('Touch object is missing identifier.');
  }

  if (__DEV__) {
    if (identifier > MAX_TOUCH_BANK) {
      console.error('Touch identifier %s is greater than maximum supported %s which causes ' + 'performance issues backfilling array locations for all of the indices.', identifier, MAX_TOUCH_BANK);
    }
  }

  return identifier;
}

function recordTouchStart(touch, touchHistory) {
  var identifier = getTouchIdentifier(touch);
  var touchRecord = touchHistory.touchBank[identifier];

  if (touchRecord) {
    resetTouchRecord(touchRecord, touch);
  } else {
    touchHistory.touchBank[identifier] = createTouchRecord(touch);
  }

  touchHistory.mostRecentTimeStamp = timestampForTouch(touch);
}

function recordTouchMove(touch, touchHistory) {
  var touchRecord = touchHistory.touchBank[getTouchIdentifier(touch)];

  if (touchRecord) {
    touchRecord.touchActive = true;
    touchRecord.previousPageX = touchRecord.currentPageX;
    touchRecord.previousPageY = touchRecord.currentPageY;
    touchRecord.previousTimeStamp = touchRecord.currentTimeStamp;
    touchRecord.currentPageX = touch.pageX;
    touchRecord.currentPageY = touch.pageY;
    touchRecord.currentTimeStamp = timestampForTouch(touch);
    touchHistory.mostRecentTimeStamp = timestampForTouch(touch);
  } else {
    console.warn('Cannot record touch move without a touch start.\n', "Touch Move: " + printTouch(touch) + "\n", "Touch Bank: " + printTouchBank(touchHistory));
  }
}

function recordTouchEnd(touch, touchHistory) {
  var touchRecord = touchHistory.touchBank[getTouchIdentifier(touch)];

  if (touchRecord) {
    touchRecord.touchActive = false;
    touchRecord.previousPageX = touchRecord.currentPageX;
    touchRecord.previousPageY = touchRecord.currentPageY;
    touchRecord.previousTimeStamp = touchRecord.currentTimeStamp;
    touchRecord.currentPageX = touch.pageX;
    touchRecord.currentPageY = touch.pageY;
    touchRecord.currentTimeStamp = timestampForTouch(touch);
    touchHistory.mostRecentTimeStamp = timestampForTouch(touch);
  } else {
    console.warn('Cannot record touch end without a touch start.\n', "Touch End: " + printTouch(touch) + "\n", "Touch Bank: " + printTouchBank(touchHistory));
  }
}

function printTouch(touch) {
  return JSON.stringify({
    identifier: touch.identifier,
    pageX: touch.pageX,
    pageY: touch.pageY,
    timestamp: timestampForTouch(touch)
  });
}

function printTouchBank(touchHistory) {
  var touchBank = touchHistory.touchBank;
  var printed = JSON.stringify(touchBank.slice(0, MAX_TOUCH_BANK));

  if (touchBank.length > MAX_TOUCH_BANK) {
    printed += ' (original size: ' + touchBank.length + ')';
  }

  return printed;
}

class ResponderTouchHistoryStore {
  constructor() {
    this._touchHistory = {
      touchBank: [],
      //Array<TouchRecord>
      numberActiveTouches: 0,
      // If there is only one active touch, we remember its location. This prevents
      // us having to loop through all of the touches all the time in the most
      // common case.
      indexOfSingleActiveTouch: -1,
      mostRecentTimeStamp: 0
    };
  }

  recordTouchTrack(topLevelType, nativeEvent) {
    var touchHistory = this._touchHistory;

    if ((0, _ResponderEventTypes.isMoveish)(topLevelType)) {
      nativeEvent.changedTouches.forEach(touch => recordTouchMove(touch, touchHistory));
    } else if ((0, _ResponderEventTypes.isStartish)(topLevelType)) {
      nativeEvent.changedTouches.forEach(touch => recordTouchStart(touch, touchHistory));
      touchHistory.numberActiveTouches = nativeEvent.touches.length;

      if (touchHistory.numberActiveTouches === 1) {
        touchHistory.indexOfSingleActiveTouch = nativeEvent.touches[0].identifier;
      }
    } else if ((0, _ResponderEventTypes.isEndish)(topLevelType)) {
      nativeEvent.changedTouches.forEach(touch => recordTouchEnd(touch, touchHistory));
      touchHistory.numberActiveTouches = nativeEvent.touches.length;

      if (touchHistory.numberActiveTouches === 1) {
        var touchBank = touchHistory.touchBank;

        for (var i = 0; i < touchBank.length; i++) {
          var touchTrackToCheck = touchBank[i];

          if (touchTrackToCheck != null && touchTrackToCheck.touchActive) {
            touchHistory.indexOfSingleActiveTouch = i;
            break;
          }
        }

        if (__DEV__) {
          var activeRecord = touchBank[touchHistory.indexOfSingleActiveTouch];

          if (!(activeRecord != null && activeRecord.touchActive)) {
            console.error('Cannot find single active touch.');
          }
        }
      }
    }
  }

  get touchHistory() {
    return this._touchHistory;
  }

}

exports.ResponderTouchHistoryStore = ResponderTouchHistoryStore;

/***/ }),

/***/ 15999:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(64836)["default"]);

exports.__esModule = true;
exports["default"] = createResponderEvent;

var _getBoundingClientRect = _interopRequireDefault(__webpack_require__(71826));

/**
 * Copyright (c) Nicolas Gallagher
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
var emptyFunction = () => {};

var emptyObject = {};
var emptyArray = [];
/**
 * Safari produces very large identifiers that would cause the `touchBank` array
 * length to be so large as to crash the browser, if not normalized like this.
 * In the future the `touchBank` should use an object/map instead.
 */

function normalizeIdentifier(identifier) {
  return identifier > 20 ? identifier % 20 : identifier;
}
/**
 * Converts a native DOM event to a ResponderEvent.
 * Mouse events are transformed into fake touch events.
 */


function createResponderEvent(domEvent, responderTouchHistoryStore) {
  var rect;
  var propagationWasStopped = false;
  var changedTouches;
  var touches;
  var domEventChangedTouches = domEvent.changedTouches;
  var domEventType = domEvent.type;
  var metaKey = domEvent.metaKey === true;
  var shiftKey = domEvent.shiftKey === true;
  var force = domEventChangedTouches && domEventChangedTouches[0].force || 0;
  var identifier = normalizeIdentifier(domEventChangedTouches && domEventChangedTouches[0].identifier || 0);
  var clientX = domEventChangedTouches && domEventChangedTouches[0].clientX || domEvent.clientX;
  var clientY = domEventChangedTouches && domEventChangedTouches[0].clientY || domEvent.clientY;
  var pageX = domEventChangedTouches && domEventChangedTouches[0].pageX || domEvent.pageX;
  var pageY = domEventChangedTouches && domEventChangedTouches[0].pageY || domEvent.pageY;
  var preventDefault = typeof domEvent.preventDefault === 'function' ? domEvent.preventDefault.bind(domEvent) : emptyFunction;
  var timestamp = domEvent.timeStamp;

  function normalizeTouches(touches) {
    return Array.prototype.slice.call(touches).map(touch => {
      return {
        force: touch.force,
        identifier: normalizeIdentifier(touch.identifier),

        get locationX() {
          return locationX(touch.clientX);
        },

        get locationY() {
          return locationY(touch.clientY);
        },

        pageX: touch.pageX,
        pageY: touch.pageY,
        target: touch.target,
        timestamp
      };
    });
  }

  if (domEventChangedTouches != null) {
    changedTouches = normalizeTouches(domEventChangedTouches);
    touches = normalizeTouches(domEvent.touches);
  } else {
    var emulatedTouches = [{
      force,
      identifier,

      get locationX() {
        return locationX(clientX);
      },

      get locationY() {
        return locationY(clientY);
      },

      pageX,
      pageY,
      target: domEvent.target,
      timestamp
    }];
    changedTouches = emulatedTouches;
    touches = domEventType === 'mouseup' || domEventType === 'dragstart' ? emptyArray : emulatedTouches;
  }

  var responderEvent = {
    bubbles: true,
    cancelable: true,
    // `currentTarget` is set before dispatch
    currentTarget: null,
    defaultPrevented: domEvent.defaultPrevented,
    dispatchConfig: emptyObject,
    eventPhase: domEvent.eventPhase,

    isDefaultPrevented() {
      return domEvent.defaultPrevented;
    },

    isPropagationStopped() {
      return propagationWasStopped;
    },

    isTrusted: domEvent.isTrusted,
    nativeEvent: {
      altKey: false,
      ctrlKey: false,
      metaKey,
      shiftKey,
      changedTouches,
      force,
      identifier,

      get locationX() {
        return locationX(clientX);
      },

      get locationY() {
        return locationY(clientY);
      },

      pageX,
      pageY,
      target: domEvent.target,
      timestamp,
      touches,
      type: domEventType
    },
    persist: emptyFunction,
    preventDefault,

    stopPropagation() {
      propagationWasStopped = true;
    },

    target: domEvent.target,
    timeStamp: timestamp,
    touchHistory: responderTouchHistoryStore.touchHistory
  }; // Using getters and functions serves two purposes:
  // 1) The value of `currentTarget` is not initially available.
  // 2) Measuring the clientRect may cause layout jank and should only be done on-demand.

  function locationX(x) {
    rect = rect || (0, _getBoundingClientRect.default)(responderEvent.currentTarget);

    if (rect) {
      return x - rect.left;
    }
  }

  function locationY(y) {
    rect = rect || (0, _getBoundingClientRect.default)(responderEvent.currentTarget);

    if (rect) {
      return y - rect.top;
    }
  }

  return responderEvent;
}

module.exports = exports.default;

/***/ }),

/***/ 36758:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireWildcard = (__webpack_require__(75263)["default"]);

exports.__esModule = true;
exports["default"] = useResponderEvents;

var React = _interopRequireWildcard(__webpack_require__(16689));

var ResponderSystem = _interopRequireWildcard(__webpack_require__(82528));

/**
 * Copyright (c) Nicolas Gallagher
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

/**
 * Hook for integrating the Responder System into React
 *
 *   function SomeComponent({ onStartShouldSetResponder }) {
 *     const ref = useRef(null);
 *     useResponderEvents(ref, { onStartShouldSetResponder });
 *     return <div ref={ref} />
 *   }
 */
var emptyObject = {};
var idCounter = 0;

function useStable(getInitialValue) {
  var ref = React.useRef(null);

  if (ref.current == null) {
    ref.current = getInitialValue();
  }

  return ref.current;
}

function useResponderEvents(hostRef, config) {
  if (config === void 0) {
    config = emptyObject;
  }

  var id = useStable(() => idCounter++);
  var isAttachedRef = React.useRef(false); // This is a separate effects so it doesn't run when the config changes.
  // On initial mount, attach global listeners if needed.
  // On unmount, remove node potentially attached to the Responder System.

  React.useEffect(() => {
    ResponderSystem.attachListeners();
    return () => {
      ResponderSystem.removeNode(id);
    };
  }, [id]); // Register and unregister with the Responder System as necessary

  React.useEffect(() => {
    var _config = config,
        onMoveShouldSetResponder = _config.onMoveShouldSetResponder,
        onMoveShouldSetResponderCapture = _config.onMoveShouldSetResponderCapture,
        onScrollShouldSetResponder = _config.onScrollShouldSetResponder,
        onScrollShouldSetResponderCapture = _config.onScrollShouldSetResponderCapture,
        onSelectionChangeShouldSetResponder = _config.onSelectionChangeShouldSetResponder,
        onSelectionChangeShouldSetResponderCapture = _config.onSelectionChangeShouldSetResponderCapture,
        onStartShouldSetResponder = _config.onStartShouldSetResponder,
        onStartShouldSetResponderCapture = _config.onStartShouldSetResponderCapture;
    var requiresResponderSystem = onMoveShouldSetResponder != null || onMoveShouldSetResponderCapture != null || onScrollShouldSetResponder != null || onScrollShouldSetResponderCapture != null || onSelectionChangeShouldSetResponder != null || onSelectionChangeShouldSetResponderCapture != null || onStartShouldSetResponder != null || onStartShouldSetResponderCapture != null;
    var node = hostRef.current;

    if (requiresResponderSystem) {
      ResponderSystem.addNode(id, node, config);
      isAttachedRef.current = true;
    } else if (isAttachedRef.current) {
      ResponderSystem.removeNode(id);
      isAttachedRef.current = false;
    }
  }, [config, hostRef, id]);
  React.useDebugValue({
    isResponder: hostRef.current === ResponderSystem.getResponderNode()
  });
  React.useDebugValue(config);
}

module.exports = exports.default;

/***/ }),

/***/ 13128:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(64836)["default"]);

exports.__esModule = true;
exports.getLowestCommonAncestor = getLowestCommonAncestor;
exports.getResponderPaths = getResponderPaths;
exports.hasTargetTouches = hasTargetTouches;
exports.hasValidSelection = hasValidSelection;
exports.isPrimaryPointerDown = isPrimaryPointerDown;
exports.setResponderId = setResponderId;

var _isSelectionValid = _interopRequireDefault(__webpack_require__(72031));

/**
 * Copyright (c) Nicolas Gallagher
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
var keyName = '__reactResponderId';

function getEventPath(domEvent) {
  // The 'selectionchange' event always has the 'document' as the target.
  // Use the anchor node as the initial target to reconstruct a path.
  // (We actually only need the first "responder" node in practice.)
  if (domEvent.type === 'selectionchange') {
    var target = window.getSelection().anchorNode;
    return composedPathFallback(target);
  } else {
    var path = domEvent.composedPath != null ? domEvent.composedPath() : composedPathFallback(domEvent.target);
    return path;
  }
}

function composedPathFallback(target) {
  var path = [];

  while (target != null && target !== document.body) {
    path.push(target);
    target = target.parentNode;
  }

  return path;
}
/**
 * Retrieve the responderId from a host node
 */


function getResponderId(node) {
  if (node != null) {
    return node[keyName];
  }

  return null;
}
/**
 * Store the responderId on a host node
 */


function setResponderId(node, id) {
  if (node != null) {
    node[keyName] = id;
  }
}
/**
 * Filter the event path to contain only the nodes attached to the responder system
 */


function getResponderPaths(domEvent) {
  var idPath = [];
  var nodePath = [];
  var eventPath = getEventPath(domEvent);

  for (var i = 0; i < eventPath.length; i++) {
    var node = eventPath[i];
    var id = getResponderId(node);

    if (id != null) {
      idPath.push(id);
      nodePath.push(node);
    }
  }

  return {
    idPath,
    nodePath
  };
}
/**
 * Walk the paths and find the first common ancestor
 */


function getLowestCommonAncestor(pathA, pathB) {
  var pathALength = pathA.length;
  var pathBLength = pathB.length;

  if ( // If either path is empty
  pathALength === 0 || pathBLength === 0 || // If the last elements aren't the same there can't be a common ancestor
  // that is connected to the responder system
  pathA[pathALength - 1] !== pathB[pathBLength - 1]) {
    return null;
  }

  var itemA = pathA[0];
  var indexA = 0;
  var itemB = pathB[0];
  var indexB = 0; // If A is deeper, skip indices that can't match.

  if (pathALength - pathBLength > 0) {
    indexA = pathALength - pathBLength;
    itemA = pathA[indexA];
    pathALength = pathBLength;
  } // If B is deeper, skip indices that can't match


  if (pathBLength - pathALength > 0) {
    indexB = pathBLength - pathALength;
    itemB = pathB[indexB];
    pathBLength = pathALength;
  } // Walk in lockstep until a match is found


  var depth = pathALength;

  while (depth--) {
    if (itemA === itemB) {
      return itemA;
    }

    itemA = pathA[indexA++];
    itemB = pathB[indexB++];
  }

  return null;
}
/**
 * Determine whether any of the active touches are within the current responder.
 * This cannot rely on W3C `targetTouches`, as neither IE11 nor Safari implement it.
 */


function hasTargetTouches(target, touches) {
  if (!touches || touches.length === 0) {
    return false;
  }

  for (var i = 0; i < touches.length; i++) {
    var node = touches[i].target;

    if (node != null) {
      if (target.contains(node)) {
        return true;
      }
    }
  }

  return false;
}
/**
 * Ignore 'selectionchange' events that don't correspond with a person's intent to
 * select text.
 */


function hasValidSelection(domEvent) {
  if (domEvent.type === 'selectionchange') {
    return (0, _isSelectionValid.default)();
  }

  return domEvent.type === 'select';
}
/**
 * Events are only valid if the primary button was used without specific modifier keys.
 */


function isPrimaryPointerDown(domEvent) {
  var altKey = domEvent.altKey,
      button = domEvent.button,
      buttons = domEvent.buttons,
      ctrlKey = domEvent.ctrlKey,
      type = domEvent.type;
  var isTouch = type === 'touchstart' || type === 'touchmove';
  var isPrimaryMouseDown = type === 'mousedown' && (button === 0 || buttons === 1);
  var isPrimaryMouseMove = type === 'mousemove' && buttons === 1;
  var noModifiers = altKey === false && ctrlKey === false;

  if (isTouch || isPrimaryMouseDown && noModifiers || isPrimaryMouseMove && noModifiers) {
    return true;
  }

  return false;
}

/***/ }),

/***/ 96492:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireWildcard = (__webpack_require__(75263)["default"]);

exports.__esModule = true;
exports["default"] = useStable;

var React = _interopRequireWildcard(__webpack_require__(16689));

/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
var UNINITIALIZED = typeof Symbol === 'function' && typeof Symbol() === 'symbol' ? Symbol() : Object.freeze({});

function useStable(getInitialValue) {
  var ref = React.useRef(UNINITIALIZED);

  if (ref.current === UNINITIALIZED) {
    ref.current = getInitialValue();
  } // $FlowFixMe (#64650789) Trouble refining types where `Symbol` is concerned.


  return ref.current;
}

module.exports = exports.default;

/***/ }),

/***/ 24262:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(64836)["default"]);

exports.__esModule = true;
exports["default"] = void 0;

var _objectSpread2 = _interopRequireDefault(__webpack_require__(42122));

var _Platform = _interopRequireDefault(__webpack_require__(98842));

var _AnimatedFlatList = _interopRequireDefault(__webpack_require__(95359));

var _AnimatedImage = _interopRequireDefault(__webpack_require__(6995));

var _AnimatedScrollView = _interopRequireDefault(__webpack_require__(10583));

var _AnimatedSectionList = _interopRequireDefault(__webpack_require__(21110));

var _AnimatedText = _interopRequireDefault(__webpack_require__(4968));

var _AnimatedView = _interopRequireDefault(__webpack_require__(6814));

var _AnimatedMock = _interopRequireDefault(__webpack_require__(55195));

var _AnimatedImplementation = _interopRequireDefault(__webpack_require__(5474));

/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 */
var Animated = _Platform.default.isTesting ? _AnimatedMock.default : _AnimatedImplementation.default;

var _default = (0, _objectSpread2.default)({
  FlatList: _AnimatedFlatList.default,
  Image: _AnimatedImage.default,
  ScrollView: _AnimatedScrollView.default,
  SectionList: _AnimatedSectionList.default,
  Text: _AnimatedText.default,
  View: _AnimatedView.default
}, Animated);

exports["default"] = _default;
module.exports = exports.default;

/***/ }),

/***/ 15673:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 */


var _interopRequireWildcard = (__webpack_require__(75263)["default"]);

var _interopRequireDefault = (__webpack_require__(64836)["default"]);

exports.__esModule = true;
exports.AnimatedEvent = void 0;
exports.attachNativeEvent = attachNativeEvent;

var _AnimatedValue = _interopRequireDefault(__webpack_require__(84902));

var _NativeAnimatedHelper = _interopRequireWildcard(__webpack_require__(20612));

var _findNodeHandle = _interopRequireDefault(__webpack_require__(10530));

var _invariant = _interopRequireDefault(__webpack_require__(44505));

var __DEV__ = "production" !== 'production';

function attachNativeEvent(viewRef, eventName, argMapping) {
  // Find animated values in `argMapping` and create an array representing their
  // key path inside the `nativeEvent` object. Ex.: ['contentOffset', 'x'].
  var eventMappings = [];

  var traverse = (value, path) => {
    if (value instanceof _AnimatedValue.default) {
      value.__makeNative();

      eventMappings.push({
        nativeEventPath: path,
        animatedValueTag: value.__getNativeTag()
      });
    } else if (typeof value === 'object') {
      for (var _key in value) {
        traverse(value[_key], path.concat(_key));
      }
    }
  };

  (0, _invariant.default)(argMapping[0] && argMapping[0].nativeEvent, 'Native driven events only support animated values contained inside `nativeEvent`.'); // Assume that the event containing `nativeEvent` is always the first argument.

  traverse(argMapping[0].nativeEvent, []);
  var viewTag = (0, _findNodeHandle.default)(viewRef);

  if (viewTag != null) {
    eventMappings.forEach(mapping => {
      _NativeAnimatedHelper.default.API.addAnimatedEventToView(viewTag, eventName, mapping);
    });
  }

  return {
    detach() {
      if (viewTag != null) {
        eventMappings.forEach(mapping => {
          _NativeAnimatedHelper.default.API.removeAnimatedEventFromView(viewTag, eventName, // $FlowFixMe[incompatible-call]
          mapping.animatedValueTag);
        });
      }
    }

  };
}

function validateMapping(argMapping, args) {
  var validate = (recMapping, recEvt, key) => {
    if (recMapping instanceof _AnimatedValue.default) {
      (0, _invariant.default)(typeof recEvt === 'number', 'Bad mapping of event key ' + key + ', should be number but got ' + typeof recEvt);
      return;
    }

    if (typeof recEvt === 'number') {
      (0, _invariant.default)(recMapping instanceof _AnimatedValue.default, 'Bad mapping of type ' + typeof recMapping + ' for key ' + key + ', event value must map to AnimatedValue');
      return;
    }

    (0, _invariant.default)(typeof recMapping === 'object', 'Bad mapping of type ' + typeof recMapping + ' for key ' + key);
    (0, _invariant.default)(typeof recEvt === 'object', 'Bad event of type ' + typeof recEvt + ' for key ' + key);

    for (var mappingKey in recMapping) {
      validate(recMapping[mappingKey], recEvt[mappingKey], mappingKey);
    }
  };

  (0, _invariant.default)(args.length >= argMapping.length, 'Event has less arguments than mapping');
  argMapping.forEach((mapping, idx) => {
    validate(mapping, args[idx], 'arg' + idx);
  });
}

class AnimatedEvent {
  constructor(argMapping, config) {
    this._listeners = [];
    this._argMapping = argMapping;

    if (config == null) {
      console.warn('Animated.event now requires a second argument for options');
      config = {
        useNativeDriver: false
      };
    }

    if (config.listener) {
      this.__addListener(config.listener);
    }

    this._callListeners = this._callListeners.bind(this);
    this._attachedEvent = null;
    this.__isNative = (0, _NativeAnimatedHelper.shouldUseNativeDriver)(config);
  }

  __addListener(callback) {
    this._listeners.push(callback);
  }

  __removeListener(callback) {
    this._listeners = this._listeners.filter(listener => listener !== callback);
  }

  __attach(viewRef, eventName) {
    (0, _invariant.default)(this.__isNative, 'Only native driven events need to be attached.');
    this._attachedEvent = attachNativeEvent(viewRef, eventName, this._argMapping);
  }

  __detach(viewTag, eventName) {
    (0, _invariant.default)(this.__isNative, 'Only native driven events need to be detached.');
    this._attachedEvent && this._attachedEvent.detach();
  }

  __getHandler() {
    var _this = this;

    if (this.__isNative) {
      if (__DEV__) {
        var _validatedMapping = false;
        return function () {
          for (var _len = arguments.length, args = new Array(_len), _key2 = 0; _key2 < _len; _key2++) {
            args[_key2] = arguments[_key2];
          }

          if (!_validatedMapping) {
            validateMapping(_this._argMapping, args);
            _validatedMapping = true;
          }

          _this._callListeners(...args);
        };
      } else {
        return this._callListeners;
      }
    }

    var validatedMapping = false;
    return function () {
      for (var _len2 = arguments.length, args = new Array(_len2), _key3 = 0; _key3 < _len2; _key3++) {
        args[_key3] = arguments[_key3];
      }

      if (__DEV__ && !validatedMapping) {
        validateMapping(_this._argMapping, args);
        validatedMapping = true;
      }

      var traverse = (recMapping, recEvt, key) => {
        if (recMapping instanceof _AnimatedValue.default) {
          if (typeof recEvt === 'number') {
            recMapping.setValue(recEvt);
          }
        } else if (typeof recMapping === 'object') {
          for (var mappingKey in recMapping) {
            /* $FlowFixMe(>=0.120.0) This comment suppresses an error found
             * when Flow v0.120 was deployed. To see the error, delete this
             * comment and run Flow. */
            traverse(recMapping[mappingKey], recEvt[mappingKey], mappingKey);
          }
        }
      };

      _this._argMapping.forEach((mapping, idx) => {
        traverse(mapping, args[idx], 'arg' + idx);
      });

      _this._callListeners(...args);
    };
  }

  _callListeners() {
    for (var _len3 = arguments.length, args = new Array(_len3), _key4 = 0; _key4 < _len3; _key4++) {
      args[_key4] = arguments[_key4];
    }

    this._listeners.forEach(listener => listener(...args));
  }

}

exports.AnimatedEvent = AnimatedEvent;

/***/ }),

/***/ 5474:
/***/ ((module, exports, __webpack_require__) => {

"use strict";
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 */


var _interopRequireDefault = (__webpack_require__(64836)["default"]);

exports.__esModule = true;
exports["default"] = void 0;

var _objectSpread2 = _interopRequireDefault(__webpack_require__(42122));

var _AnimatedEvent = __webpack_require__(15673);

var _AnimatedAddition = _interopRequireDefault(__webpack_require__(43106));

var _AnimatedDiffClamp = _interopRequireDefault(__webpack_require__(76461));

var _AnimatedDivision = _interopRequireDefault(__webpack_require__(79649));

var _AnimatedInterpolation = _interopRequireDefault(__webpack_require__(43411));

var _AnimatedModulo = _interopRequireDefault(__webpack_require__(30828));

var _AnimatedMultiplication = _interopRequireDefault(__webpack_require__(3849));

var _AnimatedNode = _interopRequireDefault(__webpack_require__(88227));

var _AnimatedProps = _interopRequireDefault(__webpack_require__(33510));

var _AnimatedSubtraction = _interopRequireDefault(__webpack_require__(33466));

var _AnimatedTracking = _interopRequireDefault(__webpack_require__(25198));

var _AnimatedValue = _interopRequireDefault(__webpack_require__(84902));

var _AnimatedValueXY = _interopRequireDefault(__webpack_require__(38914));

var _DecayAnimation = _interopRequireDefault(__webpack_require__(78321));

var _SpringAnimation = _interopRequireDefault(__webpack_require__(67594));

var _TimingAnimation = _interopRequireDefault(__webpack_require__(84040));

var _createAnimatedComponent = _interopRequireDefault(__webpack_require__(49166));

var add = function add(a, b) {
  return new _AnimatedAddition.default(a, b);
};

var subtract = function subtract(a, b) {
  return new _AnimatedSubtraction.default(a, b);
};

var divide = function divide(a, b) {
  return new _AnimatedDivision.default(a, b);
};

var multiply = function multiply(a, b) {
  return new _AnimatedMultiplication.default(a, b);
};

var modulo = function modulo(a, modulus) {
  return new _AnimatedModulo.default(a, modulus);
};

var diffClamp = function diffClamp(a, min, max) {
  return new _AnimatedDiffClamp.default(a, min, max);
};

var _combineCallbacks = function _combineCallbacks(callback, config) {
  if (callback && config.onComplete) {
    return function () {
      config.onComplete && config.onComplete(...arguments);
      callback && callback(...arguments);
    };
  } else {
    return callback || config.onComplete;
  }
};

var maybeVectorAnim = function maybeVectorAnim(value, config, anim) {
  if (value instanceof _AnimatedValueXY.default) {
    var configX = (0, _objectSpread2.default)({}, config);
    var configY = (0, _objectSpread2.default)({}, config);

    for (var key in config) {
      var _config$key = config[key],
          x = _config$key.x,
          y = _config$key.y;

      if (x !== undefined && y !== undefined) {
        configX[key] = x;
        configY[key] = y;
      }
    }

    var aX = anim(value.x, configX);
    var aY = anim(value.y, configY); // We use `stopTogether: false` here because otherwise tracking will break
    // because the second animation will get stopped before it can update.

    return parallel([aX, aY], {
      stopTogether: false
    });
  }

  return null;
};

var spring = function spring(value, config) {
  var _start = function start(animatedValue, configuration, callback) {
    callback = _combineCallbacks(callback, configuration);
    var singleValue = animatedValue;
    var singleConfig = configuration;
    singleValue.stopTracking();

    if (configuration.toValue instanceof _AnimatedNode.default) {
      singleValue.track(new _AnimatedTracking.default(singleValue, configuration.toValue, _SpringAnimation.default, singleConfig, callback));
    } else {
      singleValue.animate(new _SpringAnimation.default(singleConfig), callback);
    }
  };

  return maybeVectorAnim(value, config, spring) || {
    start: function start(callback) {
      _start(value, config, callback);
    },
    stop: function stop() {
      value.stopAnimation();
    },
    reset: function reset() {
      value.resetAnimation();
    },
    _startNativeLoop: function _startNativeLoop(iterations) {
      var singleConfig = (0, _objectSpread2.default)((0, _objectSpread2.default)({}, config), {}, {
        iterations
      });

      _start(value, singleConfig);
    },
    _isUsingNativeDriver: function _isUsingNativeDriver() {
      return config.useNativeDriver || false;
    }
  };
};

var timing = function timing(value, config) {
  var _start2 = function start(animatedValue, configuration, callback) {
    callback = _combineCallbacks(callback, configuration);
    var singleValue = animatedValue;
    var singleConfig = configuration;
    singleValue.stopTracking();

    if (configuration.toValue instanceof _AnimatedNode.default) {
      singleValue.track(new _AnimatedTracking.default(singleValue, configuration.toValue, _TimingAnimation.default, singleConfig, callback));
    } else {
      singleValue.animate(new _TimingAnimation.default(singleConfig), callback);
    }
  };

  return maybeVectorAnim(value, config, timing) || {
    start: function start(callback) {
      _start2(value, config, callback);
    },
    stop: function stop() {
      value.stopAnimation();
    },
    reset: function reset() {
      value.resetAnimation();
    },
    _startNativeLoop: function _startNativeLoop(iterations) {
      var singleConfig = (0, _objectSpread2.default)((0, _objectSpread2.default)({}, config), {}, {
        iterations
      });

      _start2(value, singleConfig);
    },
    _isUsingNativeDriver: function _isUsingNativeDriver() {
      return config.useNativeDriver || false;
    }
  };
};

var decay = function decay(value, config) {
  var _start3 = function start(animatedValue, configuration, callback) {
    callback = _combineCallbacks(callback, configuration);
    var singleValue = animatedValue;
    var singleConfig = configuration;
    singleValue.stopTracking();
    singleValue.animate(new _DecayAnimation.default(singleConfig), callback);
  };

  return maybeVectorAnim(value, config, decay) || {
    start: function start(callback) {
      _start3(value, config, callback);
    },
    stop: function stop() {
      value.stopAnimation();
    },
    reset: function reset() {
      value.resetAnimation();
    },
    _startNativeLoop: function _startNativeLoop(iterations) {
      var singleConfig = (0, _objectSpread2.default)((0, _objectSpread2.default)({}, config), {}, {
        iterations
      });

      _start3(value, singleConfig);
    },
    _isUsingNativeDriver: function _isUsingNativeDriver() {
      return config.useNativeDriver || false;
    }
  };
};

var sequence = function sequence(animations) {
  var current = 0;
  return {
    start: function start(callback) {
      var onComplete = function onComplete(result) {
        if (!result.finished) {
          callback && callback(result);
          return;
        }

        current++;

        if (current === animations.length) {
          callback && callback(result);
          return;
        }

        animations[current].start(onComplete);
      };

      if (animations.length === 0) {
        callback && callback({
          finished: true
        });
      } else {
        animations[current].start(onComplete);
      }
    },
    stop: function stop() {
      if (current < animations.length) {
        animations[current].stop();
      }
    },
    reset: function reset() {
      animations.forEach((animation, idx) => {
        if (idx <= current) {
          animation.reset();
        }
      });
      current = 0;
    },
    _startNativeLoop: function _startNativeLoop() {
      throw new Error('Loops run using the native driver cannot contain Animated.sequence animations');
    },
    _isUsingNativeDriver: function _isUsingNativeDriver() {
      return false;
    }
  };
};

var parallel = function parallel(animations, config) {
  var doneCount = 0; // Make sure we only call stop() at most once for each animation

  var hasEnded = {};
  var stopTogether = !(config && config.stopTogether === false);
  var result = {
    start: function start(callback) {
      if (doneCount === animations.length) {
        callback && callback({
          finished: true
        });
        return;
      }

      animations.forEach((animation, idx) => {
        var cb = function cb(endResult) {
          hasEnded[idx] = true;
          doneCount++;

          if (doneCount === animations.length) {
            doneCount = 0;
            callback && callback(endResult);
            return;
          }

          if (!endResult.finished && stopTogether) {
            result.stop();
          }
        };

        if (!animation) {
          cb({
            finished: true
          });
        } else {
          animation.start(cb);
        }
      });
    },
    stop: function stop() {
      animations.forEach((animation, idx) => {
        !hasEnded[idx] && animation.stop();
        hasEnded[idx] = true;
      });
    },
    reset: function reset() {
      animations.forEach((animation, idx) => {
        animation.reset();
        hasEnded[idx] = false;
        doneCount = 0;
      });
    },
    _startNativeLoop: function _startNativeLoop() {
      throw new Error('Loops run using the native driver cannot contain Animated.parallel animations');
    },
    _isUsingNativeDriver: function _isUsingNativeDriver() {
      return false;
    }
  };
  return result;
};

var delay = function delay(time) {
  // Would be nice to make a specialized implementation
  return timing(new _AnimatedValue.default(0), {
    toValue: 0,
    delay: time,
    duration: 0,
    useNativeDriver: false
  });
};

var stagger = function stagger(time, animations) {
  return parallel(animations.map((animation, i) => {
    return sequence([delay(time * i), animation]);
  }));
};

var loop = function loop(animation, _temp) {
  var _ref = _temp === void 0 ? {} : _temp,
      _ref$iterations = _ref.iterations,
      iterations = _ref$iterations === void 0 ? -1 : _ref$iterations,
      _ref$resetBeforeItera = _ref.resetBeforeIteration,
      resetBeforeIteration = _ref$resetBeforeItera === void 0 ? true : _ref$resetBeforeItera;

  var isFinished = false;
  var iterationsSoFar = 0;
  return {
    start: function start(callback) {
      var restart = function restart(result) {
        if (result === void 0) {
          result = {
            finished: true
          };
        }

        if (isFinished || iterationsSoFar === iterations || result.finished === false) {
          callback && callback(result);
        } else {
          iterationsSoFar++;
          resetBeforeIteration && animation.reset();
          animation.start(restart);
        }
      };

      if (!animation || iterations === 0) {
        callback && callback({
          finished: true
        });
      } else {
        if (animation._isUsingNativeDriver()) {
          animation._startNativeLoop(iterations);
        } else {
          restart(); // Start looping recursively on the js thread
        }
      }
    },
    stop: function stop() {
      isFinished = true;
      animation.stop();
    },
    reset: function reset() {
      iterationsSoFar = 0;
      isFinished = false;
      animation.reset();
    },
    _startNativeLoop: function _startNativeLoop() {
      throw new Error('Loops run using the native driver cannot contain Animated.loop animations');
    },
    _isUsingNativeDriver: function _isUsingNativeDriver() {
      return animation._isUsingNativeDriver();
    }
  };
};

function forkEvent(event, listener) {
  if (!event) {
    return listener;
  } else if (event instanceof _AnimatedEvent.AnimatedEvent) {
    event.__addListener(listener);

    return event;
  } else {
    return function () {
      typeof event === 'function' && event(...arguments);
      listener(...arguments);
    };
  }
}

function unforkEvent(event, listener) {
  if (event && event instanceof _AnimatedEvent.AnimatedEvent) {
    event.__removeListener(listener);
  }
}

var event = function event(argMapping, config) {
  var animatedEvent = new _AnimatedEvent.AnimatedEvent(argMapping, config);

  if (animatedEvent.__isNative) {
    return animatedEvent;
  } else {
    return animatedEvent.__getHandler();
  }
};
/**
 * The `Animated` library is designed to make animations fluid, powerful, and
 * easy to build and maintain. `Animated` focuses on declarative relationships
 * between inputs and outputs, with configurable transforms in between, and
 * simple `start`/`stop` methods to control time-based animation execution.
 * If additional transforms are added, be sure to include them in
 * AnimatedMock.js as well.
 *
 * See https://reactnative.dev/docs/animated.html
 */


var _default = {
  /**
   * Standard value class for driving animations.  Typically initialized with
   * `new Animated.Value(0);`
   *
   * See https://reactnative.dev/docs/animated.html#value
   */
  Value: _AnimatedValue.default,

  /**
   * 2D value class for driving 2D animations, such as pan gestures.
   *
   * See https://reactnative.dev/docs/animatedvaluexy.html
   */
  ValueXY: _AnimatedValueXY.default,

  /**
   * Exported to use the Interpolation type in flow.
   *
   * See https://reactnative.dev/docs/animated.html#interpolation
   */
  Interpolation: _AnimatedInterpolation.default,

  /**
   * Exported for ease of type checking. All animated values derive from this
   * class.
   *
   * See https://reactnative.dev/docs/animated.html#node
   */
  Node: _AnimatedNode.default,

  /**
   * Animates a value from an initial velocity to zero based on a decay
   * coefficient.
   *
   * See https://reactnative.dev/docs/animated.html#decay
   */
  decay,

  /**
   * Animates a value along a timed easing curve. The Easing module has tons of
   * predefined curves, or you can use your own function.
   *
   * See https://reactnative.dev/docs/animated.html#timing
   */
  timing,

  /**
   * Animates a value according to an analytical spring model based on
   * damped harmonic oscillation.
   *
   * See https://reactnative.dev/docs/animated.html#spring
   */
  spring,

  /**
   * Creates a new Animated value composed from two Animated values added
   * together.
   *
   * See https://reactnative.dev/docs/animated.html#add
   */
  add,

  /**
   * Creates a new Animated value composed by subtracting the second Animated
   * value from the first Animated value.
   *
   * See https://reactnative.dev/docs/animated.html#subtract
   */
  subtract,

  /**
   * Creates a new Animated value composed by dividing the first Animated value
   * by the second Animated value.
   *
   * See https://reactnative.dev/docs/animated.html#divide
   */
  divide,

  /**
   * Creates a new Animated value composed from two Animated values multiplied
   * together.
   *
   * See https://reactnative.dev/docs/animated.html#multiply
   */
  multiply,

  /**
   * Creates a new Animated value that is the (non-negative) modulo of the
   * provided Animated value.
   *
   * See https://reactnative.dev/docs/animated.html#modulo
   */
  modulo,

  /**
   * Create a new Animated value that is limited between 2 values. It uses the
   * difference between the last value so even if the value is far from the
   * bounds it will start changing when the value starts getting closer again.
   *
   * See https://reactnative.dev/docs/animated.html#diffclamp
   */
  diffClamp,

  /**
   * Starts an animation after the given delay.
   *
   * See https://reactnative.dev/docs/animated.html#delay
   */
  delay,

  /**
   * Starts an array of animations in order, waiting for each to complete
   * before starting the next. If the current running animation is stopped, no
   * following animations will be started.
   *
   * See https://reactnative.dev/docs/animated.html#sequence
   */
  sequence,

  /**
   * Starts an array of animations all at the same time. By default, if one
   * of the animations is stopped, they will all be stopped. You can override
   * this with the `stopTogether` flag.
   *
   * See https://reactnative.dev/docs/animated.html#parallel
   */
  parallel,

  /**
   * Array of animations may run in parallel (overlap), but are started in
   * sequence with successive delays.  Nice for doing trailing effects.
   *
   * See https://reactnative.dev/docs/animated.html#stagger
   */
  stagger,

  /**
   * Loops a given animation continuously, so that each time it reaches the
   * end, it resets and begins again from the start.
   *
   * See https://reactnative.dev/docs/animated.html#loop
   */
  loop,

  /**
   * Takes an array of mappings and extracts values from each arg accordingly,
   * then calls `setValue` on the mapped outputs.
   *
   * See https://reactnative.dev/docs/animated.html#event
   */
  event,

  /**
   * Make any React component Animatable.  Used to create `Animated.View`, etc.
   *
   * See https://reactnative.dev/docs/animated.html#createanimatedcomponent
   */
  createAnimatedComponent: _createAnimatedComponent.default,

  /**
   * Imperative API to attach an animated value to an event on a view. Prefer
   * using `Animated.event` with `useNativeDrive: true` if possible.
   *
   * See https://reactnative.dev/docs/animated.html#attachnativeevent
   */
  attachNativeEvent: _AnimatedEvent.attachNativeEvent,

  /**
   * Advanced imperative API for snooping on animated events that are passed in
   * through props. Use values directly where possible.
   *
   * See https://reactnative.dev/docs/animated.html#forkevent
   */
  forkEvent,
  unforkEvent,

  /**
   * Expose Event class, so it can be used as a type for type checkers.
   */
  Event: _AnimatedEvent.AnimatedEvent,
  __PropsOnlyForTests: _AnimatedProps.default
};
exports["default"] = _default;
module.exports = exports.default;

/***/ }),

/***/ 55195:
/***/ ((module, exports, __webpack_require__) => {

"use strict";
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 */


var _interopRequireDefault = (__webpack_require__(64836)["default"]);

exports.__esModule = true;
exports["default"] = void 0;

var _objectSpread2 = _interopRequireDefault(__webpack_require__(42122));

var _AnimatedEvent = __webpack_require__(15673);

var _AnimatedImplementation = _interopRequireDefault(__webpack_require__(5474));

var _AnimatedInterpolation = _interopRequireDefault(__webpack_require__(43411));

var _AnimatedNode = _interopRequireDefault(__webpack_require__(88227));

var _AnimatedProps = _interopRequireDefault(__webpack_require__(33510));

var _AnimatedValue = _interopRequireDefault(__webpack_require__(84902));

var _AnimatedValueXY = _interopRequireDefault(__webpack_require__(38914));

var _createAnimatedComponent = _interopRequireDefault(__webpack_require__(49166));

var emptyAnimation = {
  start: () => {},
  stop: () => {},
  reset: () => {},
  _startNativeLoop: () => {},
  _isUsingNativeDriver: () => {
    return false;
  }
};

var spring = function spring(value, config) {
  var anyValue = value;
  return (0, _objectSpread2.default)((0, _objectSpread2.default)({}, emptyAnimation), {}, {
    start: callback => {
      anyValue.setValue(config.toValue);
      callback && callback({
        finished: true
      });
    }
  });
};

var timing = function timing(value, config) {
  var anyValue = value;
  return (0, _objectSpread2.default)((0, _objectSpread2.default)({}, emptyAnimation), {}, {
    start: callback => {
      anyValue.setValue(config.toValue);
      callback && callback({
        finished: true
      });
    }
  });
};

var decay = function decay(value, config) {
  return emptyAnimation;
};

var sequence = function sequence(animations) {
  return emptyAnimation;
};

var parallel = function parallel(animations, config) {
  return emptyAnimation;
};

var delay = function delay(time) {
  return emptyAnimation;
};

var stagger = function stagger(time, animations) {
  return emptyAnimation;
};

var loop = function loop(animation, _temp) {
  var _ref = _temp === void 0 ? {} : _temp,
      _ref$iterations = _ref.iterations,
      iterations = _ref$iterations === void 0 ? -1 : _ref$iterations;

  return emptyAnimation;
};

var event = function event(argMapping, config) {
  return null;
};

var _default = {
  Value: _AnimatedValue.default,
  ValueXY: _AnimatedValueXY.default,
  Interpolation: _AnimatedInterpolation.default,
  Node: _AnimatedNode.default,
  decay,
  timing,
  spring,
  add: _AnimatedImplementation.default.add,
  subtract: _AnimatedImplementation.default.subtract,
  divide: _AnimatedImplementation.default.divide,
  multiply: _AnimatedImplementation.default.multiply,
  modulo: _AnimatedImplementation.default.modulo,
  diffClamp: _AnimatedImplementation.default.diffClamp,
  delay,
  sequence,
  parallel,
  stagger,
  loop,
  event,
  createAnimatedComponent: _createAnimatedComponent.default,
  attachNativeEvent: _AnimatedEvent.attachNativeEvent,
  forkEvent: _AnimatedImplementation.default.forkEvent,
  unforkEvent: _AnimatedImplementation.default.unforkEvent,
  Event: _AnimatedEvent.AnimatedEvent,
  __PropsOnlyForTests: _AnimatedProps.default
};
exports["default"] = _default;
module.exports = exports.default;

/***/ }),

/***/ 49266:
/***/ ((module, exports, __webpack_require__) => {

"use strict";
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @format
 * 
 */


var _interopRequireDefault = (__webpack_require__(64836)["default"]);

exports.__esModule = true;
exports["default"] = void 0;

var _bezier2 = _interopRequireDefault(__webpack_require__(5430));

var ease;
/**
 * The `Easing` module implements common easing functions. This module is used
 * by [Animate.timing()](docs/animate.html#timing) to convey physically
 * believable motion in animations.
 *
 * You can find a visualization of some common easing functions at
 * http://easings.net/
 *
 * ### Predefined animations
 *
 * The `Easing` module provides several predefined animations through the
 * following methods:
 *
 * - [`back`](docs/easing.html#back) provides a simple animation where the
 *   object goes slightly back before moving forward
 * - [`bounce`](docs/easing.html#bounce) provides a bouncing animation
 * - [`ease`](docs/easing.html#ease) provides a simple inertial animation
 * - [`elastic`](docs/easing.html#elastic) provides a simple spring interaction
 *
 * ### Standard functions
 *
 * Three standard easing functions are provided:
 *
 * - [`linear`](docs/easing.html#linear)
 * - [`quad`](docs/easing.html#quad)
 * - [`cubic`](docs/easing.html#cubic)
 *
 * The [`poly`](docs/easing.html#poly) function can be used to implement
 * quartic, quintic, and other higher power functions.
 *
 * ### Additional functions
 *
 * Additional mathematical functions are provided by the following methods:
 *
 * - [`bezier`](docs/easing.html#bezier) provides a cubic bezier curve
 * - [`circle`](docs/easing.html#circle) provides a circular function
 * - [`sin`](docs/easing.html#sin) provides a sinusoidal function
 * - [`exp`](docs/easing.html#exp) provides an exponential function
 *
 * The following helpers are used to modify other easing functions.
 *
 * - [`in`](docs/easing.html#in) runs an easing function forwards
 * - [`inOut`](docs/easing.html#inout) makes any easing function symmetrical
 * - [`out`](docs/easing.html#out) runs an easing function backwards
 */

class Easing {
  /**
   * A stepping function, returns 1 for any positive value of `n`.
   */
  static step0(n) {
    return n > 0 ? 1 : 0;
  }
  /**
   * A stepping function, returns 1 if `n` is greater than or equal to 1.
   */


  static step1(n) {
    return n >= 1 ? 1 : 0;
  }
  /**
   * A linear function, `f(t) = t`. Position correlates to elapsed time one to
   * one.
   *
   * http://cubic-bezier.com/#0,0,1,1
   */


  static linear(t) {
    return t;
  }
  /**
   * A simple inertial interaction, similar to an object slowly accelerating to
   * speed.
   *
   * http://cubic-bezier.com/#.42,0,1,1
   */


  static ease(t) {
    if (!ease) {
      ease = Easing.bezier(0.42, 0, 1, 1);
    }

    return ease(t);
  }
  /**
   * A quadratic function, `f(t) = t * t`. Position equals the square of elapsed
   * time.
   *
   * http://easings.net/#easeInQuad
   */


  static quad(t) {
    return t * t;
  }
  /**
   * A cubic function, `f(t) = t * t * t`. Position equals the cube of elapsed
   * time.
   *
   * http://easings.net/#easeInCubic
   */


  static cubic(t) {
    return t * t * t;
  }
  /**
   * A power function. Position is equal to the Nth power of elapsed time.
   *
   * n = 4: http://easings.net/#easeInQuart
   * n = 5: http://easings.net/#easeInQuint
   */


  static poly(n) {
    return t => Math.pow(t, n);
  }
  /**
   * A sinusoidal function.
   *
   * http://easings.net/#easeInSine
   */


  static sin(t) {
    return 1 - Math.cos(t * Math.PI / 2);
  }
  /**
   * A circular function.
   *
   * http://easings.net/#easeInCirc
   */


  static circle(t) {
    return 1 - Math.sqrt(1 - t * t);
  }
  /**
   * An exponential function.
   *
   * http://easings.net/#easeInExpo
   */


  static exp(t) {
    return Math.pow(2, 10 * (t - 1));
  }
  /**
   * A simple elastic interaction, similar to a spring oscillating back and
   * forth.
   *
   * Default bounciness is 1, which overshoots a little bit once. 0 bounciness
   * doesn't overshoot at all, and bounciness of N > 1 will overshoot about N
   * times.
   *
   * http://easings.net/#easeInElastic
   */


  static elastic(bounciness) {
    if (bounciness === void 0) {
      bounciness = 1;
    }

    var p = bounciness * Math.PI;
    return t => 1 - Math.pow(Math.cos(t * Math.PI / 2), 3) * Math.cos(t * p);
  }
  /**
   * Use with `Animated.parallel()` to create a simple effect where the object
   * animates back slightly as the animation starts.
   *
   * Wolfram Plot:
   *
   * - http://tiny.cc/back_default (s = 1.70158, default)
   */


  static back(s) {
    if (s === void 0) {
      s = 1.70158;
    }

    return t => t * t * ((s + 1) * t - s);
  }
  /**
   * Provides a simple bouncing effect.
   *
   * http://easings.net/#easeInBounce
   */


  static bounce(t) {
    if (t < 1 / 2.75) {
      return 7.5625 * t * t;
    }

    if (t < 2 / 2.75) {
      var _t = t - 1.5 / 2.75;

      return 7.5625 * _t * _t + 0.75;
    }

    if (t < 2.5 / 2.75) {
      var _t2 = t - 2.25 / 2.75;

      return 7.5625 * _t2 * _t2 + 0.9375;
    }

    var t2 = t - 2.625 / 2.75;
    return 7.5625 * t2 * t2 + 0.984375;
  }
  /**
   * Provides a cubic bezier curve, equivalent to CSS Transitions'
   * `transition-timing-function`.
   *
   * A useful tool to visualize cubic bezier curves can be found at
   * http://cubic-bezier.com/
   */


  static bezier(x1, y1, x2, y2) {
    return (0, _bezier2.default)(x1, y1, x2, y2);
  }
  /**
   * Runs an easing function forwards.
   */


  static in(easing) {
    return easing;
  }
  /**
   * Runs an easing function backwards.
   */


  static out(easing) {
    return t => 1 - easing(1 - t);
  }
  /**
   * Makes any easing function symmetrical. The easing function will run
   * forwards for half of the duration, then backwards for the rest of the
   * duration.
   */


  static inOut(easing) {
    return t => {
      if (t < 0.5) {
        return easing(t * 2) / 2;
      }

      return 1 - easing((1 - t) * 2) / 2;
    };
  }

}

var _default = Easing;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),

/***/ 20612:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(64836)["default"]);

exports.__esModule = true;
exports["default"] = void 0;
exports.generateNewAnimationId = generateNewAnimationId;
exports.shouldUseNativeDriver = shouldUseNativeDriver;

var _NativeAnimatedModule = _interopRequireDefault(__webpack_require__(32422));

var _NativeAnimatedTurboModule = _interopRequireDefault(__webpack_require__(78482));

var _NativeEventEmitter = _interopRequireDefault(__webpack_require__(83394));

var _Platform = _interopRequireDefault(__webpack_require__(98842));

var _invariant = _interopRequireDefault(__webpack_require__(44505));

/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 */
// TODO T69437152 @petetheheat - Delete this fork when Fabric ships to 100%.
var NativeAnimatedModule = _Platform.default.OS === 'ios' && global.RN$Bridgeless ? _NativeAnimatedTurboModule.default : _NativeAnimatedModule.default;
var __nativeAnimatedNodeTagCount = 1;
/* used for animated nodes */

var __nativeAnimationIdCount = 1;
/* used for started animations */

var nativeEventEmitter;
var waitingForQueuedOperations = new Set();
var queueOperations = false;
var queue = [];
/**
 * Simple wrappers around NativeAnimatedModule to provide flow and autocomplete support for
 * the native module methods
 */

var API = {
  getValue: function getValue(tag, saveValueCallback) {
    (0, _invariant.default)(NativeAnimatedModule, 'Native animated module is not available');

    if (NativeAnimatedModule.getValue) {
      NativeAnimatedModule.getValue(tag, saveValueCallback);
    }
  },
  setWaitingForIdentifier: function setWaitingForIdentifier(id) {
    waitingForQueuedOperations.add(id);
    queueOperations = true;
  },
  unsetWaitingForIdentifier: function unsetWaitingForIdentifier(id) {
    waitingForQueuedOperations.delete(id);

    if (waitingForQueuedOperations.size === 0) {
      queueOperations = false;
      API.disableQueue();
    }
  },
  disableQueue: function disableQueue() {
    (0, _invariant.default)(NativeAnimatedModule, 'Native animated module is not available');

    if (_Platform.default.OS === 'android') {
      NativeAnimatedModule.startOperationBatch();
    }

    for (var q = 0, l = queue.length; q < l; q++) {
      queue[q]();
    }

    queue.length = 0;

    if (_Platform.default.OS === 'android') {
      NativeAnimatedModule.finishOperationBatch();
    }
  },
  queueOperation: fn => {
    if (queueOperations) {
      queue.push(fn);
    } else {
      fn();
    }
  },
  createAnimatedNode: function createAnimatedNode(tag, config) {
    (0, _invariant.default)(NativeAnimatedModule, 'Native animated module is not available');
    API.queueOperation(() => NativeAnimatedModule.createAnimatedNode(tag, config));
  },
  startListeningToAnimatedNodeValue: function startListeningToAnimatedNodeValue(tag) {
    (0, _invariant.default)(NativeAnimatedModule, 'Native animated module is not available');
    API.queueOperation(() => NativeAnimatedModule.startListeningToAnimatedNodeValue(tag));
  },
  stopListeningToAnimatedNodeValue: function stopListeningToAnimatedNodeValue(tag) {
    (0, _invariant.default)(NativeAnimatedModule, 'Native animated module is not available');
    API.queueOperation(() => NativeAnimatedModule.stopListeningToAnimatedNodeValue(tag));
  },
  connectAnimatedNodes: function connectAnimatedNodes(parentTag, childTag) {
    (0, _invariant.default)(NativeAnimatedModule, 'Native animated module is not available');
    API.queueOperation(() => NativeAnimatedModule.connectAnimatedNodes(parentTag, childTag));
  },
  disconnectAnimatedNodes: function disconnectAnimatedNodes(parentTag, childTag) {
    (0, _invariant.default)(NativeAnimatedModule, 'Native animated module is not available');
    API.queueOperation(() => NativeAnimatedModule.disconnectAnimatedNodes(parentTag, childTag));
  },
  startAnimatingNode: function startAnimatingNode(animationId, nodeTag, config, endCallback) {
    (0, _invariant.default)(NativeAnimatedModule, 'Native animated module is not available');
    API.queueOperation(() => NativeAnimatedModule.startAnimatingNode(animationId, nodeTag, config, endCallback));
  },
  stopAnimation: function stopAnimation(animationId) {
    (0, _invariant.default)(NativeAnimatedModule, 'Native animated module is not available');
    API.queueOperation(() => NativeAnimatedModule.stopAnimation(animationId));
  },
  setAnimatedNodeValue: function setAnimatedNodeValue(nodeTag, value) {
    (0, _invariant.default)(NativeAnimatedModule, 'Native animated module is not available');
    API.queueOperation(() => NativeAnimatedModule.setAnimatedNodeValue(nodeTag, value));
  },
  setAnimatedNodeOffset: function setAnimatedNodeOffset(nodeTag, offset) {
    (0, _invariant.default)(NativeAnimatedModule, 'Native animated module is not available');
    API.queueOperation(() => NativeAnimatedModule.setAnimatedNodeOffset(nodeTag, offset));
  },
  flattenAnimatedNodeOffset: function flattenAnimatedNodeOffset(nodeTag) {
    (0, _invariant.default)(NativeAnimatedModule, 'Native animated module is not available');
    API.queueOperation(() => NativeAnimatedModule.flattenAnimatedNodeOffset(nodeTag));
  },
  extractAnimatedNodeOffset: function extractAnimatedNodeOffset(nodeTag) {
    (0, _invariant.default)(NativeAnimatedModule, 'Native animated module is not available');
    API.queueOperation(() => NativeAnimatedModule.extractAnimatedNodeOffset(nodeTag));
  },
  connectAnimatedNodeToView: function connectAnimatedNodeToView(nodeTag, viewTag) {
    (0, _invariant.default)(NativeAnimatedModule, 'Native animated module is not available');
    API.queueOperation(() => NativeAnimatedModule.connectAnimatedNodeToView(nodeTag, viewTag));
  },
  disconnectAnimatedNodeFromView: function disconnectAnimatedNodeFromView(nodeTag, viewTag) {
    (0, _invariant.default)(NativeAnimatedModule, 'Native animated module is not available');
    API.queueOperation(() => NativeAnimatedModule.disconnectAnimatedNodeFromView(nodeTag, viewTag));
  },
  restoreDefaultValues: function restoreDefaultValues(nodeTag) {
    (0, _invariant.default)(NativeAnimatedModule, 'Native animated module is not available'); // Backwards compat with older native runtimes, can be removed later.

    if (NativeAnimatedModule.restoreDefaultValues != null) {
      API.queueOperation(() => NativeAnimatedModule.restoreDefaultValues(nodeTag));
    }
  },
  dropAnimatedNode: function dropAnimatedNode(tag) {
    (0, _invariant.default)(NativeAnimatedModule, 'Native animated module is not available');
    API.queueOperation(() => NativeAnimatedModule.dropAnimatedNode(tag));
  },
  addAnimatedEventToView: function addAnimatedEventToView(viewTag, eventName, eventMapping) {
    (0, _invariant.default)(NativeAnimatedModule, 'Native animated module is not available');
    API.queueOperation(() => NativeAnimatedModule.addAnimatedEventToView(viewTag, eventName, eventMapping));
  },

  removeAnimatedEventFromView(viewTag, eventName, animatedNodeTag) {
    (0, _invariant.default)(NativeAnimatedModule, 'Native animated module is not available');
    API.queueOperation(() => NativeAnimatedModule.removeAnimatedEventFromView(viewTag, eventName, animatedNodeTag));
  }

};
/**
 * Styles allowed by the native animated implementation.
 *
 * In general native animated implementation should support any numeric property that doesn't need
 * to be updated through the shadow view hierarchy (all non-layout properties).
 */

var SUPPORTED_STYLES = {
  opacity: true,
  transform: true,
  borderRadius: true,
  borderBottomEndRadius: true,
  borderBottomLeftRadius: true,
  borderBottomRightRadius: true,
  borderBottomStartRadius: true,
  borderTopEndRadius: true,
  borderTopLeftRadius: true,
  borderTopRightRadius: true,
  borderTopStartRadius: true,
  elevation: true,
  zIndex: true,

  /* ios styles */
  shadowOpacity: true,
  shadowRadius: true,

  /* legacy android transform properties */
  scaleX: true,
  scaleY: true,
  translateX: true,
  translateY: true
};
var SUPPORTED_TRANSFORMS = {
  translateX: true,
  translateY: true,
  scale: true,
  scaleX: true,
  scaleY: true,
  rotate: true,
  rotateX: true,
  rotateY: true,
  rotateZ: true,
  perspective: true
};
var SUPPORTED_INTERPOLATION_PARAMS = {
  inputRange: true,
  outputRange: true,
  extrapolate: true,
  extrapolateRight: true,
  extrapolateLeft: true
};

function addWhitelistedStyleProp(prop) {
  SUPPORTED_STYLES[prop] = true;
}

function addWhitelistedTransformProp(prop) {
  SUPPORTED_TRANSFORMS[prop] = true;
}

function addWhitelistedInterpolationParam(param) {
  SUPPORTED_INTERPOLATION_PARAMS[param] = true;
}

function validateTransform(configs) {
  configs.forEach(config => {
    if (!SUPPORTED_TRANSFORMS.hasOwnProperty(config.property)) {
      throw new Error("Property '" + config.property + "' is not supported by native animated module");
    }
  });
}

function validateStyles(styles) {
  for (var _key in styles) {
    if (!SUPPORTED_STYLES.hasOwnProperty(_key)) {
      throw new Error("Style property '" + _key + "' is not supported by native animated module");
    }
  }
}

function validateInterpolation(config) {
  for (var _key2 in config) {
    if (!SUPPORTED_INTERPOLATION_PARAMS.hasOwnProperty(_key2)) {
      throw new Error("Interpolation property '" + _key2 + "' is not supported by native animated module");
    }
  }
}

function generateNewNodeTag() {
  return __nativeAnimatedNodeTagCount++;
}

function generateNewAnimationId() {
  return __nativeAnimationIdCount++;
}

function assertNativeAnimatedModule() {
  (0, _invariant.default)(NativeAnimatedModule, 'Native animated module is not available');
}

var _warnedMissingNativeAnimated = false;

function shouldUseNativeDriver(config) {
  if (config.useNativeDriver == null) {
    console.warn('Animated: `useNativeDriver` was not specified. This is a required ' + 'option and must be explicitly set to `true` or `false`');
  }

  if (config.useNativeDriver === true && !NativeAnimatedModule) {
    if (!_warnedMissingNativeAnimated) {
      console.warn('Animated: `useNativeDriver` is not supported because the native ' + 'animated module is missing. Falling back to JS-based animation. To ' + 'resolve this, add `RCTAnimation` module to this app, or remove ' + '`useNativeDriver`. ' + 'Make sure to run `pod install` first. Read more about autolinking: https://github.com/react-native-community/cli/blob/master/docs/autolinking.md');
      _warnedMissingNativeAnimated = true;
    }

    return false;
  }

  return config.useNativeDriver || false;
}

function transformDataType(value) {
  // Change the string type to number type so we can reuse the same logic in
  // iOS and Android platform
  if (typeof value !== 'string') {
    return value;
  }

  if (/deg$/.test(value)) {
    var degrees = parseFloat(value) || 0;
    var radians = degrees * Math.PI / 180.0;
    return radians;
  } else {
    return value;
  }
}

var _default = {
  API,
  addWhitelistedStyleProp,
  addWhitelistedTransformProp,
  addWhitelistedInterpolationParam,
  validateStyles,
  validateTransform,
  validateInterpolation,
  generateNewNodeTag,
  generateNewAnimationId,
  assertNativeAnimatedModule,
  shouldUseNativeDriver,
  transformDataType,

  // $FlowExpectedError - unsafe getter lint suppresion
  get nativeEventEmitter() {
    if (!nativeEventEmitter) {
      nativeEventEmitter = new _NativeEventEmitter.default(NativeAnimatedModule);
    }

    return nativeEventEmitter;
  }

};
exports["default"] = _default;

/***/ }),

/***/ 32422:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireWildcard = (__webpack_require__(75263)["default"]);

exports.__esModule = true;
exports["default"] = void 0;

var TurboModuleRegistry = _interopRequireWildcard(__webpack_require__(24903));

/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 */
var _default = TurboModuleRegistry.get('NativeAnimatedModule');

exports["default"] = _default;
module.exports = exports.default;

/***/ }),

/***/ 78482:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireWildcard = (__webpack_require__(75263)["default"]);

exports.__esModule = true;
exports["default"] = void 0;

var TurboModuleRegistry = _interopRequireWildcard(__webpack_require__(24903));

/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 */
var _default = TurboModuleRegistry.get('NativeAnimatedTurboModule');

exports["default"] = _default;
module.exports = exports.default;

/***/ }),

/***/ 78965:
/***/ ((module, exports) => {

"use strict";
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @format
 * 
 */


exports.__esModule = true;
exports["default"] = void 0;

function stiffnessFromOrigamiValue(oValue) {
  return (oValue - 30) * 3.62 + 194;
}

function dampingFromOrigamiValue(oValue) {
  return (oValue - 8) * 3 + 25;
}

function fromOrigamiTensionAndFriction(tension, friction) {
  return {
    stiffness: stiffnessFromOrigamiValue(tension),
    damping: dampingFromOrigamiValue(friction)
  };
}

function fromBouncinessAndSpeed(bounciness, speed) {
  function normalize(value, startValue, endValue) {
    return (value - startValue) / (endValue - startValue);
  }

  function projectNormal(n, start, end) {
    return start + n * (end - start);
  }

  function linearInterpolation(t, start, end) {
    return t * end + (1 - t) * start;
  }

  function quadraticOutInterpolation(t, start, end) {
    return linearInterpolation(2 * t - t * t, start, end);
  }

  function b3Friction1(x) {
    return 0.0007 * Math.pow(x, 3) - 0.031 * Math.pow(x, 2) + 0.64 * x + 1.28;
  }

  function b3Friction2(x) {
    return 0.000044 * Math.pow(x, 3) - 0.006 * Math.pow(x, 2) + 0.36 * x + 2;
  }

  function b3Friction3(x) {
    return 0.00000045 * Math.pow(x, 3) - 0.000332 * Math.pow(x, 2) + 0.1078 * x + 5.84;
  }

  function b3Nobounce(tension) {
    if (tension <= 18) {
      return b3Friction1(tension);
    } else if (tension > 18 && tension <= 44) {
      return b3Friction2(tension);
    } else {
      return b3Friction3(tension);
    }
  }

  var b = normalize(bounciness / 1.7, 0, 20);
  b = projectNormal(b, 0, 0.8);
  var s = normalize(speed / 1.7, 0, 20);
  var bouncyTension = projectNormal(s, 0.5, 200);
  var bouncyFriction = quadraticOutInterpolation(b, b3Nobounce(bouncyTension), 0.01);
  return {
    stiffness: stiffnessFromOrigamiValue(bouncyTension),
    damping: dampingFromOrigamiValue(bouncyFriction)
  };
}

var _default = {
  fromOrigamiTensionAndFriction,
  fromBouncinessAndSpeed
};
exports["default"] = _default;
module.exports = exports.default;

/***/ }),

/***/ 36999:
/***/ ((module, exports, __webpack_require__) => {

"use strict";
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 */


var _interopRequireDefault = (__webpack_require__(64836)["default"]);

exports.__esModule = true;
exports["default"] = void 0;

var _NativeAnimatedHelper = _interopRequireDefault(__webpack_require__(20612));

var startNativeAnimationNextId = 1; // Important note: start() and stop() will only be called at most once.
// Once an animation has been stopped or finished its course, it will
// not be reused.

class Animation {
  start(fromValue, onUpdate, onEnd, previousAnimation, animatedValue) {}

  stop() {
    if (this.__nativeId) {
      _NativeAnimatedHelper.default.API.stopAnimation(this.__nativeId);
    }
  }

  __getNativeAnimationConfig() {
    // Subclasses that have corresponding animation implementation done in native
    // should override this method
    throw new Error('This animation type cannot be offloaded to native');
  } // Helper function for subclasses to make sure onEnd is only called once.


  __debouncedOnEnd(result) {
    var onEnd = this.__onEnd;
    this.__onEnd = null;
    onEnd && onEnd(result);
  }

  __startNativeAnimation(animatedValue) {
    var startNativeAnimationWaitId = startNativeAnimationNextId + ":startAnimation";
    startNativeAnimationNextId += 1;

    _NativeAnimatedHelper.default.API.setWaitingForIdentifier(startNativeAnimationWaitId);

    try {
      animatedValue.__makeNative();

      this.__nativeId = _NativeAnimatedHelper.default.generateNewAnimationId();

      _NativeAnimatedHelper.default.API.startAnimatingNode(this.__nativeId, animatedValue.__getNativeTag(), this.__getNativeAnimationConfig(), this.__debouncedOnEnd.bind(this));
    } catch (e) {
      throw e;
    } finally {
      _NativeAnimatedHelper.default.API.unsetWaitingForIdentifier(startNativeAnimationWaitId);
    }
  }

}

var _default = Animation;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),

/***/ 78321:
/***/ ((module, exports, __webpack_require__) => {

"use strict";
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 */


var _interopRequireDefault = (__webpack_require__(64836)["default"]);

exports.__esModule = true;
exports["default"] = void 0;

var _Animation = _interopRequireDefault(__webpack_require__(36999));

var _NativeAnimatedHelper = __webpack_require__(20612);

class DecayAnimation extends _Animation.default {
  constructor(config) {
    var _config$deceleration, _config$isInteraction, _config$iterations;

    super();
    this._deceleration = (_config$deceleration = config.deceleration) !== null && _config$deceleration !== void 0 ? _config$deceleration : 0.998;
    this._velocity = config.velocity;
    this._useNativeDriver = (0, _NativeAnimatedHelper.shouldUseNativeDriver)(config);
    this.__isInteraction = (_config$isInteraction = config.isInteraction) !== null && _config$isInteraction !== void 0 ? _config$isInteraction : !this._useNativeDriver;
    this.__iterations = (_config$iterations = config.iterations) !== null && _config$iterations !== void 0 ? _config$iterations : 1;
  }

  __getNativeAnimationConfig() {
    return {
      type: 'decay',
      deceleration: this._deceleration,
      velocity: this._velocity,
      iterations: this.__iterations
    };
  }

  start(fromValue, onUpdate, onEnd, previousAnimation, animatedValue) {
    this.__active = true;
    this._lastValue = fromValue;
    this._fromValue = fromValue;
    this._onUpdate = onUpdate;
    this.__onEnd = onEnd;
    this._startTime = Date.now();

    if (this._useNativeDriver) {
      this.__startNativeAnimation(animatedValue);
    } else {
      this._animationFrame = requestAnimationFrame(this.onUpdate.bind(this));
    }
  }

  onUpdate() {
    var now = Date.now();
    var value = this._fromValue + this._velocity / (1 - this._deceleration) * (1 - Math.exp(-(1 - this._deceleration) * (now - this._startTime)));

    this._onUpdate(value);

    if (Math.abs(this._lastValue - value) < 0.1) {
      this.__debouncedOnEnd({
        finished: true
      });

      return;
    }

    this._lastValue = value;

    if (this.__active) {
      this._animationFrame = requestAnimationFrame(this.onUpdate.bind(this));
    }
  }

  stop() {
    super.stop();
    this.__active = false;
    global.cancelAnimationFrame(this._animationFrame);

    this.__debouncedOnEnd({
      finished: false
    });
  }

}

var _default = DecayAnimation;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),

/***/ 67594:
/***/ ((module, exports, __webpack_require__) => {

"use strict";
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 */


var _interopRequireDefault = (__webpack_require__(64836)["default"]);

exports.__esModule = true;
exports["default"] = void 0;

var _AnimatedValue = _interopRequireDefault(__webpack_require__(84902));

var _AnimatedValueXY = _interopRequireDefault(__webpack_require__(38914));

var _AnimatedInterpolation = _interopRequireDefault(__webpack_require__(43411));

var _Animation = _interopRequireDefault(__webpack_require__(36999));

var _SpringConfig = _interopRequireDefault(__webpack_require__(78965));

var _invariant = _interopRequireDefault(__webpack_require__(44505));

var _NativeAnimatedHelper = __webpack_require__(20612);

class SpringAnimation extends _Animation.default {
  constructor(config) {
    var _config$overshootClam, _config$restDisplacem, _config$restSpeedThre, _config$velocity, _config$velocity2, _config$delay, _config$isInteraction, _config$iterations;

    super();
    this._overshootClamping = (_config$overshootClam = config.overshootClamping) !== null && _config$overshootClam !== void 0 ? _config$overshootClam : false;
    this._restDisplacementThreshold = (_config$restDisplacem = config.restDisplacementThreshold) !== null && _config$restDisplacem !== void 0 ? _config$restDisplacem : 0.001;
    this._restSpeedThreshold = (_config$restSpeedThre = config.restSpeedThreshold) !== null && _config$restSpeedThre !== void 0 ? _config$restSpeedThre : 0.001;
    this._initialVelocity = (_config$velocity = config.velocity) !== null && _config$velocity !== void 0 ? _config$velocity : 0;
    this._lastVelocity = (_config$velocity2 = config.velocity) !== null && _config$velocity2 !== void 0 ? _config$velocity2 : 0;
    this._toValue = config.toValue;
    this._delay = (_config$delay = config.delay) !== null && _config$delay !== void 0 ? _config$delay : 0;
    this._useNativeDriver = (0, _NativeAnimatedHelper.shouldUseNativeDriver)(config);
    this.__isInteraction = (_config$isInteraction = config.isInteraction) !== null && _config$isInteraction !== void 0 ? _config$isInteraction : !this._useNativeDriver;
    this.__iterations = (_config$iterations = config.iterations) !== null && _config$iterations !== void 0 ? _config$iterations : 1;

    if (config.stiffness !== undefined || config.damping !== undefined || config.mass !== undefined) {
      var _config$stiffness, _config$damping, _config$mass;

      (0, _invariant.default)(config.bounciness === undefined && config.speed === undefined && config.tension === undefined && config.friction === undefined, 'You can define one of bounciness/speed, tension/friction, or stiffness/damping/mass, but not more than one');
      this._stiffness = (_config$stiffness = config.stiffness) !== null && _config$stiffness !== void 0 ? _config$stiffness : 100;
      this._damping = (_config$damping = config.damping) !== null && _config$damping !== void 0 ? _config$damping : 10;
      this._mass = (_config$mass = config.mass) !== null && _config$mass !== void 0 ? _config$mass : 1;
    } else if (config.bounciness !== undefined || config.speed !== undefined) {
      var _config$bounciness, _config$speed;

      // Convert the origami bounciness/speed values to stiffness/damping
      // We assume mass is 1.
      (0, _invariant.default)(config.tension === undefined && config.friction === undefined && config.stiffness === undefined && config.damping === undefined && config.mass === undefined, 'You can define one of bounciness/speed, tension/friction, or stiffness/damping/mass, but not more than one');

      var springConfig = _SpringConfig.default.fromBouncinessAndSpeed((_config$bounciness = config.bounciness) !== null && _config$bounciness !== void 0 ? _config$bounciness : 8, (_config$speed = config.speed) !== null && _config$speed !== void 0 ? _config$speed : 12);

      this._stiffness = springConfig.stiffness;
      this._damping = springConfig.damping;
      this._mass = 1;
    } else {
      var _config$tension, _config$friction;

      // Convert the origami tension/friction values to stiffness/damping
      // We assume mass is 1.
      var _springConfig = _SpringConfig.default.fromOrigamiTensionAndFriction((_config$tension = config.tension) !== null && _config$tension !== void 0 ? _config$tension : 40, (_config$friction = config.friction) !== null && _config$friction !== void 0 ? _config$friction : 7);

      this._stiffness = _springConfig.stiffness;
      this._damping = _springConfig.damping;
      this._mass = 1;
    }

    (0, _invariant.default)(this._stiffness > 0, 'Stiffness value must be greater than 0');
    (0, _invariant.default)(this._damping > 0, 'Damping value must be greater than 0');
    (0, _invariant.default)(this._mass > 0, 'Mass value must be greater than 0');
  }

  __getNativeAnimationConfig() {
    var _this$_initialVelocit;

    return {
      type: 'spring',
      overshootClamping: this._overshootClamping,
      restDisplacementThreshold: this._restDisplacementThreshold,
      restSpeedThreshold: this._restSpeedThreshold,
      stiffness: this._stiffness,
      damping: this._damping,
      mass: this._mass,
      initialVelocity: (_this$_initialVelocit = this._initialVelocity) !== null && _this$_initialVelocit !== void 0 ? _this$_initialVelocit : this._lastVelocity,
      toValue: this._toValue,
      iterations: this.__iterations
    };
  }

  start(fromValue, onUpdate, onEnd, previousAnimation, animatedValue) {
    this.__active = true;
    this._startPosition = fromValue;
    this._lastPosition = this._startPosition;
    this._onUpdate = onUpdate;
    this.__onEnd = onEnd;
    this._lastTime = Date.now();
    this._frameTime = 0.0;

    if (previousAnimation instanceof SpringAnimation) {
      var internalState = previousAnimation.getInternalState();
      this._lastPosition = internalState.lastPosition;
      this._lastVelocity = internalState.lastVelocity; // Set the initial velocity to the last velocity

      this._initialVelocity = this._lastVelocity;
      this._lastTime = internalState.lastTime;
    }

    var start = () => {
      if (this._useNativeDriver) {
        this.__startNativeAnimation(animatedValue);
      } else {
        this.onUpdate();
      }
    }; //  If this._delay is more than 0, we start after the timeout.


    if (this._delay) {
      this._timeout = setTimeout(start, this._delay);
    } else {
      start();
    }
  }

  getInternalState() {
    return {
      lastPosition: this._lastPosition,
      lastVelocity: this._lastVelocity,
      lastTime: this._lastTime
    };
  }
  /**
   * This spring model is based off of a damped harmonic oscillator
   * (https://en.wikipedia.org/wiki/Harmonic_oscillator#Damped_harmonic_oscillator).
   *
   * We use the closed form of the second order differential equation:
   *
   * x'' + (2_0)x' + ^2x = 0
   *
   * where
   *    _0 = (k / m) (undamped angular frequency of the oscillator),
   *     = c / 2mk (damping ratio),
   *    c = damping constant
   *    k = stiffness
   *    m = mass
   *
   * The derivation of the closed form is described in detail here:
   * http://planetmath.org/sites/default/files/texpdf/39745.pdf
   *
   * This algorithm happens to match the algorithm used by CASpringAnimation,
   * a QuartzCore (iOS) API that creates spring animations.
   */


  onUpdate() {
    // If for some reason we lost a lot of frames (e.g. process large payload or
    // stopped in the debugger), we only advance by 4 frames worth of
    // computation and will continue on the next frame. It's better to have it
    // running at faster speed than jumping to the end.
    var MAX_STEPS = 64;
    var now = Date.now();

    if (now > this._lastTime + MAX_STEPS) {
      now = this._lastTime + MAX_STEPS;
    }

    var deltaTime = (now - this._lastTime) / 1000;
    this._frameTime += deltaTime;
    var c = this._damping;
    var m = this._mass;
    var k = this._stiffness;
    var v0 = -this._initialVelocity;
    var zeta = c / (2 * Math.sqrt(k * m)); // damping ratio

    var omega0 = Math.sqrt(k / m); // undamped angular frequency of the oscillator (rad/ms)

    var omega1 = omega0 * Math.sqrt(1.0 - zeta * zeta); // exponential decay

    var x0 = this._toValue - this._startPosition; // calculate the oscillation from x0 = 1 to x = 0

    var position = 0.0;
    var velocity = 0.0;
    var t = this._frameTime;

    if (zeta < 1) {
      // Under damped
      var envelope = Math.exp(-zeta * omega0 * t);
      position = this._toValue - envelope * ((v0 + zeta * omega0 * x0) / omega1 * Math.sin(omega1 * t) + x0 * Math.cos(omega1 * t)); // This looks crazy -- it's actually just the derivative of the
      // oscillation function

      velocity = zeta * omega0 * envelope * (Math.sin(omega1 * t) * (v0 + zeta * omega0 * x0) / omega1 + x0 * Math.cos(omega1 * t)) - envelope * (Math.cos(omega1 * t) * (v0 + zeta * omega0 * x0) - omega1 * x0 * Math.sin(omega1 * t));
    } else {
      // Critically damped
      var _envelope = Math.exp(-omega0 * t);

      position = this._toValue - _envelope * (x0 + (v0 + omega0 * x0) * t);
      velocity = _envelope * (v0 * (t * omega0 - 1) + t * x0 * (omega0 * omega0));
    }

    this._lastTime = now;
    this._lastPosition = position;
    this._lastVelocity = velocity;

    this._onUpdate(position);

    if (!this.__active) {
      // a listener might have stopped us in _onUpdate
      return;
    } // Conditions for stopping the spring animation


    var isOvershooting = false;

    if (this._overshootClamping && this._stiffness !== 0) {
      if (this._startPosition < this._toValue) {
        isOvershooting = position > this._toValue;
      } else {
        isOvershooting = position < this._toValue;
      }
    }

    var isVelocity = Math.abs(velocity) <= this._restSpeedThreshold;

    var isDisplacement = true;

    if (this._stiffness !== 0) {
      isDisplacement = Math.abs(this._toValue - position) <= this._restDisplacementThreshold;
    }

    if (isOvershooting || isVelocity && isDisplacement) {
      if (this._stiffness !== 0) {
        // Ensure that we end up with a round value
        this._lastPosition = this._toValue;
        this._lastVelocity = 0;

        this._onUpdate(this._toValue);
      }

      this.__debouncedOnEnd({
        finished: true
      });

      return;
    }

    this._animationFrame = requestAnimationFrame(this.onUpdate.bind(this));
  }

  stop() {
    super.stop();
    this.__active = false;
    clearTimeout(this._timeout);
    global.cancelAnimationFrame(this._animationFrame);

    this.__debouncedOnEnd({
      finished: false
    });
  }

}

var _default = SpringAnimation;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),

/***/ 84040:
/***/ ((module, exports, __webpack_require__) => {

"use strict";
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 */


var _interopRequireDefault = (__webpack_require__(64836)["default"]);

exports.__esModule = true;
exports["default"] = void 0;

var _AnimatedValue = _interopRequireDefault(__webpack_require__(84902));

var _AnimatedValueXY = _interopRequireDefault(__webpack_require__(38914));

var _AnimatedInterpolation = _interopRequireDefault(__webpack_require__(43411));

var _Animation = _interopRequireDefault(__webpack_require__(36999));

var _NativeAnimatedHelper = __webpack_require__(20612);

var _Easing = _interopRequireDefault(__webpack_require__(5717));

var _easeInOut;

function easeInOut() {
  if (!_easeInOut) {
    _easeInOut = _Easing.default.inOut(_Easing.default.ease);
  }

  return _easeInOut;
}

class TimingAnimation extends _Animation.default {
  constructor(config) {
    var _config$easing, _config$duration, _config$delay, _config$iterations, _config$isInteraction;

    super();
    this._toValue = config.toValue;
    this._easing = (_config$easing = config.easing) !== null && _config$easing !== void 0 ? _config$easing : easeInOut();
    this._duration = (_config$duration = config.duration) !== null && _config$duration !== void 0 ? _config$duration : 500;
    this._delay = (_config$delay = config.delay) !== null && _config$delay !== void 0 ? _config$delay : 0;
    this.__iterations = (_config$iterations = config.iterations) !== null && _config$iterations !== void 0 ? _config$iterations : 1;
    this._useNativeDriver = (0, _NativeAnimatedHelper.shouldUseNativeDriver)(config);
    this.__isInteraction = (_config$isInteraction = config.isInteraction) !== null && _config$isInteraction !== void 0 ? _config$isInteraction : !this._useNativeDriver;
  }

  __getNativeAnimationConfig() {
    var frameDuration = 1000.0 / 60.0;
    var frames = [];
    var numFrames = Math.round(this._duration / frameDuration);

    for (var frame = 0; frame < numFrames; frame++) {
      frames.push(this._easing(frame / numFrames));
    }

    frames.push(this._easing(1));
    return {
      type: 'frames',
      frames,
      toValue: this._toValue,
      iterations: this.__iterations
    };
  }

  start(fromValue, onUpdate, onEnd, previousAnimation, animatedValue) {
    this.__active = true;
    this._fromValue = fromValue;
    this._onUpdate = onUpdate;
    this.__onEnd = onEnd;

    var start = () => {
      // Animations that sometimes have 0 duration and sometimes do not
      // still need to use the native driver when duration is 0 so as to
      // not cause intermixed JS and native animations.
      if (this._duration === 0 && !this._useNativeDriver) {
        this._onUpdate(this._toValue);

        this.__debouncedOnEnd({
          finished: true
        });
      } else {
        this._startTime = Date.now();

        if (this._useNativeDriver) {
          this.__startNativeAnimation(animatedValue);
        } else {
          this._animationFrame = requestAnimationFrame(this.onUpdate.bind(this));
        }
      }
    };

    if (this._delay) {
      this._timeout = setTimeout(start, this._delay);
    } else {
      start();
    }
  }

  onUpdate() {
    var now = Date.now();

    if (now >= this._startTime + this._duration) {
      if (this._duration === 0) {
        this._onUpdate(this._toValue);
      } else {
        this._onUpdate(this._fromValue + this._easing(1) * (this._toValue - this._fromValue));
      }

      this.__debouncedOnEnd({
        finished: true
      });

      return;
    }

    this._onUpdate(this._fromValue + this._easing((now - this._startTime) / this._duration) * (this._toValue - this._fromValue));

    if (this.__active) {
      this._animationFrame = requestAnimationFrame(this.onUpdate.bind(this));
    }
  }

  stop() {
    super.stop();
    this.__active = false;
    clearTimeout(this._timeout);
    global.cancelAnimationFrame(this._animationFrame);

    this.__debouncedOnEnd({
      finished: false
    });
  }

}

var _default = TimingAnimation;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),

/***/ 5430:
/***/ ((module, exports) => {

"use strict";
/**
 * Portions Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 */

/**
 * BezierEasing - use bezier curve for transition easing function
 * https://github.com/gre/bezier-easing
 * @copyright 2014-2015 Gatan Renaudeau. MIT License.
 */
 // These values are established by empiricism with tests (tradeoff: performance VS precision)

exports.__esModule = true;
exports["default"] = bezier;
var NEWTON_ITERATIONS = 4;
var NEWTON_MIN_SLOPE = 0.001;
var SUBDIVISION_PRECISION = 0.0000001;
var SUBDIVISION_MAX_ITERATIONS = 10;
var kSplineTableSize = 11;
var kSampleStepSize = 1.0 / (kSplineTableSize - 1.0);
var float32ArraySupported = typeof Float32Array === 'function';

function A(aA1, aA2) {
  return 1.0 - 3.0 * aA2 + 3.0 * aA1;
}

function B(aA1, aA2) {
  return 3.0 * aA2 - 6.0 * aA1;
}

function C(aA1) {
  return 3.0 * aA1;
} // Returns x(t) given t, x1, and x2, or y(t) given t, y1, and y2.


function calcBezier(aT, aA1, aA2) {
  return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT;
} // Returns dx/dt given t, x1, and x2, or dy/dt given t, y1, and y2.


function getSlope(aT, aA1, aA2) {
  return 3.0 * A(aA1, aA2) * aT * aT + 2.0 * B(aA1, aA2) * aT + C(aA1);
}

function binarySubdivide(aX, _aA, _aB, mX1, mX2) {
  var currentX,
      currentT,
      i = 0,
      aA = _aA,
      aB = _aB;

  do {
    currentT = aA + (aB - aA) / 2.0;
    currentX = calcBezier(currentT, mX1, mX2) - aX;

    if (currentX > 0.0) {
      aB = currentT;
    } else {
      aA = currentT;
    }
  } while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);

  return currentT;
}

function newtonRaphsonIterate(aX, _aGuessT, mX1, mX2) {
  var aGuessT = _aGuessT;

  for (var i = 0; i < NEWTON_ITERATIONS; ++i) {
    var currentSlope = getSlope(aGuessT, mX1, mX2);

    if (currentSlope === 0.0) {
      return aGuessT;
    }

    var currentX = calcBezier(aGuessT, mX1, mX2) - aX;
    aGuessT -= currentX / currentSlope;
  }

  return aGuessT;
}

function bezier(mX1, mY1, mX2, mY2) {
  if (!(mX1 >= 0 && mX1 <= 1 && mX2 >= 0 && mX2 <= 1)) {
    throw new Error('bezier x values must be in [0, 1] range');
  } // Precompute samples table


  var sampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize);

  if (mX1 !== mY1 || mX2 !== mY2) {
    for (var i = 0; i < kSplineTableSize; ++i) {
      sampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);
    }
  }

  function getTForX(aX) {
    var intervalStart = 0.0;
    var currentSample = 1;
    var lastSample = kSplineTableSize - 1;

    for (; currentSample !== lastSample && sampleValues[currentSample] <= aX; ++currentSample) {
      intervalStart += kSampleStepSize;
    }

    --currentSample; // Interpolate to provide an initial guess for t

    var dist = (aX - sampleValues[currentSample]) / (sampleValues[currentSample + 1] - sampleValues[currentSample]);
    var guessForT = intervalStart + dist * kSampleStepSize;
    var initialSlope = getSlope(guessForT, mX1, mX2);

    if (initialSlope >= NEWTON_MIN_SLOPE) {
      return newtonRaphsonIterate(aX, guessForT, mX1, mX2);
    } else if (initialSlope === 0.0) {
      return guessForT;
    } else {
      return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);
    }
  }

  return function BezierEasing(x) {
    if (mX1 === mY1 && mX2 === mY2) {
      return x; // linear
    } // Because JavaScript number are imprecise, we should guarantee the extremes are right.


    if (x === 0) {
      return 0;
    }

    if (x === 1) {
      return 1;
    }

    return calcBezier(getTForX(x), mY1, mY2);
  };
}

;
module.exports = exports.default;

/***/ }),

/***/ 95359:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireWildcard = (__webpack_require__(75263)["default"]);

var _interopRequireDefault = (__webpack_require__(64836)["default"]);

exports.__esModule = true;
exports["default"] = void 0;

var _extends2 = _interopRequireDefault(__webpack_require__(10434));

var React = _interopRequireWildcard(__webpack_require__(16689));

var _FlatList = _interopRequireDefault(__webpack_require__(70035));

var _createAnimatedComponent = _interopRequireDefault(__webpack_require__(49166));

/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 */

/**
 * @see https://github.com/facebook/react-native/commit/b8c8562
 */
var FlatListWithEventThrottle = /*#__PURE__*/React.forwardRef((props, ref) => /*#__PURE__*/React.createElement(_FlatList.default, (0, _extends2.default)({
  scrollEventThrottle: 0.0001
}, props, {
  ref: ref
})));

var _default = (0, _createAnimatedComponent.default)(FlatListWithEventThrottle);

exports["default"] = _default;
module.exports = exports.default;

/***/ }),

/***/ 6995:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(64836)["default"]);

var _interopRequireWildcard = (__webpack_require__(75263)["default"]);

exports.__esModule = true;
exports["default"] = void 0;

var React = _interopRequireWildcard(__webpack_require__(16689));

var _Image = _interopRequireDefault(__webpack_require__(94965));

var _createAnimatedComponent = _interopRequireDefault(__webpack_require__(49166));

/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 */
var _default = (0, _createAnimatedComponent.default)(_Image.default, {
  collapsable: false
});

exports["default"] = _default;
module.exports = exports.default;

/***/ }),

/***/ 10583:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireWildcard = (__webpack_require__(75263)["default"]);

var _interopRequireDefault = (__webpack_require__(64836)["default"]);

exports.__esModule = true;
exports["default"] = void 0;

var _extends2 = _interopRequireDefault(__webpack_require__(10434));

var React = _interopRequireWildcard(__webpack_require__(16689));

var _ScrollView = _interopRequireDefault(__webpack_require__(38174));

var _createAnimatedComponent = _interopRequireDefault(__webpack_require__(49166));

/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 */

/**
 * @see https://github.com/facebook/react-native/commit/b8c8562
 */
var ScrollViewWithEventThrottle = /*#__PURE__*/React.forwardRef((props, ref) => /*#__PURE__*/React.createElement(_ScrollView.default, (0, _extends2.default)({
  scrollEventThrottle: 0.0001
}, props, {
  ref: ref
})));

var _default = (0, _createAnimatedComponent.default)(ScrollViewWithEventThrottle, {
  collapsable: false
});

exports["default"] = _default;
module.exports = exports.default;

/***/ }),

/***/ 21110:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireWildcard = (__webpack_require__(75263)["default"]);

var _interopRequireDefault = (__webpack_require__(64836)["default"]);

exports.__esModule = true;
exports["default"] = void 0;

var _extends2 = _interopRequireDefault(__webpack_require__(10434));

var React = _interopRequireWildcard(__webpack_require__(16689));

var _SectionList = _interopRequireDefault(__webpack_require__(87355));

var _createAnimatedComponent = _interopRequireDefault(__webpack_require__(49166));

/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 */

/**
 * @see https://github.com/facebook/react-native/commit/b8c8562
 */
var SectionListWithEventThrottle = /*#__PURE__*/React.forwardRef((props, ref) => /*#__PURE__*/React.createElement(_SectionList.default, (0, _extends2.default)({
  scrollEventThrottle: 0.0001
}, props, {
  ref: ref
})));

var _default = (0, _createAnimatedComponent.default)(SectionListWithEventThrottle);

exports["default"] = _default;
module.exports = exports.default;

/***/ }),

/***/ 4968:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(64836)["default"]);

var _interopRequireWildcard = (__webpack_require__(75263)["default"]);

exports.__esModule = true;
exports["default"] = void 0;

var React = _interopRequireWildcard(__webpack_require__(16689));

var _Text = _interopRequireDefault(__webpack_require__(48409));

var _createAnimatedComponent = _interopRequireDefault(__webpack_require__(49166));

/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 */
var _default = (0, _createAnimatedComponent.default)(_Text.default, {
  collapsable: false
});

exports["default"] = _default;
module.exports = exports.default;

/***/ }),

/***/ 6814:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(64836)["default"]);

var _interopRequireWildcard = (__webpack_require__(75263)["default"]);

exports.__esModule = true;
exports["default"] = void 0;

var React = _interopRequireWildcard(__webpack_require__(16689));

var _View = _interopRequireDefault(__webpack_require__(79057));

var _createAnimatedComponent = _interopRequireDefault(__webpack_require__(49166));

/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 */
var _default = (0, _createAnimatedComponent.default)(_View.default, {
  collapsable: true
});

exports["default"] = _default;
module.exports = exports.default;

/***/ }),

/***/ 49166:
/***/ ((module, exports, __webpack_require__) => {

"use strict";
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 */


var _interopRequireDefault = (__webpack_require__(64836)["default"]);

var _interopRequireWildcard = (__webpack_require__(75263)["default"]);

exports.__esModule = true;
exports["default"] = void 0;

var _extends2 = _interopRequireDefault(__webpack_require__(10434));

var _objectSpread2 = _interopRequireDefault(__webpack_require__(42122));

var _objectWithoutPropertiesLoose2 = _interopRequireDefault(__webpack_require__(7071));

var _View = _interopRequireDefault(__webpack_require__(79057));

var _AnimatedEvent = __webpack_require__(15673);

var _AnimatedProps = _interopRequireDefault(__webpack_require__(33510));

var React = _interopRequireWildcard(__webpack_require__(16689));

var _NativeAnimatedHelper = _interopRequireDefault(__webpack_require__(20612));

var _invariant = _interopRequireDefault(__webpack_require__(44505));

var _setAndForwardRef = _interopRequireDefault(__webpack_require__(3706));

var _excluded = ["style"],
    _excluded2 = ["style"];
var animatedComponentNextId = 1;

function createAnimatedComponent(Component, options) {
  (0, _invariant.default)(typeof Component !== 'function' || Component.prototype && Component.prototype.isReactComponent, '`createAnimatedComponent` does not support stateless functional components; ' + 'use a class component instead.');

  class AnimatedComponent extends React.Component {
    constructor() {
      super(...arguments);
      this._invokeAnimatedPropsCallbackOnMount = false;
      this._eventDetachers = [];
      this._animatedComponentId = animatedComponentNextId++ + ":animatedComponent";

      this._isFabric = () => {
        var _this$_component$_int, _this$_component$_int2, _this$_component$getN, _this$_component$getN2, _this$_component$getS, _this$_component$getS2;

        // When called during the first render, `_component` is always null.
        // Therefore, even if a component is rendered in Fabric, we can't detect
        // that until ref is set, which happens sometime after the first render.
        // In cases where this value switching between "false" and "true" on Fabric
        // causes issues, add an additional check for _component nullity.
        if (this._component == null) {
          return false;
        }

        return (// eslint-disable-next-line dot-notation
          ((_this$_component$_int = this._component['_internalInstanceHandle']) == null ? void 0 : (_this$_component$_int2 = _this$_component$_int.stateNode) == null ? void 0 : _this$_component$_int2.canonical) != null || // Some components have a setNativeProps function but aren't a host component
          // such as lists like FlatList and SectionList. These should also use
          // forceUpdate in Fabric since setNativeProps doesn't exist on the underlying
          // host component. This crazy hack is essentially special casing those lists and
          // ScrollView itself to use forceUpdate in Fabric.
          // If these components end up using forwardRef then these hacks can go away
          // as this._component would actually be the underlying host component and the above check
          // would be sufficient.
          this._component.getNativeScrollRef != null && this._component.getNativeScrollRef() != null && // eslint-disable-next-line dot-notation
          ((_this$_component$getN = this._component.getNativeScrollRef()['_internalInstanceHandle']) == null ? void 0 : (_this$_component$getN2 = _this$_component$getN.stateNode) == null ? void 0 : _this$_component$getN2.canonical) != null || this._component.getScrollResponder != null && this._component.getScrollResponder() != null && this._component.getScrollResponder().getNativeScrollRef != null && this._component.getScrollResponder().getNativeScrollRef() != null && ((_this$_component$getS = this._component.getScrollResponder().getNativeScrollRef()[// eslint-disable-next-line dot-notation
          '_internalInstanceHandle']) == null ? void 0 : (_this$_component$getS2 = _this$_component$getS.stateNode) == null ? void 0 : _this$_component$getS2.canonical) != null
        );
      };

      this._waitForUpdate = () => {
        if (this._isFabric()) {
          _NativeAnimatedHelper.default.API.setWaitingForIdentifier(this._animatedComponentId);
        }
      };

      this._markUpdateComplete = () => {
        if (this._isFabric()) {
          _NativeAnimatedHelper.default.API.unsetWaitingForIdentifier(this._animatedComponentId);
        }
      };

      this._animatedPropsCallback = () => {
        if (this._component == null) {
          // AnimatedProps is created in will-mount because it's used in render.
          // But this callback may be invoked before mount in async mode,
          // In which case we should defer the setNativeProps() call.
          // React may throw away uncommitted work in async mode,
          // So a deferred call won't always be invoked.
          this._invokeAnimatedPropsCallbackOnMount = true;
        } else if ( false || // For animating properties of non-leaf/non-native components
        typeof this._component.setNativeProps !== 'function' || // In Fabric, force animations to go through forceUpdate and skip setNativeProps
        this._isFabric()) {
          this.forceUpdate();
        } else if (!this._propsAnimated.__isNative) {
          this._component.setNativeProps(this._propsAnimated.__getAnimatedValue());
        } else {
          throw new Error('Attempting to run JS driven animation on animated ' + 'node that has been moved to "native" earlier by starting an ' + 'animation with `useNativeDriver: true`');
        }
      };

      this._setComponentRef = (0, _setAndForwardRef.default)({
        getForwardedRef: () => this.props.forwardedRef,
        setLocalRef: ref => {
          this._prevComponent = this._component;
          this._component = ref; // TODO: Delete this in a future release.

          if (ref != null && ref.getNode == null) {
            ref.getNode = () => {
              var _ref$constructor$name;

              console.warn('%s: Calling `getNode()` on the ref of an Animated component ' + 'is no longer necessary. You can now directly use the ref ' + 'instead. This method will be removed in a future release.', (_ref$constructor$name = ref.constructor.name) !== null && _ref$constructor$name !== void 0 ? _ref$constructor$name : '<<anonymous>>');
              return ref;
            };
          }
        }
      });
    }

    _attachNativeEvents() {
      var _this$_component,
          _this = this;

      // Make sure to get the scrollable node for components that implement
      // `ScrollResponder.Mixin`.
      var scrollableNode = (_this$_component = this._component) != null && _this$_component.getScrollableNode ? this._component.getScrollableNode() : this._component;

      var _loop = function _loop(key) {
        var prop = _this.props[key];

        if (prop instanceof _AnimatedEvent.AnimatedEvent && prop.__isNative) {
          prop.__attach(scrollableNode, key);

          _this._eventDetachers.push(() => prop.__detach(scrollableNode, key));
        }
      };

      for (var key in this.props) {
        _loop(key);
      }
    }

    _detachNativeEvents() {
      this._eventDetachers.forEach(remove => remove());

      this._eventDetachers = [];
    }

    _attachProps(nextProps) {
      var oldPropsAnimated = this._propsAnimated;

      if (nextProps === oldPropsAnimated) {
        return;
      }

      this._propsAnimated = new _AnimatedProps.default(nextProps, this._animatedPropsCallback); // When you call detach, it removes the element from the parent list
      // of children. If it goes to 0, then the parent also detaches itself
      // and so on.
      // An optimization is to attach the new elements and THEN detach the old
      // ones instead of detaching and THEN attaching.
      // This way the intermediate state isn't to go to 0 and trigger
      // this expensive recursive detaching to then re-attach everything on
      // the very next operation.

      if (oldPropsAnimated) {
        oldPropsAnimated.__restoreDefaultValues();

        oldPropsAnimated.__detach();
      }
    }

    render() {
      var _ref = this._propsAnimated.__getValue() || {},
          _ref$style = _ref.style,
          style = _ref$style === void 0 ? {} : _ref$style,
          props = (0, _objectWithoutPropertiesLoose2.default)(_ref, _excluded);

      var _ref2 = this.props.passthroughAnimatedPropExplicitValues || {},
          _ref2$style = _ref2.style,
          passthruStyle = _ref2$style === void 0 ? {} : _ref2$style,
          passthruProps = (0, _objectWithoutPropertiesLoose2.default)(_ref2, _excluded2);

      var mergedStyle = (0, _objectSpread2.default)((0, _objectSpread2.default)({}, style), passthruStyle);
      return /*#__PURE__*/React.createElement(Component, (0, _extends2.default)({}, props, passthruProps, {
        style: mergedStyle,
        ref: this._setComponentRef
      }));
    }

    UNSAFE_componentWillMount() {
      this._waitForUpdate();

      this._attachProps(this.props);
    }

    componentDidMount() {
      if (this._invokeAnimatedPropsCallbackOnMount) {
        this._invokeAnimatedPropsCallbackOnMount = false;

        this._animatedPropsCallback();
      }

      this._propsAnimated.setNativeView(this._component);

      this._attachNativeEvents();

      this._markUpdateComplete();
    }

    UNSAFE_componentWillReceiveProps(newProps) {
      this._waitForUpdate();

      this._attachProps(newProps);
    }

    componentDidUpdate(prevProps) {
      if (this._component !== this._prevComponent) {
        this._propsAnimated.setNativeView(this._component);
      }

      if (this._component !== this._prevComponent || prevProps !== this.props) {
        this._detachNativeEvents();

        this._attachNativeEvents();
      }

      this._markUpdateComplete();
    }

    componentWillUnmount() {
      this._propsAnimated && this._propsAnimated.__detach();

      this._detachNativeEvents();

      this._markUpdateComplete();

      this._component = null;
      this._prevComponent = null;
    }

  }

  return /*#__PURE__*/React.forwardRef(function AnimatedComponentWrapper(props, ref) {
    return /*#__PURE__*/React.createElement(AnimatedComponent, (0, _extends2.default)({}, props, ref == null ? null : {
      forwardedRef: ref
    }));
  });
}

var _default = createAnimatedComponent;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),

/***/ 43106:
/***/ ((module, exports, __webpack_require__) => {

"use strict";
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 */


var _interopRequireDefault = (__webpack_require__(64836)["default"]);

exports.__esModule = true;
exports["default"] = void 0;

var _AnimatedInterpolation = _interopRequireDefault(__webpack_require__(43411));

var _AnimatedNode = _interopRequireDefault(__webpack_require__(88227));

var _AnimatedValue = _interopRequireDefault(__webpack_require__(84902));

var _AnimatedWithChildren = _interopRequireDefault(__webpack_require__(34069));

class AnimatedAddition extends _AnimatedWithChildren.default {
  constructor(a, b) {
    super();
    this._a = typeof a === 'number' ? new _AnimatedValue.default(a) : a;
    this._b = typeof b === 'number' ? new _AnimatedValue.default(b) : b;
  }

  __makeNative() {
    this._a.__makeNative();

    this._b.__makeNative();

    super.__makeNative();
  }

  __getValue() {
    return this._a.__getValue() + this._b.__getValue();
  }

  interpolate(config) {
    return new _AnimatedInterpolation.default(this, config);
  }

  __attach() {
    this._a.__addChild(this);

    this._b.__addChild(this);
  }

  __detach() {
    this._a.__removeChild(this);

    this._b.__removeChild(this);

    super.__detach();
  }

  __getNativeConfig() {
    return {
      type: 'addition',
      input: [this._a.__getNativeTag(), this._b.__getNativeTag()]
    };
  }

}

var _default = AnimatedAddition;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),

/***/ 76461:
/***/ ((module, exports, __webpack_require__) => {

"use strict";
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 */


var _interopRequireDefault = (__webpack_require__(64836)["default"]);

exports.__esModule = true;
exports["default"] = void 0;

var _AnimatedInterpolation = _interopRequireDefault(__webpack_require__(43411));

var _AnimatedNode = _interopRequireDefault(__webpack_require__(88227));

var _AnimatedWithChildren = _interopRequireDefault(__webpack_require__(34069));

class AnimatedDiffClamp extends _AnimatedWithChildren.default {
  constructor(a, min, max) {
    super();
    this._a = a;
    this._min = min;
    this._max = max;
    this._value = this._lastValue = this._a.__getValue();
  }

  __makeNative() {
    this._a.__makeNative();

    super.__makeNative();
  }

  interpolate(config) {
    return new _AnimatedInterpolation.default(this, config);
  }

  __getValue() {
    var value = this._a.__getValue();

    var diff = value - this._lastValue;
    this._lastValue = value;
    this._value = Math.min(Math.max(this._value + diff, this._min), this._max);
    return this._value;
  }

  __attach() {
    this._a.__addChild(this);
  }

  __detach() {
    this._a.__removeChild(this);

    super.__detach();
  }

  __getNativeConfig() {
    return {
      type: 'diffclamp',
      input: this._a.__getNativeTag(),
      min: this._min,
      max: this._max
    };
  }

}

var _default = AnimatedDiffClamp;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),

/***/ 79649:
/***/ ((module, exports, __webpack_require__) => {

"use strict";
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 */


var _interopRequireDefault = (__webpack_require__(64836)["default"]);

exports.__esModule = true;
exports["default"] = void 0;

var _AnimatedInterpolation = _interopRequireDefault(__webpack_require__(43411));

var _AnimatedNode = _interopRequireDefault(__webpack_require__(88227));

var _AnimatedValue = _interopRequireDefault(__webpack_require__(84902));

var _AnimatedWithChildren = _interopRequireDefault(__webpack_require__(34069));

class AnimatedDivision extends _AnimatedWithChildren.default {
  constructor(a, b) {
    super();
    this._warnedAboutDivideByZero = false;

    if (b === 0 || b instanceof _AnimatedNode.default && b.__getValue() === 0) {
      console.error('Detected potential division by zero in AnimatedDivision');
    }

    this._a = typeof a === 'number' ? new _AnimatedValue.default(a) : a;
    this._b = typeof b === 'number' ? new _AnimatedValue.default(b) : b;
  }

  __makeNative() {
    this._a.__makeNative();

    this._b.__makeNative();

    super.__makeNative();
  }

  __getValue() {
    var a = this._a.__getValue();

    var b = this._b.__getValue();

    if (b === 0) {
      // Prevent spamming the console/LogBox
      if (!this._warnedAboutDivideByZero) {
        console.error('Detected division by zero in AnimatedDivision');
        this._warnedAboutDivideByZero = true;
      } // Passing infinity/NaN to Fabric will cause a native crash


      return 0;
    }

    this._warnedAboutDivideByZero = false;
    return a / b;
  }

  interpolate(config) {
    return new _AnimatedInterpolation.default(this, config);
  }

  __attach() {
    this._a.__addChild(this);

    this._b.__addChild(this);
  }

  __detach() {
    this._a.__removeChild(this);

    this._b.__removeChild(this);

    super.__detach();
  }

  __getNativeConfig() {
    return {
      type: 'division',
      input: [this._a.__getNativeTag(), this._b.__getNativeTag()]
    };
  }

}

var _default = AnimatedDivision;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),

/***/ 43411:
/***/ ((module, exports, __webpack_require__) => {

"use strict";
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 */

/* eslint no-bitwise: 0 */


var _interopRequireDefault = (__webpack_require__(64836)["default"]);

exports.__esModule = true;
exports["default"] = void 0;

var _objectSpread2 = _interopRequireDefault(__webpack_require__(42122));

var _AnimatedNode = _interopRequireDefault(__webpack_require__(88227));

var _AnimatedWithChildren = _interopRequireDefault(__webpack_require__(34069));

var _NativeAnimatedHelper = _interopRequireDefault(__webpack_require__(20612));

var _invariant = _interopRequireDefault(__webpack_require__(44505));

var _normalizeCssColor = _interopRequireDefault(__webpack_require__(15002));

var __DEV__ = "production" !== 'production';

var linear = t => t;
/**
 * Very handy helper to map input ranges to output ranges with an easing
 * function and custom behavior outside of the ranges.
 */


function createInterpolation(config) {
  if (config.outputRange && typeof config.outputRange[0] === 'string') {
    return createInterpolationFromStringOutputRange(config);
  }

  var outputRange = config.outputRange;
  checkInfiniteRange('outputRange', outputRange);
  var inputRange = config.inputRange;
  checkInfiniteRange('inputRange', inputRange);
  checkValidInputRange(inputRange);
  (0, _invariant.default)(inputRange.length === outputRange.length, 'inputRange (' + inputRange.length + ') and outputRange (' + outputRange.length + ') must have the same length');
  var easing = config.easing || linear;
  var extrapolateLeft = 'extend';

  if (config.extrapolateLeft !== undefined) {
    extrapolateLeft = config.extrapolateLeft;
  } else if (config.extrapolate !== undefined) {
    extrapolateLeft = config.extrapolate;
  }

  var extrapolateRight = 'extend';

  if (config.extrapolateRight !== undefined) {
    extrapolateRight = config.extrapolateRight;
  } else if (config.extrapolate !== undefined) {
    extrapolateRight = config.extrapolate;
  }

  return input => {
    (0, _invariant.default)(typeof input === 'number', 'Cannot interpolation an input which is not a number');
    var range = findRange(input, inputRange);
    return interpolate(input, inputRange[range], inputRange[range + 1], outputRange[range], outputRange[range + 1], easing, extrapolateLeft, extrapolateRight);
  };
}

function interpolate(input, inputMin, inputMax, outputMin, outputMax, easing, extrapolateLeft, extrapolateRight) {
  var result = input; // Extrapolate

  if (result < inputMin) {
    if (extrapolateLeft === 'identity') {
      return result;
    } else if (extrapolateLeft === 'clamp') {
      result = inputMin;
    } else if (extrapolateLeft === 'extend') {// noop
    }
  }

  if (result > inputMax) {
    if (extrapolateRight === 'identity') {
      return result;
    } else if (extrapolateRight === 'clamp') {
      result = inputMax;
    } else if (extrapolateRight === 'extend') {// noop
    }
  }

  if (outputMin === outputMax) {
    return outputMin;
  }

  if (inputMin === inputMax) {
    if (input <= inputMin) {
      return outputMin;
    }

    return outputMax;
  } // Input Range


  if (inputMin === -Infinity) {
    result = -result;
  } else if (inputMax === Infinity) {
    result = result - inputMin;
  } else {
    result = (result - inputMin) / (inputMax - inputMin);
  } // Easing


  result = easing(result); // Output Range

  if (outputMin === -Infinity) {
    result = -result;
  } else if (outputMax === Infinity) {
    result = result + outputMin;
  } else {
    result = result * (outputMax - outputMin) + outputMin;
  }

  return result;
}

function colorToRgba(input) {
  var normalizedColor = (0, _normalizeCssColor.default)(input);

  if (normalizedColor === null || typeof normalizedColor !== 'number') {
    return input;
  }

  normalizedColor = normalizedColor || 0;
  var r = (normalizedColor & 0xff000000) >>> 24;
  var g = (normalizedColor & 0x00ff0000) >>> 16;
  var b = (normalizedColor & 0x0000ff00) >>> 8;
  var a = (normalizedColor & 0x000000ff) / 255;
  return "rgba(" + r + ", " + g + ", " + b + ", " + a + ")";
}

var stringShapeRegex = /[+-]?(?:\d+\.?\d*|\.\d+)(?:[eE][+-]?\d+)?/g;
/**
 * Supports string shapes by extracting numbers so new values can be computed,
 * and recombines those values into new strings of the same shape.  Supports
 * things like:
 *
 *   rgba(123, 42, 99, 0.36) // colors
 *   -45deg                  // values with units
 */

function createInterpolationFromStringOutputRange(config) {
  var outputRange = config.outputRange;
  (0, _invariant.default)(outputRange.length >= 2, 'Bad output range');
  outputRange = outputRange.map(colorToRgba);
  checkPattern(outputRange); // ['rgba(0, 100, 200, 0)', 'rgba(50, 150, 250, 0.5)']
  // ->
  // [
  //   [0, 50],
  //   [100, 150],
  //   [200, 250],
  //   [0, 0.5],
  // ]

  /* $FlowFixMe(>=0.18.0): `outputRange[0].match()` can return `null`. Need to
   * guard against this possibility.
   */

  var outputRanges = outputRange[0].match(stringShapeRegex).map(() => []);
  outputRange.forEach(value => {
    /* $FlowFixMe(>=0.18.0): `value.match()` can return `null`. Need to guard
     * against this possibility.
     */
    value.match(stringShapeRegex).forEach((number, i) => {
      outputRanges[i].push(+number);
    });
  });
  var interpolations = outputRange[0].match(stringShapeRegex)
  /* $FlowFixMe(>=0.18.0): `outputRange[0].match()` can return `null`. Need
   * to guard against this possibility. */
  .map((value, i) => {
    return createInterpolation((0, _objectSpread2.default)((0, _objectSpread2.default)({}, config), {}, {
      outputRange: outputRanges[i]
    }));
  }); // rgba requires that the r,g,b are integers.... so we want to round them, but we *dont* want to
  // round the opacity (4th column).

  var shouldRound = isRgbOrRgba(outputRange[0]);
  return input => {
    var i = 0; // 'rgba(0, 100, 200, 0)'
    // ->
    // 'rgba(${interpolations[0](input)}, ${interpolations[1](input)}, ...'

    return outputRange[0].replace(stringShapeRegex, () => {
      var val = +interpolations[i++](input);

      if (shouldRound) {
        val = i < 4 ? Math.round(val) : Math.round(val * 1000) / 1000;
      }

      return String(val);
    });
  };
}

function isRgbOrRgba(range) {
  return typeof range === 'string' && range.startsWith('rgb');
}

function checkPattern(arr) {
  var pattern = arr[0].replace(stringShapeRegex, '');

  for (var i = 1; i < arr.length; ++i) {
    (0, _invariant.default)(pattern === arr[i].replace(stringShapeRegex, ''), 'invalid pattern ' + arr[0] + ' and ' + arr[i]);
  }
}

function findRange(input, inputRange) {
  var i;

  for (i = 1; i < inputRange.length - 1; ++i) {
    if (inputRange[i] >= input) {
      break;
    }
  }

  return i - 1;
}

function checkValidInputRange(arr) {
  (0, _invariant.default)(arr.length >= 2, 'inputRange must have at least 2 elements');

  for (var i = 1; i < arr.length; ++i) {
    (0, _invariant.default)(arr[i] >= arr[i - 1],
    /* $FlowFixMe(>=0.13.0) - In the addition expression below this comment,
     * one or both of the operands may be something that doesn't cleanly
     * convert to a string, like undefined, null, and object, etc. If you really
     * mean this implicit string conversion, you can do something like
     * String(myThing)
     */
    'inputRange must be monotonically non-decreasing ' + arr);
  }
}

function checkInfiniteRange(name, arr) {
  (0, _invariant.default)(arr.length >= 2, name + ' must have at least 2 elements');
  (0, _invariant.default)(arr.length !== 2 || arr[0] !== -Infinity || arr[1] !== Infinity,
  /* $FlowFixMe(>=0.13.0) - In the addition expression below this comment,
   * one or both of the operands may be something that doesn't cleanly convert
   * to a string, like undefined, null, and object, etc. If you really mean
   * this implicit string conversion, you can do something like
   * String(myThing)
   */
  name + 'cannot be ]-infinity;+infinity[ ' + arr);
}

class AnimatedInterpolation extends _AnimatedWithChildren.default {
  // Export for testing.
  constructor(parent, config) {
    super();
    this._parent = parent;
    this._config = config;
    this._interpolation = createInterpolation(config);
  }

  __makeNative() {
    this._parent.__makeNative();

    super.__makeNative();
  }

  __getValue() {
    var parentValue = this._parent.__getValue();

    (0, _invariant.default)(typeof parentValue === 'number', 'Cannot interpolate an input which is not a number.');
    return this._interpolation(parentValue);
  }

  interpolate(config) {
    return new AnimatedInterpolation(this, config);
  }

  __attach() {
    this._parent.__addChild(this);
  }

  __detach() {
    this._parent.__removeChild(this);

    super.__detach();
  }

  __transformDataType(range) {
    return range.map(_NativeAnimatedHelper.default.transformDataType);
  }

  __getNativeConfig() {
    if (__DEV__) {
      _NativeAnimatedHelper.default.validateInterpolation(this._config);
    }

    return {
      inputRange: this._config.inputRange,
      // Only the `outputRange` can contain strings so we don't need to transform `inputRange` here

      /* $FlowFixMe(>=0.38.0) - Flow error detected during the deployment of
       * v0.38.0. To see the error, remove this comment and run flow */
      outputRange: this.__transformDataType(this._config.outputRange),
      extrapolateLeft: this._config.extrapolateLeft || this._config.extrapolate || 'extend',
      extrapolateRight: this._config.extrapolateRight || this._config.extrapolate || 'extend',
      type: 'interpolation'
    };
  }

}

AnimatedInterpolation.__createInterpolation = createInterpolation;
var _default = AnimatedInterpolation;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),

/***/ 30828:
/***/ ((module, exports, __webpack_require__) => {

"use strict";
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 */


var _interopRequireDefault = (__webpack_require__(64836)["default"]);

exports.__esModule = true;
exports["default"] = void 0;

var _AnimatedInterpolation = _interopRequireDefault(__webpack_require__(43411));

var _AnimatedNode = _interopRequireDefault(__webpack_require__(88227));

var _AnimatedWithChildren = _interopRequireDefault(__webpack_require__(34069));

class AnimatedModulo extends _AnimatedWithChildren.default {
  constructor(a, modulus) {
    super();
    this._a = a;
    this._modulus = modulus;
  }

  __makeNative() {
    this._a.__makeNative();

    super.__makeNative();
  }

  __getValue() {
    return (this._a.__getValue() % this._modulus + this._modulus) % this._modulus;
  }

  interpolate(config) {
    return new _AnimatedInterpolation.default(this, config);
  }

  __attach() {
    this._a.__addChild(this);
  }

  __detach() {
    this._a.__removeChild(this);

    super.__detach();
  }

  __getNativeConfig() {
    return {
      type: 'modulus',
      input: this._a.__getNativeTag(),
      modulus: this._modulus
    };
  }

}

var _default = AnimatedModulo;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),

/***/ 3849:
/***/ ((module, exports, __webpack_require__) => {

"use strict";
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 */


var _interopRequireDefault = (__webpack_require__(64836)["default"]);

exports.__esModule = true;
exports["default"] = void 0;

var _AnimatedInterpolation = _interopRequireDefault(__webpack_require__(43411));

var _AnimatedNode = _interopRequireDefault(__webpack_require__(88227));

var _AnimatedValue = _interopRequireDefault(__webpack_require__(84902));

var _AnimatedWithChildren = _interopRequireDefault(__webpack_require__(34069));

class AnimatedMultiplication extends _AnimatedWithChildren.default {
  constructor(a, b) {
    super();
    this._a = typeof a === 'number' ? new _AnimatedValue.default(a) : a;
    this._b = typeof b === 'number' ? new _AnimatedValue.default(b) : b;
  }

  __makeNative() {
    this._a.__makeNative();

    this._b.__makeNative();

    super.__makeNative();
  }

  __getValue() {
    return this._a.__getValue() * this._b.__getValue();
  }

  interpolate(config) {
    return new _AnimatedInterpolation.default(this, config);
  }

  __attach() {
    this._a.__addChild(this);

    this._b.__addChild(this);
  }

  __detach() {
    this._a.__removeChild(this);

    this._b.__removeChild(this);

    super.__detach();
  }

  __getNativeConfig() {
    return {
      type: 'multiplication',
      input: [this._a.__getNativeTag(), this._b.__getNativeTag()]
    };
  }

}

var _default = AnimatedMultiplication;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),

/***/ 88227:
/***/ ((module, exports, __webpack_require__) => {

"use strict";
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 */


var _interopRequireDefault = (__webpack_require__(64836)["default"]);

exports.__esModule = true;
exports["default"] = void 0;

var _NativeAnimatedHelper = _interopRequireDefault(__webpack_require__(20612));

var _invariant = _interopRequireDefault(__webpack_require__(44505));

var NativeAnimatedAPI = _NativeAnimatedHelper.default.API;
var _uniqueId = 1; // Note(vjeux): this would be better as an interface but flow doesn't
// support them yet

class AnimatedNode {
  __attach() {}

  __detach() {
    if (this.__isNative && this.__nativeTag != null) {
      _NativeAnimatedHelper.default.API.dropAnimatedNode(this.__nativeTag);

      this.__nativeTag = undefined;
    }
  }

  __getValue() {}

  __getAnimatedValue() {
    return this.__getValue();
  }

  __addChild(child) {}

  __removeChild(child) {}

  __getChildren() {
    return [];
  }
  /* Methods and props used by native Animated impl */


  constructor() {
    this._listeners = {};
  }

  __makeNative() {
    if (!this.__isNative) {
      throw new Error('This node cannot be made a "native" animated node');
    }

    if (this.hasListeners()) {
      this._startListeningToNativeValueUpdates();
    }
  }
  /**
   * Adds an asynchronous listener to the value so you can observe updates from
   * animations.  This is useful because there is no way to
   * synchronously read the value because it might be driven natively.
   *
   * See https://reactnative.dev/docs/animatedvalue.html#addlistener
   */


  addListener(callback) {
    var id = String(_uniqueId++);
    this._listeners[id] = callback;

    if (this.__isNative) {
      this._startListeningToNativeValueUpdates();
    }

    return id;
  }
  /**
   * Unregister a listener. The `id` param shall match the identifier
   * previously returned by `addListener()`.
   *
   * See https://reactnative.dev/docs/animatedvalue.html#removelistener
   */


  removeListener(id) {
    delete this._listeners[id];

    if (this.__isNative && !this.hasListeners()) {
      this._stopListeningForNativeValueUpdates();
    }
  }
  /**
   * Remove all registered listeners.
   *
   * See https://reactnative.dev/docs/animatedvalue.html#removealllisteners
   */


  removeAllListeners() {
    this._listeners = {};

    if (this.__isNative) {
      this._stopListeningForNativeValueUpdates();
    }
  }

  hasListeners() {
    return !!Object.keys(this._listeners).length;
  }

  _startListeningToNativeValueUpdates() {
    if (this.__nativeAnimatedValueListener && !this.__shouldUpdateListenersForNewNativeTag) {
      return;
    }

    if (this.__shouldUpdateListenersForNewNativeTag) {
      this.__shouldUpdateListenersForNewNativeTag = false;

      this._stopListeningForNativeValueUpdates();
    }

    NativeAnimatedAPI.startListeningToAnimatedNodeValue(this.__getNativeTag());
    this.__nativeAnimatedValueListener = _NativeAnimatedHelper.default.nativeEventEmitter.addListener('onAnimatedValueUpdate', data => {
      if (data.tag !== this.__getNativeTag()) {
        return;
      }

      this._onAnimatedValueUpdateReceived(data.value);
    });
  }

  _onAnimatedValueUpdateReceived(value) {
    this.__callListeners(value);
  }

  __callListeners(value) {
    for (var _key in this._listeners) {
      this._listeners[_key]({
        value
      });
    }
  }

  _stopListeningForNativeValueUpdates() {
    if (!this.__nativeAnimatedValueListener) {
      return;
    }

    this.__nativeAnimatedValueListener.remove();

    this.__nativeAnimatedValueListener = null;
    NativeAnimatedAPI.stopListeningToAnimatedNodeValue(this.__getNativeTag());
  }

  __getNativeTag() {
    var _this$__nativeTag;

    _NativeAnimatedHelper.default.assertNativeAnimatedModule();

    (0, _invariant.default)(this.__isNative, 'Attempt to get native tag from node not marked as "native"');
    var nativeTag = (_this$__nativeTag = this.__nativeTag) !== null && _this$__nativeTag !== void 0 ? _this$__nativeTag : _NativeAnimatedHelper.default.generateNewNodeTag();

    if (this.__nativeTag == null) {
      this.__nativeTag = nativeTag;

      _NativeAnimatedHelper.default.API.createAnimatedNode(nativeTag, this.__getNativeConfig());

      this.__shouldUpdateListenersForNewNativeTag = true;
    }

    return nativeTag;
  }

  __getNativeConfig() {
    throw new Error('This JS animated node type cannot be used as native animated node');
  }

  toJSON() {
    return this.__getValue();
  }

}

var _default = AnimatedNode;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),

/***/ 33510:
/***/ ((module, exports, __webpack_require__) => {

"use strict";
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 */


var _interopRequireDefault = (__webpack_require__(64836)["default"]);

exports.__esModule = true;
exports["default"] = void 0;

var _objectSpread2 = _interopRequireDefault(__webpack_require__(42122));

var _AnimatedEvent = __webpack_require__(15673);

var _AnimatedNode = _interopRequireDefault(__webpack_require__(88227));

var _AnimatedStyle = _interopRequireDefault(__webpack_require__(59439));

var _NativeAnimatedHelper = _interopRequireDefault(__webpack_require__(20612));

var _findNodeHandle = _interopRequireDefault(__webpack_require__(10530));

var _invariant = _interopRequireDefault(__webpack_require__(44505));

class AnimatedProps extends _AnimatedNode.default {
  constructor(props, callback) {
    super();

    if (props.style) {
      props = (0, _objectSpread2.default)((0, _objectSpread2.default)({}, props), {}, {
        style: new _AnimatedStyle.default(props.style)
      });
    }

    this._props = props;
    this._callback = callback;

    this.__attach();
  }

  __getValue() {
    var props = {};

    for (var key in this._props) {
      var value = this._props[key];

      if (value instanceof _AnimatedNode.default) {
        if (!value.__isNative || value instanceof _AnimatedStyle.default) {
          // We cannot use value of natively driven nodes this way as the value we have access from
          // JS may not be up to date.
          props[key] = value.__getValue();
        }
      } else if (value instanceof _AnimatedEvent.AnimatedEvent) {
        props[key] = value.__getHandler();
      } else {
        props[key] = value;
      }
    }

    return props;
  }

  __getAnimatedValue() {
    var props = {};

    for (var key in this._props) {
      var value = this._props[key];

      if (value instanceof _AnimatedNode.default) {
        props[key] = value.__getAnimatedValue();
      }
    }

    return props;
  }

  __attach() {
    for (var key in this._props) {
      var value = this._props[key];

      if (value instanceof _AnimatedNode.default) {
        value.__addChild(this);
      }
    }
  }

  __detach() {
    if (this.__isNative && this._animatedView) {
      this.__disconnectAnimatedView();
    }

    for (var key in this._props) {
      var value = this._props[key];

      if (value instanceof _AnimatedNode.default) {
        value.__removeChild(this);
      }
    }

    super.__detach();
  }

  update() {
    this._callback();
  }

  __makeNative() {
    if (!this.__isNative) {
      this.__isNative = true;

      for (var key in this._props) {
        var value = this._props[key];

        if (value instanceof _AnimatedNode.default) {
          value.__makeNative();
        }
      }

      if (this._animatedView) {
        this.__connectAnimatedView();
      }
    }
  }

  setNativeView(animatedView) {
    if (this._animatedView === animatedView) {
      return;
    }

    this._animatedView = animatedView;

    if (this.__isNative) {
      this.__connectAnimatedView();
    }
  }

  __connectAnimatedView() {
    (0, _invariant.default)(this.__isNative, 'Expected node to be marked as "native"');
    var nativeViewTag = (0, _findNodeHandle.default)(this._animatedView);
    (0, _invariant.default)(nativeViewTag != null, 'Unable to locate attached view in the native tree');

    _NativeAnimatedHelper.default.API.connectAnimatedNodeToView(this.__getNativeTag(), nativeViewTag);
  }

  __disconnectAnimatedView() {
    (0, _invariant.default)(this.__isNative, 'Expected node to be marked as "native"');
    var nativeViewTag = (0, _findNodeHandle.default)(this._animatedView);
    (0, _invariant.default)(nativeViewTag != null, 'Unable to locate attached view in the native tree');

    _NativeAnimatedHelper.default.API.disconnectAnimatedNodeFromView(this.__getNativeTag(), nativeViewTag);
  }

  __restoreDefaultValues() {
    // When using the native driver, view properties need to be restored to
    // their default values manually since react no longer tracks them. This
    // is needed to handle cases where a prop driven by native animated is removed
    // after having been changed natively by an animation.
    if (this.__isNative) {
      _NativeAnimatedHelper.default.API.restoreDefaultValues(this.__getNativeTag());
    }
  }

  __getNativeConfig() {
    var propsConfig = {};

    for (var propKey in this._props) {
      var value = this._props[propKey];

      if (value instanceof _AnimatedNode.default) {
        value.__makeNative();

        propsConfig[propKey] = value.__getNativeTag();
      }
    }

    return {
      type: 'props',
      props: propsConfig
    };
  }

}

var _default = AnimatedProps;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),

/***/ 59439:
/***/ ((module, exports, __webpack_require__) => {

"use strict";
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 */


var _interopRequireDefault = (__webpack_require__(64836)["default"]);

exports.__esModule = true;
exports["default"] = void 0;

var _objectSpread2 = _interopRequireDefault(__webpack_require__(42122));

var _AnimatedNode = _interopRequireDefault(__webpack_require__(88227));

var _AnimatedTransform = _interopRequireDefault(__webpack_require__(50220));

var _AnimatedWithChildren = _interopRequireDefault(__webpack_require__(34069));

var _NativeAnimatedHelper = _interopRequireDefault(__webpack_require__(20612));

var _StyleSheet = _interopRequireDefault(__webpack_require__(84099));

var flattenStyle = _StyleSheet.default.flatten;

class AnimatedStyle extends _AnimatedWithChildren.default {
  constructor(style) {
    super();
    style = flattenStyle(style) || {};

    if (style.transform) {
      style = (0, _objectSpread2.default)((0, _objectSpread2.default)({}, style), {}, {
        transform: new _AnimatedTransform.default(style.transform)
      });
    }

    this._style = style;
  } // Recursively get values for nested styles (like iOS's shadowOffset)


  _walkStyleAndGetValues(style) {
    var updatedStyle = {};

    for (var key in style) {
      var value = style[key];

      if (value instanceof _AnimatedNode.default) {
        if (!value.__isNative) {
          // We cannot use value of natively driven nodes this way as the value we have access from
          // JS may not be up to date.
          updatedStyle[key] = value.__getValue();
        }
      } else if (value && !Array.isArray(value) && typeof value === 'object') {
        // Support animating nested values (for example: shadowOffset.height)
        updatedStyle[key] = this._walkStyleAndGetValues(value);
      } else {
        updatedStyle[key] = value;
      }
    }

    return updatedStyle;
  }

  __getValue() {
    return this._walkStyleAndGetValues(this._style);
  } // Recursively get animated values for nested styles (like iOS's shadowOffset)


  _walkStyleAndGetAnimatedValues(style) {
    var updatedStyle = {};

    for (var key in style) {
      var value = style[key];

      if (value instanceof _AnimatedNode.default) {
        updatedStyle[key] = value.__getAnimatedValue();
      } else if (value && !Array.isArray(value) && typeof value === 'object') {
        // Support animating nested values (for example: shadowOffset.height)
        updatedStyle[key] = this._walkStyleAndGetAnimatedValues(value);
      }
    }

    return updatedStyle;
  }

  __getAnimatedValue() {
    return this._walkStyleAndGetAnimatedValues(this._style);
  }

  __attach() {
    for (var key in this._style) {
      var value = this._style[key];

      if (value instanceof _AnimatedNode.default) {
        value.__addChild(this);
      }
    }
  }

  __detach() {
    for (var key in this._style) {
      var value = this._style[key];

      if (value instanceof _AnimatedNode.default) {
        value.__removeChild(this);
      }
    }

    super.__detach();
  }

  __makeNative() {
    for (var key in this._style) {
      var value = this._style[key];

      if (value instanceof _AnimatedNode.default) {
        value.__makeNative();
      }
    }

    super.__makeNative();
  }

  __getNativeConfig() {
    var styleConfig = {};

    for (var styleKey in this._style) {
      if (this._style[styleKey] instanceof _AnimatedNode.default) {
        var style = this._style[styleKey];

        style.__makeNative();

        styleConfig[styleKey] = style.__getNativeTag();
      } // Non-animated styles are set using `setNativeProps`, no need
      // to pass those as a part of the node config

    }

    _NativeAnimatedHelper.default.validateStyles(styleConfig);

    return {
      type: 'style',
      style: styleConfig
    };
  }

}

var _default = AnimatedStyle;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),

/***/ 33466:
/***/ ((module, exports, __webpack_require__) => {

"use strict";
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 */


var _interopRequireDefault = (__webpack_require__(64836)["default"]);

exports.__esModule = true;
exports["default"] = void 0;

var _AnimatedInterpolation = _interopRequireDefault(__webpack_require__(43411));

var _AnimatedNode = _interopRequireDefault(__webpack_require__(88227));

var _AnimatedValue = _interopRequireDefault(__webpack_require__(84902));

var _AnimatedWithChildren = _interopRequireDefault(__webpack_require__(34069));

class AnimatedSubtraction extends _AnimatedWithChildren.default {
  constructor(a, b) {
    super();
    this._a = typeof a === 'number' ? new _AnimatedValue.default(a) : a;
    this._b = typeof b === 'number' ? new _AnimatedValue.default(b) : b;
  }

  __makeNative() {
    this._a.__makeNative();

    this._b.__makeNative();

    super.__makeNative();
  }

  __getValue() {
    return this._a.__getValue() - this._b.__getValue();
  }

  interpolate(config) {
    return new _AnimatedInterpolation.default(this, config);
  }

  __attach() {
    this._a.__addChild(this);

    this._b.__addChild(this);
  }

  __detach() {
    this._a.__removeChild(this);

    this._b.__removeChild(this);

    super.__detach();
  }

  __getNativeConfig() {
    return {
      type: 'subtraction',
      input: [this._a.__getNativeTag(), this._b.__getNativeTag()]
    };
  }

}

var _default = AnimatedSubtraction;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),

/***/ 25198:
/***/ ((module, exports, __webpack_require__) => {

"use strict";
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 */


var _interopRequireDefault = (__webpack_require__(64836)["default"]);

exports.__esModule = true;
exports["default"] = void 0;

var _objectSpread2 = _interopRequireDefault(__webpack_require__(42122));

var _AnimatedValue = _interopRequireDefault(__webpack_require__(84902));

var _AnimatedNode = _interopRequireDefault(__webpack_require__(88227));

var _NativeAnimatedHelper = __webpack_require__(20612);

class AnimatedTracking extends _AnimatedNode.default {
  constructor(value, parent, animationClass, animationConfig, callback) {
    super();
    this._value = value;
    this._parent = parent;
    this._animationClass = animationClass;
    this._animationConfig = animationConfig;
    this._useNativeDriver = (0, _NativeAnimatedHelper.shouldUseNativeDriver)(animationConfig);
    this._callback = callback;

    this.__attach();
  }

  __makeNative() {
    this.__isNative = true;

    this._parent.__makeNative();

    super.__makeNative();

    this._value.__makeNative();
  }

  __getValue() {
    return this._parent.__getValue();
  }

  __attach() {
    this._parent.__addChild(this);

    if (this._useNativeDriver) {
      // when the tracking starts we need to convert this node to a "native node"
      // so that the parent node will be made "native" too. This is necessary as
      // if we don't do this `update` method will get called. At that point it
      // may be too late as it would mean the JS driver has already started
      // updating node values
      this.__makeNative();
    }
  }

  __detach() {
    this._parent.__removeChild(this);

    super.__detach();
  }

  update() {
    this._value.animate(new this._animationClass((0, _objectSpread2.default)((0, _objectSpread2.default)({}, this._animationConfig), {}, {
      toValue: this._animationConfig.toValue.__getValue()
    })), this._callback);
  }

  __getNativeConfig() {
    var animation = new this._animationClass((0, _objectSpread2.default)((0, _objectSpread2.default)({}, this._animationConfig), {}, {
      // remove toValue from the config as it's a ref to Animated.Value
      toValue: undefined
    }));

    var animationConfig = animation.__getNativeAnimationConfig();

    return {
      type: 'tracking',
      animationId: (0, _NativeAnimatedHelper.generateNewAnimationId)(),
      animationConfig,
      toValue: this._parent.__getNativeTag(),
      value: this._value.__getNativeTag()
    };
  }

}

var _default = AnimatedTracking;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),

/***/ 50220:
/***/ ((module, exports, __webpack_require__) => {

"use strict";
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 */


var _interopRequireDefault = (__webpack_require__(64836)["default"]);

exports.__esModule = true;
exports["default"] = void 0;

var _AnimatedNode = _interopRequireDefault(__webpack_require__(88227));

var _AnimatedWithChildren = _interopRequireDefault(__webpack_require__(34069));

var _NativeAnimatedHelper = _interopRequireDefault(__webpack_require__(20612));

class AnimatedTransform extends _AnimatedWithChildren.default {
  constructor(transforms) {
    super();
    this._transforms = transforms;
  }

  __makeNative() {
    this._transforms.forEach(transform => {
      for (var key in transform) {
        var value = transform[key];

        if (value instanceof _AnimatedNode.default) {
          value.__makeNative();
        }
      }
    });

    super.__makeNative();
  }

  __getValue() {
    return this._transforms.map(transform => {
      var result = {};

      for (var key in transform) {
        var value = transform[key];

        if (value instanceof _AnimatedNode.default) {
          result[key] = value.__getValue();
        } else {
          result[key] = value;
        }
      }

      return result;
    });
  }

  __getAnimatedValue() {
    return this._transforms.map(transform => {
      var result = {};

      for (var key in transform) {
        var value = transform[key];

        if (value instanceof _AnimatedNode.default) {
          result[key] = value.__getAnimatedValue();
        } else {
          // All transform components needed to recompose matrix
          result[key] = value;
        }
      }

      return result;
    });
  }

  __attach() {
    this._transforms.forEach(transform => {
      for (var key in transform) {
        var value = transform[key];

        if (value instanceof _AnimatedNode.default) {
          value.__addChild(this);
        }
      }
    });
  }

  __detach() {
    this._transforms.forEach(transform => {
      for (var key in transform) {
        var value = transform[key];

        if (value instanceof _AnimatedNode.default) {
          value.__removeChild(this);
        }
      }
    });

    super.__detach();
  }

  __getNativeConfig() {
    var transConfigs = [];

    this._transforms.forEach(transform => {
      for (var key in transform) {
        var value = transform[key];

        if (value instanceof _AnimatedNode.default) {
          transConfigs.push({
            type: 'animated',
            property: key,
            nodeTag: value.__getNativeTag()
          });
        } else {
          transConfigs.push({
            type: 'static',
            property: key,
            value: _NativeAnimatedHelper.default.transformDataType(value)
          });
        }
      }
    });

    _NativeAnimatedHelper.default.validateTransform(transConfigs);

    return {
      type: 'transform',
      transforms: transConfigs
    };
  }

}

var _default = AnimatedTransform;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),

/***/ 84902:
/***/ ((module, exports, __webpack_require__) => {

"use strict";
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 */


var _interopRequireDefault = (__webpack_require__(64836)["default"]);

exports.__esModule = true;
exports["default"] = void 0;

var _AnimatedInterpolation = _interopRequireDefault(__webpack_require__(43411));

var _AnimatedWithChildren = _interopRequireDefault(__webpack_require__(34069));

var _InteractionManager = _interopRequireDefault(__webpack_require__(91195));

var _NativeAnimatedHelper = _interopRequireDefault(__webpack_require__(20612));

var NativeAnimatedAPI = _NativeAnimatedHelper.default.API;
/**
 * Animated works by building a directed acyclic graph of dependencies
 * transparently when you render your Animated components.
 *
 *               new Animated.Value(0)
 *     .interpolate()        .interpolate()    new Animated.Value(1)
 *         opacity               translateY      scale
 *          style                         transform
 *         View#234                         style
 *                                         View#123
 *
 * A) Top Down phase
 * When an Animated.Value is updated, we recursively go down through this
 * graph in order to find leaf nodes: the views that we flag as needing
 * an update.
 *
 * B) Bottom Up phase
 * When a view is flagged as needing an update, we recursively go back up
 * in order to build the new value that it needs. The reason why we need
 * this two-phases process is to deal with composite props such as
 * transform which can receive values from multiple parents.
 */

function _flush(rootNode) {
  var animatedStyles = new Set();

  function findAnimatedStyles(node) {
    /* $FlowFixMe(>=0.68.0 site=react_native_fb) This comment suppresses an
     * error found when Flow v0.68 was deployed. To see the error delete this
     * comment and run Flow. */
    if (typeof node.update === 'function') {
      animatedStyles.add(node);
    } else {
      node.__getChildren().forEach(findAnimatedStyles);
    }
  }

  findAnimatedStyles(rootNode);
  /* $FlowFixMe */

  animatedStyles.forEach(animatedStyle => animatedStyle.update());
}
/**
 * Standard value for driving animations.  One `Animated.Value` can drive
 * multiple properties in a synchronized fashion, but can only be driven by one
 * mechanism at a time.  Using a new mechanism (e.g. starting a new animation,
 * or calling `setValue`) will stop any previous ones.
 *
 * See https://reactnative.dev/docs/animatedvalue.html
 */


class AnimatedValue extends _AnimatedWithChildren.default {
  constructor(value) {
    super();

    if (typeof value !== 'number') {
      throw new Error('AnimatedValue: Attempting to set value to undefined');
    }

    this._startingValue = this._value = value;
    this._offset = 0;
    this._animation = null;
  }

  __detach() {
    if (this.__isNative) {
      NativeAnimatedAPI.getValue(this.__getNativeTag(), value => {
        this._value = value;
      });
    }

    this.stopAnimation();

    super.__detach();
  }

  __getValue() {
    return this._value + this._offset;
  }
  /**
   * Directly set the value.  This will stop any animations running on the value
   * and update all the bound properties.
   *
   * See https://reactnative.dev/docs/animatedvalue.html#setvalue
   */


  setValue(value) {
    if (this._animation) {
      this._animation.stop();

      this._animation = null;
    }

    this._updateValue(value, !this.__isNative
    /* don't perform a flush for natively driven values */
    );

    if (this.__isNative) {
      NativeAnimatedAPI.setAnimatedNodeValue(this.__getNativeTag(), value);
    }
  }
  /**
   * Sets an offset that is applied on top of whatever value is set, whether via
   * `setValue`, an animation, or `Animated.event`.  Useful for compensating
   * things like the start of a pan gesture.
   *
   * See https://reactnative.dev/docs/animatedvalue.html#setoffset
   */


  setOffset(offset) {
    this._offset = offset;

    if (this.__isNative) {
      NativeAnimatedAPI.setAnimatedNodeOffset(this.__getNativeTag(), offset);
    }
  }
  /**
   * Merges the offset value into the base value and resets the offset to zero.
   * The final output of the value is unchanged.
   *
   * See https://reactnative.dev/docs/animatedvalue.html#flattenoffset
   */


  flattenOffset() {
    this._value += this._offset;
    this._offset = 0;

    if (this.__isNative) {
      NativeAnimatedAPI.flattenAnimatedNodeOffset(this.__getNativeTag());
    }
  }
  /**
   * Sets the offset value to the base value, and resets the base value to zero.
   * The final output of the value is unchanged.
   *
   * See https://reactnative.dev/docs/animatedvalue.html#extractoffset
   */


  extractOffset() {
    this._offset += this._value;
    this._value = 0;

    if (this.__isNative) {
      NativeAnimatedAPI.extractAnimatedNodeOffset(this.__getNativeTag());
    }
  }
  /**
   * Stops any running animation or tracking. `callback` is invoked with the
   * final value after stopping the animation, which is useful for updating
   * state to match the animation position with layout.
   *
   * See https://reactnative.dev/docs/animatedvalue.html#stopanimation
   */


  stopAnimation(callback) {
    this.stopTracking();
    this._animation && this._animation.stop();
    this._animation = null;
    callback && callback(this.__getValue());
  }
  /**
   * Stops any animation and resets the value to its original.
   *
   * See https://reactnative.dev/docs/animatedvalue.html#resetanimation
   */


  resetAnimation(callback) {
    this.stopAnimation(callback);
    this._value = this._startingValue;
  }

  _onAnimatedValueUpdateReceived(value) {
    this._updateValue(value, false
    /*flush*/
    );
  }
  /**
   * Interpolates the value before updating the property, e.g. mapping 0-1 to
   * 0-10.
   */


  interpolate(config) {
    return new _AnimatedInterpolation.default(this, config);
  }
  /**
   * Typically only used internally, but could be used by a custom Animation
   * class.
   *
   * See https://reactnative.dev/docs/animatedvalue.html#animate
   */


  animate(animation, callback) {
    var handle = null;

    if (animation.__isInteraction) {
      handle = _InteractionManager.default.createInteractionHandle();
    }

    var previousAnimation = this._animation;
    this._animation && this._animation.stop();
    this._animation = animation;
    animation.start(this._value, value => {
      // Natively driven animations will never call into that callback, therefore we can always
      // pass flush = true to allow the updated value to propagate to native with setNativeProps
      this._updateValue(value, true
      /* flush */
      );
    }, result => {
      this._animation = null;

      if (handle !== null) {
        _InteractionManager.default.clearInteractionHandle(handle);
      }

      callback && callback(result);
    }, previousAnimation, this);
  }
  /**
   * Typically only used internally.
   */


  stopTracking() {
    this._tracking && this._tracking.__detach();
    this._tracking = null;
  }
  /**
   * Typically only used internally.
   */


  track(tracking) {
    this.stopTracking();
    this._tracking = tracking;
  }

  _updateValue(value, flush) {
    if (value === undefined) {
      throw new Error('AnimatedValue: Attempting to set value to undefined');
    }

    this._value = value;

    if (flush) {
      _flush(this);
    }

    super.__callListeners(this.__getValue());
  }

  __getNativeConfig() {
    return {
      type: 'value',
      value: this._value,
      offset: this._offset
    };
  }

}

var _default = AnimatedValue;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),

/***/ 38914:
/***/ ((module, exports, __webpack_require__) => {

"use strict";
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 */


var _interopRequireDefault = (__webpack_require__(64836)["default"]);

exports.__esModule = true;
exports["default"] = void 0;

var _AnimatedValue = _interopRequireDefault(__webpack_require__(84902));

var _AnimatedWithChildren = _interopRequireDefault(__webpack_require__(34069));

var _invariant = _interopRequireDefault(__webpack_require__(44505));

var _uniqueId = 1;
/**
 * 2D Value for driving 2D animations, such as pan gestures. Almost identical
 * API to normal `Animated.Value`, but multiplexed.
 *
 * See https://reactnative.dev/docs/animatedvaluexy.html
 */

class AnimatedValueXY extends _AnimatedWithChildren.default {
  constructor(valueIn) {
    super();
    var value = valueIn || {
      x: 0,
      y: 0
    }; // fixme: shouldn't need `: any`

    if (typeof value.x === 'number' && typeof value.y === 'number') {
      this.x = new _AnimatedValue.default(value.x);
      this.y = new _AnimatedValue.default(value.y);
    } else {
      (0, _invariant.default)(value.x instanceof _AnimatedValue.default && value.y instanceof _AnimatedValue.default, 'AnimatedValueXY must be initialized with an object of numbers or ' + 'AnimatedValues.');
      this.x = value.x;
      this.y = value.y;
    }

    this._listeners = {};
  }
  /**
   * Directly set the value. This will stop any animations running on the value
   * and update all the bound properties.
   *
   * See https://reactnative.dev/docs/animatedvaluexy.html#setvalue
   */


  setValue(value) {
    this.x.setValue(value.x);
    this.y.setValue(value.y);
  }
  /**
   * Sets an offset that is applied on top of whatever value is set, whether
   * via `setValue`, an animation, or `Animated.event`. Useful for compensating
   * things like the start of a pan gesture.
   *
   * See https://reactnative.dev/docs/animatedvaluexy.html#setoffset
   */


  setOffset(offset) {
    this.x.setOffset(offset.x);
    this.y.setOffset(offset.y);
  }
  /**
   * Merges the offset value into the base value and resets the offset to zero.
   * The final output of the value is unchanged.
   *
   * See https://reactnative.dev/docs/animatedvaluexy.html#flattenoffset
   */


  flattenOffset() {
    this.x.flattenOffset();
    this.y.flattenOffset();
  }
  /**
   * Sets the offset value to the base value, and resets the base value to
   * zero. The final output of the value is unchanged.
   *
   * See https://reactnative.dev/docs/animatedvaluexy.html#extractoffset
   */


  extractOffset() {
    this.x.extractOffset();
    this.y.extractOffset();
  }

  __getValue() {
    return {
      x: this.x.__getValue(),
      y: this.y.__getValue()
    };
  }
  /**
   * Stops any animation and resets the value to its original.
   *
   * See https://reactnative.dev/docs/animatedvaluexy.html#resetanimation
   */


  resetAnimation(callback) {
    this.x.resetAnimation();
    this.y.resetAnimation();
    callback && callback(this.__getValue());
  }
  /**
   * Stops any running animation or tracking. `callback` is invoked with the
   * final value after stopping the animation, which is useful for updating
   * state to match the animation position with layout.
   *
   * See https://reactnative.dev/docs/animatedvaluexy.html#stopanimation
   */


  stopAnimation(callback) {
    this.x.stopAnimation();
    this.y.stopAnimation();
    callback && callback(this.__getValue());
  }
  /**
   * Adds an asynchronous listener to the value so you can observe updates from
   * animations.  This is useful because there is no way to synchronously read
   * the value because it might be driven natively.
   *
   * Returns a string that serves as an identifier for the listener.
   *
   * See https://reactnative.dev/docs/animatedvaluexy.html#addlistener
   */


  addListener(callback) {
    var id = String(_uniqueId++);

    var jointCallback = _ref => {
      var number = _ref.value;
      callback(this.__getValue());
    };

    this._listeners[id] = {
      x: this.x.addListener(jointCallback),
      y: this.y.addListener(jointCallback)
    };
    return id;
  }
  /**
   * Unregister a listener. The `id` param shall match the identifier
   * previously returned by `addListener()`.
   *
   * See https://reactnative.dev/docs/animatedvaluexy.html#removelistener
   */


  removeListener(id) {
    this.x.removeListener(this._listeners[id].x);
    this.y.removeListener(this._listeners[id].y);
    delete this._listeners[id];
  }
  /**
   * Remove all registered listeners.
   *
   * See https://reactnative.dev/docs/animatedvaluexy.html#removealllisteners
   */


  removeAllListeners() {
    this.x.removeAllListeners();
    this.y.removeAllListeners();
    this._listeners = {};
  }
  /**
   * Converts `{x, y}` into `{left, top}` for use in style.
   *
   * See https://reactnative.dev/docs/animatedvaluexy.html#getlayout
   */


  getLayout() {
    return {
      left: this.x,
      top: this.y
    };
  }
  /**
   * Converts `{x, y}` into a useable translation transform.
   *
   * See https://reactnative.dev/docs/animatedvaluexy.html#gettranslatetransform
   */


  getTranslateTransform() {
    return [{
      translateX: this.x
    }, {
      translateY: this.y
    }];
  }

}

var _default = AnimatedValueXY;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),

/***/ 34069:
/***/ ((module, exports, __webpack_require__) => {

"use strict";
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 */


var _interopRequireDefault = (__webpack_require__(64836)["default"]);

exports.__esModule = true;
exports["default"] = void 0;

var _createForOfIteratorHelperLoose2 = _interopRequireDefault(__webpack_require__(92535));

var _AnimatedNode = _interopRequireDefault(__webpack_require__(88227));

var _NativeAnimatedHelper = _interopRequireDefault(__webpack_require__(20612));

class AnimatedWithChildren extends _AnimatedNode.default {
  constructor() {
    super();
    this._children = [];
  }

  __makeNative() {
    if (!this.__isNative) {
      this.__isNative = true;

      for (var _iterator = (0, _createForOfIteratorHelperLoose2.default)(this._children), _step; !(_step = _iterator()).done;) {
        var child = _step.value;

        child.__makeNative();

        _NativeAnimatedHelper.default.API.connectAnimatedNodes(this.__getNativeTag(), child.__getNativeTag());
      }
    }

    super.__makeNative();
  }

  __addChild(child) {
    if (this._children.length === 0) {
      this.__attach();
    }

    this._children.push(child);

    if (this.__isNative) {
      // Only accept "native" animated nodes as children
      child.__makeNative();

      _NativeAnimatedHelper.default.API.connectAnimatedNodes(this.__getNativeTag(), child.__getNativeTag());
    }
  }

  __removeChild(child) {
    var index = this._children.indexOf(child);

    if (index === -1) {
      console.warn("Trying to remove a child that doesn't exist");
      return;
    }

    if (this.__isNative && child.__isNative) {
      _NativeAnimatedHelper.default.API.disconnectAnimatedNodes(this.__getNativeTag(), child.__getNativeTag());
    }

    this._children.splice(index, 1);

    if (this._children.length === 0) {
      this.__detach();
    }
  }

  __getChildren() {
    return this._children;
  }

  __callListeners(value) {
    super.__callListeners(value);

    if (!this.__isNative) {
      for (var _iterator2 = (0, _createForOfIteratorHelperLoose2.default)(this._children), _step2; !(_step2 = _iterator2()).done;) {
        var child = _step2.value;

        if (child.__getValue) {
          child.__callListeners(child.__getValue());
        }
      }
    }
  }

}

var _default = AnimatedWithChildren;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),

/***/ 96365:
/***/ ((module, exports, __webpack_require__) => {

"use strict";
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @format
 * 
 */


var _interopRequireDefault = (__webpack_require__(64836)["default"]);

exports.__esModule = true;
exports["default"] = void 0;

var _InteractionManager = _interopRequireDefault(__webpack_require__(91195));

/**
 * A simple class for batching up invocations of a low-pri callback. A timeout is set to run the
 * callback once after a delay, no matter how many times it's scheduled. Once the delay is reached,
 * InteractionManager.runAfterInteractions is used to invoke the callback after any hi-pri
 * interactions are done running.
 *
 * Make sure to cleanup with dispose().  Example:
 *
 *   class Widget extends React.Component {
 *     _batchedSave: new Batchinator(() => this._saveState, 1000);
 *     _saveSate() {
 *       // save this.state to disk
 *     }
 *     componentDidUpdate() {
 *       this._batchedSave.schedule();
 *     }
 *     componentWillUnmount() {
 *       this._batchedSave.dispose();
 *     }
 *     ...
 *   }
 */
class Batchinator {
  constructor(callback, delayMS) {
    this._delay = delayMS;
    this._callback = callback;
  }
  /*
   * Cleanup any pending tasks.
   *
   * By default, if there is a pending task the callback is run immediately. Set the option abort to
   * true to not call the callback if it was pending.
   */


  dispose(options) {
    if (options === void 0) {
      options = {
        abort: false
      };
    }

    if (this._taskHandle) {
      this._taskHandle.cancel();

      if (!options.abort) {
        this._callback();
      }

      this._taskHandle = null;
    }
  }

  schedule() {
    if (this._taskHandle) {
      return;
    }

    var timeoutHandle = setTimeout(() => {
      this._taskHandle = _InteractionManager.default.runAfterInteractions(() => {
        // Note that we clear the handle before invoking the callback so that if the callback calls
        // schedule again, it will actually schedule another task.
        this._taskHandle = null;

        this._callback();
      });
    }, this._delay);
    this._taskHandle = {
      cancel: () => clearTimeout(timeoutHandle)
    };
  }

}

var _default = Batchinator;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),

/***/ 41505:
/***/ ((module, exports, __webpack_require__) => {

"use strict";
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 */


var _interopRequireDefault = (__webpack_require__(64836)["default"]);

exports.__esModule = true;
exports["default"] = void 0;

var _objectSpread2 = _interopRequireDefault(__webpack_require__(42122));

class Info {
  constructor() {
    this.any_blank_count = 0;
    this.any_blank_ms = 0;
    this.any_blank_speed_sum = 0;
    this.mostly_blank_count = 0;
    this.mostly_blank_ms = 0;
    this.pixels_blank = 0;
    this.pixels_sampled = 0;
    this.pixels_scrolled = 0;
    this.total_time_spent = 0;
    this.sample_count = 0;
  }

}

var DEBUG = false;
var _listeners = [];
var _minSampleCount = 10;

var _sampleRate = DEBUG ? 1 : null;
/**
 * A helper class for detecting when the maximem fill rate of `VirtualizedList` is exceeded.
 * By default the sampling rate is set to zero and this will do nothing. If you want to collect
 * samples (e.g. to log them), make sure to call `FillRateHelper.setSampleRate(0.0-1.0)`.
 *
 * Listeners and sample rate are global for all `VirtualizedList`s - typical usage will combine with
 * `SceneTracker.getActiveScene` to determine the context of the events.
 */


class FillRateHelper {
  static addListener(callback) {
    if (_sampleRate === null) {
      console.warn('Call `FillRateHelper.setSampleRate` before `addListener`.');
    }

    _listeners.push(callback);

    return {
      remove: () => {
        _listeners = _listeners.filter(listener => callback !== listener);
      }
    };
  }

  static setSampleRate(sampleRate) {
    _sampleRate = sampleRate;
  }

  static setMinSampleCount(minSampleCount) {
    _minSampleCount = minSampleCount;
  }

  constructor(getFrameMetrics) {
    this._anyBlankStartTime = null;
    this._enabled = false;
    this._info = new Info();
    this._mostlyBlankStartTime = null;
    this._samplesStartTime = null;
    this._getFrameMetrics = getFrameMetrics;
    this._enabled = (_sampleRate || 0) > Math.random();

    this._resetData();
  }

  activate() {
    if (this._enabled && this._samplesStartTime == null) {
      DEBUG && console.debug('FillRateHelper: activate');
      this._samplesStartTime = global.performance.now();
    }
  }

  deactivateAndFlush() {
    if (!this._enabled) {
      return;
    }

    var start = this._samplesStartTime; // const for flow

    if (start == null) {
      DEBUG && console.debug('FillRateHelper: bail on deactivate with no start time');
      return;
    }

    if (this._info.sample_count < _minSampleCount) {
      // Don't bother with under-sampled events.
      this._resetData();

      return;
    }

    var total_time_spent = global.performance.now() - start;
    var info = (0, _objectSpread2.default)((0, _objectSpread2.default)({}, this._info), {}, {
      total_time_spent
    });

    if (DEBUG) {
      var derived = {
        avg_blankness: this._info.pixels_blank / this._info.pixels_sampled,
        avg_speed: this._info.pixels_scrolled / (total_time_spent / 1000),
        avg_speed_when_any_blank: this._info.any_blank_speed_sum / this._info.any_blank_count,
        any_blank_per_min: this._info.any_blank_count / (total_time_spent / 1000 / 60),
        any_blank_time_frac: this._info.any_blank_ms / total_time_spent,
        mostly_blank_per_min: this._info.mostly_blank_count / (total_time_spent / 1000 / 60),
        mostly_blank_time_frac: this._info.mostly_blank_ms / total_time_spent
      };

      for (var key in derived) {
        derived[key] = Math.round(1000 * derived[key]) / 1000;
      }

      console.debug('FillRateHelper deactivateAndFlush: ', {
        derived,
        info
      });
    }

    _listeners.forEach(listener => listener(info));

    this._resetData();
  }

  computeBlankness(props, state, scrollMetrics) {
    if (!this._enabled || props.getItemCount(props.data) === 0 || this._samplesStartTime == null) {
      return 0;
    }

    var dOffset = scrollMetrics.dOffset,
        offset = scrollMetrics.offset,
        velocity = scrollMetrics.velocity,
        visibleLength = scrollMetrics.visibleLength; // Denominator metrics that we track for all events - most of the time there is no blankness and
    // we want to capture that.

    this._info.sample_count++;
    this._info.pixels_sampled += Math.round(visibleLength);
    this._info.pixels_scrolled += Math.round(Math.abs(dOffset));
    var scrollSpeed = Math.round(Math.abs(velocity) * 1000); // px / sec
    // Whether blank now or not, record the elapsed time blank if we were blank last time.

    var now = global.performance.now();

    if (this._anyBlankStartTime != null) {
      this._info.any_blank_ms += now - this._anyBlankStartTime;
    }

    this._anyBlankStartTime = null;

    if (this._mostlyBlankStartTime != null) {
      this._info.mostly_blank_ms += now - this._mostlyBlankStartTime;
    }

    this._mostlyBlankStartTime = null;
    var blankTop = 0;
    var first = state.first;

    var firstFrame = this._getFrameMetrics(first);

    while (first <= state.last && (!firstFrame || !firstFrame.inLayout)) {
      firstFrame = this._getFrameMetrics(first);
      first++;
    } // Only count blankTop if we aren't rendering the first item, otherwise we will count the header
    // as blank.


    if (firstFrame && first > 0) {
      blankTop = Math.min(visibleLength, Math.max(0, firstFrame.offset - offset));
    }

    var blankBottom = 0;
    var last = state.last;

    var lastFrame = this._getFrameMetrics(last);

    while (last >= state.first && (!lastFrame || !lastFrame.inLayout)) {
      lastFrame = this._getFrameMetrics(last);
      last--;
    } // Only count blankBottom if we aren't rendering the last item, otherwise we will count the
    // footer as blank.


    if (lastFrame && last < props.getItemCount(props.data) - 1) {
      var bottomEdge = lastFrame.offset + lastFrame.length;
      blankBottom = Math.min(visibleLength, Math.max(0, offset + visibleLength - bottomEdge));
    }

    var pixels_blank = Math.round(blankTop + blankBottom);
    var blankness = pixels_blank / visibleLength;

    if (blankness > 0) {
      this._anyBlankStartTime = now;
      this._info.any_blank_speed_sum += scrollSpeed;
      this._info.any_blank_count++;
      this._info.pixels_blank += pixels_blank;

      if (blankness > 0.5) {
        this._mostlyBlankStartTime = now;
        this._info.mostly_blank_count++;
      }
    } else if (scrollSpeed < 0.01 || Math.abs(dOffset) < 1) {
      this.deactivateAndFlush();
    }

    return blankness;
  }

  enabled() {
    return this._enabled;
  }

  _resetData() {
    this._anyBlankStartTime = null;
    this._info = new Info();
    this._mostlyBlankStartTime = null;
    this._samplesStartTime = null;
  }

}

var _default = FillRateHelper;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),

/***/ 63392:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(64836)["default"]);

var _interopRequireWildcard = (__webpack_require__(75263)["default"]);

exports.__esModule = true;
exports["default"] = void 0;

var _extends2 = _interopRequireDefault(__webpack_require__(10434));

var _objectWithoutPropertiesLoose2 = _interopRequireDefault(__webpack_require__(7071));

var _objectSpread2 = _interopRequireDefault(__webpack_require__(42122));

var _Platform = _interopRequireDefault(__webpack_require__(98842));

var _deepDiffer = _interopRequireDefault(__webpack_require__(70339));

var React = _interopRequireWildcard(__webpack_require__(16689));

var _View = _interopRequireDefault(__webpack_require__(79057));

var _VirtualizedList = _interopRequireDefault(__webpack_require__(71655));

var _StyleSheet = _interopRequireDefault(__webpack_require__(84099));

var _invariant = _interopRequireDefault(__webpack_require__(44505));

var _VirtualizeUtils = __webpack_require__(39474);

var _excluded = ["numColumns", "columnWrapperStyle", "removeClippedSubviews"];

/**
 * Default Props Helper Functions
 * Use the following helper functions for default values
 */
// removeClippedSubviewsOrDefault(this.props.removeClippedSubviews)
function removeClippedSubviewsOrDefault(removeClippedSubviews) {
  return removeClippedSubviews !== null && removeClippedSubviews !== void 0 ? removeClippedSubviews : _Platform.default.OS === 'android';
} // numColumnsOrDefault(this.props.numColumns)


function numColumnsOrDefault(numColumns) {
  return numColumns !== null && numColumns !== void 0 ? numColumns : 1;
}

/**
 * A performant interface for rendering simple, flat lists, supporting the most handy features:
 *
 *  - Fully cross-platform.
 *  - Optional horizontal mode.
 *  - Configurable viewability callbacks.
 *  - Header support.
 *  - Footer support.
 *  - Separator support.
 *  - Pull to Refresh.
 *  - Scroll loading.
 *  - ScrollToIndex support.
 *
 * If you need section support, use [`<SectionList>`](docs/sectionlist.html).
 *
 * Minimal Example:
 *
 *     <FlatList
 *       data={[{key: 'a'}, {key: 'b'}]}
 *       renderItem={({item}) => <Text>{item.key}</Text>}
 *     />
 *
 * More complex, multi-select example demonstrating `PureComponent` usage for perf optimization and avoiding bugs.
 *
 * - By binding the `onPressItem` handler, the props will remain `===` and `PureComponent` will
 *   prevent wasteful re-renders unless the actual `id`, `selected`, or `title` props change, even
 *   if the components rendered in `MyListItem` did not have such optimizations.
 * - By passing `extraData={this.state}` to `FlatList` we make sure `FlatList` itself will re-render
 *   when the `state.selected` changes. Without setting this prop, `FlatList` would not know it
 *   needs to re-render any items because it is also a `PureComponent` and the prop comparison will
 *   not show any changes.
 * - `keyExtractor` tells the list to use the `id`s for the react keys instead of the default `key` property.
 *
 *
 *     class MyListItem extends React.PureComponent {
 *       _onPress = () => {
 *         this.props.onPressItem(this.props.id);
 *       };
 *
 *       render() {
 *         const textColor = this.props.selected ? "red" : "black";
 *         return (
 *           <TouchableOpacity onPress={this._onPress}>
 *             <View>
 *               <Text style={{ color: textColor }}>
 *                 {this.props.title}
 *               </Text>
 *             </View>
 *           </TouchableOpacity>
 *         );
 *       }
 *     }
 *
 *     class MultiSelectList extends React.PureComponent {
 *       state = {selected: (new Map(): Map<string, boolean>)};
 *
 *       _keyExtractor = (item, index) => item.id;
 *
 *       _onPressItem = (id: string) => {
 *         // updater functions are preferred for transactional updates
 *         this.setState((state) => {
 *           // copy the map rather than modifying state.
 *           const selected = new Map(state.selected);
 *           selected.set(id, !selected.get(id)); // toggle
 *           return {selected};
 *         });
 *       };
 *
 *       _renderItem = ({item}) => (
 *         <MyListItem
 *           id={item.id}
 *           onPressItem={this._onPressItem}
 *           selected={!!this.state.selected.get(item.id)}
 *           title={item.title}
 *         />
 *       );
 *
 *       render() {
 *         return (
 *           <FlatList
 *             data={this.props.data}
 *             extraData={this.state}
 *             keyExtractor={this._keyExtractor}
 *             renderItem={this._renderItem}
 *           />
 *         );
 *       }
 *     }
 *
 * This is a convenience wrapper around [`<VirtualizedList>`](docs/virtualizedlist.html),
 * and thus inherits its props (as well as those of `ScrollView`) that aren't explicitly listed
 * here, along with the following caveats:
 *
 * - Internal state is not preserved when content scrolls out of the render window. Make sure all
 *   your data is captured in the item data or external stores like Flux, Redux, or Relay.
 * - This is a `PureComponent` which means that it will not re-render if `props` remain shallow-
 *   equal. Make sure that everything your `renderItem` function depends on is passed as a prop
 *   (e.g. `extraData`) that is not `===` after updates, otherwise your UI may not update on
 *   changes. This includes the `data` prop and parent component state.
 * - In order to constrain memory and enable smooth scrolling, content is rendered asynchronously
 *   offscreen. This means it's possible to scroll faster than the fill rate ands momentarily see
 *   blank content. This is a tradeoff that can be adjusted to suit the needs of each application,
 *   and we are working on improving it behind the scenes.
 * - By default, the list looks for a `key` prop on each item and uses that for the React key.
 *   Alternatively, you can provide a custom `keyExtractor` prop.
 *
 * Also inherits [ScrollView Props](docs/scrollview.html#props), unless it is nested in another FlatList of same orientation.
 */
class FlatList extends React.PureComponent {
  /**
   * Scrolls to the end of the content. May be janky without `getItemLayout` prop.
   */
  scrollToEnd(params) {
    if (this._listRef) {
      this._listRef.scrollToEnd(params);
    }
  }
  /**
   * Scrolls to the item at the specified index such that it is positioned in the viewable area
   * such that `viewPosition` 0 places it at the top, 1 at the bottom, and 0.5 centered in the
   * middle. `viewOffset` is a fixed number of pixels to offset the final target position.
   *
   * Note: cannot scroll to locations outside the render window without specifying the
   * `getItemLayout` prop.
   */


  scrollToIndex(params) {
    if (this._listRef) {
      this._listRef.scrollToIndex(params);
    }
  }
  /**
   * Requires linear scan through data - use `scrollToIndex` instead if possible.
   *
   * Note: cannot scroll to locations outside the render window without specifying the
   * `getItemLayout` prop.
   */


  scrollToItem(params) {
    if (this._listRef) {
      this._listRef.scrollToItem(params);
    }
  }
  /**
   * Scroll to a specific content pixel offset in the list.
   *
   * Check out [scrollToOffset](docs/virtualizedlist.html#scrolltooffset) of VirtualizedList
   */


  scrollToOffset(params) {
    if (this._listRef) {
      this._listRef.scrollToOffset(params);
    }
  }
  /**
   * Tells the list an interaction has occurred, which should trigger viewability calculations, e.g.
   * if `waitForInteractions` is true and the user has not scrolled. This is typically called by
   * taps on items or by navigation actions.
   */


  recordInteraction() {
    if (this._listRef) {
      this._listRef.recordInteraction();
    }
  }
  /**
   * Displays the scroll indicators momentarily.
   *
   * @platform ios
   */


  flashScrollIndicators() {
    if (this._listRef) {
      this._listRef.flashScrollIndicators();
    }
  }
  /**
   * Provides a handle to the underlying scroll responder.
   */


  getScrollResponder() {
    if (this._listRef) {
      return this._listRef.getScrollResponder();
    }
  }
  /**
   * Provides a reference to the underlying host component
   */


  getNativeScrollRef() {
    if (this._listRef) {
      /* $FlowFixMe[incompatible-return] Suppresses errors found when fixing
       * TextInput typing */
      return this._listRef.getScrollRef();
    }
  }

  getScrollableNode() {
    if (this._listRef) {
      return this._listRef.getScrollableNode();
    }
  }

  setNativeProps(props) {
    if (this._listRef) {
      this._listRef.setNativeProps(props);
    }
  }

  constructor(_props) {
    super(_props);
    this._virtualizedListPairs = [];

    this._captureRef = ref => {
      this._listRef = ref;
    };

    this._getItem = (data, index) => {
      var numColumns = numColumnsOrDefault(this.props.numColumns);

      if (numColumns > 1) {
        var ret = [];

        for (var kk = 0; kk < numColumns; kk++) {
          var _item = data[index * numColumns + kk];

          if (_item != null) {
            ret.push(_item);
          }
        }

        return ret;
      } else {
        return data[index];
      }
    };

    this._getItemCount = data => {
      if (data) {
        var numColumns = numColumnsOrDefault(this.props.numColumns);
        return numColumns > 1 ? Math.ceil(data.length / numColumns) : data.length;
      } else {
        return 0;
      }
    };

    this._keyExtractor = (items, index) => {
      var _this$props$keyExtrac;

      var numColumns = numColumnsOrDefault(this.props.numColumns);
      var keyExtractor = (_this$props$keyExtrac = this.props.keyExtractor) !== null && _this$props$keyExtrac !== void 0 ? _this$props$keyExtrac : _VirtualizeUtils.keyExtractor;

      if (numColumns > 1) {
        if (Array.isArray(items)) {
          return items.map((item, kk) => keyExtractor(item, index * numColumns + kk)).join(':');
        } else {
          (0, _invariant.default)(Array.isArray(items), 'FlatList: Encountered internal consistency error, expected each item to consist of an ' + 'array with 1-%s columns; instead, received a single item.', numColumns);
        }
      } else {
        // $FlowFixMe[incompatible-call] Can't call keyExtractor with an array
        return keyExtractor(items, index);
      }
    };

    this._renderer = () => {
      var _this$props = this.props,
          ListItemComponent = _this$props.ListItemComponent,
          renderItem = _this$props.renderItem,
          columnWrapperStyle = _this$props.columnWrapperStyle;
      var numColumns = numColumnsOrDefault(this.props.numColumns);
      var virtualizedListRenderKey = ListItemComponent ? 'ListItemComponent' : 'renderItem';

      var renderer = props => {
        if (ListItemComponent) {
          // $FlowFixMe[not-a-component] Component isn't valid
          // $FlowFixMe[incompatible-type-arg] Component isn't valid
          // $FlowFixMe[incompatible-return] Component isn't valid
          return /*#__PURE__*/React.createElement(ListItemComponent, props);
        } else if (renderItem) {
          // $FlowFixMe[incompatible-call]
          return renderItem(props);
        } else {
          return null;
        }
      };

      return {
        /* $FlowFixMe[invalid-computed-prop] (>=0.111.0 site=react_native_fb)
         * This comment suppresses an error found when Flow v0.111 was deployed.
         * To see the error, delete this comment and run Flow. */
        [virtualizedListRenderKey]: info => {
          if (numColumns > 1) {
            var _item2 = info.item,
                _index = info.index;
            (0, _invariant.default)(Array.isArray(_item2), 'Expected array of items with numColumns > 1');
            return /*#__PURE__*/React.createElement(_View.default, {
              style: _StyleSheet.default.compose(styles.row, columnWrapperStyle)
            }, _item2.map((it, kk) => {
              var element = renderer({
                item: it,
                index: _index * numColumns + kk,
                separators: info.separators
              });
              return element != null ? /*#__PURE__*/React.createElement(React.Fragment, {
                key: kk
              }, element) : null;
            }));
          } else {
            return renderer(info);
          }
        }
      };
    };

    this._checkProps(this.props);

    if (this.props.viewabilityConfigCallbackPairs) {
      this._virtualizedListPairs = this.props.viewabilityConfigCallbackPairs.map(pair => ({
        viewabilityConfig: pair.viewabilityConfig,
        onViewableItemsChanged: this._createOnViewableItemsChanged(pair.onViewableItemsChanged)
      }));
    } else if (this.props.onViewableItemsChanged) {
      this._virtualizedListPairs.push({
        /* $FlowFixMe[incompatible-call] (>=0.63.0 site=react_native_fb) This
         * comment suppresses an error found when Flow v0.63 was deployed. To
         * see the error delete this comment and run Flow. */
        viewabilityConfig: this.props.viewabilityConfig,
        onViewableItemsChanged: this._createOnViewableItemsChanged(this.props.onViewableItemsChanged)
      });
    }
  }

  componentDidUpdate(prevProps) {
    (0, _invariant.default)(prevProps.numColumns === this.props.numColumns, 'Changing numColumns on the fly is not supported. Change the key prop on FlatList when ' + 'changing the number of columns to force a fresh render of the component.');
    (0, _invariant.default)(prevProps.onViewableItemsChanged === this.props.onViewableItemsChanged, 'Changing onViewableItemsChanged on the fly is not supported');
    (0, _invariant.default)(!(0, _deepDiffer.default)(prevProps.viewabilityConfig, this.props.viewabilityConfig), 'Changing viewabilityConfig on the fly is not supported');
    (0, _invariant.default)(prevProps.viewabilityConfigCallbackPairs === this.props.viewabilityConfigCallbackPairs, 'Changing viewabilityConfigCallbackPairs on the fly is not supported');

    this._checkProps(this.props);
  }

  _checkProps(props) {
    var getItem = props.getItem,
        getItemCount = props.getItemCount,
        horizontal = props.horizontal,
        columnWrapperStyle = props.columnWrapperStyle,
        onViewableItemsChanged = props.onViewableItemsChanged,
        viewabilityConfigCallbackPairs = props.viewabilityConfigCallbackPairs;
    var numColumns = numColumnsOrDefault(this.props.numColumns);
    (0, _invariant.default)(!getItem && !getItemCount, 'FlatList does not support custom data formats.');

    if (numColumns > 1) {
      (0, _invariant.default)(!horizontal, 'numColumns does not support horizontal.');
    } else {
      (0, _invariant.default)(!columnWrapperStyle, 'columnWrapperStyle not supported for single column lists');
    }

    (0, _invariant.default)(!(onViewableItemsChanged && viewabilityConfigCallbackPairs), 'FlatList does not support setting both onViewableItemsChanged and ' + 'viewabilityConfigCallbackPairs.');
  }

  _pushMultiColumnViewable(arr, v) {
    var _this$props$keyExtrac2;

    var numColumns = numColumnsOrDefault(this.props.numColumns);
    var keyExtractor = (_this$props$keyExtrac2 = this.props.keyExtractor) !== null && _this$props$keyExtrac2 !== void 0 ? _this$props$keyExtrac2 : _VirtualizeUtils.keyExtractor;
    v.item.forEach((item, ii) => {
      (0, _invariant.default)(v.index != null, 'Missing index!');
      var index = v.index * numColumns + ii;
      arr.push((0, _objectSpread2.default)((0, _objectSpread2.default)({}, v), {}, {
        item,
        key: keyExtractor(item, index),
        index
      }));
    });
  }

  _createOnViewableItemsChanged(onViewableItemsChanged) {
    return info => {
      var numColumns = numColumnsOrDefault(this.props.numColumns);

      if (onViewableItemsChanged) {
        if (numColumns > 1) {
          var changed = [];
          var viewableItems = [];
          info.viewableItems.forEach(v => this._pushMultiColumnViewable(viewableItems, v));
          info.changed.forEach(v => this._pushMultiColumnViewable(changed, v));
          onViewableItemsChanged({
            viewableItems,
            changed
          });
        } else {
          onViewableItemsChanged(info);
        }
      }
    };
  }

  render() {
    var _this$props2 = this.props,
        numColumns = _this$props2.numColumns,
        columnWrapperStyle = _this$props2.columnWrapperStyle,
        _removeClippedSubviews = _this$props2.removeClippedSubviews,
        restProps = (0, _objectWithoutPropertiesLoose2.default)(_this$props2, _excluded);
    return /*#__PURE__*/React.createElement(_VirtualizedList.default, (0, _extends2.default)({}, restProps, {
      getItem: this._getItem,
      getItemCount: this._getItemCount,
      keyExtractor: this._keyExtractor,
      ref: this._captureRef,
      viewabilityConfigCallbackPairs: this._virtualizedListPairs,
      removeClippedSubviews: removeClippedSubviewsOrDefault(_removeClippedSubviews)
    }, this._renderer()));
  }

}

var styles = _StyleSheet.default.create({
  row: {
    flexDirection: 'row'
  }
});

var _default = FlatList;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),

/***/ 82626:
/***/ ((module, exports, __webpack_require__) => {

"use strict";
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 */


var _interopRequireDefault = (__webpack_require__(64836)["default"]);

exports.__esModule = true;
exports["default"] = void 0;

var _Platform = _interopRequireDefault(__webpack_require__(98842));

var _UIManager = _interopRequireDefault(__webpack_require__(56629));

var __DEV__ = (/* unused pure expression or super */ null && ("production" !== 'production'));

function configureNext(config, onAnimationDidEnd) {
  if (!_Platform.default.isTesting) {
    _UIManager.default.configureNextLayoutAnimation(config, onAnimationDidEnd !== null && onAnimationDidEnd !== void 0 ? onAnimationDidEnd : function () {}, function () {}
    /* unused onError */
    );
  }
}

function create(duration, type, property) {
  return {
    duration,
    create: {
      type,
      property
    },
    update: {
      type
    },
    delete: {
      type,
      property
    }
  };
}

var Presets = {
  easeInEaseOut: create(300, 'easeInEaseOut', 'opacity'),
  linear: create(500, 'linear', 'opacity'),
  spring: {
    duration: 700,
    create: {
      type: 'linear',
      property: 'opacity'
    },
    update: {
      type: 'spring',
      springDamping: 0.4
    },
    delete: {
      type: 'linear',
      property: 'opacity'
    }
  }
};
/**
 * Automatically animates views to their new positions when the
 * next layout happens.
 *
 * A common way to use this API is to call it before calling `setState`.
 *
 * Note that in order to get this to work on **Android** you need to set the following flags via `UIManager`:
 *
 *     UIManager.setLayoutAnimationEnabledExperimental && UIManager.setLayoutAnimationEnabledExperimental(true);
 */

var LayoutAnimation = {
  /**
   * Schedules an animation to happen on the next layout.
   *
   * @param config Specifies animation properties:
   *
   *   - `duration` in milliseconds
   *   - `create`, `AnimationConfig` for animating in new views
   *   - `update`, `AnimationConfig` for animating views that have been updated
   *
   * @param onAnimationDidEnd Called when the animation finished.
   * Only supported on iOS.
   * @param onError Called on error. Only supported on iOS.
   */
  configureNext,

  /**
   * Helper for creating a config for `configureNext`.
   */
  create,
  Types: Object.freeze({
    spring: 'spring',
    linear: 'linear',
    easeInEaseOut: 'easeInEaseOut',
    easeIn: 'easeIn',
    easeOut: 'easeOut',
    keyboard: 'keyboard'
  }),
  Properties: Object.freeze({
    opacity: 'opacity',
    scaleX: 'scaleX',
    scaleY: 'scaleY',
    scaleXY: 'scaleXY'
  }),

  checkConfig() {
    console.error('LayoutAnimation.checkConfig(...) has been disabled.');
  },

  Presets,
  easeInEaseOut: configureNext.bind(null, Presets.easeInEaseOut),
  linear: configureNext.bind(null, Presets.linear),
  spring: configureNext.bind(null, Presets.spring)
};
var _default = LayoutAnimation;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),

/***/ 28939:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(64836)["default"]);

exports.__esModule = true;
exports["default"] = void 0;

var _EventEmitter = _interopRequireDefault(__webpack_require__(77580));

/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 */

/**
 * Global EventEmitter used by the native platform to emit events to JavaScript.
 * Events are identified by globally unique event names.
 *
 * NativeModules that emit events should instead subclass `NativeEventEmitter`.
 */
var _default = new _EventEmitter.default();

exports["default"] = _default;
module.exports = exports.default;

/***/ }),

/***/ 83394:
/***/ ((module, exports, __webpack_require__) => {

"use strict";
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 */


var _interopRequireDefault = (__webpack_require__(64836)["default"]);

exports.__esModule = true;
exports["default"] = void 0;

var _Platform = _interopRequireDefault(__webpack_require__(98842));

var _RCTDeviceEventEmitter = _interopRequireDefault(__webpack_require__(28939));

var _invariant = _interopRequireDefault(__webpack_require__(44505));

/**
 * `NativeEventEmitter` is intended for use by Native Modules to emit events to
 * JavaScript listeners. If a `NativeModule` is supplied to the constructor, it
 * will be notified (via `addListener` and `removeListeners`) when the listener
 * count changes to manage "native memory".
 *
 * Currently, all native events are fired via a global `RCTDeviceEventEmitter`.
 * This means event names must be globally unique, and it means that call sites
 * can theoretically listen to `RCTDeviceEventEmitter` (although discouraged).
 */
class NativeEventEmitter {
  constructor(nativeModule) {
    if (_Platform.default.OS === 'ios') {
      (0, _invariant.default)(nativeModule != null, '`new NativeEventEmitter()` requires a non-null argument.');
      this._nativeModule = nativeModule;
    }
  }

  addListener(eventType, listener, context) {
    var _this$_nativeModule;

    (_this$_nativeModule = this._nativeModule) == null ? void 0 : _this$_nativeModule.addListener(eventType);

    var subscription = _RCTDeviceEventEmitter.default.addListener(eventType, listener, context);

    return {
      remove: () => {
        if (subscription != null) {
          var _this$_nativeModule2;

          (_this$_nativeModule2 = this._nativeModule) == null ? void 0 : _this$_nativeModule2.removeListeners(1); // $FlowFixMe[incompatible-use]

          subscription.remove();
          subscription = null;
        }
      }
    };
  }
  /**
   * @deprecated Use `remove` on the EventSubscription from `addListener`.
   */


  removeListener(eventType, listener) {
    var _this$_nativeModule3;

    (_this$_nativeModule3 = this._nativeModule) == null ? void 0 : _this$_nativeModule3.removeListeners(1); // NOTE: This will report a deprecation notice via `console.error`.
    // $FlowFixMe[prop-missing] - `removeListener` exists but is deprecated.

    _RCTDeviceEventEmitter.default.removeListener(eventType, listener);
  }

  emit(eventType) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    // Generally, `RCTDeviceEventEmitter` is directly invoked. But this is
    // included for completeness.
    _RCTDeviceEventEmitter.default.emit(eventType, ...args);
  }

  removeAllListeners(eventType) {
    var _this$_nativeModule4;

    (0, _invariant.default)(eventType != null, '`NativeEventEmitter.removeAllListener()` requires a non-null argument.');
    (_this$_nativeModule4 = this._nativeModule) == null ? void 0 : _this$_nativeModule4.removeListeners(this.listenerCount(eventType));

    _RCTDeviceEventEmitter.default.removeAllListeners(eventType);
  }

  listenerCount(eventType) {
    return _RCTDeviceEventEmitter.default.listenerCount(eventType);
  }

}

exports["default"] = NativeEventEmitter;
module.exports = exports.default;

/***/ }),

/***/ 77145:
/***/ ((module, exports, __webpack_require__) => {

"use strict";
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 */


var _interopRequireDefault = (__webpack_require__(64836)["default"]);

exports.__esModule = true;
exports["default"] = void 0;

var _InteractionManager = _interopRequireDefault(__webpack_require__(91195));

var _TouchHistoryMath = _interopRequireDefault(__webpack_require__(80468));

var currentCentroidXOfTouchesChangedAfter = _TouchHistoryMath.default.currentCentroidXOfTouchesChangedAfter;
var currentCentroidYOfTouchesChangedAfter = _TouchHistoryMath.default.currentCentroidYOfTouchesChangedAfter;
var previousCentroidXOfTouchesChangedAfter = _TouchHistoryMath.default.previousCentroidXOfTouchesChangedAfter;
var previousCentroidYOfTouchesChangedAfter = _TouchHistoryMath.default.previousCentroidYOfTouchesChangedAfter;
var currentCentroidX = _TouchHistoryMath.default.currentCentroidX;
var currentCentroidY = _TouchHistoryMath.default.currentCentroidY;
/**
 * `PanResponder` reconciles several touches into a single gesture. It makes
 * single-touch gestures resilient to extra touches, and can be used to
 * recognize simple multi-touch gestures.
 *
 * By default, `PanResponder` holds an `InteractionManager` handle to block
 * long-running JS events from interrupting active gestures.
 *
 * It provides a predictable wrapper of the responder handlers provided by the
 * [gesture responder system](docs/gesture-responder-system.html).
 * For each handler, it provides a new `gestureState` object alongside the
 * native event object:
 *
 * ```
 * onPanResponderMove: (event, gestureState) => {}
 * ```
 *
 * A native event is a synthetic touch event with the following form:
 *
 *  - `nativeEvent`
 *      + `changedTouches` - Array of all touch events that have changed since the last event
 *      + `identifier` - The ID of the touch
 *      + `locationX` - The X position of the touch, relative to the element
 *      + `locationY` - The Y position of the touch, relative to the element
 *      + `pageX` - The X position of the touch, relative to the root element
 *      + `pageY` - The Y position of the touch, relative to the root element
 *      + `target` - The node id of the element receiving the touch event
 *      + `timestamp` - A time identifier for the touch, useful for velocity calculation
 *      + `touches` - Array of all current touches on the screen
 *
 * A `gestureState` object has the following:
 *
 *  - `stateID` - ID of the gestureState- persisted as long as there at least
 *     one touch on screen
 *  - `moveX` - the latest screen coordinates of the recently-moved touch
 *  - `moveY` - the latest screen coordinates of the recently-moved touch
 *  - `x0` - the screen coordinates of the responder grant
 *  - `y0` - the screen coordinates of the responder grant
 *  - `dx` - accumulated distance of the gesture since the touch started
 *  - `dy` - accumulated distance of the gesture since the touch started
 *  - `vx` - current velocity of the gesture
 *  - `vy` - current velocity of the gesture
 *  - `numberActiveTouches` - Number of touches currently on screen
 *
 * ### Basic Usage
 *
 * ```
 *   componentWillMount: function() {
 *     this._panResponder = PanResponder.create({
 *       // Ask to be the responder:
 *       onStartShouldSetPanResponder: (evt, gestureState) => true,
 *       onStartShouldSetPanResponderCapture: (evt, gestureState) => true,
 *       onMoveShouldSetPanResponder: (evt, gestureState) => true,
 *       onMoveShouldSetPanResponderCapture: (evt, gestureState) => true,
 *
 *       onPanResponderGrant: (evt, gestureState) => {
 *         // The gesture has started. Show visual feedback so the user knows
 *         // what is happening!
 *
 *         // gestureState.d{x,y} will be set to zero now
 *       },
 *       onPanResponderMove: (evt, gestureState) => {
 *         // The most recent move distance is gestureState.move{X,Y}
 *
 *         // The accumulated gesture distance since becoming responder is
 *         // gestureState.d{x,y}
 *       },
 *       onPanResponderTerminationRequest: (evt, gestureState) => true,
 *       onPanResponderRelease: (evt, gestureState) => {
 *         // The user has released all touches while this view is the
 *         // responder. This typically means a gesture has succeeded
 *       },
 *       onPanResponderTerminate: (evt, gestureState) => {
 *         // Another component has become the responder, so this gesture
 *         // should be cancelled
 *       },
 *       onShouldBlockNativeResponder: (evt, gestureState) => {
 *         // Returns whether this component should block native components from becoming the JS
 *         // responder. Returns true by default. Is currently only supported on android.
 *         return true;
 *       },
 *     });
 *   },
 *
 *   render: function() {
 *     return (
 *       <View {...this._panResponder.panHandlers} />
 *     );
 *   },
 *
 * ```
 *
 * ### Working Example
 *
 * To see it in action, try the
 * [PanResponder example in RNTester](https://github.com/facebook/react-native/blob/master/RNTester/js/PanResponderExample.js)
 */

var PanResponder = {
  /**
   *
   * A graphical explanation of the touch data flow:
   *
   * +----------------------------+             +--------------------------------+
   * | ResponderTouchHistoryStore |             |TouchHistoryMath                |
   * +----------------------------+             +----------+---------------------+
   * |Global store of touchHistory|             |Allocation-less math util       |
   * |including activeness, start |             |on touch history (centroids     |
   * |position, prev/cur position.|             |and multitouch movement etc)    |
   * |                            |             |                                |
   * +----^-----------------------+             +----^---------------------------+
   *      |                                          |
   *      | (records relevant history                |
   *      |  of touches relevant for                 |
   *      |  implementing higher level               |
   *      |  gestures)                               |
   *      |                                          |
   * +----+-----------------------+             +----|---------------------------+
   * | ResponderEventPlugin       |             |    |   Your App/Component      |
   * +----------------------------+             +----|---------------------------+
   * |Negotiates which view gets  | Low level   |    |             High level    |
   * |onResponderMove events.     | events w/   |  +-+-------+     events w/     |
   * |Also records history into   | touchHistory|  |   Pan   |     multitouch +  |
   * |ResponderTouchHistoryStore. +---------------->Responder+-----> accumulative|
   * +----------------------------+ attached to |  |         |     distance and  |
   *                                 each event |  +---------+     velocity.     |
   *                                            |                                |
   *                                            |                                |
   *                                            +--------------------------------+
   *
   *
   *
   * Gesture that calculates cumulative movement over time in a way that just
   * "does the right thing" for multiple touches. The "right thing" is very
   * nuanced. When moving two touches in opposite directions, the cumulative
   * distance is zero in each dimension. When two touches move in parallel five
   * pixels in the same direction, the cumulative distance is five, not ten. If
   * two touches start, one moves five in a direction, then stops and the other
   * touch moves fives in the same direction, the cumulative distance is ten.
   *
   * This logic requires a kind of processing of time "clusters" of touch events
   * so that two touch moves that essentially occur in parallel but move every
   * other frame respectively, are considered part of the same movement.
   *
   * Explanation of some of the non-obvious fields:
   *
   * - moveX/moveY: If no move event has been observed, then `(moveX, moveY)` is
   *   invalid. If a move event has been observed, `(moveX, moveY)` is the
   *   centroid of the most recently moved "cluster" of active touches.
   *   (Currently all move have the same timeStamp, but later we should add some
   *   threshold for what is considered to be "moving"). If a palm is
   *   accidentally counted as a touch, but a finger is moving greatly, the palm
   *   will move slightly, but we only want to count the single moving touch.
   * - x0/y0: Centroid location (non-cumulative) at the time of becoming
   *   responder.
   * - dx/dy: Cumulative touch distance - not the same thing as sum of each touch
   *   distance. Accounts for touch moves that are clustered together in time,
   *   moving the same direction. Only valid when currently responder (otherwise,
   *   it only represents the drag distance below the threshold).
   * - vx/vy: Velocity.
   */
  _initializeGestureState(gestureState) {
    gestureState.moveX = 0;
    gestureState.moveY = 0;
    gestureState.x0 = 0;
    gestureState.y0 = 0;
    gestureState.dx = 0;
    gestureState.dy = 0;
    gestureState.vx = 0;
    gestureState.vy = 0;
    gestureState.numberActiveTouches = 0; // All `gestureState` accounts for timeStamps up until:

    gestureState._accountsForMovesUpTo = 0;
  },

  /**
   * This is nuanced and is necessary. It is incorrect to continuously take all
   * active *and* recently moved touches, find the centroid, and track how that
   * result changes over time. Instead, we must take all recently moved
   * touches, and calculate how the centroid has changed just for those
   * recently moved touches, and append that change to an accumulator. This is
   * to (at least) handle the case where the user is moving three fingers, and
   * then one of the fingers stops but the other two continue.
   *
   * This is very different than taking all of the recently moved touches and
   * storing their centroid as `dx/dy`. For correctness, we must *accumulate
   * changes* in the centroid of recently moved touches.
   *
   * There is also some nuance with how we handle multiple moved touches in a
   * single event. With the way `ReactNativeEventEmitter` dispatches touches as
   * individual events, multiple touches generate two 'move' events, each of
   * them triggering `onResponderMove`. But with the way `PanResponder` works,
   * all of the gesture inference is performed on the first dispatch, since it
   * looks at all of the touches (even the ones for which there hasn't been a
   * native dispatch yet). Therefore, `PanResponder` does not call
   * `onResponderMove` passed the first dispatch. This diverges from the
   * typical responder callback pattern (without using `PanResponder`), but
   * avoids more dispatches than necessary.
   */
  _updateGestureStateOnMove(gestureState, touchHistory) {
    gestureState.numberActiveTouches = touchHistory.numberActiveTouches;
    gestureState.moveX = currentCentroidXOfTouchesChangedAfter(touchHistory, gestureState._accountsForMovesUpTo);
    gestureState.moveY = currentCentroidYOfTouchesChangedAfter(touchHistory, gestureState._accountsForMovesUpTo);
    var movedAfter = gestureState._accountsForMovesUpTo;
    var prevX = previousCentroidXOfTouchesChangedAfter(touchHistory, movedAfter);
    var x = currentCentroidXOfTouchesChangedAfter(touchHistory, movedAfter);
    var prevY = previousCentroidYOfTouchesChangedAfter(touchHistory, movedAfter);
    var y = currentCentroidYOfTouchesChangedAfter(touchHistory, movedAfter);
    var nextDX = gestureState.dx + (x - prevX);
    var nextDY = gestureState.dy + (y - prevY); // TODO: This must be filtered intelligently.

    var dt = touchHistory.mostRecentTimeStamp - gestureState._accountsForMovesUpTo;
    gestureState.vx = (nextDX - gestureState.dx) / dt;
    gestureState.vy = (nextDY - gestureState.dy) / dt;
    gestureState.dx = nextDX;
    gestureState.dy = nextDY;
    gestureState._accountsForMovesUpTo = touchHistory.mostRecentTimeStamp;
  },

  /**
   * @param {object} config Enhanced versions of all of the responder callbacks
   * that provide not only the typical `ResponderSyntheticEvent`, but also the
   * `PanResponder` gesture state.  Simply replace the word `Responder` with
   * `PanResponder` in each of the typical `onResponder*` callbacks. For
   * example, the `config` object would look like:
   *
   *  - `onMoveShouldSetPanResponder: (e, gestureState) => {...}`
   *  - `onMoveShouldSetPanResponderCapture: (e, gestureState) => {...}`
   *  - `onStartShouldSetPanResponder: (e, gestureState) => {...}`
   *  - `onStartShouldSetPanResponderCapture: (e, gestureState) => {...}`
   *  - `onPanResponderReject: (e, gestureState) => {...}`
   *  - `onPanResponderGrant: (e, gestureState) => {...}`
   *  - `onPanResponderStart: (e, gestureState) => {...}`
   *  - `onPanResponderEnd: (e, gestureState) => {...}`
   *  - `onPanResponderRelease: (e, gestureState) => {...}`
   *  - `onPanResponderMove: (e, gestureState) => {...}`
   *  - `onPanResponderTerminate: (e, gestureState) => {...}`
   *  - `onPanResponderTerminationRequest: (e, gestureState) => {...}`
   *  - `onShouldBlockNativeResponder: (e, gestureState) => {...}`
   *
   *  In general, for events that have capture equivalents, we update the
   *  gestureState once in the capture phase and can use it in the bubble phase
   *  as well.
   *
   *  Be careful with onStartShould* callbacks. They only reflect updated
   *  `gestureState` for start/end events that bubble/capture to the Node.
   *  Once the node is the responder, you can rely on every start/end event
   *  being processed by the gesture and `gestureState` being updated
   *  accordingly. (numberActiveTouches) may not be totally accurate unless you
   *  are the responder.
   */
  create(config) {
    var interactionState = {
      handle: null,
      shouldCancelClick: false,
      timeout: null
    };
    var gestureState = {
      // Useful for debugging
      stateID: Math.random(),
      moveX: 0,
      moveY: 0,
      x0: 0,
      y0: 0,
      dx: 0,
      dy: 0,
      vx: 0,
      vy: 0,
      numberActiveTouches: 0,
      _accountsForMovesUpTo: 0
    };
    var panHandlers = {
      onStartShouldSetResponder(event) {
        return config.onStartShouldSetPanResponder == null ? false : config.onStartShouldSetPanResponder(event, gestureState);
      },

      onMoveShouldSetResponder(event) {
        return config.onMoveShouldSetPanResponder == null ? false : config.onMoveShouldSetPanResponder(event, gestureState);
      },

      onStartShouldSetResponderCapture(event) {
        // TODO: Actually, we should reinitialize the state any time
        // touches.length increases from 0 active to > 0 active.
        if (event.nativeEvent.touches.length === 1) {
          PanResponder._initializeGestureState(gestureState);
        }

        gestureState.numberActiveTouches = event.touchHistory.numberActiveTouches;
        return config.onStartShouldSetPanResponderCapture != null ? config.onStartShouldSetPanResponderCapture(event, gestureState) : false;
      },

      onMoveShouldSetResponderCapture(event) {
        var touchHistory = event.touchHistory; // Responder system incorrectly dispatches should* to current responder
        // Filter out any touch moves past the first one - we would have
        // already processed multi-touch geometry during the first event.

        if (gestureState._accountsForMovesUpTo === touchHistory.mostRecentTimeStamp) {
          return false;
        }

        PanResponder._updateGestureStateOnMove(gestureState, touchHistory);

        return config.onMoveShouldSetPanResponderCapture ? config.onMoveShouldSetPanResponderCapture(event, gestureState) : false;
      },

      onResponderGrant(event) {
        if (!interactionState.handle) {
          interactionState.handle = _InteractionManager.default.createInteractionHandle();
        }

        if (interactionState.timeout) {
          clearInteractionTimeout(interactionState);
        }

        interactionState.shouldCancelClick = true;
        gestureState.x0 = currentCentroidX(event.touchHistory);
        gestureState.y0 = currentCentroidY(event.touchHistory);
        gestureState.dx = 0;
        gestureState.dy = 0;

        if (config.onPanResponderGrant) {
          config.onPanResponderGrant(event, gestureState);
        } // TODO: t7467124 investigate if this can be removed


        return config.onShouldBlockNativeResponder == null ? true : config.onShouldBlockNativeResponder(event, gestureState);
      },

      onResponderReject(event) {
        clearInteractionHandle(interactionState, config.onPanResponderReject, event, gestureState);
      },

      onResponderRelease(event) {
        clearInteractionHandle(interactionState, config.onPanResponderRelease, event, gestureState);
        setInteractionTimeout(interactionState);

        PanResponder._initializeGestureState(gestureState);
      },

      onResponderStart(event) {
        var touchHistory = event.touchHistory;
        gestureState.numberActiveTouches = touchHistory.numberActiveTouches;

        if (config.onPanResponderStart) {
          config.onPanResponderStart(event, gestureState);
        }
      },

      onResponderMove(event) {
        var touchHistory = event.touchHistory; // Guard against the dispatch of two touch moves when there are two
        // simultaneously changed touches.

        if (gestureState._accountsForMovesUpTo === touchHistory.mostRecentTimeStamp) {
          return;
        } // Filter out any touch moves past the first one - we would have
        // already processed multi-touch geometry during the first event.


        PanResponder._updateGestureStateOnMove(gestureState, touchHistory);

        if (config.onPanResponderMove) {
          config.onPanResponderMove(event, gestureState);
        }
      },

      onResponderEnd(event) {
        var touchHistory = event.touchHistory;
        gestureState.numberActiveTouches = touchHistory.numberActiveTouches;
        clearInteractionHandle(interactionState, config.onPanResponderEnd, event, gestureState);
      },

      onResponderTerminate(event) {
        clearInteractionHandle(interactionState, config.onPanResponderTerminate, event, gestureState);
        setInteractionTimeout(interactionState);

        PanResponder._initializeGestureState(gestureState);
      },

      onResponderTerminationRequest(event) {
        return config.onPanResponderTerminationRequest == null ? true : config.onPanResponderTerminationRequest(event, gestureState);
      },

      // We do not want to trigger 'click' activated gestures or native behaviors
      // on any pan target that is under a mouse cursor when it is released.
      // Browsers will natively cancel 'click' events on a target if a non-mouse
      // active pointer moves.
      onClickCapture: event => {
        if (interactionState.shouldCancelClick === true) {
          event.stopPropagation();
          event.preventDefault();
        }
      }
    };
    return {
      panHandlers,

      getInteractionHandle() {
        return interactionState.handle;
      }

    };
  }

};

function clearInteractionHandle(interactionState, callback, event, gestureState) {
  if (interactionState.handle) {
    _InteractionManager.default.clearInteractionHandle(interactionState.handle);

    interactionState.handle = null;
  }

  if (callback) {
    callback(event, gestureState);
  }
}

function clearInteractionTimeout(interactionState) {
  clearTimeout(interactionState.timeout);
}

function setInteractionTimeout(interactionState) {
  interactionState.timeout = setTimeout(() => {
    interactionState.shouldCancelClick = false;
  }, 250);
}

var _default = PanResponder;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),

/***/ 25919:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(64836)["default"]);

exports.__esModule = true;
exports["default"] = void 0;

var _invariant = _interopRequireDefault(__webpack_require__(44505));

/* eslint-disable */

/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * From React 16.0.0
 */
var twoArgumentPooler = function twoArgumentPooler(a1, a2) {
  var Klass = this;

  if (Klass.instancePool.length) {
    var instance = Klass.instancePool.pop();
    Klass.call(instance, a1, a2);
    return instance;
  } else {
    return new Klass(a1, a2);
  }
};

var standardReleaser = function standardReleaser(instance) {
  var Klass = this;
  instance.destructor();

  if (Klass.instancePool.length < Klass.poolSize) {
    Klass.instancePool.push(instance);
  }
};

var DEFAULT_POOL_SIZE = 10;
var DEFAULT_POOLER = twoArgumentPooler;
/**
 * Augments `CopyConstructor` to be a poolable class, augmenting only the class
 * itself (statically) not adding any prototypical fields. Any CopyConstructor
 * you give this may have a `poolSize` property, and will look for a
 * prototypical `destructor` on instances.
 *
 * @param {Function} CopyConstructor Constructor that can be used to reset.
 * @param {Function} pooler Customizable pooler.
 */

var addPoolingTo = function addPoolingTo(CopyConstructor, pooler) {
  // Casting as any so that flow ignores the actual implementation and trusts
  // it to match the type we declared
  var NewKlass = CopyConstructor;
  NewKlass.instancePool = [];
  NewKlass.getPooled = pooler || DEFAULT_POOLER;

  if (!NewKlass.poolSize) {
    NewKlass.poolSize = DEFAULT_POOL_SIZE;
  }

  NewKlass.release = standardReleaser;
  return NewKlass;
};

var PooledClass = {
  addPoolingTo: addPoolingTo,
  twoArgumentPooler: twoArgumentPooler
};
var _default = PooledClass;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),

/***/ 33316:
/***/ ((module, exports, __webpack_require__) => {

"use strict";
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 */


var _interopRequireDefault = (__webpack_require__(64836)["default"]);

var _interopRequireWildcard = (__webpack_require__(75263)["default"]);

exports.__esModule = true;
exports["default"] = void 0;

var _extends2 = _interopRequireDefault(__webpack_require__(10434));

var _objectWithoutPropertiesLoose2 = _interopRequireDefault(__webpack_require__(7071));

var _Platform = _interopRequireDefault(__webpack_require__(98842));

var React = _interopRequireWildcard(__webpack_require__(16689));

var _VirtualizedSectionList = _interopRequireDefault(__webpack_require__(85919));

var _excluded = ["stickySectionHeadersEnabled"];

/**
 * A performant interface for rendering sectioned lists, supporting the most handy features:
 *
 *  - Fully cross-platform.
 *  - Configurable viewability callbacks.
 *  - List header support.
 *  - List footer support.
 *  - Item separator support.
 *  - Section header support.
 *  - Section separator support.
 *  - Heterogeneous data and item rendering support.
 *  - Pull to Refresh.
 *  - Scroll loading.
 *
 * If you don't need section support and want a simpler interface, use
 * [`<FlatList>`](https://reactnative.dev/docs/flatlist).
 *
 * Simple Examples:
 *
 *     <SectionList
 *       renderItem={({item}) => <ListItem title={item} />}
 *       renderSectionHeader={({section}) => <Header title={section.title} />}
 *       sections={[ // homogeneous rendering between sections
 *         {data: [...], title: ...},
 *         {data: [...], title: ...},
 *         {data: [...], title: ...},
 *       ]}
 *     />
 *
 *     <SectionList
 *       sections={[ // heterogeneous rendering between sections
 *         {data: [...], renderItem: ...},
 *         {data: [...], renderItem: ...},
 *         {data: [...], renderItem: ...},
 *       ]}
 *     />
 *
 * This is a convenience wrapper around [`<VirtualizedList>`](docs/virtualizedlist),
 * and thus inherits its props (as well as those of `ScrollView`) that aren't explicitly listed
 * here, along with the following caveats:
 *
 * - Internal state is not preserved when content scrolls out of the render window. Make sure all
 *   your data is captured in the item data or external stores like Flux, Redux, or Relay.
 * - This is a `PureComponent` which means that it will not re-render if `props` remain shallow-
 *   equal. Make sure that everything your `renderItem` function depends on is passed as a prop
 *   (e.g. `extraData`) that is not `===` after updates, otherwise your UI may not update on
 *   changes. This includes the `data` prop and parent component state.
 * - In order to constrain memory and enable smooth scrolling, content is rendered asynchronously
 *   offscreen. This means it's possible to scroll faster than the fill rate and momentarily see
 *   blank content. This is a tradeoff that can be adjusted to suit the needs of each application,
 *   and we are working on improving it behind the scenes.
 * - By default, the list looks for a `key` prop on each item and uses that for the React key.
 *   Alternatively, you can provide a custom `keyExtractor` prop.
 *
 */
class SectionList extends React.PureComponent {
  constructor() {
    super(...arguments);

    this._captureRef = ref => {
      this._wrapperListRef = ref;
    };
  }

  /**
   * Scrolls to the item at the specified `sectionIndex` and `itemIndex` (within the section)
   * positioned in the viewable area such that `viewPosition` 0 places it at the top (and may be
   * covered by a sticky header), 1 at the bottom, and 0.5 centered in the middle. `viewOffset` is a
   * fixed number of pixels to offset the final target position, e.g. to compensate for sticky
   * headers.
   *
   * Note: cannot scroll to locations outside the render window without specifying the
   * `getItemLayout` prop.
   */
  scrollToLocation(params) {
    if (this._wrapperListRef != null) {
      this._wrapperListRef.scrollToLocation(params);
    }
  }
  /**
   * Tells the list an interaction has occurred, which should trigger viewability calculations, e.g.
   * if `waitForInteractions` is true and the user has not scrolled. This is typically called by
   * taps on items or by navigation actions.
   */


  recordInteraction() {
    var listRef = this._wrapperListRef && this._wrapperListRef.getListRef();

    listRef && listRef.recordInteraction();
  }
  /**
   * Displays the scroll indicators momentarily.
   *
   * @platform ios
   */


  flashScrollIndicators() {
    var listRef = this._wrapperListRef && this._wrapperListRef.getListRef();

    listRef && listRef.flashScrollIndicators();
  }
  /**
   * Provides a handle to the underlying scroll responder.
   */


  getScrollResponder() {
    var listRef = this._wrapperListRef && this._wrapperListRef.getListRef();

    if (listRef) {
      return listRef.getScrollResponder();
    }
  }

  getScrollableNode() {
    var listRef = this._wrapperListRef && this._wrapperListRef.getListRef();

    if (listRef) {
      return listRef.getScrollableNode();
    }
  }

  setNativeProps(props) {
    var listRef = this._wrapperListRef && this._wrapperListRef.getListRef();

    if (listRef) {
      listRef.setNativeProps(props);
    }
  }

  render() {
    var _this$props = this.props,
        _stickySectionHeadersEnabled = _this$props.stickySectionHeadersEnabled,
        restProps = (0, _objectWithoutPropertiesLoose2.default)(_this$props, _excluded);
    var stickySectionHeadersEnabled = _stickySectionHeadersEnabled !== null && _stickySectionHeadersEnabled !== void 0 ? _stickySectionHeadersEnabled : _Platform.default.OS === 'ios';
    return /*#__PURE__*/React.createElement(_VirtualizedSectionList.default, (0, _extends2.default)({}, restProps, {
      stickySectionHeadersEnabled: stickySectionHeadersEnabled,
      ref: this._captureRef,
      getItemCount: items => items.length,
      getItem: (items, index) => items[index]
    }));
  }

}

exports["default"] = SectionList;
module.exports = exports.default;

/***/ }),

/***/ 80468:
/***/ ((module, exports) => {

"use strict";


exports.__esModule = true;
exports["default"] = void 0;

/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @format
 */
var TouchHistoryMath = {
  /**
   * This code is optimized and not intended to look beautiful. This allows
   * computing of touch centroids that have moved after `touchesChangedAfter`
   * timeStamp. You can compute the current centroid involving all touches
   * moves after `touchesChangedAfter`, or you can compute the previous
   * centroid of all touches that were moved after `touchesChangedAfter`.
   *
   * @param {TouchHistoryMath} touchHistory Standard Responder touch track
   * data.
   * @param {number} touchesChangedAfter timeStamp after which moved touches
   * are considered "actively moving" - not just "active".
   * @param {boolean} isXAxis Consider `x` dimension vs. `y` dimension.
   * @param {boolean} ofCurrent Compute current centroid for actively moving
   * touches vs. previous centroid of now actively moving touches.
   * @return {number} value of centroid in specified dimension.
   */
  centroidDimension: function centroidDimension(touchHistory, touchesChangedAfter, isXAxis, ofCurrent) {
    var touchBank = touchHistory.touchBank;
    var total = 0;
    var count = 0;
    var oneTouchData = touchHistory.numberActiveTouches === 1 ? touchHistory.touchBank[touchHistory.indexOfSingleActiveTouch] : null;

    if (oneTouchData !== null) {
      if (oneTouchData.touchActive && oneTouchData.currentTimeStamp > touchesChangedAfter) {
        total += ofCurrent && isXAxis ? oneTouchData.currentPageX : ofCurrent && !isXAxis ? oneTouchData.currentPageY : !ofCurrent && isXAxis ? oneTouchData.previousPageX : oneTouchData.previousPageY;
        count = 1;
      }
    } else {
      for (var i = 0; i < touchBank.length; i++) {
        var touchTrack = touchBank[i];

        if (touchTrack !== null && touchTrack !== undefined && touchTrack.touchActive && touchTrack.currentTimeStamp >= touchesChangedAfter) {
          var toAdd = void 0; // Yuck, program temporarily in invalid state.

          if (ofCurrent && isXAxis) {
            toAdd = touchTrack.currentPageX;
          } else if (ofCurrent && !isXAxis) {
            toAdd = touchTrack.currentPageY;
          } else if (!ofCurrent && isXAxis) {
            toAdd = touchTrack.previousPageX;
          } else {
            toAdd = touchTrack.previousPageY;
          }

          total += toAdd;
          count++;
        }
      }
    }

    return count > 0 ? total / count : TouchHistoryMath.noCentroid;
  },
  currentCentroidXOfTouchesChangedAfter: function currentCentroidXOfTouchesChangedAfter(touchHistory, touchesChangedAfter) {
    return TouchHistoryMath.centroidDimension(touchHistory, touchesChangedAfter, true, // isXAxis
    true // ofCurrent
    );
  },
  currentCentroidYOfTouchesChangedAfter: function currentCentroidYOfTouchesChangedAfter(touchHistory, touchesChangedAfter) {
    return TouchHistoryMath.centroidDimension(touchHistory, touchesChangedAfter, false, // isXAxis
    true // ofCurrent
    );
  },
  previousCentroidXOfTouchesChangedAfter: function previousCentroidXOfTouchesChangedAfter(touchHistory, touchesChangedAfter) {
    return TouchHistoryMath.centroidDimension(touchHistory, touchesChangedAfter, true, // isXAxis
    false // ofCurrent
    );
  },
  previousCentroidYOfTouchesChangedAfter: function previousCentroidYOfTouchesChangedAfter(touchHistory, touchesChangedAfter) {
    return TouchHistoryMath.centroidDimension(touchHistory, touchesChangedAfter, false, // isXAxis
    false // ofCurrent
    );
  },
  currentCentroidX: function currentCentroidX(touchHistory) {
    return TouchHistoryMath.centroidDimension(touchHistory, 0, // touchesChangedAfter
    true, // isXAxis
    true // ofCurrent
    );
  },
  currentCentroidY: function currentCentroidY(touchHistory) {
    return TouchHistoryMath.centroidDimension(touchHistory, 0, // touchesChangedAfter
    false, // isXAxis
    true // ofCurrent
    );
  },
  noCentroid: -1
};
var _default = TouchHistoryMath;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),

/***/ 24903:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 */


var _interopRequireDefault = (__webpack_require__(64836)["default"]);

exports.__esModule = true;
exports.get = get;
exports.getEnforcing = getEnforcing;

var _invariant = _interopRequireDefault(__webpack_require__(44505));

function get(name) {
  return null;
}

function getEnforcing(name) {
  var module = get(name);
  (0, _invariant.default)(module != null, "TurboModuleRegistry.getEnforcing(...): '" + name + "' could not be found. " + 'Verify that a module by this name is registered in the native binary.');
  return module;
}

/***/ }),

/***/ 3706:
/***/ ((module, exports) => {

"use strict";
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @format
 * 
 */


exports.__esModule = true;
exports["default"] = void 0;

/**
 * This is a helper function for when a component needs to be able to forward a ref
 * to a child component, but still needs to have access to that component as part of
 * its implementation.
 *
 * Its main use case is in wrappers for native components.
 *
 * Usage:
 *
 *   class MyView extends React.Component {
 *     _nativeRef = null;
 *
 *     _setNativeRef = setAndForwardRef({
 *       getForwardedRef: () => this.props.forwardedRef,
 *       setLocalRef: ref => {
 *         this._nativeRef = ref;
 *       },
 *     });
 *
 *     render() {
 *       return <View ref={this._setNativeRef} />;
 *     }
 *   }
 *
 *   const MyViewWithRef = React.forwardRef((props, ref) => (
 *     <MyView {...props} forwardedRef={ref} />
 *   ));
 *
 *   module.exports = MyViewWithRef;
 */
function setAndForwardRef(_ref) {
  var getForwardedRef = _ref.getForwardedRef,
      setLocalRef = _ref.setLocalRef;
  return function forwardRef(ref) {
    var forwardedRef = getForwardedRef();
    setLocalRef(ref); // Forward to user ref prop (if one has been specified)

    if (typeof forwardedRef === 'function') {
      // Handle function-based refs. String-based refs are handled as functions.
      forwardedRef(ref);
    } else if (typeof forwardedRef === 'object' && forwardedRef != null) {
      // Handle createRef-based refs
      forwardedRef.current = ref;
    }
  };
}

var _default = setAndForwardRef;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),

/***/ 15433:
/***/ ((module, exports, __webpack_require__) => {

"use strict";
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 */


var _interopRequireDefault = (__webpack_require__(64836)["default"]);

exports.__esModule = true;
exports["default"] = void 0;

var _objectSpread2 = _interopRequireDefault(__webpack_require__(42122));

var _createForOfIteratorHelperLoose2 = _interopRequireDefault(__webpack_require__(92535));

var _invariant = _interopRequireDefault(__webpack_require__(44505));

/**
 * A Utility class for calculating viewable items based on current metrics like scroll position and
 * layout.
 *
 * An item is said to be in a "viewable" state when any of the following
 * is true for longer than `minimumViewTime` milliseconds (after an interaction if `waitForInteraction`
 * is true):
 *
 * - Occupying >= `viewAreaCoveragePercentThreshold` of the view area XOR fraction of the item
 *   visible in the view area >= `itemVisiblePercentThreshold`.
 * - Entirely visible on screen
 */
class ViewabilityHelper {
  constructor(config) {
    if (config === void 0) {
      config = {
        viewAreaCoveragePercentThreshold: 0
      };
    }

    this._hasInteracted = false;
    this._timers = new Set();
    this._viewableIndices = [];
    this._viewableItems = new Map();
    this._config = config;
  }
  /**
   * Cleanup, e.g. on unmount. Clears any pending timers.
   */


  dispose() {
    this._timers.forEach(clearTimeout);
  }
  /**
   * Determines which items are viewable based on the current metrics and config.
   */


  computeViewableItems(itemCount, scrollOffset, viewportHeight, getFrameMetrics, renderRange // Optional optimization to reduce the scan size
  ) {
    var _this$_config = this._config,
        itemVisiblePercentThreshold = _this$_config.itemVisiblePercentThreshold,
        viewAreaCoveragePercentThreshold = _this$_config.viewAreaCoveragePercentThreshold;
    var viewAreaMode = viewAreaCoveragePercentThreshold != null;
    var viewablePercentThreshold = viewAreaMode ? viewAreaCoveragePercentThreshold : itemVisiblePercentThreshold;
    (0, _invariant.default)(viewablePercentThreshold != null && itemVisiblePercentThreshold != null !== (viewAreaCoveragePercentThreshold != null), 'Must set exactly one of itemVisiblePercentThreshold or viewAreaCoveragePercentThreshold');
    var viewableIndices = [];

    if (itemCount === 0) {
      return viewableIndices;
    }

    var firstVisible = -1;

    var _ref = renderRange || {
      first: 0,
      last: itemCount - 1
    },
        first = _ref.first,
        last = _ref.last;

    if (last >= itemCount) {
      console.warn('Invalid render range computing viewability ' + JSON.stringify({
        renderRange,
        itemCount
      }));
      return [];
    }

    for (var idx = first; idx <= last; idx++) {
      var metrics = getFrameMetrics(idx);

      if (!metrics) {
        continue;
      }

      var top = metrics.offset - scrollOffset;
      var bottom = top + metrics.length;

      if (top < viewportHeight && bottom > 0) {
        firstVisible = idx;

        if (_isViewable(viewAreaMode, viewablePercentThreshold, top, bottom, viewportHeight, metrics.length)) {
          viewableIndices.push(idx);
        }
      } else if (firstVisible >= 0) {
        break;
      }
    }

    return viewableIndices;
  }
  /**
   * Figures out which items are viewable and how that has changed from before and calls
   * `onViewableItemsChanged` as appropriate.
   */


  onUpdate(itemCount, scrollOffset, viewportHeight, getFrameMetrics, createViewToken, onViewableItemsChanged, renderRange // Optional optimization to reduce the scan size
  ) {
    if (this._config.waitForInteraction && !this._hasInteracted || itemCount === 0 || !getFrameMetrics(0)) {
      return;
    }

    var viewableIndices = [];

    if (itemCount) {
      viewableIndices = this.computeViewableItems(itemCount, scrollOffset, viewportHeight, getFrameMetrics, renderRange);
    }

    if (this._viewableIndices.length === viewableIndices.length && this._viewableIndices.every((v, ii) => v === viewableIndices[ii])) {
      // We might get a lot of scroll events where visibility doesn't change and we don't want to do
      // extra work in those cases.
      return;
    }

    this._viewableIndices = viewableIndices;

    if (this._config.minimumViewTime) {
      var handle = setTimeout(() => {
        this._timers.delete(handle);

        this._onUpdateSync(viewableIndices, onViewableItemsChanged, createViewToken);
      }, this._config.minimumViewTime);

      this._timers.add(handle);
    } else {
      this._onUpdateSync(viewableIndices, onViewableItemsChanged, createViewToken);
    }
  }
  /**
   * clean-up cached _viewableIndices to evaluate changed items on next update
   */


  resetViewableIndices() {
    this._viewableIndices = [];
  }
  /**
   * Records that an interaction has happened even if there has been no scroll.
   */


  recordInteraction() {
    this._hasInteracted = true;
  }

  _onUpdateSync( // $FlowFixMe
  viewableIndicesToCheck, // $FlowFixMe
  onViewableItemsChanged, // $FlowFixMe
  createViewToken) {
    // Filter out indices that have gone out of view since this call was scheduled.
    viewableIndicesToCheck = viewableIndicesToCheck.filter(ii => this._viewableIndices.includes(ii));
    var prevItems = this._viewableItems;
    var nextItems = new Map(viewableIndicesToCheck.map(ii => {
      var viewable = createViewToken(ii, true);
      return [viewable.key, viewable];
    }));
    var changed = [];

    for (var _iterator = (0, _createForOfIteratorHelperLoose2.default)(nextItems), _step; !(_step = _iterator()).done;) {
      var _step$value = _step.value,
          key = _step$value[0],
          viewable = _step$value[1];

      if (!prevItems.has(key)) {
        changed.push(viewable);
      }
    }

    for (var _iterator2 = (0, _createForOfIteratorHelperLoose2.default)(prevItems), _step2; !(_step2 = _iterator2()).done;) {
      var _step2$value = _step2.value,
          _key = _step2$value[0],
          _viewable = _step2$value[1];

      if (!nextItems.has(_key)) {
        changed.push((0, _objectSpread2.default)((0, _objectSpread2.default)({}, _viewable), {}, {
          isViewable: false
        }));
      }
    }

    if (changed.length > 0) {
      this._viewableItems = nextItems;
      onViewableItemsChanged({
        viewableItems: Array.from(nextItems.values()),
        changed,
        viewabilityConfig: this._config
      });
    }
  }

}

function _isViewable(viewAreaMode, viewablePercentThreshold, top, bottom, viewportHeight, itemLength) {
  if (_isEntirelyVisible(top, bottom, viewportHeight)) {
    return true;
  } else {
    var pixels = _getPixelsVisible(top, bottom, viewportHeight);

    var percent = 100 * (viewAreaMode ? pixels / viewportHeight : pixels / itemLength);
    return percent >= viewablePercentThreshold;
  }
}

function _getPixelsVisible(top, bottom, viewportHeight) {
  var visibleHeight = Math.min(bottom, viewportHeight) - Math.max(top, 0);
  return Math.max(0, visibleHeight);
}

function _isEntirelyVisible(top, bottom, viewportHeight) {
  return top >= 0 && bottom <= viewportHeight && bottom > top;
}

var _default = ViewabilityHelper;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),

/***/ 39474:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 */


var _interopRequireDefault = (__webpack_require__(64836)["default"]);

exports.__esModule = true;
exports.computeWindowedRenderLimits = computeWindowedRenderLimits;
exports.elementsThatOverlapOffsets = elementsThatOverlapOffsets;
exports.keyExtractor = keyExtractor;
exports.newRangeCount = newRangeCount;

var _invariant = _interopRequireDefault(__webpack_require__(44505));

/**
 * Used to find the indices of the frames that overlap the given offsets. Useful for finding the
 * items that bound different windows of content, such as the visible area or the buffered overscan
 * area.
 */
function elementsThatOverlapOffsets(offsets, itemCount, getFrameMetrics) {
  var out = [];
  var outLength = 0;

  for (var ii = 0; ii < itemCount; ii++) {
    var frame = getFrameMetrics(ii);
    var trailingOffset = frame.offset + frame.length;

    for (var kk = 0; kk < offsets.length; kk++) {
      if (out[kk] == null && trailingOffset >= offsets[kk]) {
        out[kk] = ii;
        outLength++;

        if (kk === offsets.length - 1) {
          (0, _invariant.default)(outLength === offsets.length, 'bad offsets input, should be in increasing order: %s', JSON.stringify(offsets));
          return out;
        }
      }
    }
  }

  return out;
}
/**
 * Computes the number of elements in the `next` range that are new compared to the `prev` range.
 * Handy for calculating how many new items will be rendered when the render window changes so we
 * can restrict the number of new items render at once so that content can appear on the screen
 * faster.
 */


function newRangeCount(prev, next) {
  return next.last - next.first + 1 - Math.max(0, 1 + Math.min(next.last, prev.last) - Math.max(next.first, prev.first));
}
/**
 * Custom logic for determining which items should be rendered given the current frame and scroll
 * metrics, as well as the previous render state. The algorithm may evolve over time, but generally
 * prioritizes the visible area first, then expands that with overscan regions ahead and behind,
 * biased in the direction of scroll.
 */


function computeWindowedRenderLimits(data, getItemCount, maxToRenderPerBatch, windowSize, prev, getFrameMetricsApprox, scrollMetrics) {
  var itemCount = getItemCount(data);

  if (itemCount === 0) {
    return prev;
  }

  var offset = scrollMetrics.offset,
      velocity = scrollMetrics.velocity,
      visibleLength = scrollMetrics.visibleLength; // Start with visible area, then compute maximum overscan region by expanding from there, biased
  // in the direction of scroll. Total overscan area is capped, which should cap memory consumption
  // too.

  var visibleBegin = Math.max(0, offset);
  var visibleEnd = visibleBegin + visibleLength;
  var overscanLength = (windowSize - 1) * visibleLength; // Considering velocity seems to introduce more churn than it's worth.

  var leadFactor = 0.5; // Math.max(0, Math.min(1, velocity / 25 + 0.5));

  var fillPreference = velocity > 1 ? 'after' : velocity < -1 ? 'before' : 'none';
  var overscanBegin = Math.max(0, visibleBegin - (1 - leadFactor) * overscanLength);
  var overscanEnd = Math.max(0, visibleEnd + leadFactor * overscanLength);
  var lastItemOffset = getFrameMetricsApprox(itemCount - 1).offset;

  if (lastItemOffset < overscanBegin) {
    // Entire list is before our overscan window
    return {
      first: Math.max(0, itemCount - 1 - maxToRenderPerBatch),
      last: itemCount - 1
    };
  } // Find the indices that correspond to the items at the render boundaries we're targeting.


  var _elementsThatOverlapO = elementsThatOverlapOffsets([overscanBegin, visibleBegin, visibleEnd, overscanEnd], itemCount, getFrameMetricsApprox),
      overscanFirst = _elementsThatOverlapO[0],
      first = _elementsThatOverlapO[1],
      last = _elementsThatOverlapO[2],
      overscanLast = _elementsThatOverlapO[3];

  overscanFirst = overscanFirst == null ? 0 : overscanFirst;
  first = first == null ? Math.max(0, overscanFirst) : first;
  overscanLast = overscanLast == null ? itemCount - 1 : overscanLast;
  last = last == null ? Math.min(overscanLast, first + maxToRenderPerBatch - 1) : last;
  var visible = {
    first,
    last
  }; // We want to limit the number of new cells we're rendering per batch so that we can fill the
  // content on the screen quickly. If we rendered the entire overscan window at once, the user
  // could be staring at white space for a long time waiting for a bunch of offscreen content to
  // render.

  var newCellCount = newRangeCount(prev, visible);

  while (true) {
    if (first <= overscanFirst && last >= overscanLast) {
      // If we fill the entire overscan range, we're done.
      break;
    }

    var maxNewCells = newCellCount >= maxToRenderPerBatch;
    var firstWillAddMore = first <= prev.first || first > prev.last;
    var firstShouldIncrement = first > overscanFirst && (!maxNewCells || !firstWillAddMore);
    var lastWillAddMore = last >= prev.last || last < prev.first;
    var lastShouldIncrement = last < overscanLast && (!maxNewCells || !lastWillAddMore);

    if (maxNewCells && !firstShouldIncrement && !lastShouldIncrement) {
      // We only want to stop if we've hit maxNewCells AND we cannot increment first or last
      // without rendering new items. This let's us preserve as many already rendered items as
      // possible, reducing render churn and keeping the rendered overscan range as large as
      // possible.
      break;
    }

    if (firstShouldIncrement && !(fillPreference === 'after' && lastShouldIncrement && lastWillAddMore)) {
      if (firstWillAddMore) {
        newCellCount++;
      }

      first--;
    }

    if (lastShouldIncrement && !(fillPreference === 'before' && firstShouldIncrement && firstWillAddMore)) {
      if (lastWillAddMore) {
        newCellCount++;
      }

      last++;
    }
  }

  if (!(last >= first && first >= 0 && last < itemCount && first >= overscanFirst && last <= overscanLast && first <= visible.first && last >= visible.last)) {
    throw new Error('Bad window calculation ' + JSON.stringify({
      first,
      last,
      itemCount,
      overscanFirst,
      overscanLast,
      visible
    }));
  }

  return {
    first,
    last
  };
}

function keyExtractor(item, index) {
  if (typeof item === 'object' && (item == null ? void 0 : item.key) != null) {
    return item.key;
  }

  if (typeof item === 'object' && (item == null ? void 0 : item.id) != null) {
    return item.id;
  }

  return String(index);
}

/***/ }),

/***/ 71570:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var _interopRequireWildcard = (__webpack_require__(75263)["default"]);

var _interopRequireDefault = (__webpack_require__(64836)["default"]);

exports.__esModule = true;
exports.VirtualizedListCellContextProvider = VirtualizedListCellContextProvider;
exports.VirtualizedListContext = void 0;
exports.VirtualizedListContextProvider = VirtualizedListContextProvider;
exports.VirtualizedListContextResetter = VirtualizedListContextResetter;

var _objectSpread2 = _interopRequireDefault(__webpack_require__(42122));

var React = _interopRequireWildcard(__webpack_require__(16689));

/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 */
var __DEV__ = "production" !== 'production';

var VirtualizedListContext = /*#__PURE__*/React.createContext(null);
exports.VirtualizedListContext = VirtualizedListContext;

if (__DEV__) {
  VirtualizedListContext.displayName = 'VirtualizedListContext';
}
/**
 * Resets the context. Intended for use by portal-like components (e.g. Modal).
 */


function VirtualizedListContextResetter(_ref) {
  var children = _ref.children;
  return /*#__PURE__*/React.createElement(VirtualizedListContext.Provider, {
    value: null
  }, children);
}
/**
 * Sets the context with memoization. Intended to be used by `VirtualizedList`.
 */


function VirtualizedListContextProvider(_ref2) {
  var children = _ref2.children,
      value = _ref2.value;
  // Avoid setting a newly created context object if the values are identical.
  var context = (0, React.useMemo)(() => ({
    cellKey: null,
    getScrollMetrics: value.getScrollMetrics,
    horizontal: value.horizontal,
    getOutermostParentListRef: value.getOutermostParentListRef,
    getNestedChildState: value.getNestedChildState,
    registerAsNestedChild: value.registerAsNestedChild,
    unregisterAsNestedChild: value.unregisterAsNestedChild,
    debugInfo: {
      cellKey: value.debugInfo.cellKey,
      horizontal: value.debugInfo.horizontal,
      listKey: value.debugInfo.listKey,
      parent: value.debugInfo.parent
    }
  }), [value.getScrollMetrics, value.horizontal, value.getOutermostParentListRef, value.getNestedChildState, value.registerAsNestedChild, value.unregisterAsNestedChild, value.debugInfo.cellKey, value.debugInfo.horizontal, value.debugInfo.listKey, value.debugInfo.parent]);
  return /*#__PURE__*/React.createElement(VirtualizedListContext.Provider, {
    value: context
  }, children);
}
/**
 * Sets the `cellKey`. Intended to be used by `VirtualizedList` for each cell.
 */


function VirtualizedListCellContextProvider(_ref3) {
  var cellKey = _ref3.cellKey,
      children = _ref3.children;
  var context = (0, React.useContext)(VirtualizedListContext);
  return /*#__PURE__*/React.createElement(VirtualizedListContext.Provider, {
    value: context == null ? null : (0, _objectSpread2.default)((0, _objectSpread2.default)({}, context), {}, {
      cellKey
    })
  }, children);
}

/***/ }),

/***/ 71655:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireWildcard = (__webpack_require__(75263)["default"]);

var _interopRequireDefault = (__webpack_require__(64836)["default"]);

exports.__esModule = true;
exports["default"] = void 0;

var _createForOfIteratorHelperLoose2 = _interopRequireDefault(__webpack_require__(92535));

var _extends2 = _interopRequireDefault(__webpack_require__(10434));

var _objectSpread2 = _interopRequireDefault(__webpack_require__(42122));

var _Batchinator = _interopRequireDefault(__webpack_require__(96365));

var _FillRateHelper = _interopRequireDefault(__webpack_require__(41505));

var _findNodeHandle = _interopRequireDefault(__webpack_require__(10530));

var _RefreshControl = _interopRequireDefault(__webpack_require__(77818));

var _ScrollView = _interopRequireDefault(__webpack_require__(38174));

var _StyleSheet = _interopRequireDefault(__webpack_require__(84099));

var _View = _interopRequireDefault(__webpack_require__(79057));

var _ViewabilityHelper = _interopRequireDefault(__webpack_require__(15433));

var _infoLog = _interopRequireDefault(__webpack_require__(91455));

var _invariant = _interopRequireDefault(__webpack_require__(44505));

var _VirtualizeUtils = __webpack_require__(39474);

var React = _interopRequireWildcard(__webpack_require__(16689));

var _VirtualizedListContext = __webpack_require__(71570);

/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 */
var flattenStyle = _StyleSheet.default.flatten;

var __DEV__ = "production" !== 'production';

var _usedIndexForKey = false;
var _keylessItemComponentName = '';

/**
 * Default Props Helper Functions
 * Use the following helper functions for default values
 */
// horizontalOrDefault(this.props.horizontal)
function horizontalOrDefault(horizontal) {
  return horizontal !== null && horizontal !== void 0 ? horizontal : false;
} // initialNumToRenderOrDefault(this.props.initialNumToRenderOrDefault)


function initialNumToRenderOrDefault(initialNumToRender) {
  return initialNumToRender !== null && initialNumToRender !== void 0 ? initialNumToRender : 10;
} // maxToRenderPerBatchOrDefault(this.props.maxToRenderPerBatch)


function maxToRenderPerBatchOrDefault(maxToRenderPerBatch) {
  return maxToRenderPerBatch !== null && maxToRenderPerBatch !== void 0 ? maxToRenderPerBatch : 10;
} // onEndReachedThresholdOrDefault(this.props.onEndReachedThreshold)


function onEndReachedThresholdOrDefault(onEndReachedThreshold) {
  return onEndReachedThreshold !== null && onEndReachedThreshold !== void 0 ? onEndReachedThreshold : 2;
} // scrollEventThrottleOrDefault(this.props.scrollEventThrottle)


function scrollEventThrottleOrDefault(scrollEventThrottle) {
  return scrollEventThrottle !== null && scrollEventThrottle !== void 0 ? scrollEventThrottle : 50;
} // windowSizeOrDefault(this.props.windowSize)


function windowSizeOrDefault(windowSize) {
  return windowSize !== null && windowSize !== void 0 ? windowSize : 21;
}
/**
 * Base implementation for the more convenient [`<FlatList>`](https://reactnative.dev/docs/flatlist)
 * and [`<SectionList>`](https://reactnative.dev/docs/sectionlist) components, which are also better
 * documented. In general, this should only really be used if you need more flexibility than
 * `FlatList` provides, e.g. for use with immutable data instead of plain arrays.
 *
 * Virtualization massively improves memory consumption and performance of large lists by
 * maintaining a finite render window of active items and replacing all items outside of the render
 * window with appropriately sized blank space. The window adapts to scrolling behavior, and items
 * are rendered incrementally with low-pri (after any running interactions) if they are far from the
 * visible area, or with hi-pri otherwise to minimize the potential of seeing blank space.
 *
 * Some caveats:
 *
 * - Internal state is not preserved when content scrolls out of the render window. Make sure all
 *   your data is captured in the item data or external stores like Flux, Redux, or Relay.
 * - This is a `PureComponent` which means that it will not re-render if `props` remain shallow-
 *   equal. Make sure that everything your `renderItem` function depends on is passed as a prop
 *   (e.g. `extraData`) that is not `===` after updates, otherwise your UI may not update on
 *   changes. This includes the `data` prop and parent component state.
 * - In order to constrain memory and enable smooth scrolling, content is rendered asynchronously
 *   offscreen. This means it's possible to scroll faster than the fill rate ands momentarily see
 *   blank content. This is a tradeoff that can be adjusted to suit the needs of each application,
 *   and we are working on improving it behind the scenes.
 * - By default, the list looks for a `key` or `id` prop on each item and uses that for the React key.
 *   Alternatively, you can provide a custom `keyExtractor` prop.
 * - As an effort to remove defaultProps, use helper functions when referencing certain props
 *
 */


class VirtualizedList extends React.PureComponent {
  // scrollToEnd may be janky without getItemLayout prop
  scrollToEnd(params) {
    var animated = params ? params.animated : true;
    var veryLast = this.props.getItemCount(this.props.data) - 1;

    var frame = this._getFrameMetricsApprox(veryLast);

    var offset = Math.max(0, frame.offset + frame.length + this._footerLength - this._scrollMetrics.visibleLength);

    if (this._scrollRef == null) {
      return;
    }

    if (this._scrollRef.scrollTo == null) {
      console.warn('No scrollTo method provided. This may be because you have two nested ' + 'VirtualizedLists with the same orientation, or because you are ' + 'using a custom component that does not implement scrollTo.');
      return;
    }

    this._scrollRef.scrollTo(horizontalOrDefault(this.props.horizontal) ? {
      x: offset,
      animated
    } : {
      y: offset,
      animated
    });
  } // scrollToIndex may be janky without getItemLayout prop


  scrollToIndex(params) {
    var _this$props = this.props,
        data = _this$props.data,
        horizontal = _this$props.horizontal,
        getItemCount = _this$props.getItemCount,
        getItemLayout = _this$props.getItemLayout,
        onScrollToIndexFailed = _this$props.onScrollToIndexFailed;
    var animated = params.animated,
        index = params.index,
        viewOffset = params.viewOffset,
        viewPosition = params.viewPosition;
    (0, _invariant.default)(index >= 0, "scrollToIndex out of range: requested index " + index + " but minimum is 0");
    (0, _invariant.default)(getItemCount(data) >= 1, "scrollToIndex out of range: item length " + getItemCount(data) + " but minimum is 1");
    (0, _invariant.default)(index < getItemCount(data), "scrollToIndex out of range: requested index " + index + " is out of 0 to " + (getItemCount(data) - 1));

    if (!getItemLayout && index > this._highestMeasuredFrameIndex) {
      (0, _invariant.default)(!!onScrollToIndexFailed, 'scrollToIndex should be used in conjunction with getItemLayout or onScrollToIndexFailed, ' + 'otherwise there is no way to know the location of offscreen indices or handle failures.');
      onScrollToIndexFailed({
        averageItemLength: this._averageCellLength,
        highestMeasuredFrameIndex: this._highestMeasuredFrameIndex,
        index
      });
      return;
    }

    var frame = this._getFrameMetricsApprox(index);

    var offset = Math.max(0, frame.offset - (viewPosition || 0) * (this._scrollMetrics.visibleLength - frame.length)) - (viewOffset || 0);

    if (this._scrollRef == null) {
      return;
    }

    if (this._scrollRef.scrollTo == null) {
      console.warn('No scrollTo method provided. This may be because you have two nested ' + 'VirtualizedLists with the same orientation, or because you are ' + 'using a custom component that does not implement scrollTo.');
      return;
    }

    this._scrollRef.scrollTo(horizontal ? {
      x: offset,
      animated
    } : {
      y: offset,
      animated
    });
  } // scrollToItem may be janky without getItemLayout prop. Required linear scan through items -
  // use scrollToIndex instead if possible.


  scrollToItem(params) {
    var item = params.item;
    var _this$props2 = this.props,
        data = _this$props2.data,
        getItem = _this$props2.getItem,
        getItemCount = _this$props2.getItemCount;
    var itemCount = getItemCount(data);

    for (var _index = 0; _index < itemCount; _index++) {
      if (getItem(data, _index) === item) {
        this.scrollToIndex((0, _objectSpread2.default)((0, _objectSpread2.default)({}, params), {}, {
          index: _index
        }));
        break;
      }
    }
  }
  /**
   * Scroll to a specific content pixel offset in the list.
   *
   * Param `offset` expects the offset to scroll to.
   * In case of `horizontal` is true, the offset is the x-value,
   * in any other case the offset is the y-value.
   *
   * Param `animated` (`true` by default) defines whether the list
   * should do an animation while scrolling.
   */


  scrollToOffset(params) {
    var animated = params.animated,
        offset = params.offset;

    if (this._scrollRef == null) {
      return;
    }

    if (this._scrollRef.scrollTo == null) {
      console.warn('No scrollTo method provided. This may be because you have two nested ' + 'VirtualizedLists with the same orientation, or because you are ' + 'using a custom component that does not implement scrollTo.');
      return;
    }

    this._scrollRef.scrollTo(horizontalOrDefault(this.props.horizontal) ? {
      x: offset,
      animated
    } : {
      y: offset,
      animated
    });
  }

  recordInteraction() {
    this._nestedChildLists.forEach(childList => {
      childList.ref && childList.ref.recordInteraction();
    });

    this._viewabilityTuples.forEach(t => {
      t.viewabilityHelper.recordInteraction();
    });

    this._updateViewableItems(this.props.data);
  }

  flashScrollIndicators() {
    if (this._scrollRef == null) {
      return;
    }

    this._scrollRef.flashScrollIndicators();
  }
  /**
   * Provides a handle to the underlying scroll responder.
   * Note that `this._scrollRef` might not be a `ScrollView`, so we
   * need to check that it responds to `getScrollResponder` before calling it.
   */


  getScrollResponder() {
    if (this._scrollRef && this._scrollRef.getScrollResponder) {
      return this._scrollRef.getScrollResponder();
    }
  }

  getScrollableNode() {
    if (this._scrollRef && this._scrollRef.getScrollableNode) {
      return this._scrollRef.getScrollableNode();
    } else {
      return (0, _findNodeHandle.default)(this._scrollRef);
    }
  }

  getScrollRef() {
    if (this._scrollRef && this._scrollRef.getScrollRef) {
      return this._scrollRef.getScrollRef();
    } else {
      return this._scrollRef;
    }
  }

  setNativeProps(props) {
    if (this._scrollRef) {
      this._scrollRef.setNativeProps(props);
    }
  }

  _getCellKey() {
    var _this$context;

    return ((_this$context = this.context) == null ? void 0 : _this$context.cellKey) || 'rootList';
  }

  _getListKey() {
    return this.props.listKey || this._getCellKey();
  }

  _getDebugInfo() {
    var _this$context2;

    return {
      listKey: this._getListKey(),
      cellKey: this._getCellKey(),
      horizontal: horizontalOrDefault(this.props.horizontal),
      parent: (_this$context2 = this.context) == null ? void 0 : _this$context2.debugInfo
    };
  }

  hasMore() {
    return this._hasMore;
  }

  constructor(_props) {
    var _this$props$updateCel;

    super(_props);

    this._getScrollMetrics = () => {
      return this._scrollMetrics;
    };

    this._getOutermostParentListRef = () => {
      if (this._isNestedWithSameOrientation()) {
        return this.context.getOutermostParentListRef();
      } else {
        return this;
      }
    };

    this._getNestedChildState = key => {
      var existingChildData = this._nestedChildLists.get(key);

      return existingChildData && existingChildData.state;
    };

    this._registerAsNestedChild = childList => {
      // Register the mapping between this child key and the cellKey for its cell
      var childListsInCell = this._cellKeysToChildListKeys.get(childList.cellKey) || new Set();
      childListsInCell.add(childList.key);

      this._cellKeysToChildListKeys.set(childList.cellKey, childListsInCell);

      var existingChildData = this._nestedChildLists.get(childList.key);

      if (existingChildData && existingChildData.ref !== null) {
        console.error('A VirtualizedList contains a cell which itself contains ' + 'more than one VirtualizedList of the same orientation as the parent ' + 'list. You must pass a unique listKey prop to each sibling list.\n\n' + describeNestedLists((0, _objectSpread2.default)((0, _objectSpread2.default)({}, childList), {}, {
          // We're called from the child's componentDidMount, so it's safe to
          // read the child's props here (albeit weird).
          horizontal: !!childList.ref.props.horizontal
        })));
      }

      this._nestedChildLists.set(childList.key, {
        ref: childList.ref,
        state: null
      });

      if (this._hasInteracted) {
        childList.ref.recordInteraction();
      }
    };

    this._unregisterAsNestedChild = childList => {
      this._nestedChildLists.set(childList.key, {
        ref: null,
        state: childList.state
      });
    };

    this._onUpdateSeparators = (keys, newProps) => {
      keys.forEach(key => {
        var ref = key != null && this._cellRefs[key];
        ref && ref.updateSeparatorProps(newProps);
      });
    };

    this._getSpacerKey = isVertical => isVertical ? 'height' : 'width';

    this._averageCellLength = 0;
    this._cellKeysToChildListKeys = new Map();
    this._cellRefs = {};
    this._frames = {};
    this._footerLength = 0;
    this._hasDoneInitialScroll = false;
    this._hasInteracted = false;
    this._hasMore = false;
    this._hasWarned = {};
    this._headerLength = 0;
    this._hiPriInProgress = false;
    this._highestMeasuredFrameIndex = 0;
    this._indicesToKeys = new Map();
    this._nestedChildLists = new Map();
    this._offsetFromParentVirtualizedList = 0;
    this._prevParentOffset = 0;
    this._scrollMetrics = {
      contentLength: 0,
      dOffset: 0,
      dt: 10,
      offset: 0,
      timestamp: 0,
      velocity: 0,
      visibleLength: 0
    };
    this._scrollRef = null;
    this._sentEndForContentLength = 0;
    this._totalCellLength = 0;
    this._totalCellsMeasured = 0;
    this._viewabilityTuples = [];

    this._captureScrollRef = ref => {
      this._scrollRef = ref;
    };

    this._defaultRenderScrollComponent = props => {
      var onRefresh = props.onRefresh;

      if (this._isNestedWithSameOrientation()) {
        // $FlowFixMe[prop-missing] - Typing ReactNativeComponent revealed errors
        return /*#__PURE__*/React.createElement(_View.default, props);
      } else if (onRefresh) {
        var _props$refreshing;

        (0, _invariant.default)(typeof props.refreshing === 'boolean', '`refreshing` prop must be set as a boolean in order to use `onRefresh`, but got `' + JSON.stringify((_props$refreshing = props.refreshing) !== null && _props$refreshing !== void 0 ? _props$refreshing : 'undefined') + '`');
        return (
          /*#__PURE__*/
          // $FlowFixMe[prop-missing] Invalid prop usage
          React.createElement(_ScrollView.default, (0, _extends2.default)({}, props, {
            refreshControl: props.refreshControl == null ? /*#__PURE__*/React.createElement(_RefreshControl.default, {
              refreshing: props.refreshing,
              onRefresh: onRefresh,
              progressViewOffset: props.progressViewOffset
            }) : props.refreshControl
          }))
        );
      } else {
        // $FlowFixMe[prop-missing] Invalid prop usage
        return /*#__PURE__*/React.createElement(_ScrollView.default, props);
      }
    };

    this._onCellUnmount = cellKey => {
      var curr = this._frames[cellKey];

      if (curr) {
        this._frames[cellKey] = (0, _objectSpread2.default)((0, _objectSpread2.default)({}, curr), {}, {
          inLayout: false
        });
      }
    };

    this._onLayout = e => {
      if (this._isNestedWithSameOrientation()) {
        // Need to adjust our scroll metrics to be relative to our containing
        // VirtualizedList before we can make claims about list item viewability
        this.measureLayoutRelativeToContainingList();
      } else {
        this._scrollMetrics.visibleLength = this._selectLength(e.nativeEvent.layout);
      }

      this.props.onLayout && this.props.onLayout(e);

      this._scheduleCellsToRenderUpdate();

      this._maybeCallOnEndReached();
    };

    this._onLayoutEmpty = e => {
      this.props.onLayout && this.props.onLayout(e);
    };

    this._onLayoutFooter = e => {
      this._triggerRemeasureForChildListsInCell(this._getFooterCellKey());

      this._footerLength = this._selectLength(e.nativeEvent.layout);
    };

    this._onLayoutHeader = e => {
      this._headerLength = this._selectLength(e.nativeEvent.layout);
    };

    this._onContentSizeChange = (width, height) => {
      if (width > 0 && height > 0 && this.props.initialScrollIndex != null && this.props.initialScrollIndex > 0 && !this._hasDoneInitialScroll) {
        if (this.props.contentOffset == null) {
          this.scrollToIndex({
            animated: false,
            index: this.props.initialScrollIndex
          });
        }

        this._hasDoneInitialScroll = true;
      }

      if (this.props.onContentSizeChange) {
        this.props.onContentSizeChange(width, height);
      }

      this._scrollMetrics.contentLength = this._selectLength({
        height,
        width
      });

      this._scheduleCellsToRenderUpdate();

      this._maybeCallOnEndReached();
    };

    this._convertParentScrollMetrics = metrics => {
      // Offset of the top of the nested list relative to the top of its parent's viewport
      var offset = metrics.offset - this._offsetFromParentVirtualizedList; // Child's visible length is the same as its parent's

      var visibleLength = metrics.visibleLength;
      var dOffset = offset - this._scrollMetrics.offset;
      var contentLength = this._scrollMetrics.contentLength;
      return {
        visibleLength,
        contentLength,
        offset,
        dOffset
      };
    };

    this._onScroll = e => {
      this._nestedChildLists.forEach(childList => {
        childList.ref && childList.ref._onScroll(e);
      });

      if (this.props.onScroll) {
        this.props.onScroll(e);
      }

      var timestamp = e.timeStamp;

      var visibleLength = this._selectLength(e.nativeEvent.layoutMeasurement);

      var contentLength = this._selectLength(e.nativeEvent.contentSize);

      var offset = this._selectOffset(e.nativeEvent.contentOffset);

      var dOffset = offset - this._scrollMetrics.offset;

      if (this._isNestedWithSameOrientation()) {
        if (this._scrollMetrics.contentLength === 0) {
          // Ignore scroll events until onLayout has been called and we
          // know our offset from our offset from our parent
          return;
        }

        var _this$_convertParentS = this._convertParentScrollMetrics({
          visibleLength,
          offset
        });

        visibleLength = _this$_convertParentS.visibleLength;
        contentLength = _this$_convertParentS.contentLength;
        offset = _this$_convertParentS.offset;
        dOffset = _this$_convertParentS.dOffset;
      }

      var dt = this._scrollMetrics.timestamp ? Math.max(1, timestamp - this._scrollMetrics.timestamp) : 1;
      var velocity = dOffset / dt;

      if (dt > 500 && this._scrollMetrics.dt > 500 && contentLength > 5 * visibleLength && !this._hasWarned.perf) {
        (0, _infoLog.default)('VirtualizedList: You have a large list that is slow to update - make sure your ' + 'renderItem function renders components that follow React performance best practices ' + 'like PureComponent, shouldComponentUpdate, etc.', {
          dt,
          prevDt: this._scrollMetrics.dt,
          contentLength
        });
        this._hasWarned.perf = true;
      }

      this._scrollMetrics = {
        contentLength,
        dt,
        dOffset,
        offset,
        timestamp,
        velocity,
        visibleLength
      };

      this._updateViewableItems(this.props.data);

      if (!this.props) {
        return;
      }

      this._maybeCallOnEndReached();

      if (velocity !== 0) {
        this._fillRateHelper.activate();
      }

      this._computeBlankness();

      this._scheduleCellsToRenderUpdate();
    };

    this._onScrollBeginDrag = e => {
      this._nestedChildLists.forEach(childList => {
        childList.ref && childList.ref._onScrollBeginDrag(e);
      });

      this._viewabilityTuples.forEach(tuple => {
        tuple.viewabilityHelper.recordInteraction();
      });

      this._hasInteracted = true;
      this.props.onScrollBeginDrag && this.props.onScrollBeginDrag(e);
    };

    this._onScrollEndDrag = e => {
      this._nestedChildLists.forEach(childList => {
        childList.ref && childList.ref._onScrollEndDrag(e);
      });

      var velocity = e.nativeEvent.velocity;

      if (velocity) {
        this._scrollMetrics.velocity = this._selectOffset(velocity);
      }

      this._computeBlankness();

      this.props.onScrollEndDrag && this.props.onScrollEndDrag(e);
    };

    this._onMomentumScrollBegin = e => {
      this._nestedChildLists.forEach(childList => {
        childList.ref && childList.ref._onMomentumScrollBegin(e);
      });

      this.props.onMomentumScrollBegin && this.props.onMomentumScrollBegin(e);
    };

    this._onMomentumScrollEnd = e => {
      this._nestedChildLists.forEach(childList => {
        childList.ref && childList.ref._onMomentumScrollEnd(e);
      });

      this._scrollMetrics.velocity = 0;

      this._computeBlankness();

      this.props.onMomentumScrollEnd && this.props.onMomentumScrollEnd(e);
    };

    this._updateCellsToRender = () => {
      var _this$props3 = this.props,
          data = _this$props3.data,
          getItemCount = _this$props3.getItemCount,
          _onEndReachedThreshold = _this$props3.onEndReachedThreshold;
      var onEndReachedThreshold = onEndReachedThresholdOrDefault(_onEndReachedThreshold);

      var isVirtualizationDisabled = this._isVirtualizationDisabled();

      this._updateViewableItems(data);

      if (!data) {
        return;
      }

      this.setState(state => {
        var newState;
        var _this$_scrollMetrics = this._scrollMetrics,
            contentLength = _this$_scrollMetrics.contentLength,
            offset = _this$_scrollMetrics.offset,
            visibleLength = _this$_scrollMetrics.visibleLength;

        if (!isVirtualizationDisabled) {
          // If we run this with bogus data, we'll force-render window {first: 0, last: 0},
          // and wipe out the initialNumToRender rendered elements.
          // So let's wait until the scroll view metrics have been set up. And until then,
          // we will trust the initialNumToRender suggestion
          if (visibleLength > 0 && contentLength > 0) {
            // If we have a non-zero initialScrollIndex and run this before we've scrolled,
            // we'll wipe out the initialNumToRender rendered elements starting at initialScrollIndex.
            // So let's wait until we've scrolled the view to the right place. And until then,
            // we will trust the initialScrollIndex suggestion.
            if (!this.props.initialScrollIndex || this._scrollMetrics.offset) {
              newState = (0, _VirtualizeUtils.computeWindowedRenderLimits)(this.props.data, this.props.getItemCount, maxToRenderPerBatchOrDefault(this.props.maxToRenderPerBatch), windowSizeOrDefault(this.props.windowSize), state, this._getFrameMetricsApprox, this._scrollMetrics);
            }
          }
        } else {
          var distanceFromEnd = contentLength - visibleLength - offset;
          var renderAhead = distanceFromEnd < onEndReachedThreshold * visibleLength ? maxToRenderPerBatchOrDefault(this.props.maxToRenderPerBatch) : 0;
          newState = {
            first: 0,
            last: Math.min(state.last + renderAhead, getItemCount(data) - 1)
          };
        }

        if (newState && this._nestedChildLists.size > 0) {
          var newFirst = newState.first;
          var newLast = newState.last; // If some cell in the new state has a child list in it, we should only render
          // up through that item, so that we give that list a chance to render.
          // Otherwise there's churn from multiple child lists mounting and un-mounting
          // their items.

          for (var ii = newFirst; ii <= newLast; ii++) {
            var cellKeyForIndex = this._indicesToKeys.get(ii);

            var childListKeys = cellKeyForIndex && this._cellKeysToChildListKeys.get(cellKeyForIndex);

            if (!childListKeys) {
              continue;
            }

            var someChildHasMore = false; // For each cell, need to check whether any child list in it has more elements to render

            for (var _iterator = (0, _createForOfIteratorHelperLoose2.default)(childListKeys), _step; !(_step = _iterator()).done;) {
              var childKey = _step.value;

              var childList = this._nestedChildLists.get(childKey);

              if (childList && childList.ref && childList.ref.hasMore()) {
                someChildHasMore = true;
                break;
              }
            }

            if (someChildHasMore) {
              // $FlowFixMe[incompatible-use] The newState definitely exists past "if (newState &&"
              newState.last = ii;
              break;
            }
          }
        }

        if (newState != null && newState.first === state.first && newState.last === state.last) {
          newState = null;
        }

        return newState;
      });
    };

    this._createViewToken = (index, isViewable) => {
      var _this$props4 = this.props,
          data = _this$props4.data,
          getItem = _this$props4.getItem;
      var item = getItem(data, index);
      return {
        index,
        item,
        key: this._keyExtractor(item, index),
        isViewable
      };
    };

    this._getFrameMetricsApprox = index => {
      var frame = this._getFrameMetrics(index);

      if (frame && frame.index === index) {
        // check for invalid frames due to row re-ordering
        return frame;
      } else {
        var getItemLayout = this.props.getItemLayout;
        (0, _invariant.default)(!getItemLayout, 'Should not have to estimate frames when a measurement metrics function is provided');
        return {
          length: this._averageCellLength,
          offset: this._averageCellLength * index
        };
      }
    };

    this._getFrameMetrics = index => {
      var _this$props5 = this.props,
          data = _this$props5.data,
          getItem = _this$props5.getItem,
          getItemCount = _this$props5.getItemCount,
          getItemLayout = _this$props5.getItemLayout;
      (0, _invariant.default)(getItemCount(data) > index, 'Tried to get frame for out of range index ' + index);
      var item = getItem(data, index);

      var frame = item && this._frames[this._keyExtractor(item, index)];

      if (!frame || frame.index !== index) {
        if (getItemLayout) {
          frame = getItemLayout(data, index);
        }
      }
      /* $FlowFixMe[prop-missing] (>=0.63.0 site=react_native_fb) This comment
       * suppresses an error found when Flow v0.63 was deployed. To see the error
       * delete this comment and run Flow. */


      return frame;
    };

    (0, _invariant.default)( // $FlowFixMe[prop-missing]
    !_props.onScroll || !_props.onScroll.__isNative, 'Components based on VirtualizedList must be wrapped with Animated.createAnimatedComponent ' + 'to support native onScroll events with useNativeDriver');
    (0, _invariant.default)(windowSizeOrDefault(_props.windowSize) > 0, 'VirtualizedList: The windowSize prop must be present and set to a value greater than 0.');
    this._fillRateHelper = new _FillRateHelper.default(this._getFrameMetrics);
    this._updateCellsToRenderBatcher = new _Batchinator.default(this._updateCellsToRender, (_this$props$updateCel = this.props.updateCellsBatchingPeriod) !== null && _this$props$updateCel !== void 0 ? _this$props$updateCel : 50);

    if (this.props.viewabilityConfigCallbackPairs) {
      this._viewabilityTuples = this.props.viewabilityConfigCallbackPairs.map(pair => ({
        viewabilityHelper: new _ViewabilityHelper.default(pair.viewabilityConfig),
        onViewableItemsChanged: pair.onViewableItemsChanged
      }));
    } else if (this.props.onViewableItemsChanged) {
      this._viewabilityTuples.push({
        viewabilityHelper: new _ViewabilityHelper.default(this.props.viewabilityConfig),
        // $FlowFixMe[incompatible-call]
        onViewableItemsChanged: this.props.onViewableItemsChanged
      });
    }

    var initialState = {
      first: this.props.initialScrollIndex || 0,
      last: Math.min(this.props.getItemCount(this.props.data), (this.props.initialScrollIndex || 0) + initialNumToRenderOrDefault(this.props.initialNumToRender)) - 1
    };

    if (this._isNestedWithSameOrientation()) {
      var storedState = this.context.getNestedChildState(this._getListKey());

      if (storedState) {
        initialState = storedState;
        this.state = storedState;
        this._frames = storedState.frames;
      }
    } // REACT-NATIVE-WEB patch to preserve during future RN merges: Support inverted wheel scroller.
    // For issue https://github.com/necolas/react-native-web/issues/995


    this.invertedWheelEventHandler = ev => {
      if (this.props.inverted && this._scrollRef && this._scrollRef.getScrollableNode) {
        var node = this._scrollRef.getScrollableNode();

        if (this.props.horizontal) {
          node.scrollLeft -= ev.deltaX || ev.wheelDeltaX;
        } else {
          node.scrollTop -= ev.deltaY || ev.wheelDeltaY;
        }

        ev.preventDefault();
      }
    };

    this.state = initialState;
  }

  componentDidMount() {
    if (this._isNestedWithSameOrientation()) {
      this.context.registerAsNestedChild({
        cellKey: this._getCellKey(),
        key: this._getListKey(),
        ref: this,
        // NOTE: When the child mounts (here) it's not necessarily safe to read
        // the parent's props. This is why we explicitly propagate debugInfo
        // "down" via context and "up" again via this method call on the
        // parent.
        parentDebugInfo: this.context.debugInfo
      });
    } // REACT-NATIVE-WEB patch to preserve during future RN merges: Support inverted wheel scroller.


    this.setupWebWheelHandler();
  }

  componentWillUnmount() {
    if (this._isNestedWithSameOrientation()) {
      this.context.unregisterAsNestedChild({
        key: this._getListKey(),
        state: {
          first: this.state.first,
          last: this.state.last,
          frames: this._frames
        }
      });
    }

    this._updateViewableItems(null);

    this._updateCellsToRenderBatcher.dispose({
      abort: true
    });

    this._viewabilityTuples.forEach(tuple => {
      tuple.viewabilityHelper.dispose();
    });

    this._fillRateHelper.deactivateAndFlush(); // REACT-NATIVE-WEB patch to preserve during future RN merges: Support inverted wheel scroller.


    this.teardownWebWheelHandler();
  } // REACT-NATIVE-WEB patch to preserve during future RN merges: Support inverted wheel scroller.


  setupWebWheelHandler() {
    if (this._scrollRef && this._scrollRef.getScrollableNode) {
      this._scrollRef.getScrollableNode().addEventListener('wheel', this.invertedWheelEventHandler);
    } else {
      setTimeout(() => this.setupWebWheelHandler(), 50);
      return;
    }
  } // REACT-NATIVE-WEB patch to preserve during future RN merges: Support inverted wheel scroller.


  teardownWebWheelHandler() {
    if (this._scrollRef && this._scrollRef.getScrollableNode) {
      this._scrollRef.getScrollableNode().removeEventListener('wheel', this.invertedWheelEventHandler);
    }
  }

  static getDerivedStateFromProps(newProps, prevState) {
    var data = newProps.data,
        getItemCount = newProps.getItemCount;
    var maxToRenderPerBatch = maxToRenderPerBatchOrDefault(newProps.maxToRenderPerBatch); // first and last could be stale (e.g. if a new, shorter items props is passed in), so we make
    // sure we're rendering a reasonable range here.

    return {
      first: Math.max(0, Math.min(prevState.first, getItemCount(data) - 1 - maxToRenderPerBatch)),
      last: Math.max(0, Math.min(prevState.last, getItemCount(data) - 1))
    };
  }

  _pushCells(cells, stickyHeaderIndices, stickyIndicesFromProps, first, last, inversionStyle) {
    var _this = this;

    var _this$props6 = this.props,
        CellRendererComponent = _this$props6.CellRendererComponent,
        ItemSeparatorComponent = _this$props6.ItemSeparatorComponent,
        data = _this$props6.data,
        getItem = _this$props6.getItem,
        getItemCount = _this$props6.getItemCount,
        horizontal = _this$props6.horizontal;
    var stickyOffset = this.props.ListHeaderComponent ? 1 : 0;
    var end = getItemCount(data) - 1;
    var prevCellKey;
    last = Math.min(end, last);

    var _loop = function _loop(ii) {
      var item = getItem(data, ii);

      var key = _this._keyExtractor(item, ii);

      _this._indicesToKeys.set(ii, key);

      if (stickyIndicesFromProps.has(ii + stickyOffset)) {
        stickyHeaderIndices.push(cells.length);
      }

      cells.push( /*#__PURE__*/React.createElement(CellRenderer, {
        CellRendererComponent: CellRendererComponent,
        ItemSeparatorComponent: ii < end ? ItemSeparatorComponent : undefined,
        cellKey: key,
        fillRateHelper: _this._fillRateHelper,
        horizontal: horizontal,
        index: ii,
        inversionStyle: inversionStyle,
        item: item,
        key: key,
        prevCellKey: prevCellKey,
        onUpdateSeparators: _this._onUpdateSeparators,
        onLayout: e => _this._onCellLayout(e, key, ii),
        onUnmount: _this._onCellUnmount,
        parentProps: _this.props,
        ref: _ref => {
          _this._cellRefs[key] = _ref;
        }
      }));
      prevCellKey = key;
    };

    for (var ii = first; ii <= last; ii++) {
      _loop(ii);
    }
  }

  _isVirtualizationDisabled() {
    return this.props.disableVirtualization || false;
  }

  _isNestedWithSameOrientation() {
    var nestedContext = this.context;
    return !!(nestedContext && !!nestedContext.horizontal === horizontalOrDefault(this.props.horizontal));
  }

  _keyExtractor(item, index) {
    if (this.props.keyExtractor != null) {
      return this.props.keyExtractor(item, index);
    }

    var key = (0, _VirtualizeUtils.keyExtractor)(item, index);

    if (key === String(index)) {
      _usedIndexForKey = true;

      if (item.type && item.type.displayName) {
        _keylessItemComponentName = item.type.displayName;
      }
    }

    return key;
  }

  render() {
    if (__DEV__) {
      var flatStyles = flattenStyle(this.props.contentContainerStyle);

      if (flatStyles != null && flatStyles.flexWrap === 'wrap') {
        console.warn('`flexWrap: `wrap`` is not supported with the `VirtualizedList` components.' + 'Consider using `numColumns` with `FlatList` instead.');
      }
    }

    var _this$props7 = this.props,
        ListEmptyComponent = _this$props7.ListEmptyComponent,
        ListFooterComponent = _this$props7.ListFooterComponent,
        ListHeaderComponent = _this$props7.ListHeaderComponent;
    var _this$props8 = this.props,
        data = _this$props8.data,
        horizontal = _this$props8.horizontal;

    var isVirtualizationDisabled = this._isVirtualizationDisabled();

    var inversionStyle = this.props.inverted ? horizontalOrDefault(this.props.horizontal) ? styles.horizontallyInverted : styles.verticallyInverted : null;
    var cells = [];
    var stickyIndicesFromProps = new Set(this.props.stickyHeaderIndices);
    var stickyHeaderIndices = [];

    if (ListHeaderComponent) {
      if (stickyIndicesFromProps.has(0)) {
        stickyHeaderIndices.push(0);
      }

      var element = /*#__PURE__*/React.isValidElement(ListHeaderComponent) ? ListHeaderComponent :
      /*#__PURE__*/
      // $FlowFixMe[not-a-component]
      // $FlowFixMe[incompatible-type-arg]
      React.createElement(ListHeaderComponent, null);
      cells.push( /*#__PURE__*/React.createElement(_VirtualizedListContext.VirtualizedListCellContextProvider, {
        cellKey: this._getCellKey() + '-header',
        key: "$header"
      }, /*#__PURE__*/React.createElement(_View.default, {
        onLayout: this._onLayoutHeader,
        style: _StyleSheet.default.compose(inversionStyle, this.props.ListHeaderComponentStyle)
      }, // $FlowFixMe[incompatible-type] - Typing ReactNativeComponent revealed errors
      element)));
    }

    var itemCount = this.props.getItemCount(data);

    if (itemCount > 0) {
      _usedIndexForKey = false;
      _keylessItemComponentName = '';

      var spacerKey = this._getSpacerKey(!horizontal);

      var lastInitialIndex = this.props.initialScrollIndex ? -1 : initialNumToRenderOrDefault(this.props.initialNumToRender) - 1;
      var _this$state = this.state,
          first = _this$state.first,
          last = _this$state.last;

      this._pushCells(cells, stickyHeaderIndices, stickyIndicesFromProps, 0, lastInitialIndex, inversionStyle);

      var firstAfterInitial = Math.max(lastInitialIndex + 1, first);

      if (!isVirtualizationDisabled && first > lastInitialIndex + 1) {
        var insertedStickySpacer = false;

        if (stickyIndicesFromProps.size > 0) {
          var stickyOffset = ListHeaderComponent ? 1 : 0; // See if there are any sticky headers in the virtualized space that we need to render.

          for (var ii = firstAfterInitial - 1; ii > lastInitialIndex; ii--) {
            if (stickyIndicesFromProps.has(ii + stickyOffset)) {
              var initBlock = this._getFrameMetricsApprox(lastInitialIndex);

              var stickyBlock = this._getFrameMetricsApprox(ii);

              var leadSpace = stickyBlock.offset - initBlock.offset - (this.props.initialScrollIndex ? 0 : initBlock.length);
              cells.push( /*#__PURE__*/React.createElement(_View.default, {
                key: "$sticky_lead",
                style: {
                  [spacerKey]: leadSpace
                }
              }));

              this._pushCells(cells, stickyHeaderIndices, stickyIndicesFromProps, ii, ii, inversionStyle);

              var trailSpace = this._getFrameMetricsApprox(first).offset - (stickyBlock.offset + stickyBlock.length);
              cells.push( /*#__PURE__*/React.createElement(_View.default, {
                key: "$sticky_trail",
                style: {
                  [spacerKey]: trailSpace
                }
              }));
              insertedStickySpacer = true;
              break;
            }
          }
        }

        if (!insertedStickySpacer) {
          var _initBlock = this._getFrameMetricsApprox(lastInitialIndex);

          var firstSpace = this._getFrameMetricsApprox(first).offset - (_initBlock.offset + _initBlock.length);

          cells.push( /*#__PURE__*/React.createElement(_View.default, {
            key: "$lead_spacer",
            style: {
              [spacerKey]: firstSpace
            }
          }));
        }
      }

      this._pushCells(cells, stickyHeaderIndices, stickyIndicesFromProps, firstAfterInitial, last, inversionStyle);

      if (!this._hasWarned.keys && _usedIndexForKey) {
        console.warn('VirtualizedList: missing keys for items, make sure to specify a key or id property on each ' + 'item or provide a custom keyExtractor.', _keylessItemComponentName);
        this._hasWarned.keys = true;
      }

      if (!isVirtualizationDisabled && last < itemCount - 1) {
        var lastFrame = this._getFrameMetricsApprox(last); // Without getItemLayout, we limit our tail spacer to the _highestMeasuredFrameIndex to
        // prevent the user for hyperscrolling into un-measured area because otherwise content will
        // likely jump around as it renders in above the viewport.


        var end = this.props.getItemLayout ? itemCount - 1 : Math.min(itemCount - 1, this._highestMeasuredFrameIndex);

        var endFrame = this._getFrameMetricsApprox(end);

        var tailSpacerLength = endFrame.offset + endFrame.length - (lastFrame.offset + lastFrame.length);
        cells.push( /*#__PURE__*/React.createElement(_View.default, {
          key: "$tail_spacer",
          style: {
            [spacerKey]: tailSpacerLength
          }
        }));
      }
    } else if (ListEmptyComponent) {
      var _element = /*#__PURE__*/React.isValidElement(ListEmptyComponent) ? ListEmptyComponent :
      /*#__PURE__*/
      // $FlowFixMe[not-a-component]
      // $FlowFixMe[incompatible-type-arg]
      React.createElement(ListEmptyComponent, null);

      cells.push( /*#__PURE__*/React.cloneElement(_element, {
        key: '$empty',
        onLayout: event => {
          this._onLayoutEmpty(event);

          if (_element.props.onLayout) {
            _element.props.onLayout(event);
          }
        },
        style: _StyleSheet.default.compose(inversionStyle, _element.props.style)
      }));
    }

    if (ListFooterComponent) {
      var _element2 = /*#__PURE__*/React.isValidElement(ListFooterComponent) ? ListFooterComponent :
      /*#__PURE__*/
      // $FlowFixMe[not-a-component]
      // $FlowFixMe[incompatible-type-arg]
      React.createElement(ListFooterComponent, null);

      cells.push( /*#__PURE__*/React.createElement(_VirtualizedListContext.VirtualizedListCellContextProvider, {
        cellKey: this._getFooterCellKey(),
        key: "$footer"
      }, /*#__PURE__*/React.createElement(_View.default, {
        onLayout: this._onLayoutFooter,
        style: _StyleSheet.default.compose(inversionStyle, this.props.ListFooterComponentStyle)
      }, // $FlowFixMe[incompatible-type] - Typing ReactNativeComponent revealed errors
      _element2)));
    }

    var scrollProps = (0, _objectSpread2.default)((0, _objectSpread2.default)({}, this.props), {}, {
      onContentSizeChange: this._onContentSizeChange,
      onLayout: this._onLayout,
      onScroll: this._onScroll,
      onScrollBeginDrag: this._onScrollBeginDrag,
      onScrollEndDrag: this._onScrollEndDrag,
      onMomentumScrollBegin: this._onMomentumScrollBegin,
      onMomentumScrollEnd: this._onMomentumScrollEnd,
      scrollEventThrottle: scrollEventThrottleOrDefault(this.props.scrollEventThrottle),
      // TODO: Android support
      invertStickyHeaders: this.props.invertStickyHeaders !== undefined ? this.props.invertStickyHeaders : this.props.inverted,
      stickyHeaderIndices,
      style: inversionStyle ? [inversionStyle, this.props.style] : this.props.style
    });
    this._hasMore = this.state.last < this.props.getItemCount(this.props.data) - 1;
    var innerRet = /*#__PURE__*/React.createElement(_VirtualizedListContext.VirtualizedListContextProvider, {
      value: {
        cellKey: null,
        getScrollMetrics: this._getScrollMetrics,
        horizontal: horizontalOrDefault(this.props.horizontal),
        getOutermostParentListRef: this._getOutermostParentListRef,
        getNestedChildState: this._getNestedChildState,
        registerAsNestedChild: this._registerAsNestedChild,
        unregisterAsNestedChild: this._unregisterAsNestedChild,
        debugInfo: this._getDebugInfo()
      }
    }, /*#__PURE__*/React.cloneElement((this.props.renderScrollComponent || this._defaultRenderScrollComponent)(scrollProps), {
      ref: this._captureScrollRef
    }, cells));
    var ret = innerRet;
    /* https://github.com/necolas/react-native-web/issues/2239: Re-enable when ScrollView.Context.Consumer is available.
    if (__DEV__) {
      ret = (
        <ScrollView.Context.Consumer>
          {scrollContext => {
            if (
              scrollContext != null &&
              !scrollContext.horizontal ===
                !horizontalOrDefault(this.props.horizontal) &&
              !this._hasWarned.nesting &&
              this.context == null
            ) {
              // TODO (T46547044): use React.warn once 16.9 is sync'd: https://github.com/facebook/react/pull/15170
              console.error(
                'VirtualizedLists should never be nested inside plain ScrollViews with the same ' +
                  'orientation because it can break windowing and other functionality - use another ' +
                  'VirtualizedList-backed container instead.',
              );
              this._hasWarned.nesting = true;
            }
            return innerRet;
          }}
        </ScrollView.Context.Consumer>
      );
    }*/

    if (this.props.debug) {
      return /*#__PURE__*/React.createElement(_View.default, {
        style: styles.debug
      }, ret, this._renderDebugOverlay());
    } else {
      return ret;
    }
  }

  componentDidUpdate(prevProps) {
    var _this$props9 = this.props,
        data = _this$props9.data,
        extraData = _this$props9.extraData;

    if (data !== prevProps.data || extraData !== prevProps.extraData) {
      // clear the viewableIndices cache to also trigger
      // the onViewableItemsChanged callback with the new data
      this._viewabilityTuples.forEach(tuple => {
        tuple.viewabilityHelper.resetViewableIndices();
      });
    } // The `this._hiPriInProgress` is guaranteeing a hiPri cell update will only happen
    // once per fiber update. The `_scheduleCellsToRenderUpdate` will set it to true
    // if a hiPri update needs to perform. If `componentDidUpdate` is triggered with
    // `this._hiPriInProgress=true`, means it's triggered by the hiPri update. The
    // `_scheduleCellsToRenderUpdate` will check this condition and not perform
    // another hiPri update.


    var hiPriInProgress = this._hiPriInProgress;

    this._scheduleCellsToRenderUpdate(); // Make sure setting `this._hiPriInProgress` back to false after `componentDidUpdate`
    // is triggered with `this._hiPriInProgress = true`


    if (hiPriInProgress) {
      this._hiPriInProgress = false;
    }
  }

  _computeBlankness() {
    this._fillRateHelper.computeBlankness(this.props, this.state, this._scrollMetrics);
  }

  _onCellLayout(e, cellKey, index) {
    var layout = e.nativeEvent.layout;
    var next = {
      offset: this._selectOffset(layout),
      length: this._selectLength(layout),
      index,
      inLayout: true
    };
    var curr = this._frames[cellKey];

    if (!curr || next.offset !== curr.offset || next.length !== curr.length || index !== curr.index) {
      this._totalCellLength += next.length - (curr ? curr.length : 0);
      this._totalCellsMeasured += curr ? 0 : 1;
      this._averageCellLength = this._totalCellLength / this._totalCellsMeasured;
      this._frames[cellKey] = next;
      this._highestMeasuredFrameIndex = Math.max(this._highestMeasuredFrameIndex, index);

      this._scheduleCellsToRenderUpdate();
    } else {
      this._frames[cellKey].inLayout = true;
    }

    this._triggerRemeasureForChildListsInCell(cellKey);

    this._computeBlankness();

    this._updateViewableItems(this.props.data);
  }

  _triggerRemeasureForChildListsInCell(cellKey) {
    var childListKeys = this._cellKeysToChildListKeys.get(cellKey);

    if (childListKeys) {
      for (var _iterator2 = (0, _createForOfIteratorHelperLoose2.default)(childListKeys), _step2; !(_step2 = _iterator2()).done;) {
        var childKey = _step2.value;

        var childList = this._nestedChildLists.get(childKey);

        childList && childList.ref && childList.ref.measureLayoutRelativeToContainingList();
      }
    }
  }

  measureLayoutRelativeToContainingList() {
    // TODO (T35574538): findNodeHandle sometimes crashes with "Unable to find
    // node on an unmounted component" during scrolling
    try {
      if (!this._scrollRef) {
        return;
      } // We are assuming that getOutermostParentListRef().getScrollRef()
      // is a non-null reference to a ScrollView


      this._scrollRef.measureLayout(this.context.getOutermostParentListRef().getScrollRef(), (x, y, width, height) => {
        this._offsetFromParentVirtualizedList = this._selectOffset({
          x,
          y
        });
        this._scrollMetrics.contentLength = this._selectLength({
          width,
          height
        });

        var scrollMetrics = this._convertParentScrollMetrics(this.context.getScrollMetrics());

        var metricsChanged = this._scrollMetrics.visibleLength !== scrollMetrics.visibleLength || this._scrollMetrics.offset !== scrollMetrics.offset;

        if (metricsChanged) {
          this._scrollMetrics.visibleLength = scrollMetrics.visibleLength;
          this._scrollMetrics.offset = scrollMetrics.offset; // If metrics of the scrollView changed, then we triggered remeasure for child list
          // to ensure VirtualizedList has the right information.

          this._cellKeysToChildListKeys.forEach(childListKeys => {
            if (childListKeys) {
              for (var _iterator3 = (0, _createForOfIteratorHelperLoose2.default)(childListKeys), _step3; !(_step3 = _iterator3()).done;) {
                var childKey = _step3.value;

                var childList = this._nestedChildLists.get(childKey);

                childList && childList.ref && childList.ref.measureLayoutRelativeToContainingList();
              }
            }
          });
        }
      }, error => {
        console.warn("VirtualizedList: Encountered an error while measuring a list's" + ' offset from its containing VirtualizedList.');
      });
    } catch (error) {
      console.warn('measureLayoutRelativeToContainingList threw an error', error.stack);
    }
  }

  _getFooterCellKey() {
    return this._getCellKey() + '-footer';
  }

  _renderDebugOverlay() {
    var normalize = this._scrollMetrics.visibleLength / (this._scrollMetrics.contentLength || 1);
    var framesInLayout = [];
    var itemCount = this.props.getItemCount(this.props.data);

    for (var ii = 0; ii < itemCount; ii++) {
      var frame = this._getFrameMetricsApprox(ii);
      /* $FlowFixMe[prop-missing] (>=0.68.0 site=react_native_fb) This comment
       * suppresses an error found when Flow v0.68 was deployed. To see the
       * error delete this comment and run Flow. */


      if (frame.inLayout) {
        framesInLayout.push(frame);
      }
    }

    var windowTop = this._getFrameMetricsApprox(this.state.first).offset;

    var frameLast = this._getFrameMetricsApprox(this.state.last);

    var windowLen = frameLast.offset + frameLast.length - windowTop;
    var visTop = this._scrollMetrics.offset;
    var visLen = this._scrollMetrics.visibleLength;
    return /*#__PURE__*/React.createElement(_View.default, {
      style: [styles.debugOverlayBase, styles.debugOverlay]
    }, framesInLayout.map((f, ii) => /*#__PURE__*/React.createElement(_View.default, {
      key: 'f' + ii,
      style: [styles.debugOverlayBase, styles.debugOverlayFrame, {
        top: f.offset * normalize,
        height: f.length * normalize
      }]
    })), /*#__PURE__*/React.createElement(_View.default, {
      style: [styles.debugOverlayBase, styles.debugOverlayFrameLast, {
        top: windowTop * normalize,
        height: windowLen * normalize
      }]
    }), /*#__PURE__*/React.createElement(_View.default, {
      style: [styles.debugOverlayBase, styles.debugOverlayFrameVis, {
        top: visTop * normalize,
        height: visLen * normalize
      }]
    }));
  }

  _selectLength(metrics) {
    return !horizontalOrDefault(this.props.horizontal) ? metrics.height : metrics.width;
  }

  _selectOffset(metrics) {
    return !horizontalOrDefault(this.props.horizontal) ? metrics.y : metrics.x;
  }

  _maybeCallOnEndReached() {
    var _this$props10 = this.props,
        data = _this$props10.data,
        getItemCount = _this$props10.getItemCount,
        onEndReached = _this$props10.onEndReached,
        onEndReachedThreshold = _this$props10.onEndReachedThreshold;
    var _this$_scrollMetrics2 = this._scrollMetrics,
        contentLength = _this$_scrollMetrics2.contentLength,
        visibleLength = _this$_scrollMetrics2.visibleLength,
        offset = _this$_scrollMetrics2.offset;
    var distanceFromEnd = contentLength - visibleLength - offset;
    var threshold = onEndReachedThreshold != null ? onEndReachedThreshold * visibleLength : 2;

    if (onEndReached && this.state.last === getItemCount(data) - 1 && distanceFromEnd < threshold && this._scrollMetrics.contentLength !== this._sentEndForContentLength) {
      // Only call onEndReached once for a given content length
      this._sentEndForContentLength = this._scrollMetrics.contentLength;
      onEndReached({
        distanceFromEnd
      });
    } else if (distanceFromEnd > threshold) {
      // If the user scrolls away from the end and back again cause
      // an onEndReached to be triggered again
      this._sentEndForContentLength = 0;
    }
  }

  _scheduleCellsToRenderUpdate() {
    var _this$state2 = this.state,
        first = _this$state2.first,
        last = _this$state2.last;
    var _this$_scrollMetrics3 = this._scrollMetrics,
        offset = _this$_scrollMetrics3.offset,
        visibleLength = _this$_scrollMetrics3.visibleLength,
        velocity = _this$_scrollMetrics3.velocity;
    var itemCount = this.props.getItemCount(this.props.data);
    var hiPri = false;
    var onEndReachedThreshold = onEndReachedThresholdOrDefault(this.props.onEndReachedThreshold);
    var scrollingThreshold = onEndReachedThreshold * visibleLength / 2; // Mark as high priority if we're close to the start of the first item
    // But only if there are items before the first rendered item

    if (first > 0) {
      var distTop = offset - this._getFrameMetricsApprox(first).offset;

      hiPri = hiPri || distTop < 0 || velocity < -2 && distTop < scrollingThreshold;
    } // Mark as high priority if we're close to the end of the last item
    // But only if there are items after the last rendered item


    if (last < itemCount - 1) {
      var distBottom = this._getFrameMetricsApprox(last).offset - (offset + visibleLength);
      hiPri = hiPri || distBottom < 0 || velocity > 2 && distBottom < scrollingThreshold;
    } // Only trigger high-priority updates if we've actually rendered cells,
    // and with that size estimate, accurately compute how many cells we should render.
    // Otherwise, it would just render as many cells as it can (of zero dimension),
    // each time through attempting to render more (limited by maxToRenderPerBatch),
    // starving the renderer from actually laying out the objects and computing _averageCellLength.
    // If this is triggered in an `componentDidUpdate` followed by a hiPri cellToRenderUpdate
    // We shouldn't do another hipri cellToRenderUpdate


    if (hiPri && (this._averageCellLength || this.props.getItemLayout) && !this._hiPriInProgress) {
      this._hiPriInProgress = true; // Don't worry about interactions when scrolling quickly; focus on filling content as fast
      // as possible.

      this._updateCellsToRenderBatcher.dispose({
        abort: true
      });

      this._updateCellsToRender();

      return;
    } else {
      this._updateCellsToRenderBatcher.schedule();
    }
  }

  _updateViewableItems(data) {
    var getItemCount = this.props.getItemCount;

    this._viewabilityTuples.forEach(tuple => {
      tuple.viewabilityHelper.onUpdate(getItemCount(data), this._scrollMetrics.offset, this._scrollMetrics.visibleLength, this._getFrameMetrics, this._createViewToken, tuple.onViewableItemsChanged, this.state);
    });
  }

}

VirtualizedList.contextType = _VirtualizedListContext.VirtualizedListContext;

class CellRenderer extends React.Component {
  constructor() {
    super(...arguments);
    this.state = {
      separatorProps: {
        highlighted: false,
        leadingItem: this.props.item
      }
    };
    this._separators = {
      highlight: () => {
        var _this$props11 = this.props,
            cellKey = _this$props11.cellKey,
            prevCellKey = _this$props11.prevCellKey;
        this.props.onUpdateSeparators([cellKey, prevCellKey], {
          highlighted: true
        });
      },
      unhighlight: () => {
        var _this$props12 = this.props,
            cellKey = _this$props12.cellKey,
            prevCellKey = _this$props12.prevCellKey;
        this.props.onUpdateSeparators([cellKey, prevCellKey], {
          highlighted: false
        });
      },
      updateProps: (select, newProps) => {
        var _this$props13 = this.props,
            cellKey = _this$props13.cellKey,
            prevCellKey = _this$props13.prevCellKey;
        this.props.onUpdateSeparators([select === 'leading' ? prevCellKey : cellKey], newProps);
      }
    };
  }

  static getDerivedStateFromProps(props, prevState) {
    return {
      separatorProps: (0, _objectSpread2.default)((0, _objectSpread2.default)({}, prevState.separatorProps), {}, {
        leadingItem: props.item
      })
    };
  } // TODO: consider factoring separator stuff out of VirtualizedList into FlatList since it's not
  // reused by SectionList and we can keep VirtualizedList simpler.


  updateSeparatorProps(newProps) {
    this.setState(state => ({
      separatorProps: (0, _objectSpread2.default)((0, _objectSpread2.default)({}, state.separatorProps), newProps)
    }));
  }

  componentWillUnmount() {
    this.props.onUnmount(this.props.cellKey);
  }

  _renderElement(renderItem, ListItemComponent, item, index) {
    if (renderItem && ListItemComponent) {
      console.warn('VirtualizedList: Both ListItemComponent and renderItem props are present. ListItemComponent will take' + ' precedence over renderItem.');
    }

    if (ListItemComponent) {
      /* $FlowFixMe[not-a-component] (>=0.108.0 site=react_native_fb) This
       * comment suppresses an error found when Flow v0.108 was deployed. To
       * see the error, delete this comment and run Flow. */

      /* $FlowFixMe[incompatible-type-arg] (>=0.108.0 site=react_native_fb)
       * This comment suppresses an error found when Flow v0.108 was deployed.
       * To see the error, delete this comment and run Flow. */
      return /*#__PURE__*/React.createElement(ListItemComponent, {
        item,
        index,
        separators: this._separators
      });
    }

    if (renderItem) {
      return renderItem({
        item,
        index,
        separators: this._separators
      });
    }

    (0, _invariant.default)(false, 'VirtualizedList: Either ListItemComponent or renderItem props are required but none were found.');
  }

  render() {
    var _this$props14 = this.props,
        CellRendererComponent = _this$props14.CellRendererComponent,
        ItemSeparatorComponent = _this$props14.ItemSeparatorComponent,
        fillRateHelper = _this$props14.fillRateHelper,
        horizontal = _this$props14.horizontal,
        item = _this$props14.item,
        index = _this$props14.index,
        inversionStyle = _this$props14.inversionStyle,
        parentProps = _this$props14.parentProps;
    var renderItem = parentProps.renderItem,
        getItemLayout = parentProps.getItemLayout,
        ListItemComponent = parentProps.ListItemComponent;

    var element = this._renderElement(renderItem, ListItemComponent, item, index);

    var onLayout =
    /* $FlowFixMe[prop-missing] (>=0.68.0 site=react_native_fb) This comment
     * suppresses an error found when Flow v0.68 was deployed. To see the
     * error delete this comment and run Flow. */
    getItemLayout && !parentProps.debug && !fillRateHelper.enabled() ? undefined : this.props.onLayout; // NOTE: that when this is a sticky header, `onLayout` will get automatically extracted and
    // called explicitly by `ScrollViewStickyHeader`.

    var itemSeparator = ItemSeparatorComponent && /*#__PURE__*/React.createElement(ItemSeparatorComponent, this.state.separatorProps);
    var cellStyle = inversionStyle ? horizontal ? [styles.rowReverse, inversionStyle] : [styles.columnReverse, inversionStyle] : horizontal ? [styles.row, inversionStyle] : inversionStyle;
    var result = !CellRendererComponent ?
    /*#__PURE__*/

    /* $FlowFixMe[incompatible-type-arg] (>=0.89.0 site=react_native_fb) *
      This comment suppresses an error found when Flow v0.89 was deployed. *
      To see the error, delete this comment and run Flow. */
    React.createElement(_View.default, {
      style: cellStyle,
      onLayout: onLayout
    }, element, itemSeparator) : /*#__PURE__*/React.createElement(CellRendererComponent, (0, _extends2.default)({}, this.props, {
      style: cellStyle,
      onLayout: onLayout
    }), element, itemSeparator);
    return /*#__PURE__*/React.createElement(_VirtualizedListContext.VirtualizedListCellContextProvider, {
      cellKey: this.props.cellKey
    }, result);
  }

}

function describeNestedLists(childList) {
  var trace = 'VirtualizedList trace:\n' + ("  Child (" + (childList.horizontal ? 'horizontal' : 'vertical') + "):\n") + ("    listKey: " + childList.key + "\n") + ("    cellKey: " + childList.cellKey);
  var debugInfo = childList.parentDebugInfo;

  while (debugInfo) {
    trace += "\n  Parent (" + (debugInfo.horizontal ? 'horizontal' : 'vertical') + "):\n" + ("    listKey: " + debugInfo.listKey + "\n") + ("    cellKey: " + debugInfo.cellKey);
    debugInfo = debugInfo.parent;
  }

  return trace;
}

var styles = _StyleSheet.default.create({
  verticallyInverted: {
    transform: [{
      scaleY: -1
    }]
  },
  horizontallyInverted: {
    transform: [{
      scaleX: -1
    }]
  },
  row: {
    flexDirection: 'row'
  },
  rowReverse: {
    flexDirection: 'row-reverse'
  },
  columnReverse: {
    flexDirection: 'column-reverse'
  },
  debug: {
    flex: 1
  },
  debugOverlayBase: {
    position: 'absolute',
    top: 0,
    right: 0
  },
  debugOverlay: {
    bottom: 0,
    width: 20,
    borderColor: 'blue',
    borderWidth: 1
  },
  debugOverlayFrame: {
    left: 0,
    backgroundColor: 'orange'
  },
  debugOverlayFrameLast: {
    left: 0,
    borderColor: 'green',
    borderWidth: 2
  },
  debugOverlayFrameVis: {
    left: 0,
    borderColor: 'red',
    borderWidth: 2
  }
});

var _default = VirtualizedList;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),

/***/ 85919:
/***/ ((module, exports, __webpack_require__) => {

"use strict";
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 */


var _interopRequireDefault = (__webpack_require__(64836)["default"]);

var _interopRequireWildcard = (__webpack_require__(75263)["default"]);

exports.__esModule = true;
exports["default"] = void 0;

var _extends2 = _interopRequireDefault(__webpack_require__(10434));

var _createForOfIteratorHelperLoose2 = _interopRequireDefault(__webpack_require__(92535));

var _objectWithoutPropertiesLoose2 = _interopRequireDefault(__webpack_require__(7071));

var _objectSpread2 = _interopRequireDefault(__webpack_require__(42122));

var _VirtualizeUtils = __webpack_require__(39474);

var _View = _interopRequireDefault(__webpack_require__(79057));

var _VirtualizedList = _interopRequireDefault(__webpack_require__(71655));

var React = _interopRequireWildcard(__webpack_require__(16689));

var _invariant = _interopRequireDefault(__webpack_require__(44505));

var _excluded = ["ItemSeparatorComponent", "SectionSeparatorComponent", "renderItem", "renderSectionFooter", "renderSectionHeader", "sections", "stickySectionHeadersEnabled"];

/**
 * Right now this just flattens everything into one list and uses VirtualizedList under the
 * hood. The only operation that might not scale well is concatting the data arrays of all the
 * sections when new props are received, which should be plenty fast for up to ~10,000 items.
 */
class VirtualizedSectionList extends React.PureComponent {
  constructor() {
    super(...arguments);

    this._keyExtractor = (item, index) => {
      var info = this._subExtractor(index);

      return info && info.key || String(index);
    };

    this._convertViewable = viewable => {
      var _info$index;

      (0, _invariant.default)(viewable.index != null, 'Received a broken ViewToken');

      var info = this._subExtractor(viewable.index);

      if (!info) {
        return null;
      }

      var keyExtractorWithNullableIndex = info.section.keyExtractor;
      var keyExtractorWithNonNullableIndex = this.props.keyExtractor || _VirtualizeUtils.keyExtractor;
      var key = keyExtractorWithNullableIndex != null ? keyExtractorWithNullableIndex(viewable.item, info.index) : keyExtractorWithNonNullableIndex(viewable.item, (_info$index = info.index) !== null && _info$index !== void 0 ? _info$index : 0);
      return (0, _objectSpread2.default)((0, _objectSpread2.default)({}, viewable), {}, {
        index: info.index,
        key,
        section: info.section
      });
    };

    this._onViewableItemsChanged = _ref => {
      var viewableItems = _ref.viewableItems,
          changed = _ref.changed;
      var onViewableItemsChanged = this.props.onViewableItemsChanged;

      if (onViewableItemsChanged != null) {
        onViewableItemsChanged({
          viewableItems: viewableItems.map(this._convertViewable, this).filter(Boolean),
          changed: changed.map(this._convertViewable, this).filter(Boolean)
        });
      }
    };

    this._renderItem = listItemCount => _ref2 => {
      var item = _ref2.item,
          index = _ref2.index;

      var info = this._subExtractor(index);

      if (!info) {
        return null;
      }

      var infoIndex = info.index;

      if (infoIndex == null) {
        var section = info.section;

        if (info.header === true) {
          var renderSectionHeader = this.props.renderSectionHeader;
          return renderSectionHeader ? renderSectionHeader({
            section
          }) : null;
        } else {
          var renderSectionFooter = this.props.renderSectionFooter;
          return renderSectionFooter ? renderSectionFooter({
            section
          }) : null;
        }
      } else {
        var renderItem = info.section.renderItem || this.props.renderItem;

        var SeparatorComponent = this._getSeparatorComponent(index, info, listItemCount);

        (0, _invariant.default)(renderItem, 'no renderItem!');
        return /*#__PURE__*/React.createElement(ItemWithSeparator, {
          SeparatorComponent: SeparatorComponent,
          LeadingSeparatorComponent: infoIndex === 0 ? this.props.SectionSeparatorComponent : undefined,
          cellKey: info.key,
          index: infoIndex,
          item: item,
          leadingItem: info.leadingItem,
          leadingSection: info.leadingSection,
          prevCellKey: (this._subExtractor(index - 1) || {}).key // Callback to provide updateHighlight for this item
          ,
          setSelfHighlightCallback: this._setUpdateHighlightFor,
          setSelfUpdatePropsCallback: this._setUpdatePropsFor // Provide child ability to set highlight/updateProps for previous item using prevCellKey
          ,
          updateHighlightFor: this._updateHighlightFor,
          updatePropsFor: this._updatePropsFor,
          renderItem: renderItem,
          section: info.section,
          trailingItem: info.trailingItem,
          trailingSection: info.trailingSection,
          inverted: !!this.props.inverted
        });
      }
    };

    this._updatePropsFor = (cellKey, value) => {
      var updateProps = this._updatePropsMap[cellKey];

      if (updateProps != null) {
        updateProps(value);
      }
    };

    this._updateHighlightFor = (cellKey, value) => {
      var updateHighlight = this._updateHighlightMap[cellKey];

      if (updateHighlight != null) {
        updateHighlight(value);
      }
    };

    this._setUpdateHighlightFor = (cellKey, updateHighlightFn) => {
      if (updateHighlightFn != null) {
        this._updateHighlightMap[cellKey] = updateHighlightFn;
      } else {
        delete this._updateHighlightFor[cellKey];
      }
    };

    this._setUpdatePropsFor = (cellKey, updatePropsFn) => {
      if (updatePropsFn != null) {
        this._updatePropsMap[cellKey] = updatePropsFn;
      } else {
        delete this._updatePropsMap[cellKey];
      }
    };

    this._updateHighlightMap = {};
    this._updatePropsMap = {};

    this._captureRef = ref => {
      this._listRef = ref;
    };
  }

  scrollToLocation(params) {
    var index = params.itemIndex;

    for (var i = 0; i < params.sectionIndex; i++) {
      index += this.props.getItemCount(this.props.sections[i].data) + 2;
    }

    var viewOffset = params.viewOffset || 0;

    if (this._listRef == null) {
      return;
    }

    if (params.itemIndex > 0 && this.props.stickySectionHeadersEnabled) {
      // $FlowFixMe[prop-missing] Cannot access private property
      var frame = this._listRef._getFrameMetricsApprox(index - params.itemIndex);

      viewOffset += frame.length;
    }

    var toIndexParams = (0, _objectSpread2.default)((0, _objectSpread2.default)({}, params), {}, {
      viewOffset,
      index
    });

    this._listRef.scrollToIndex(toIndexParams);
  }

  getListRef() {
    return this._listRef;
  }

  render() {
    var _this$props = this.props,
        ItemSeparatorComponent = _this$props.ItemSeparatorComponent,
        SectionSeparatorComponent = _this$props.SectionSeparatorComponent,
        _renderItem = _this$props.renderItem,
        renderSectionFooter = _this$props.renderSectionFooter,
        renderSectionHeader = _this$props.renderSectionHeader,
        _sections = _this$props.sections,
        stickySectionHeadersEnabled = _this$props.stickySectionHeadersEnabled,
        passThroughProps = (0, _objectWithoutPropertiesLoose2.default)(_this$props, _excluded);
    var listHeaderOffset = this.props.ListHeaderComponent ? 1 : 0;
    var stickyHeaderIndices = this.props.stickySectionHeadersEnabled ? [] : undefined;
    var itemCount = 0;

    for (var _iterator = (0, _createForOfIteratorHelperLoose2.default)(this.props.sections), _step; !(_step = _iterator()).done;) {
      var section = _step.value;

      // Track the section header indices
      if (stickyHeaderIndices != null) {
        stickyHeaderIndices.push(itemCount + listHeaderOffset);
      } // Add two for the section header and footer.


      itemCount += 2;
      itemCount += this.props.getItemCount(section.data);
    }

    var renderItem = this._renderItem(itemCount);

    return /*#__PURE__*/React.createElement(_VirtualizedList.default, (0, _extends2.default)({}, passThroughProps, {
      keyExtractor: this._keyExtractor,
      stickyHeaderIndices: stickyHeaderIndices,
      renderItem: renderItem,
      data: this.props.sections,
      getItem: (sections, index) => this._getItem(this.props, sections, index),
      getItemCount: () => itemCount,
      onViewableItemsChanged: this.props.onViewableItemsChanged ? this._onViewableItemsChanged : undefined,
      ref: this._captureRef
    }));
  }

  _getItem(props, sections, index) {
    if (!sections) {
      return null;
    }

    var itemIdx = index - 1;

    for (var i = 0; i < sections.length; i++) {
      var section = sections[i];
      var sectionData = section.data;
      var itemCount = props.getItemCount(sectionData);

      if (itemIdx === -1 || itemIdx === itemCount) {
        // We intend for there to be overflow by one on both ends of the list.
        // This will be for headers and footers. When returning a header or footer
        // item the section itself is the item.
        return section;
      } else if (itemIdx < itemCount) {
        // If we are in the bounds of the list's data then return the item.
        return props.getItem(sectionData, itemIdx);
      } else {
        itemIdx -= itemCount + 2; // Add two for the header and footer
      }
    }

    return null;
  }

  _subExtractor(index) {
    var itemIndex = index;
    var _this$props2 = this.props,
        getItem = _this$props2.getItem,
        getItemCount = _this$props2.getItemCount,
        keyExtractor = _this$props2.keyExtractor,
        sections = _this$props2.sections;

    for (var i = 0; i < sections.length; i++) {
      var section = sections[i];
      var sectionData = section.data;
      var key = section.key || String(i);
      itemIndex -= 1; // The section adds an item for the header

      if (itemIndex >= getItemCount(sectionData) + 1) {
        itemIndex -= getItemCount(sectionData) + 1; // The section adds an item for the footer.
      } else if (itemIndex === -1) {
        return {
          section,
          key: key + ':header',
          index: null,
          header: true,
          trailingSection: sections[i + 1]
        };
      } else if (itemIndex === getItemCount(sectionData)) {
        return {
          section,
          key: key + ':footer',
          index: null,
          header: false,
          trailingSection: sections[i + 1]
        };
      } else {
        var extractor = section.keyExtractor || keyExtractor || _VirtualizeUtils.keyExtractor;
        return {
          section,
          key: key + ':' + extractor(getItem(sectionData, itemIndex), itemIndex),
          index: itemIndex,
          leadingItem: getItem(sectionData, itemIndex - 1),
          leadingSection: sections[i - 1],
          trailingItem: getItem(sectionData, itemIndex + 1),
          trailingSection: sections[i + 1]
        };
      }
    }
  }

  _getSeparatorComponent(index, info, listItemCount) {
    info = info || this._subExtractor(index);

    if (!info) {
      return null;
    }

    var ItemSeparatorComponent = info.section.ItemSeparatorComponent || this.props.ItemSeparatorComponent;
    var SectionSeparatorComponent = this.props.SectionSeparatorComponent;
    var isLastItemInList = index === listItemCount - 1;
    var isLastItemInSection = info.index === this.props.getItemCount(info.section.data) - 1;

    if (SectionSeparatorComponent && isLastItemInSection) {
      return SectionSeparatorComponent;
    }

    if (ItemSeparatorComponent && !isLastItemInSection && !isLastItemInList) {
      return ItemSeparatorComponent;
    }

    return null;
  }

}

function ItemWithSeparator(props) {
  var LeadingSeparatorComponent = props.LeadingSeparatorComponent,
      SeparatorComponent = props.SeparatorComponent,
      cellKey = props.cellKey,
      prevCellKey = props.prevCellKey,
      setSelfHighlightCallback = props.setSelfHighlightCallback,
      updateHighlightFor = props.updateHighlightFor,
      setSelfUpdatePropsCallback = props.setSelfUpdatePropsCallback,
      updatePropsFor = props.updatePropsFor,
      item = props.item,
      index = props.index,
      section = props.section,
      inverted = props.inverted;

  var _React$useState = React.useState(false),
      leadingSeparatorHiglighted = _React$useState[0],
      setLeadingSeparatorHighlighted = _React$useState[1];

  var _React$useState2 = React.useState(false),
      separatorHighlighted = _React$useState2[0],
      setSeparatorHighlighted = _React$useState2[1];

  var _React$useState3 = React.useState({
    leadingItem: props.leadingItem,
    leadingSection: props.leadingSection,
    section: props.section,
    trailingItem: props.item,
    trailingSection: props.trailingSection
  }),
      leadingSeparatorProps = _React$useState3[0],
      setLeadingSeparatorProps = _React$useState3[1];

  var _React$useState4 = React.useState({
    leadingItem: props.item,
    leadingSection: props.leadingSection,
    section: props.section,
    trailingItem: props.trailingItem,
    trailingSection: props.trailingSection
  }),
      separatorProps = _React$useState4[0],
      setSeparatorProps = _React$useState4[1];

  React.useEffect(() => {
    setSelfHighlightCallback(cellKey, setSeparatorHighlighted);
    setSelfUpdatePropsCallback(cellKey, setSeparatorProps);
    return () => {
      setSelfUpdatePropsCallback(cellKey, null);
      setSelfHighlightCallback(cellKey, null);
    };
  }, [cellKey, setSelfHighlightCallback, setSeparatorProps, setSelfUpdatePropsCallback]);
  var separators = {
    highlight: () => {
      setLeadingSeparatorHighlighted(true);
      setSeparatorHighlighted(true);

      if (prevCellKey != null) {
        updateHighlightFor(prevCellKey, true);
      }
    },
    unhighlight: () => {
      setLeadingSeparatorHighlighted(false);
      setSeparatorHighlighted(false);

      if (prevCellKey != null) {
        updateHighlightFor(prevCellKey, false);
      }
    },
    updateProps: (select, newProps) => {
      if (select === 'leading') {
        if (LeadingSeparatorComponent != null) {
          setLeadingSeparatorProps((0, _objectSpread2.default)((0, _objectSpread2.default)({}, leadingSeparatorProps), newProps));
        } else if (prevCellKey != null) {
          // update the previous item's separator
          updatePropsFor(prevCellKey, (0, _objectSpread2.default)((0, _objectSpread2.default)({}, leadingSeparatorProps), newProps));
        }
      } else if (select === 'trailing' && SeparatorComponent != null) {
        setSeparatorProps((0, _objectSpread2.default)((0, _objectSpread2.default)({}, separatorProps), newProps));
      }
    }
  };
  var element = props.renderItem({
    item,
    index,
    section,
    separators
  });
  var leadingSeparator = LeadingSeparatorComponent != null && /*#__PURE__*/React.createElement(LeadingSeparatorComponent, (0, _extends2.default)({
    highlighted: leadingSeparatorHiglighted
  }, leadingSeparatorProps));
  var separator = SeparatorComponent != null && /*#__PURE__*/React.createElement(SeparatorComponent, (0, _extends2.default)({
    highlighted: separatorHighlighted
  }, separatorProps));
  return leadingSeparator || separator ? /*#__PURE__*/React.createElement(_View.default, null, inverted === false ? leadingSeparator : separator, element, inverted === false ? separator : leadingSeparator) : element;
}

var _default = VirtualizedSectionList;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),

/***/ 70339:
/***/ ((module, exports) => {

"use strict";
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @format
 * 
 */

/*
 * @returns {bool} true if different, false if equal
 */

exports.__esModule = true;
exports["default"] = void 0;

var deepDiffer = function deepDiffer(one, two, maxDepth) {
  if (maxDepth === void 0) {
    maxDepth = -1;
  }

  if (maxDepth === 0) {
    return true;
  }

  if (one === two) {
    // Short circuit on identical object references instead of traversing them.
    return false;
  }

  if (typeof one === 'function' && typeof two === 'function') {
    // We consider all functions equal
    return false;
  }

  if (typeof one !== 'object' || one === null) {
    // Primitives can be directly compared
    return one !== two;
  }

  if (typeof two !== 'object' || two === null) {
    // We know they are different because the previous case would have triggered
    // otherwise.
    return true;
  }

  if (one.constructor !== two.constructor) {
    return true;
  }

  if (Array.isArray(one)) {
    // We know two is also an array because the constructors are equal
    var len = one.length;

    if (two.length !== len) {
      return true;
    }

    for (var ii = 0; ii < len; ii++) {
      if (deepDiffer(one[ii], two[ii], maxDepth - 1)) {
        return true;
      }
    }
  } else {
    for (var key in one) {
      if (deepDiffer(one[key], two[key], maxDepth - 1)) {
        return true;
      }
    }

    for (var twoKey in two) {
      // The only case we haven't checked yet is keys that are in two but aren't
      // in one, which means they are different.
      if (one[twoKey] === undefined && two[twoKey] !== undefined) {
        return true;
      }
    }
  }

  return false;
};

var _default = deepDiffer;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),

/***/ 77580:
/***/ ((module, exports, __webpack_require__) => {

"use strict";
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 */


var _interopRequireDefault = (__webpack_require__(64836)["default"]);

exports.__esModule = true;
exports["default"] = void 0;

var _EventEmitter = _interopRequireDefault(__webpack_require__(67834));

var _default = _EventEmitter.default;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),

/***/ 15920:
/***/ ((module, exports, __webpack_require__) => {

"use strict";
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @format
 * 
 */


var _interopRequireDefault = (__webpack_require__(64836)["default"]);

exports.__esModule = true;
exports["default"] = void 0;

var _EventSubscription2 = _interopRequireDefault(__webpack_require__(42447));

/**
 * EmitterSubscription represents a subscription with listener and context data.
 */
class EmitterSubscription extends _EventSubscription2.default {
  /**
   * @param {EventEmitter} emitter - The event emitter that registered this
   *   subscription
   * @param {EventSubscriptionVendor} subscriber - The subscriber that controls
   *   this subscription
   * @param {function} listener - Function to invoke when the specified event is
   *   emitted
   * @param {*} context - Optional context object to use when invoking the
   *   listener
   */
  constructor(emitter, subscriber, listener, context) {
    super(subscriber);
    this.emitter = emitter;
    this.listener = listener;
    this.context = context;
  }
  /**
   * Removes this subscription from the emitter that registered it.
   * Note: we're overriding the `remove()` method of _EventSubscription here
   * but deliberately not calling `super.remove()` as the responsibility
   * for removing the subscription lies with the EventEmitter.
   */


  remove() {
    this.emitter.removeSubscription(this);
  }

}

var _default = EmitterSubscription;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),

/***/ 67834:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(64836)["default"]);

exports.__esModule = true;
exports["default"] = void 0;

var _invariant = _interopRequireDefault(__webpack_require__(44505));

var _EmitterSubscription = _interopRequireDefault(__webpack_require__(15920));

var _EventSubscriptionVendor = _interopRequireDefault(__webpack_require__(86439));

/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @format
 * 
 * @typecheck
 */
var sparseFilterPredicate = () => true;

/**
 * @class EventEmitter
 * @description
 * An EventEmitter is responsible for managing a set of listeners and publishing
 * events to them when it is told that such events happened. In addition to the
 * data for the given event it also sends a event control object which allows
 * the listeners/handlers to prevent the default behavior of the given event.
 *
 * The emitter is designed to be generic enough to support all the different
 * contexts in which one might want to emit events. It is a simple multicast
 * mechanism on top of which extra functionality can be composed. For example, a
 * more advanced emitter may use an EventHolder and EventFactory.
 */
class EventEmitter {
  /**
   * @constructor
   *
   * @param {EventSubscriptionVendor} subscriber - Optional subscriber instance
   *   to use. If omitted, a new subscriber will be created for the emitter.
   */
  constructor(subscriber) {
    this._subscriber = subscriber || new _EventSubscriptionVendor.default();
  }
  /**
   * Adds a listener to be invoked when events of the specified type are
   * emitted. An optional calling context may be provided. The data arguments
   * emitted will be passed to the listener function.
   *
   * TODO: Annotate the listener arg's type. This is tricky because listeners
   *       can be invoked with varargs.
   *
   * @param {string} eventType - Name of the event to listen to
   * @param {function} listener - Function to invoke when the specified event is
   *   emitted
   * @param {*} context - Optional context object to use when invoking the
   *   listener
   */


  addListener(eventType, // FIXME: listeners should return void instead of mixed to prevent issues
  listener, context) {
    return this._subscriber.addSubscription(eventType, new _EmitterSubscription.default(this, this._subscriber, listener, context));
  }
  /**
   * Removes all of the registered listeners, including those registered as
   * listener maps.
   *
   * @param {?string} eventType - Optional name of the event whose registered
   *   listeners to remove
   */


  removeAllListeners(eventType) {
    this._subscriber.removeAllSubscriptions(eventType);
  }
  /**
   * @deprecated Use `remove` on the EventSubscription from `addListener`.
   */


  removeSubscription(subscription) {
    (0, _invariant.default)(subscription.emitter === this, 'Subscription does not belong to this emitter.');

    this._subscriber.removeSubscription(subscription);
  }
  /**
   * Returns the number of listeners that are currently registered for the given
   * event.
   *
   * @param {string} eventType - Name of the event to query
   * @returns {number}
   */


  listenerCount(eventType) {
    var subscriptions = this._subscriber.getSubscriptionsForType(eventType);

    return subscriptions ? // We filter out missing entries because the array is sparse.
    // "callbackfn is called only for elements of the array which actually
    // exist; it is not called for missing elements of the array."
    // https://www.ecma-international.org/ecma-262/9.0/index.html#sec-array.prototype.filter
    subscriptions.filter(sparseFilterPredicate).length : 0;
  }
  /**
   * Emits an event of the given type with the given data. All handlers of that
   * particular type will be notified.
   *
   * @param {string} eventType - Name of the event to emit
   * @param {...*} Arbitrary arguments to be passed to each registered listener
   *
   * @example
   *   emitter.addListener('someEvent', function(message) {
   *     console.log(message);
   *   });
   *
   *   emitter.emit('someEvent', 'abc'); // logs 'abc'
   */


  emit(eventType) {
    var subscriptions = this._subscriber.getSubscriptionsForType(eventType);

    if (subscriptions) {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      for (var i = 0, l = subscriptions.length; i < l; i++) {
        var subscription = subscriptions[i]; // The subscription may have been removed during this event loop.

        if (subscription && subscription.listener) {
          subscription.listener.apply(subscription.context, args);
        }
      }
    }
  }
  /**
   * @deprecated Use `remove` on the EventSubscription from `addListener`.
   */


  removeListener(eventType, // FIXME: listeners should return void instead of mixed to prevent issues
  listener) {
    console.error("EventEmitter.removeListener('" + eventType + "', ...): Method has been " + 'deprecated. Please instead use `remove()` on the subscription ' + 'returned by `EventEmitter.addListener`.');

    var subscriptions = this._subscriber.getSubscriptionsForType(eventType);

    if (subscriptions) {
      for (var i = 0, l = subscriptions.length; i < l; i++) {
        var subscription = subscriptions[i]; // The subscription may have been removed during this event loop.
        // its listener matches the listener in method parameters

        if (subscription && subscription.listener === listener) {
          subscription.remove();
        }
      }
    }
  }

}

var _default = EventEmitter;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),

/***/ 42447:
/***/ ((module, exports) => {

"use strict";
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @format
 * 
 */


exports.__esModule = true;
exports["default"] = void 0;

/**
 * EventSubscription represents a subscription to a particular event. It can
 * remove its own subscription.
 */
class _EventSubscription {
  /**
   * @param {EventSubscriptionVendor} subscriber the subscriber that controls
   *   this subscription.
   */
  constructor(subscriber) {
    this.subscriber = subscriber;
  }
  /**
   * Removes this subscription from the subscriber that controls it.
   */


  remove() {
    this.subscriber.removeSubscription(this);
  }

}

var _default = _EventSubscription;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),

/***/ 86439:
/***/ ((module, exports, __webpack_require__) => {

"use strict";
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @format
 * 
 */


var _interopRequireDefault = (__webpack_require__(64836)["default"]);

exports.__esModule = true;
exports["default"] = void 0;

var _invariant = _interopRequireDefault(__webpack_require__(44505));

/**
 * EventSubscriptionVendor stores a set of EventSubscriptions that are
 * subscribed to a particular event type.
 */
class EventSubscriptionVendor {
  constructor() {
    this._subscriptionsForType = {};
  }
  /**
   * Adds a subscription keyed by an event type.
   *
   * @param {string} eventType
   * @param {EventSubscription} subscription
   */


  addSubscription(eventType, subscription) {
    (0, _invariant.default)(subscription.subscriber === this, 'The subscriber of the subscription is incorrectly set.');

    if (!this._subscriptionsForType[eventType]) {
      this._subscriptionsForType[eventType] = [];
    }

    var key = this._subscriptionsForType[eventType].length;

    this._subscriptionsForType[eventType].push(subscription);

    subscription.eventType = eventType;
    subscription.key = key;
    return subscription;
  }
  /**
   * Removes a bulk set of the subscriptions.
   *
   * @param {?string} eventType - Optional name of the event type whose
   *   registered supscriptions to remove, if null remove all subscriptions.
   */


  removeAllSubscriptions(eventType) {
    if (eventType == null) {
      this._subscriptionsForType = {};
    } else {
      delete this._subscriptionsForType[eventType];
    }
  }
  /**
   * Removes a specific subscription. Instead of calling this function, call
   * `subscription.remove()` directly.
   *
   * @param {object} subscription
   */


  removeSubscription(subscription) {
    var eventType = subscription.eventType;
    var key = subscription.key;
    var subscriptionsForType = this._subscriptionsForType[eventType];

    if (subscriptionsForType) {
      delete subscriptionsForType[key];
    }
  }
  /**
   * Returns the array of subscriptions that are currently registered for the
   * given event type.
   *
   * Note: This array can be potentially sparse as subscriptions are deleted
   * from it when they are removed.
   *
   * TODO: This returns a nullable array. wat?
   *
   * @param {string} eventType
   * @returns {?array}
   */


  getSubscriptionsForType(eventType) {
    return this._subscriptionsForType[eventType];
  }

}

var _default = EventSubscriptionVendor;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),

/***/ 91455:
/***/ ((module, exports) => {

"use strict";
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

/**
 * Intentional info-level logging for clear separation from ad-hoc console debug logging.
 */

exports.__esModule = true;
exports["default"] = void 0;

function infoLog() {
  return console.log(...arguments);
}

var _default = infoLog;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),

/***/ 75251:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var f=__webpack_require__(16689),k=Symbol.for("react.element"),l=Symbol.for("react.fragment"),m=Object.prototype.hasOwnProperty,n=f.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,p={key:!0,ref:!0,__self:!0,__source:!0};
function q(c,a,g){var b,d={},e=null,h=null;void 0!==g&&(e=""+g);void 0!==a.key&&(e=""+a.key);void 0!==a.ref&&(h=a.ref);for(b in a)m.call(a,b)&&!p.hasOwnProperty(b)&&(d[b]=a[b]);if(c&&c.defaultProps)for(b in a=c.defaultProps,a)void 0===d[b]&&(d[b]=a[b]);return{$$typeof:k,type:c,key:e,ref:h,props:d,_owner:n.current}}exports.Fragment=l;exports.jsx=q;exports.jsxs=q;


/***/ }),

/***/ 85893:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


if (true) {
  module.exports = __webpack_require__(75251);
} else {}


/***/ }),

/***/ 73897:
/***/ ((module) => {

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}
module.exports = _arrayLikeToArray, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ 92535:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var unsupportedIterableToArray = __webpack_require__(86116);
function _createForOfIteratorHelperLoose(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (it) return (it = it.call(o)).next.bind(it);
  if (Array.isArray(o) || (it = unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
    if (it) o = it;
    var i = 0;
    return function () {
      if (i >= o.length) return {
        done: true
      };
      return {
        done: false,
        value: o[i++]
      };
    };
  }
  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
module.exports = _createForOfIteratorHelperLoose, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ 38416:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var toPropertyKey = __webpack_require__(64062);
function _defineProperty(obj, key, value) {
  key = toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
module.exports = _defineProperty, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ 10434:
/***/ ((module) => {

function _extends() {
  module.exports = _extends = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  }, module.exports.__esModule = true, module.exports["default"] = module.exports;
  return _extends.apply(this, arguments);
}
module.exports = _extends, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ 64836:
/***/ ((module) => {

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}
module.exports = _interopRequireDefault, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ 75263:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _typeof = (__webpack_require__(18698)["default"]);
function _getRequireWildcardCache(nodeInterop) {
  if (typeof WeakMap !== "function") return null;
  var cacheBabelInterop = new WeakMap();
  var cacheNodeInterop = new WeakMap();
  return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) {
    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
  })(nodeInterop);
}
function _interopRequireWildcard(obj, nodeInterop) {
  if (!nodeInterop && obj && obj.__esModule) {
    return obj;
  }
  if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") {
    return {
      "default": obj
    };
  }
  var cache = _getRequireWildcardCache(nodeInterop);
  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }
  var newObj = {};
  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
  for (var key in obj) {
    if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
      if (desc && (desc.get || desc.set)) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = obj[key];
      }
    }
  }
  newObj["default"] = obj;
  if (cache) {
    cache.set(obj, newObj);
  }
  return newObj;
}
module.exports = _interopRequireWildcard, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ 42122:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var defineProperty = __webpack_require__(38416);
function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {
      defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
module.exports = _objectSpread2, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ 7071:
/***/ ((module) => {

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
module.exports = _objectWithoutPropertiesLoose, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ 95036:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _typeof = (__webpack_require__(18698)["default"]);
function _toPrimitive(input, hint) {
  if (_typeof(input) !== "object" || input === null) return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== undefined) {
    var res = prim.call(input, hint || "default");
    if (_typeof(res) !== "object") return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
module.exports = _toPrimitive, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ 64062:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _typeof = (__webpack_require__(18698)["default"]);
var toPrimitive = __webpack_require__(95036);
function _toPropertyKey(arg) {
  var key = toPrimitive(arg, "string");
  return _typeof(key) === "symbol" ? key : String(key);
}
module.exports = _toPropertyKey, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ 18698:
/***/ ((module) => {

function _typeof(obj) {
  "@babel/helpers - typeof";

  return (module.exports = _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  }, module.exports.__esModule = true, module.exports["default"] = module.exports), _typeof(obj);
}
module.exports = _typeof, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ 86116:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var arrayLikeToArray = __webpack_require__(73897);
function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);
}
module.exports = _unsupportedIterableToArray, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ 50167:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


exports._ = exports._interop_require_default = _interop_require_default;
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
}


/***/ }),

/***/ 28760:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;

    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();

    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
exports._ = exports._interop_require_wildcard = _interop_require_wildcard;
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) return obj;
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") return { default: obj };

    var cache = _getRequireWildcardCache(nodeInterop);

    if (cache && cache.has(obj)) return cache.get(obj);

    var newObj = {};
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

    for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) Object.defineProperty(newObj, key, desc);
            else newObj[key] = obj[key];
        }
    }

    newObj.default = obj;

    if (cache) cache.set(obj, newObj);

    return newObj;
}


/***/ }),

/***/ 32834:
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"name":"react-native","version":"0.71.12","bin":"./cli.js","description":"A framework for building native apps using React","license":"MIT","repository":"github:facebook/react-native","engines":{"node":">=14"},"types":"types","jest-junit":{"outputDirectory":"reports/junit","outputName":"js-test-results.xml"},"files":["android","build.gradle.kts","cli.js","flow","flow-typed","gradle.properties","index.js","interface.js","jest-preset.js","jest","!jest/private","Libraries","LICENSE","local-cli","React-Core.podspec","react-native.config.js","react.gradle","React.podspec","React","ReactAndroid","ReactCommon","README.md","rn-get-polyfills.js","scripts/compose-source-maps.js","scripts/find-node-for-xcode.sh","scripts/generate-codegen-artifacts.js","scripts/generate-provider-cli.js","scripts/generate-specs-cli.js","scripts/codegen/codegen-utils.js","scripts/codegen/generate-artifacts-executor.js","scripts/codegen/generate-specs-cli-executor.js","scripts/hermes/hermes-utils.js","scripts/hermes/prepare-hermes-for-build.js","scripts/ios-configure-glog.sh","scripts/xcode/with-environment.sh","scripts/launchPackager.bat","scripts/launchPackager.command","scripts/native_modules.rb","scripts/node-binary.sh","scripts/packager.sh","scripts/packager-reporter.js","scripts/react_native_pods_utils/script_phases.rb","scripts/react_native_pods_utils/script_phases.sh","scripts/react_native_pods.rb","scripts/cocoapods","scripts/react-native-xcode.sh","sdks/.hermesversion","sdks/hermes-engine","sdks/hermesc","settings.gradle.kts","template.config.js","template","!template/node_modules","!template/package-lock.json","!template/yarn.lock","third-party-podspecs","types"],"scripts":{"start":"react-native start","test":"jest","test-ci":"jest --maxWorkers=2 --ci --reporters=\\"default\\" --reporters=\\"jest-junit\\"","flow":"flow","flow-check-ios":"flow check","flow-check-android":"flow check --flowconfig-name .flowconfig.android","lint":"eslint .","lint-ci":"./scripts/circleci/analyze_code.sh && yarn shellcheck","lint-java":"node ./scripts/lint-java.js","shellcheck":"./scripts/circleci/analyze_scripts.sh","clang-format":"clang-format -i --glob=*/**/*.{h,cpp,m,mm}","format":"npm run prettier && npm run clang-format","prettier":"prettier --write \\"./**/*.{js,md,yml,ts,tsx}\\"","format-check":"prettier --list-different \\"./**/*.{js,md,yml,ts,tsx}\\"","update-lock":"npx yarn-deduplicate","docker-setup-android":"docker pull reactnativecommunity/react-native-android:6.2","docker-build-android":"docker build -t reactnativeci/android -f .circleci/Dockerfiles/Dockerfile.android .","test-android-run-instrumentation":"docker run --cap-add=SYS_ADMIN -it reactnativeci/android bash .circleci/Dockerfiles/scripts/run-android-docker-instrumentation-tests.sh","test-android-run-unit":"docker run --cap-add=SYS_ADMIN -it reactnativeci/android bash .circleci/Dockerfiles/scripts/run-android-docker-unit-tests.sh","test-android-run-e2e":"docker run --privileged -it reactnativeci/android bash .circleci/Dockerfiles/scripts/run-ci-e2e-tests.sh --android --js","test-android-all":"yarn run docker-build-android && yarn run test-android-run-unit && yarn run test-android-run-instrumentation && yarn run test-android-run-e2e","test-android-instrumentation":"yarn run docker-build-android && yarn run test-android-run-instrumentation","test-android-unit":"yarn run docker-build-android && yarn run test-android-run-unit","test-android-e2e":"yarn run docker-build-android && yarn run test-android-run-e2e","test-e2e-local":"node ./scripts/test-e2e-local.js","test-e2e-local-clean":"node ./scripts/test-e2e-local-clean.js","test-ios":"./scripts/objc-test.sh test","test-typescript":"dtslint types","test-typescript-offline":"dtslint --localTs node_modules/typescript/lib types","bump-all-updated-packages":"node ./scripts/monorepo/bump-all-updated-packages","align-package-versions":"node ./scripts/monorepo/align-package-versions.js"},"peerDependencies":{"react":"18.2.0"},"dependencies":{"@jest/create-cache-key-function":"^29.2.1","@react-native-community/cli":"10.2.4","@react-native-community/cli-platform-android":"10.2.0","@react-native-community/cli-platform-ios":"10.2.4","@react-native/assets":"1.0.0","@react-native/normalize-color":"2.1.0","@react-native/polyfills":"2.0.0","abort-controller":"^3.0.0","anser":"^1.4.9","ansi-regex":"^5.0.0","base64-js":"^1.1.2","deprecated-react-native-prop-types":"^3.0.1","event-target-shim":"^5.0.1","invariant":"^2.2.4","jest-environment-node":"^29.2.1","jsc-android":"^250231.0.0","memoize-one":"^5.0.0","metro-react-native-babel-transformer":"0.73.10","metro-runtime":"0.73.10","metro-source-map":"0.73.10","mkdirp":"^0.5.1","nullthrows":"^1.1.1","pretty-format":"^26.5.2","promise":"^8.3.0","react-devtools-core":"^4.26.1","react-native-gradle-plugin":"^0.71.19","react-refresh":"^0.4.0","react-shallow-renderer":"^16.15.0","regenerator-runtime":"^0.13.2","scheduler":"^0.23.0","stacktrace-parser":"^0.1.3","use-sync-external-store":"^1.0.0","whatwg-fetch":"^3.0.0","ws":"^6.2.2","react-native-codegen":"^0.71.5"},"devDependencies":{"flow-bin":"^0.191.0","hermes-eslint":"0.8.0","react":"18.2.0","react-test-renderer":"18.2.0","@babel/core":"^7.20.0","@babel/eslint-parser":"^7.18.2","@babel/generator":"^7.20.0","@babel/plugin-transform-regenerator":"^7.0.0","@babel/preset-flow":"^7.18.0","@definitelytyped/dtslint":"^0.0.127","@react-native-community/eslint-config":"*","@react-native-community/eslint-plugin":"*","@react-native/eslint-plugin-specs":"^0.71.1","@reactions/component":"^2.0.2","@types/react":"^18.0.18","@typescript-eslint/parser":"^5.30.5","async":"^3.2.2","clang-format":"^1.8.0","connect":"^3.6.5","coveralls":"^3.1.1","eslint":"^8.19.0","eslint-config-prettier":"^8.5.0","eslint-plugin-babel":"^5.3.1","eslint-plugin-eslint-comments":"^3.2.0","eslint-plugin-ft-flow":"^2.0.1","eslint-plugin-jest":"^26.5.3","eslint-plugin-jsx-a11y":"^6.6.0","eslint-plugin-lint":"^1.0.0","eslint-plugin-prettier":"^4.2.1","eslint-plugin-react":"^7.30.1","eslint-plugin-react-hooks":"^4.6.0","eslint-plugin-react-native":"^4.0.0","eslint-plugin-relay":"^1.8.3","inquirer":"^7.1.0","jest":"^29.2.1","jest-junit":"^10.0.0","jscodeshift":"^0.13.1","metro-babel-register":"0.73.10","metro-memory-fs":"0.73.10","mkdirp":"^0.5.1","mock-fs":"^5.1.4","prettier":"^2.4.1","shelljs":"^0.8.5","signedsource":"^1.0.0","typescript":"4.1.3","ws":"^6.2.2","yargs":"^17.5.1"},"codegenConfig":{"libraries":[{"name":"FBReactNativeSpec","type":"modules","ios":{},"android":{},"jsSrcsDir":"Libraries"},{"name":"rncore","type":"components","ios":{},"android":{},"jsSrcsDir":"Libraries"}]}}');

/***/ })

};
;